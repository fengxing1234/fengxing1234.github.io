<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,基础,设计模式," />










<meta name="description" content="java集合框架图java集合框架图  Java集合的类结构图  java集合继承关系图  在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。 简单来看，Collection代表的是单个元素对象的序列，（可以有序&#x2F;无序，可重复&#x2F;不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代">
<meta property="og:type" content="article">
<meta property="og:title" content="Java容器类">
<meta property="og:url" content="http://yoursite.com/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="java集合框架图java集合框架图  Java集合的类结构图  java集合继承关系图  在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。 简单来看，Collection代表的是单个元素对象的序列，（可以有序&#x2F;无序，可重复&#x2F;不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-04-30T15:03:36.000Z">
<meta property="article:modified_time" content="2020-05-06T07:20:48.924Z">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/30/Java容器类/"/>





  <title>Java容器类 | 冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java容器类</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java集合框架图"><a href="#java集合框架图" class="headerlink" title="java集合框架图"></a>java集合框架图</h1><p>java集合框架图</p>
<p><img src="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java集合的类结构图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>java集合继承关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。</p>
<p>简单来看，Collection代表的是单个元素对象的序列，（可以有序/无序，可重复/不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代表的是“键值对”对象的集合（同样可以有序/无序 等依据具体实现）</p>
<ul>
<li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li>
<li>Set：无序，不可重复；</li>
<li>Map：键值对，键唯一，值多个；</li>
</ul>
<h1 id="Collection-集合接口"><a href="#Collection-集合接口" class="headerlink" title="Collection 集合接口"></a>Collection 集合接口</h1><p>Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。有些容器允许重复元素有的不允许，有些有序有些无需。由Collection接口派生的两个接口是List和Set。这个接口的设计目的是希望能最大程度抽象出元素的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型即该Collection中元素对象的类型，继承的Iterable是定义的一个遍历操作接口，采用hasNext next的方式进行遍历。具体实现还是放在具体类中去实现。</p>
<p>主要方法</p>
<ul>
<li>boolean add(Object o) 添加对象到集合</li>
<li>boolean remove(Object o) 删除指定的对象</li>
<li>int size() 返回当前集合中元素的数量</li>
<li>boolean contains(Object o) 查找集合中是否有指定的对象</li>
<li>boolean isEmpty() 判断集合是否为空</li>
<li>Iterator iterator() 返回一个迭代器</li>
<li>boolean containsAll(Collection c) 查找集合中是否有集合c中的元素</li>
<li>boolean addAll(Collection c) 将集合c中所有的元素添加给该集合</li>
<li>void clear() 删除集合中所有元素</li>
<li>void removeAll(Collection c) 从集合中删除c集合中也有的元素</li>
<li>void retainAll(Collection c) 从集合中删除集合c中不包含的元素</li>
</ul>
<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><p>List是一个允许重复元素的指定索引、有序集合。</p>
<p>从List接口的方法来看，List接口增加了面向位置的操作，允许在指定位置上操作元素。用户可以使用这个接口精准掌控元素插入，还能够使用索引index（元素在List中的位置，类似于数组下标）来访问List中的元素。List接口有两个重要的实现类：ArrayList和LinkedList。</p>
<p><strong>Set里面和List最大的区别是Set里面的元素对象不可重复。</strong></p>
<h3 id="ArrayList-数组"><a href="#ArrayList-数组" class="headerlink" title="ArrayList 数组"></a>ArrayList 数组</h3><p>ArrayList的底层数据结构就是一个数组，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。默认列表长度10，也可以自己指定长度。ArrayList中的对象数组的最大数组容量为Integer.MAX_VALUE – 8。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>ArrayList实现了List接口的可变大小的数组。（数组可动态创建，如果元素个数超过数组容量，那么就创建一个更大的新数组）</li>
<li>它允许所有元素，包括null</li>
<li>它的size, isEmpty, get, set, iterator,add这些方法的时间复杂度是O(1),如果add n个数据则时间复杂度是O(n)</li>
<li>ArrayList没有同步方法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。</li>
<li>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。</li>
<li>根据下标遍历元素，效率高。</li>
<li>根据下标访问元素，效率高。</li>
<li>可以自动扩容，默认为每次扩容为原来的1.5倍。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除元素的效率不高。</li>
<li>根据元素下标查找元素需要遍历整个元素数组，效率不高。</li>
<li>线程不安全。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>Boolean add(Object o)将指定元素添加到列表的末尾</li>
<li>Boolean add(int index,Object element)在列表中指定位置加入指定元素</li>
<li>Boolean addAll(Collection c)将指定集合添加到列表末尾</li>
<li>Boolean addAll(int index,Collection c)在列表中指定位置加入指定集合</li>
<li>Boolean clear()删除列表中所有元素</li>
<li>Boolean clone()返回该列表实例的一个拷贝</li>
<li>Boolean contains(Object o)判断列表中是否包含元素</li>
<li>Boolean ensureCapacity(int m)增加列表的容量,如果必须,该列表能够容纳m个元素</li>
<li>Object get(int index)返回列表中指定位置的元素</li>
<li>Int indexOf(Object elem)在列表中查找指定元素的下标</li>
<li>Int size()返回当前列表的元素个数</li>
</ul>
<h4 id="常见源码分析"><a href="#常见源码分析" class="headerlink" title="常见源码分析"></a>常见源码分析</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">        elementData[size++] &#x3D; e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 确认能否装得下size+1的对象</span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;计算容量</span><br><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是默认长度，就比较默认长度和size+1,取最大值</span><br><span class="line">        if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;如果容量大于数组的长度</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;扩容</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;取数组的长度</span><br><span class="line">        int oldCapacity &#x3D; elementData.length;</span><br><span class="line">        &#x2F;&#x2F;计算新长度，新长度&#x3D;旧长度+旧长度&#x2F;2</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity &#x3D; minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">        &#x2F;&#x2F;最后按照新容量进行扩容，复制。</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在add()方法中主要完成了三件事：首先确保能够将希望添加到集合中的元素能够添加到集合中，即确保ArrayList的容量（判断是否需要扩容）；然后将元素添加到elementData数组的指定位置；最后将集合中实际的元素个数加1。</p>
<p>ArrayList的实际默认容量直到调用add()方法才会真正扩容到10，这里通过new ArrayList（）在内存分配的是一个空数组，并没有直接new Object[10],这样设计是很巧妙的，可以节省很多空间。</p>
<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F;判断是否越界</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">   &#x2F;&#x2F; 重新复制数组，把index+1位置往后的对象全部后移</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       &#x2F;&#x2F;覆盖index位置的对象                 </span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的指定位置添加对象方法，需要把指定位置后面的全部对象后移，所以这样也是ArrayList相对于linkList添加耗时的地方。</p>
<h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     return elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的get(int index) 方法比较简单，只有两步，第一，检查是否越界，第二，返回数组索引位置的数据。</p>
<h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;父类的属性，用来记录list修改的次数，后续迭代器中会用到</span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">      int numMoved &#x3D; size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">      &#x2F;&#x2F;把index位置后面的元素左移</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的remove（int index）方法主要分为 3步:</p>
<ul>
<li>第一步，判断下标是否越界</li>
<li>第二步，记录修改次数，并左移index位置后面的元素，</li>
<li>第三，把最后位置赋值为null，用于快速垃圾回收。</li>
</ul>
<h4 id="for循环问题"><a href="#for循环问题" class="headerlink" title="for循环问题"></a>for循环问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; new ArrayList&lt;&gt;(5);</span><br><span class="line">     integers.add(1);</span><br><span class="line">     integers.add(2);</span><br><span class="line">     integers.add(3);</span><br><span class="line">     integers.add(4);</span><br><span class="line">     integers.add(5);</span><br><span class="line"></span><br><span class="line">     for (int i &#x3D; 0; i &lt; integers.size(); i++) &#123;</span><br><span class="line">         integers.remove(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(integers.size());</span><br></pre></td></tr></table></figure>

<p>这里首先申明一个长度为5的ArrayList的集合，然后添加五个元素，最后通过循环遍历删除，理论结果输出0，但是输出的结果却是2，为什么呢？之前分析remove源码我们知道，ArrayList每删除一次就会把后面的全部元素左移，以这5个元素为例，第一个正常删除没问题，删除后，元素就只剩下[2,3,4,5],这个时候remove(1),还剩[2,4,5],再remove(2),剩下[2,4],后面再remove没有元素了，所以最后size为2。</p>
<h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a>LinkedList 链表</h3><p><strong><code>LinkedList</code> 保存链表的第一个节点和最后一个节点,每个节点上有三个字段：当前节点的数据字段（data）,指向上一个节点的字段（prev），和指向下一个节点的字段（next）。</strong></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p><strong><code>LinkedList</code> 集合底层实现的数据结构为双向链表</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 集合中元素允许为 null</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 允许存入重复的数据</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 中元素存放顺序为插入顺序。</strong></p>
</li>
<li><p><code>LinkedList</code>实现<code>Deque</code>接口使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<ul>
<li><strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong></li>
<li><strong>当<code>Deque</code> 作为栈使用的时候，遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的</strong>。</li>
</ul>
</li>
<li><p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。</p>
</li>
<li><p>分配内存空间不是连续的。</p>
</li>
<li><p>插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；</p>
</li>
<li><p>访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；</p>
</li>
</ul>
<h4 id="结点定义（双向链表）"><a href="#结点定义（双向链表）" class="headerlink" title="结点定义（双向链表）"></a>结点定义（双向链表）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前节点的元素值</span><br><span class="line">   E item;</span><br><span class="line">   &#x2F;&#x2F; 下一个节点的索引</span><br><span class="line">   Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; 上一个节点的索引</span><br><span class="line">   Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">       this.item &#x3D; element;</span><br><span class="line">       this.next &#x3D; next;</span><br><span class="line">       this.prev &#x3D; prev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h4><p>每个LinkedList中会持有链表的头指针和尾指针,LinkedList 主要成员变量有下边三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedList 中的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的第一个节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的最后一个节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p>之所以 LinkedList 要保存链表的第一个节点和最后一个节点是因为，我们都知道，链表数据结构相对于数组结构， 优点在于增删，缺点在于查找。如果我们保存了LinkedList 的头尾两端，当我们需要以索引来查找节点的时候，我们可以根据 <code>index</code> 和 <code>size/2</code> 的大小,来决定从头查找还是从尾部查找，这也算是一定程度上弥补了单链表数据结构的缺点。</p>
<h4 id="LinkedList-的构造函数"><a href="#LinkedList-的构造函数" class="headerlink" title="LinkedList 的构造函数"></a>LinkedList 的构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空参数的构造由于生成一个空链表 first &#x3D; last &#x3D; null</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入一个集合类，来构造一个具有一定元素的 LinkedList 集合</span><br><span class="line"> * @param  c  其内部的元素将按顺序作为 LinkedList 节点</span><br><span class="line"> * @throws NullPointerException 如果 参数 collection 为空将抛出空指针异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   this();</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在 index 节点前插入包含所有 c 集合元素的节点。</span><br><span class="line"> * 返回值表示是否成功添加了对应的元素.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   &#x2F;&#x2F; 查看索引是否满足 0 &#x3D;&lt; index &#x3D;&lt; size 的要求</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 调用对应 Collection 实现类的 toArray 方法将集合转为数组</span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   &#x2F;&#x2F;检查数组长度，如果为 0 则直接返回 false 表示没有添加任何元素</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">       return false;</span><br><span class="line">   &#x2F;&#x2F; 保存 index 当前的节点为 succ，当前节点的上一个节点为 pred</span><br><span class="line">   Node&lt;E&gt; pred, succ;</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 表示在链表尾部插入</span><br><span class="line">   if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">       succ &#x3D; null;</span><br><span class="line">       pred &#x3D; last;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       succ &#x3D; node(index);</span><br><span class="line">       pred &#x3D; succ.prev;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历数组将对应的元素包装成节点添加到链表中</span><br><span class="line">   for (Object o : a) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">       Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">       &#x2F;&#x2F;如果 pred 为空表示 LinkedList 集合中还没有元素</span><br><span class="line">       &#x2F;&#x2F;生成的第一个节点将作为头节点 赋值给 first 成员变量</span><br><span class="line">       if (pred &#x3D;&#x3D; null)</span><br><span class="line">           first &#x3D; newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next &#x3D; newNode;</span><br><span class="line">       pred &#x3D; newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果 index 位置的元素为 null 则遍历数组后 pred 所指向的节点即为新链表的末节点，赋值给 last 成员变量</span><br><span class="line">   if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; pred;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 否则将 pred 的 next 索引指向 succ ，succ 的 prev 索引指向 pred</span><br><span class="line">       pred.next &#x3D; succ;</span><br><span class="line">       succ.prev &#x3D; pred;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 更新当前链表的长度 size 并返回 true 表示添加成功</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   modCount++;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 批量添加节点的实现。大体分下面几个步骤：</p>
<ul>
<li>检查索引值是否合法，不合法将抛出角标越界异常</li>
<li>保存 index 位置的节点，和 index-1 位置的节点。</li>
<li>将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。</li>
<li>更新链表长度并返回添加 true 表示添加成功。</li>
</ul>
<p>越界检查最后都调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-添加节点的方法"><a href="#LinkedList-添加节点的方法" class="headerlink" title="LinkedList 添加节点的方法"></a>LinkedList 添加节点的方法</h4><p>LinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the beginning of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法默认调用<code>linkLast</code>添加到最后一个节点。</p>
<h5 id="linkXXX-方法：linkFirst、linkLast"><a href="#linkXXX-方法：linkFirst、linkLast" class="headerlink" title="linkXXX 方法：linkFirst、linkLast"></a><code>linkXXX</code> 方法：<code>linkFirst、linkLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 添加一个元素在链表的头节点位置</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加元素之前的头节点</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   &#x2F;&#x2F;以添加的元素为节点值构建新的头节点 并将 next 指针指向 之前的头节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">   &#x2F;&#x2F; first 索引指向将新的节点</span><br><span class="line">   first &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果添加之前链表空则新的节点也作为未节点</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       last &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       f.prev &#x3D; newNode;&#x2F;&#x2F;否则之前头节点的 prev 指针指向新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在链表末尾添加一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> void linkLast(E e) &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F;保存之前的未节点</span><br><span class="line">   &#x2F;&#x2F;构建新的未节点，并将新节点 prev 指针指向 之前的未节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">   &#x2F;&#x2F;last 索引指向末节点</span><br><span class="line">   last &#x3D; newNode;</span><br><span class="line">   if (l &#x3D;&#x3D; null)&#x2F;&#x2F;如果之前链表为空则新节点也作为头节点</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else&#x2F;&#x2F;否则将之前的未节点的 next 指针指向新节点</span><br><span class="line">       l.next &#x3D; newNode;</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-int-index-E-element-、addAll"><a href="#add-int-index-E-element-、addAll" class="headerlink" title="add(int index, E element)、addAll"></a>add(int index, E element)、addAll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在指定 index 位置插入节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 检查角标是否越界</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 代表是在尾部插入节点</span><br><span class="line">   if (index &#x3D;&#x3D; size)</span><br><span class="line">       linkLast(element);</span><br><span class="line">   else</span><br><span class="line">       linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="node-index-方法的实现"><a href="#node-index-方法的实现" class="headerlink" title="node(index) 方法的实现"></a>node(index) 方法的实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回一个非空节点，这个非空节点位于 index 位置</span><br><span class="line"> *&#x2F;</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 如果 index &lt; size&#x2F;2 则从0开始寻找指定角标的节点</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果 index &gt;&#x3D; size&#x2F;2 则从 size-1 开始寻找指定角标的节点</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会疑惑为什么这里注释为返回一个非空节点？其实仔细想下就明白了，这里的节点一定不为 null，如果一开始链表为空的时候，index 为 0 的位置肯定为 null，为什么不会产生异常情况呢？其实如果一开始链表中没有元素 size = 0，如果我们向 <code>index = 0</code> 的位置添加元素是不会走到 else 中的，而是会调用 <code>linkLast(element);</code> 方法去添加元素。 因此<strong>node 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;</strong></p>
<h6 id="linkBefore-E-e-Node-succ-实现"><a href="#linkBefore-E-e-Node-succ-实现" class="headerlink" title="linkBefore(E e, Node succ)实现"></a>linkBefore(E e, Node<E> succ)实现</h6><p>为什么要叫做 linkBefore 呢，因为在链表的中间位置添加节点，其实就是将 index 原来的节点前添加一个节点，添加节点我们需要知道该节点的前一个节点和当前节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; 由于 succ 一定不为空，所以可以直接获取 prev 节点</span><br><span class="line">   final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">   &#x2F;&#x2F; 新节点 prev 节点为 pred，next 节点为 succ</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">   &#x2F;&#x2F; 原节点的 prev 指向新节点</span><br><span class="line">   succ.prev &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果 pred 为空即头节点出插入了一个节点，则将新的节点赋值给 first 索引</span><br><span class="line">   if (pred &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       pred.next &#x3D; newNode;&#x2F;&#x2F;否则 pred 的下一个节点改为新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将构造的新节点前指针 prev 指向 index 的前一个元素，</p>
</li>
<li><p>新节点前指针 next 指针指向 index 位置的节点，</p>
</li>
<li><p>index 位置节点 prev 指针指向新节点</p>
</li>
<li><p>index 位置前节点（pred）的 next 指针指向新节点</p>
</li>
</ul>
<h4 id="LinkedList-删除节点的方法"><a href="#LinkedList-删除节点的方法" class="headerlink" title="LinkedList 删除节点的方法"></a>LinkedList 删除节点的方法</h4><h5 id="removeFirst、removeLast"><a href="#removeFirst、removeLast" class="headerlink" title="removeFirst、removeLast"></a><code>removeFirst</code>、<code>removeLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  删除头节点</span><br><span class="line"> * @return 删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  删除尾节点</span><br><span class="line"> *</span><br><span class="line"> * @return  删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException  如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="unlinkFirst、unlinkLast"><a href="#unlinkFirst、unlinkLast" class="headerlink" title="unlinkFirst、unlinkLast"></a><code>unlinkFirst</code>、<code>unlinkLast</code></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 移除头节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 头节点的 element 这里作为返回值使用</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    &#x2F;&#x2F; 头节点下个节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    &#x2F;&#x2F; 释放头节点的 next 指针，和 element 下次 gc 的时候回收这个内部类</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F; 将 first 索引指向新的节点</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    &#x2F;&#x2F; 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;否则 next 的 prev 指针指向 null</span><br><span class="line">    size--;&#x2F;&#x2F;改变链表长度</span><br><span class="line">    modCount++;&#x2F;&#x2F;修改操作数</span><br><span class="line">    return element;&#x2F;&#x2F;返回删除节点的值</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 移除未节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    &#x2F;&#x2F;未节点的前一个节点，</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    &#x2F;&#x2F;释放未节点的内容</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F;将 last 索引指向新的未节点</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    &#x2F;&#x2F; 链表只有一个节点的时候，first 指向 null</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刚才已经分析过node(index)方法了，就是找到index位置的节点。</p>
<h6 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Unlinks non-null node x.</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">   final E element &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F;保存 index 节点的前后两个节点</span><br><span class="line">   final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">   final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为头节点，则做 unlinkFirst 相同操作</span><br><span class="line">   if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">       first &#x3D; next;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则将上一个节点的 next 指针指向下个节点</span><br><span class="line">       prev.next &#x3D; next;</span><br><span class="line">       &#x2F;&#x2F; 释放 index 位置 prev 指针</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为尾节点，则将 last 索引指向上个节点</span><br><span class="line">   if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; prev;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则下个节点 prev 指针指向上个节点</span><br><span class="line">       next.prev &#x3D; prev;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   x.item &#x3D; null;</span><br><span class="line">   size--;</span><br><span class="line">   modCount++;</span><br><span class="line">   return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完 <code>unlink</code> 操作结合之前说的 <code>node(index)</code>，下边两种删除节点的操作，就很好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定索引位置的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *删除从头节点其第一个与 o 相同的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F; 区别对待 null 元素，比较元素时候使用 &#x3D;&#x3D; 而不是 equals</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item)) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完单个删除节点的方法 LinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Removes all of the elements from this list.</span><br><span class="line">* The list will be empty after this call returns.</span><br><span class="line">*&#x2F;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">   &#x2F;&#x2F; 依次清除节点，帮助释放内存空间</span><br><span class="line">   for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">       Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">       x.item &#x3D; null;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">       x &#x3D; next;</span><br><span class="line">   &#125;</span><br><span class="line">   first &#x3D; last &#x3D; null;</span><br><span class="line">   size &#x3D; 0;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-查询节点的方法"><a href="#LinkedList-查询节点的方法" class="headerlink" title="LinkedList 查询节点的方法"></a>LinkedList 查询节点的方法</h4><p>LinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 <code>ArrayList</code> 去替代。</p>
<h5 id="get-int-index-、getFirst-、getLast"><a href="#get-int-index-、getFirst-、getLast" class="headerlink" title="get(int index)、getFirst() 、getLast"></a><code>get(int index)、getFirst() 、getLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 根据索引查询</span><br><span class="line">*</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 first 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the first element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 last 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the last element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">   if (l &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexOf-Object-o-、lastIndexOf-Object-o"><a href="#indexOf-Object-o-、lastIndexOf-Object-o" class="headerlink" title="indexOf(Object o)、lastIndexOf(Object o)"></a><code>indexOf(Object o)、lastIndexOf(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">* 返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**头节点**起的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">* </span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return </span><br><span class="line">*&#x2F;</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 区别对待 null 元素，用 &#x3D;&#x3D; 判断，非空元素用 equels 方法判断 </span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">**返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**尾节点起**的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">*</span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return the index of the last occurrence of the specified element in</span><br><span class="line">*         this list, or -1 if this list does not contain the element</span><br><span class="line">*&#x2F;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; size;</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法分别返回从<strong>头节点起</strong>第一个与参数元素相同的节点索引，和从<strong>尾节点起</strong>第一个与参数元素相同的节点索引。</p>
<h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a><code>contains(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) !&#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 indexOf 从头结点开始查询元素位置遍历完成后若 返回值 !=-1 则表示存在，反之不存在</p>
<h4 id="LinkedList-的修改节点方法"><a href="#LinkedList-的修改节点方法" class="headerlink" title="LinkedList 的修改节点方法"></a>LinkedList 的修改节点方法</h4><p><code>LinkedList</code> 只提供了 <code>set(int index, E element)</code> 一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 判断角标是否越界</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 采用 node 方法查找对应索引的节点</span><br><span class="line">   Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">   &#x2F;&#x2F;保存节点原有的内容值</span><br><span class="line">   E oldVal &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F; 设置新值</span><br><span class="line">   x.item &#x3D; element;</span><br><span class="line">   &#x2F;&#x2F; 返回旧的值</span><br><span class="line">   return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList-作为双向队列的增删改查"><a href="#LinkedList-作为双向队列的增删改查" class="headerlink" title="LinkedList 作为双向队列的增删改查"></a>LinkedList 作为双向队列的增删改查</h3><p><code>LinkedList</code>实现<code>Deque</code>接口，可实现双向队列。</p>
<h4 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h4><p><code>Queue</code> 是一个队列，遵循 FIFO 准则，我们也知道 <code>Stack</code> 是一个栈结构，遵循 FILO 准则。 而<code>Deque</code> 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。</p>
<p>Deque接口中的方法:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">头部</th>
<th align="center">头部</th>
<th align="center">尾部</th>
<th align="center">尾部</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="center">addFirst(e)</td>
<td align="center">offerFirst(e)</td>
<td align="center">addLast(e)</td>
<td align="center">offerLast(e)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="center">removeFirst()</td>
<td align="center">pollFirst()</td>
<td align="center">remveLast()</td>
<td align="center">pollLast</td>
</tr>
<tr>
<td align="left">获取</td>
<td align="center">getFirst()</td>
<td align="center">peekFirst()</td>
<td align="center">getLast()</td>
<td align="center">peekLast</td>
</tr>
</tbody></table>
<p>由于 <code>Deque</code> 接口继承 <code>Queue</code> 接口，<strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong>。我们现在复习下 <code>Queue</code> 中的方法及区别：</p>
<ul>
<li><code>Queue</code> 的 <code>offer</code> 和 <code>add</code> 都是在队列中插入一个元素，具体区别在于，对于一些 Queue 的实现的队列是有大小限制的，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。此时调用 <code>add()</code>方法会抛出异常，而 <code>offer()</code> 只是返回的 false。</li>
<li><code>remove()</code> 和 <code>poll()</code> 方法都是从队列中删除第一个元素。remove()也将抛出异常，而 <code>poll()</code> 则会返回 <code>null</code></li>
<li><code>element()</code> 和 <code>peek()</code> 用于在队列的头部查询元素。在队列为空时， <code>element()</code> 抛出一个异常，而 <code>peek()</code> 返回 <code>null</code>。</li>
</ul>
<h4 id="Deque-和-Queue-添加元素的方法"><a href="#Deque-和-Queue-添加元素的方法" class="headerlink" title="Deque 和 Queue 添加元素的方法"></a>Deque 和 Queue 添加元素的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">   return add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提及到 <code>Queue</code>的 <code>offer</code> 和 <code>add</code> 的区别针对容量有限制的实现，很明显 <code>LinkedList</code> 的大小并没有限制，所以在 <code>LinkedList</code> 中他们的实现并没有实质性不同。</p>
<h4 id="Deque-和-Queue-删除元素的方法"><a href="#Deque-和-Queue-删除元素的方法" class="headerlink" title="Deque 和 Queue 删除元素的方法"></a>Deque 和 Queue 删除元素的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 removeFirst 会抛出 NoSuchElement 异常</span><br><span class="line">public E remove() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的删除方法实现</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E poll() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deque-和-Queue-获取队列头部元素的实现"><a href="#Deque-和-Queue-获取队列头部元素的实现" class="headerlink" title="Deque 和 Queue 获取队列头部元素的实现"></a>Deque 和 Queue 获取队列头部元素的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line"> public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述我们分析了，双端队列作为队列使用的时候的各个方法的区别，也可是看出 <code>LinkedList</code> 对对应方法的实现，遵循了队列设计原则。</p>
<h3 id="LinkedList作为Stack使用"><a href="#LinkedList作为Stack使用" class="headerlink" title="LinkedList作为Stack使用"></a><code>LinkedList</code>作为<code>Stack</code>使用</h3><p>下面我们来看看下双端队列作为栈 <code>Stack</code>使用的时候方法对应关系，与 <code>Queue</code> 不同，<code>Stack</code> 本身就是实现类，他拥有 FILO 的原则， <code>Stack</code> 的入栈操作通过 <code>push</code> 方法进行，出栈操作通过 <code>pop</code> 方法进行，查询操作通过 <code>peek</code> 操作进行。 <strong><code>Deque</code> 作为栈使用的时候，也遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的。</strong></p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFist(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><code>LinkedList</code>中的<code>push</code>、<code>pop</code>、<code>peek</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void push(E e) &#123;</span><br><span class="line">   addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pop() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-的遍历"><a href="#LinkedList-的遍历" class="headerlink" title="LinkedList 的遍历"></a>LinkedList 的遍历</h4><p>在 <code>ArrayList</code> 分析的时候，我们就知道 <code>List</code> 的实现类，有4中遍历方式：for 循环，高级 for 循环，<code>Iterator</code> 迭代器方法， <code>ListIterator</code> 迭代方法。</p>
<p><code>LinkedList</code> 没有单独 <code>Iterator</code> 实现类，它的 <code>iterator</code> 和 <code>listIterator</code> 方法均返回 <code>ListItr</code>的一个对象。 LinkedList 作为双向链表数据结构，获取上个元素和下个元素很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 上一个遍历的节点</span><br><span class="line">   private Node&lt;E&gt; lastReturned;</span><br><span class="line">   &#x2F;&#x2F; 下一次遍历返回的节点</span><br><span class="line">   private Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; cursor 指针下一次遍历返回的节点</span><br><span class="line">   private int nextIndex;</span><br><span class="line">   &#x2F;&#x2F; 期望的操作数</span><br><span class="line">   private int expectedModCount &#x3D; modCount;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; 根据参数 index 确定生成的迭代器 cursor 的位置</span><br><span class="line">   ListItr(int index) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert isPositionIndex(index);</span><br><span class="line">       &#x2F;&#x2F; 如果 index &#x3D;&#x3D; size 则 next 为 null 否则寻找 index 位置的节点</span><br><span class="line">       next &#x3D; (index &#x3D;&#x3D; size) ? null : node(index);</span><br><span class="line">       nextIndex &#x3D; index;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 判断指针是否还可以移动</span><br><span class="line">   public boolean hasNext() &#123;</span><br><span class="line">       return nextIndex &lt; size;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 返回下一个带遍历的元素</span><br><span class="line">  public E next() &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查操作数是否合法</span><br><span class="line">       checkForComodification();</span><br><span class="line">       &#x2F;&#x2F; 如果 hasNext 返回 false 抛出异常，所以我们在调用 next 前应先调用 hasNext 检查</span><br><span class="line">       if (!hasNext())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 移动 lastReturned 指针</span><br><span class="line">       lastReturned &#x3D; next;</span><br><span class="line">        &#x2F;&#x2F; 移动 next 指针</span><br><span class="line">       next &#x3D; next.next;</span><br><span class="line">       &#x2F;&#x2F; 移动 nextIndex cursor</span><br><span class="line">       nextIndex++;</span><br><span class="line">       &#x2F;&#x2F; 返回移动后 lastReturned</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前游标位置是否还有前一个元素</span><br><span class="line">   public boolean hasPrevious() &#123;</span><br><span class="line">       return nextIndex &gt; 0;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 当前游标位置的前一个元素</span><br><span class="line">   public E previous() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (!hasPrevious())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 等同于 lastReturned &#x3D; next；next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">        &#x2F;&#x2F; 发生在 index &#x3D; size 时</span><br><span class="line">       lastReturned &#x3D; next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">       nextIndex--;</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public int nextIndex() &#123;</span><br><span class="line">       return nextIndex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int previousIndex() &#123;</span><br><span class="line">       return nextIndex - 1;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 删除链表当前节点也就是调用 next&#x2F;previous 返回的这节点，也就 lastReturned</span><br><span class="line">   public void remove() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; lastNext &#x3D; lastReturned.next;</span><br><span class="line">       &#x2F;&#x2F;调用LinkedList 的删除节点的方法</span><br><span class="line">       unlink(lastReturned);</span><br><span class="line">       if (next &#x3D;&#x3D; lastReturned)</span><br><span class="line">           next &#x3D; lastNext;</span><br><span class="line">       else</span><br><span class="line">           nextIndex--;</span><br><span class="line">       &#x2F;&#x2F;上一次所操作的 节点置位空    </span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置当前遍历的节点的值</span><br><span class="line">   public void set(E e) &#123;</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned.item &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 在 next 节点位置插入及节点</span><br><span class="line">   public void add(E e) &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       if (next &#x3D;&#x3D; null)</span><br><span class="line">           linkLast(e);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(e, next);</span><br><span class="line">       nextIndex++;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;简单哈操作数是否合法</span><br><span class="line">   final void checkForComodification() &#123;</span><br><span class="line">       if (modCount !&#x3D; expectedModCount)</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>链表LinkedList和数组ArrayList的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同。实际使用时根据特定的需求选用合适的类。</p>
<ul>
<li><p>ArrayList基于数组；LinkedList基于双向链表。</p>
</li>
<li><p>查找方面。数组的效率更高，可以直接索引出查找；而链表必须从头查找。</p>
</li>
<li><p>插入删除方面。特别是在中间进行插入删除，这时候链表体现出了极大的便利性，只需要在插入或者删除的地方断掉链然后插入或者移除元素，然后再将前后链重新组装；但是数组必须重新复制一份将所有数据后移或者前移。</p>
</li>
<li><p>在内存申请方面，当数组达到初始的申请长度后，需要重新申请一个更大的数组然后把数据迁移过去才行。而链表只需要动态创建即可。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
          
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/" rel="next" title="第一次测试">
                <i class="fa fa-chevron-left"></i> 第一次测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="Java设计模式">
                Java设计模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java集合框架图"><span class="nav-number">1.</span> <span class="nav-text">java集合框架图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection-集合接口"><span class="nav-number">2.</span> <span class="nav-text">Collection 集合接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List子接口"><span class="nav-number">2.1.</span> <span class="nav-text">List子接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-数组"><span class="nav-number">2.1.1.</span> <span class="nav-text">ArrayList 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见源码分析"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">常见源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#add"><span class="nav-number">2.1.1.5.1.</span> <span class="nav-text">add()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-int-index-E-element-方法"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">add(int index, E element)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-int-index-方法"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">get(int index)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-int-index-方法"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">remove(int index)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for循环问题"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">for循环问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-链表"><span class="nav-number">2.1.2.</span> <span class="nav-text">LinkedList 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结点定义（双向链表）"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">结点定义（双向链表）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表定义"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">链表定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-的构造函数"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">LinkedList 的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-添加节点的方法"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">LinkedList 添加节点的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#linkXXX-方法：linkFirst、linkLast"><span class="nav-number">2.1.2.5.1.</span> <span class="nav-text">linkXXX 方法：linkFirst、linkLast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#add-int-index-E-element-、addAll"><span class="nav-number">2.1.2.5.2.</span> <span class="nav-text">add(int index, E element)、addAll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#node-index-方法的实现"><span class="nav-number">2.1.2.5.2.1.</span> <span class="nav-text">node(index) 方法的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#linkBefore-E-e-Node-succ-实现"><span class="nav-number">2.1.2.5.2.2.</span> <span class="nav-text">linkBefore(E e, Node succ)实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-删除节点的方法"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">LinkedList 删除节点的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#removeFirst、removeLast"><span class="nav-number">2.1.2.6.1.</span> <span class="nav-text">removeFirst、removeLast</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unlinkFirst、unlinkLast"><span class="nav-number">2.1.2.6.1.1.</span> <span class="nav-text">unlinkFirst、unlinkLast</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove-int-index"><span class="nav-number">2.1.2.6.2.</span> <span class="nav-text">remove(int index)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unlink-Node-x"><span class="nav-number">2.1.2.6.2.1.</span> <span class="nav-text">unlink(Node x)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-查询节点的方法"><span class="nav-number">2.1.2.7.</span> <span class="nav-text">LinkedList 查询节点的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get-int-index-、getFirst-、getLast"><span class="nav-number">2.1.2.7.1.</span> <span class="nav-text">get(int index)、getFirst() 、getLast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#indexOf-Object-o-、lastIndexOf-Object-o"><span class="nav-number">2.1.2.7.2.</span> <span class="nav-text">indexOf(Object o)、lastIndexOf(Object o)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#contains-Object-o"><span class="nav-number">2.1.2.7.3.</span> <span class="nav-text">contains(Object o)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-的修改节点方法"><span class="nav-number">2.1.2.8.</span> <span class="nav-text">LinkedList 的修改节点方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-作为双向队列的增删改查"><span class="nav-number">2.1.3.</span> <span class="nav-text">LinkedList 作为双向队列的增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque-双端队列"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">Deque 双端队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque-和-Queue-添加元素的方法"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">Deque 和 Queue 添加元素的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque-和-Queue-删除元素的方法"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">Deque 和 Queue 删除元素的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque-和-Queue-获取队列头部元素的实现"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">Deque 和 Queue 获取队列头部元素的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList作为Stack使用"><span class="nav-number">2.1.4.</span> <span class="nav-text">LinkedList作为Stack使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-的遍历"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">LinkedList 的遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList与LinkedList"><span class="nav-number">2.1.5.</span> <span class="nav-text">ArrayList与LinkedList</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
