<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,基础,设计模式," />










<meta name="description" content="java集合框架图java集合框架图  Java集合的类结构图  java集合继承关系图  在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。 简单来看，Collection代表的是单个元素对象的序列，（可以有序&#x2F;无序，可重复&#x2F;不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代">
<meta property="og:type" content="article">
<meta property="og:title" content="Java容器类">
<meta property="og:url" content="http://yoursite.com/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="java集合框架图java集合框架图  Java集合的类结构图  java集合继承关系图  在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。 简单来看，Collection代表的是单个元素对象的序列，（可以有序&#x2F;无序，可重复&#x2F;不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190607103330622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/5/21/1638145a2ead2bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190725082450961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210635_58179.jpg">
<meta property="og:image" content="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210658_66827.jpg">
<meta property="og:image" content="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210713_35028.jpg">
<meta property="og:image" content="http://www.justdojava.com/assets/images/2019/java/image-jay/ebdd7991f4634d4393568b0632d769ab.jpg">
<meta property="og:image" content="http://www.justdojava.com/assets/images/2019/java/image-jay/82a5ff28b5c14da29f3081db4cc2cd23.jpg">
<meta property="og:image" content="http://www.justdojava.com/assets/images/2019/java/image-jay/7486b49ac2f4410099b5764082a6d352.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166327271293.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166881843975.jpg">
<meta property="og:image" content="http://yoursite.com/Users/fengxing/Desktop/Android/%E6%A0%91%E6%9C%AF%E8%AF%AD.png">
<meta property="article:published_time" content="2020-04-30T15:03:36.000Z">
<meta property="article:modified_time" content="2020-05-07T05:54:40.050Z">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/30/Java容器类/"/>





  <title>Java容器类 | 冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java容器类</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java集合框架图"><a href="#java集合框架图" class="headerlink" title="java集合框架图"></a>java集合框架图</h1><p>java集合框架图</p>
<p><img src="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java集合的类结构图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>java集合继承关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。</p>
<p>简单来看，Collection代表的是单个元素对象的序列，（可以有序/无序，可重复/不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代表的是“键值对”对象的集合（同样可以有序/无序 等依据具体实现）</p>
<ul>
<li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li>
<li>Set：无序，不可重复；</li>
<li>Map：键值对，键唯一，值多个；</li>
</ul>
<h1 id="Collection-集合接口"><a href="#Collection-集合接口" class="headerlink" title="Collection 集合接口"></a>Collection 集合接口</h1><p>Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。有些容器允许重复元素有的不允许，有些有序有些无需。由Collection接口派生的两个接口是List和Set。这个接口的设计目的是希望能最大程度抽象出元素的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型即该Collection中元素对象的类型，继承的Iterable是定义的一个遍历操作接口，采用hasNext next的方式进行遍历。具体实现还是放在具体类中去实现。</p>
<p>主要方法</p>
<ul>
<li>boolean add(Object o) 添加对象到集合</li>
<li>boolean remove(Object o) 删除指定的对象</li>
<li>int size() 返回当前集合中元素的数量</li>
<li>boolean contains(Object o) 查找集合中是否有指定的对象</li>
<li>boolean isEmpty() 判断集合是否为空</li>
<li>Iterator iterator() 返回一个迭代器</li>
<li>boolean containsAll(Collection c) 查找集合中是否有集合c中的元素</li>
<li>boolean addAll(Collection c) 将集合c中所有的元素添加给该集合</li>
<li>void clear() 删除集合中所有元素</li>
<li>void removeAll(Collection c) 从集合中删除c集合中也有的元素</li>
<li>void retainAll(Collection c) 从集合中删除集合c中不包含的元素</li>
</ul>
<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><p>List是一个允许重复元素的指定索引、有序集合。</p>
<p>从List接口的方法来看，List接口增加了面向位置的操作，允许在指定位置上操作元素。用户可以使用这个接口精准掌控元素插入，还能够使用索引index（元素在List中的位置，类似于数组下标）来访问List中的元素。List接口有两个重要的实现类：ArrayList和LinkedList。</p>
<p><strong>Set里面和List最大的区别是Set里面的元素对象不可重复。</strong></p>
<h3 id="ArrayList-数组"><a href="#ArrayList-数组" class="headerlink" title="ArrayList 数组"></a>ArrayList 数组</h3><p>ArrayList的底层数据结构就是一个数组，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。默认列表长度10，也可以自己指定长度。ArrayList中的对象数组的最大数组容量为Integer.MAX_VALUE – 8。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>ArrayList实现了List接口的可变大小的数组。（数组可动态创建，如果元素个数超过数组容量，那么就创建一个更大的新数组）</li>
<li>它允许所有元素，包括null</li>
<li>它的size, isEmpty, get, set, iterator,add这些方法的时间复杂度是O(1),如果add n个数据则时间复杂度是O(n)</li>
<li>ArrayList没有同步方法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。</li>
<li>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。</li>
<li>根据下标遍历元素，效率高。</li>
<li>根据下标访问元素，效率高。</li>
<li>可以自动扩容，默认为每次扩容为原来的1.5倍。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除元素的效率不高。</li>
<li>根据元素下标查找元素需要遍历整个元素数组，效率不高。</li>
<li>线程不安全。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>Boolean add(Object o)将指定元素添加到列表的末尾</li>
<li>Boolean add(int index,Object element)在列表中指定位置加入指定元素</li>
<li>Boolean addAll(Collection c)将指定集合添加到列表末尾</li>
<li>Boolean addAll(int index,Collection c)在列表中指定位置加入指定集合</li>
<li>Boolean clear()删除列表中所有元素</li>
<li>Boolean clone()返回该列表实例的一个拷贝</li>
<li>Boolean contains(Object o)判断列表中是否包含元素</li>
<li>Boolean ensureCapacity(int m)增加列表的容量,如果必须,该列表能够容纳m个元素</li>
<li>Object get(int index)返回列表中指定位置的元素</li>
<li>Int indexOf(Object elem)在列表中查找指定元素的下标</li>
<li>Int size()返回当前列表的元素个数</li>
</ul>
<h4 id="常见源码分析"><a href="#常见源码分析" class="headerlink" title="常见源码分析"></a>常见源码分析</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">        elementData[size++] &#x3D; e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 确认能否装得下size+1的对象</span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;计算容量</span><br><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是默认长度，就比较默认长度和size+1,取最大值</span><br><span class="line">        if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;如果容量大于数组的长度</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;扩容</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;取数组的长度</span><br><span class="line">        int oldCapacity &#x3D; elementData.length;</span><br><span class="line">        &#x2F;&#x2F;计算新长度，新长度&#x3D;旧长度+旧长度&#x2F;2</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity &#x3D; minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">        &#x2F;&#x2F;最后按照新容量进行扩容，复制。</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在add()方法中主要完成了三件事：首先确保能够将希望添加到集合中的元素能够添加到集合中，即确保ArrayList的容量（判断是否需要扩容）；然后将元素添加到elementData数组的指定位置；最后将集合中实际的元素个数加1。</p>
<p>ArrayList的实际默认容量直到调用add()方法才会真正扩容到10，这里通过new ArrayList（）在内存分配的是一个空数组，并没有直接new Object[10],这样设计是很巧妙的，可以节省很多空间。</p>
<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F;判断是否越界</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">   &#x2F;&#x2F; 重新复制数组，把index+1位置往后的对象全部后移</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       &#x2F;&#x2F;覆盖index位置的对象                 </span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的指定位置添加对象方法，需要把指定位置后面的全部对象后移，所以这样也是ArrayList相对于linkList添加耗时的地方。</p>
<h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     return elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的get(int index) 方法比较简单，只有两步，第一，检查是否越界，第二，返回数组索引位置的数据。</p>
<h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;父类的属性，用来记录list修改的次数，后续迭代器中会用到</span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">      int numMoved &#x3D; size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">      &#x2F;&#x2F;把index位置后面的元素左移</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的remove（int index）方法主要分为 3步:</p>
<ul>
<li>第一步，判断下标是否越界</li>
<li>第二步，记录修改次数，并左移index位置后面的元素，</li>
<li>第三，把最后位置赋值为null，用于快速垃圾回收。</li>
</ul>
<h4 id="for循环问题"><a href="#for循环问题" class="headerlink" title="for循环问题"></a>for循环问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; new ArrayList&lt;&gt;(5);</span><br><span class="line">     integers.add(1);</span><br><span class="line">     integers.add(2);</span><br><span class="line">     integers.add(3);</span><br><span class="line">     integers.add(4);</span><br><span class="line">     integers.add(5);</span><br><span class="line"></span><br><span class="line">     for (int i &#x3D; 0; i &lt; integers.size(); i++) &#123;</span><br><span class="line">         integers.remove(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(integers.size());</span><br></pre></td></tr></table></figure>

<p>这里首先申明一个长度为5的ArrayList的集合，然后添加五个元素，最后通过循环遍历删除，理论结果输出0，但是输出的结果却是2，为什么呢？之前分析remove源码我们知道，ArrayList每删除一次就会把后面的全部元素左移，以这5个元素为例，第一个正常删除没问题，删除后，元素就只剩下[2,3,4,5],这个时候remove(1),还剩[2,4,5],再remove(2),剩下[2,4],后面再remove没有元素了，所以最后size为2。</p>
<h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a>LinkedList 链表</h3><p><strong><code>LinkedList</code> 保存链表的第一个节点和最后一个节点,每个节点上有三个字段：当前节点的数据字段（data）,指向上一个节点的字段（prev），和指向下一个节点的字段（next）。</strong></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p><strong><code>LinkedList</code> 集合底层实现的数据结构为双向链表</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 集合中元素允许为 null</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 允许存入重复的数据</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 中元素存放顺序为插入顺序。</strong></p>
</li>
<li><p><code>LinkedList</code>实现<code>Deque</code>接口使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<ul>
<li><strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong></li>
<li><strong>当<code>Deque</code> 作为栈使用的时候，遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的</strong>。</li>
</ul>
</li>
<li><p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。</p>
</li>
<li><p>分配内存空间不是连续的。</p>
</li>
<li><p>插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；</p>
</li>
<li><p>访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；</p>
</li>
</ul>
<h4 id="结点定义（双向链表）"><a href="#结点定义（双向链表）" class="headerlink" title="结点定义（双向链表）"></a>结点定义（双向链表）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前节点的元素值</span><br><span class="line">   E item;</span><br><span class="line">   &#x2F;&#x2F; 下一个节点的索引</span><br><span class="line">   Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; 上一个节点的索引</span><br><span class="line">   Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">       this.item &#x3D; element;</span><br><span class="line">       this.next &#x3D; next;</span><br><span class="line">       this.prev &#x3D; prev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h4><p>每个LinkedList中会持有链表的头指针和尾指针,LinkedList 主要成员变量有下边三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedList 中的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的第一个节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的最后一个节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p>之所以 LinkedList 要保存链表的第一个节点和最后一个节点是因为，我们都知道，链表数据结构相对于数组结构， 优点在于增删，缺点在于查找。如果我们保存了LinkedList 的头尾两端，当我们需要以索引来查找节点的时候，我们可以根据 <code>index</code> 和 <code>size/2</code> 的大小,来决定从头查找还是从尾部查找，这也算是一定程度上弥补了单链表数据结构的缺点。</p>
<h4 id="LinkedList-的构造函数"><a href="#LinkedList-的构造函数" class="headerlink" title="LinkedList 的构造函数"></a>LinkedList 的构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空参数的构造由于生成一个空链表 first &#x3D; last &#x3D; null</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入一个集合类，来构造一个具有一定元素的 LinkedList 集合</span><br><span class="line"> * @param  c  其内部的元素将按顺序作为 LinkedList 节点</span><br><span class="line"> * @throws NullPointerException 如果 参数 collection 为空将抛出空指针异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   this();</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在 index 节点前插入包含所有 c 集合元素的节点。</span><br><span class="line"> * 返回值表示是否成功添加了对应的元素.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   &#x2F;&#x2F; 查看索引是否满足 0 &#x3D;&lt; index &#x3D;&lt; size 的要求</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 调用对应 Collection 实现类的 toArray 方法将集合转为数组</span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   &#x2F;&#x2F;检查数组长度，如果为 0 则直接返回 false 表示没有添加任何元素</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">       return false;</span><br><span class="line">   &#x2F;&#x2F; 保存 index 当前的节点为 succ，当前节点的上一个节点为 pred</span><br><span class="line">   Node&lt;E&gt; pred, succ;</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 表示在链表尾部插入</span><br><span class="line">   if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">       succ &#x3D; null;</span><br><span class="line">       pred &#x3D; last;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       succ &#x3D; node(index);</span><br><span class="line">       pred &#x3D; succ.prev;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历数组将对应的元素包装成节点添加到链表中</span><br><span class="line">   for (Object o : a) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">       Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">       &#x2F;&#x2F;如果 pred 为空表示 LinkedList 集合中还没有元素</span><br><span class="line">       &#x2F;&#x2F;生成的第一个节点将作为头节点 赋值给 first 成员变量</span><br><span class="line">       if (pred &#x3D;&#x3D; null)</span><br><span class="line">           first &#x3D; newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next &#x3D; newNode;</span><br><span class="line">       pred &#x3D; newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果 index 位置的元素为 null 则遍历数组后 pred 所指向的节点即为新链表的末节点，赋值给 last 成员变量</span><br><span class="line">   if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; pred;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 否则将 pred 的 next 索引指向 succ ，succ 的 prev 索引指向 pred</span><br><span class="line">       pred.next &#x3D; succ;</span><br><span class="line">       succ.prev &#x3D; pred;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 更新当前链表的长度 size 并返回 true 表示添加成功</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   modCount++;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 批量添加节点的实现。大体分下面几个步骤：</p>
<ul>
<li>检查索引值是否合法，不合法将抛出角标越界异常</li>
<li>保存 index 位置的节点，和 index-1 位置的节点。</li>
<li>将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。</li>
<li>更新链表长度并返回添加 true 表示添加成功。</li>
</ul>
<p>越界检查最后都调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-添加节点的方法"><a href="#LinkedList-添加节点的方法" class="headerlink" title="LinkedList 添加节点的方法"></a>LinkedList 添加节点的方法</h4><p>LinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the beginning of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法默认调用<code>linkLast</code>添加到最后一个节点。</p>
<h5 id="linkXXX-方法：linkFirst、linkLast"><a href="#linkXXX-方法：linkFirst、linkLast" class="headerlink" title="linkXXX 方法：linkFirst、linkLast"></a><code>linkXXX</code> 方法：<code>linkFirst、linkLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 添加一个元素在链表的头节点位置</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加元素之前的头节点</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   &#x2F;&#x2F;以添加的元素为节点值构建新的头节点 并将 next 指针指向 之前的头节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">   &#x2F;&#x2F; first 索引指向将新的节点</span><br><span class="line">   first &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果添加之前链表空则新的节点也作为未节点</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       last &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       f.prev &#x3D; newNode;&#x2F;&#x2F;否则之前头节点的 prev 指针指向新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在链表末尾添加一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> void linkLast(E e) &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F;保存之前的未节点</span><br><span class="line">   &#x2F;&#x2F;构建新的未节点，并将新节点 prev 指针指向 之前的未节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">   &#x2F;&#x2F;last 索引指向末节点</span><br><span class="line">   last &#x3D; newNode;</span><br><span class="line">   if (l &#x3D;&#x3D; null)&#x2F;&#x2F;如果之前链表为空则新节点也作为头节点</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else&#x2F;&#x2F;否则将之前的未节点的 next 指针指向新节点</span><br><span class="line">       l.next &#x3D; newNode;</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-int-index-E-element-、addAll"><a href="#add-int-index-E-element-、addAll" class="headerlink" title="add(int index, E element)、addAll"></a>add(int index, E element)、addAll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在指定 index 位置插入节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 检查角标是否越界</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 代表是在尾部插入节点</span><br><span class="line">   if (index &#x3D;&#x3D; size)</span><br><span class="line">       linkLast(element);</span><br><span class="line">   else</span><br><span class="line">       linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="node-index-方法的实现"><a href="#node-index-方法的实现" class="headerlink" title="node(index) 方法的实现"></a>node(index) 方法的实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回一个非空节点，这个非空节点位于 index 位置</span><br><span class="line"> *&#x2F;</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 如果 index &lt; size&#x2F;2 则从0开始寻找指定角标的节点</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果 index &gt;&#x3D; size&#x2F;2 则从 size-1 开始寻找指定角标的节点</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会疑惑为什么这里注释为返回一个非空节点？其实仔细想下就明白了，这里的节点一定不为 null，如果一开始链表为空的时候，index 为 0 的位置肯定为 null，为什么不会产生异常情况呢？其实如果一开始链表中没有元素 size = 0，如果我们向 <code>index = 0</code> 的位置添加元素是不会走到 else 中的，而是会调用 <code>linkLast(element);</code> 方法去添加元素。 因此<strong>node 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;</strong></p>
<h6 id="linkBefore-E-e-Node-succ-实现"><a href="#linkBefore-E-e-Node-succ-实现" class="headerlink" title="linkBefore(E e, Node succ)实现"></a>linkBefore(E e, Node<E> succ)实现</h6><p>为什么要叫做 linkBefore 呢，因为在链表的中间位置添加节点，其实就是将 index 原来的节点前添加一个节点，添加节点我们需要知道该节点的前一个节点和当前节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; 由于 succ 一定不为空，所以可以直接获取 prev 节点</span><br><span class="line">   final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">   &#x2F;&#x2F; 新节点 prev 节点为 pred，next 节点为 succ</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">   &#x2F;&#x2F; 原节点的 prev 指向新节点</span><br><span class="line">   succ.prev &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果 pred 为空即头节点出插入了一个节点，则将新的节点赋值给 first 索引</span><br><span class="line">   if (pred &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       pred.next &#x3D; newNode;&#x2F;&#x2F;否则 pred 的下一个节点改为新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将构造的新节点前指针 prev 指向 index 的前一个元素，</p>
</li>
<li><p>新节点前指针 next 指针指向 index 位置的节点，</p>
</li>
<li><p>index 位置节点 prev 指针指向新节点</p>
</li>
<li><p>index 位置前节点（pred）的 next 指针指向新节点</p>
</li>
</ul>
<h4 id="LinkedList-删除节点的方法"><a href="#LinkedList-删除节点的方法" class="headerlink" title="LinkedList 删除节点的方法"></a>LinkedList 删除节点的方法</h4><h5 id="removeFirst、removeLast"><a href="#removeFirst、removeLast" class="headerlink" title="removeFirst、removeLast"></a><code>removeFirst</code>、<code>removeLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  删除头节点</span><br><span class="line"> * @return 删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  删除尾节点</span><br><span class="line"> *</span><br><span class="line"> * @return  删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException  如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="unlinkFirst、unlinkLast"><a href="#unlinkFirst、unlinkLast" class="headerlink" title="unlinkFirst、unlinkLast"></a><code>unlinkFirst</code>、<code>unlinkLast</code></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 移除头节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 头节点的 element 这里作为返回值使用</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    &#x2F;&#x2F; 头节点下个节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    &#x2F;&#x2F; 释放头节点的 next 指针，和 element 下次 gc 的时候回收这个内部类</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F; 将 first 索引指向新的节点</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    &#x2F;&#x2F; 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;否则 next 的 prev 指针指向 null</span><br><span class="line">    size--;&#x2F;&#x2F;改变链表长度</span><br><span class="line">    modCount++;&#x2F;&#x2F;修改操作数</span><br><span class="line">    return element;&#x2F;&#x2F;返回删除节点的值</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 移除未节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    &#x2F;&#x2F;未节点的前一个节点，</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    &#x2F;&#x2F;释放未节点的内容</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F;将 last 索引指向新的未节点</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    &#x2F;&#x2F; 链表只有一个节点的时候，first 指向 null</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刚才已经分析过node(index)方法了，就是找到index位置的节点。</p>
<h6 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Unlinks non-null node x.</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">   final E element &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F;保存 index 节点的前后两个节点</span><br><span class="line">   final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">   final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为头节点，则做 unlinkFirst 相同操作</span><br><span class="line">   if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">       first &#x3D; next;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则将上一个节点的 next 指针指向下个节点</span><br><span class="line">       prev.next &#x3D; next;</span><br><span class="line">       &#x2F;&#x2F; 释放 index 位置 prev 指针</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为尾节点，则将 last 索引指向上个节点</span><br><span class="line">   if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; prev;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则下个节点 prev 指针指向上个节点</span><br><span class="line">       next.prev &#x3D; prev;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   x.item &#x3D; null;</span><br><span class="line">   size--;</span><br><span class="line">   modCount++;</span><br><span class="line">   return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完 <code>unlink</code> 操作结合之前说的 <code>node(index)</code>，下边两种删除节点的操作，就很好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定索引位置的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *删除从头节点其第一个与 o 相同的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F; 区别对待 null 元素，比较元素时候使用 &#x3D;&#x3D; 而不是 equals</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item)) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完单个删除节点的方法 LinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Removes all of the elements from this list.</span><br><span class="line">* The list will be empty after this call returns.</span><br><span class="line">*&#x2F;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">   &#x2F;&#x2F; 依次清除节点，帮助释放内存空间</span><br><span class="line">   for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">       Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">       x.item &#x3D; null;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">       x &#x3D; next;</span><br><span class="line">   &#125;</span><br><span class="line">   first &#x3D; last &#x3D; null;</span><br><span class="line">   size &#x3D; 0;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-查询节点的方法"><a href="#LinkedList-查询节点的方法" class="headerlink" title="LinkedList 查询节点的方法"></a>LinkedList 查询节点的方法</h4><p>LinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 <code>ArrayList</code> 去替代。</p>
<h5 id="get-int-index-、getFirst-、getLast"><a href="#get-int-index-、getFirst-、getLast" class="headerlink" title="get(int index)、getFirst() 、getLast"></a><code>get(int index)、getFirst() 、getLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 根据索引查询</span><br><span class="line">*</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 first 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the first element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 last 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the last element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">   if (l &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexOf-Object-o-、lastIndexOf-Object-o"><a href="#indexOf-Object-o-、lastIndexOf-Object-o" class="headerlink" title="indexOf(Object o)、lastIndexOf(Object o)"></a><code>indexOf(Object o)、lastIndexOf(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">* 返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**头节点**起的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">* </span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return </span><br><span class="line">*&#x2F;</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 区别对待 null 元素，用 &#x3D;&#x3D; 判断，非空元素用 equels 方法判断 </span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">**返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**尾节点起**的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">*</span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return the index of the last occurrence of the specified element in</span><br><span class="line">*         this list, or -1 if this list does not contain the element</span><br><span class="line">*&#x2F;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; size;</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法分别返回从<strong>头节点起</strong>第一个与参数元素相同的节点索引，和从<strong>尾节点起</strong>第一个与参数元素相同的节点索引。</p>
<h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a><code>contains(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) !&#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 indexOf 从头结点开始查询元素位置遍历完成后若 返回值 !=-1 则表示存在，反之不存在</p>
<h4 id="LinkedList-的修改节点方法"><a href="#LinkedList-的修改节点方法" class="headerlink" title="LinkedList 的修改节点方法"></a>LinkedList 的修改节点方法</h4><p><code>LinkedList</code> 只提供了 <code>set(int index, E element)</code> 一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 判断角标是否越界</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 采用 node 方法查找对应索引的节点</span><br><span class="line">   Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">   &#x2F;&#x2F;保存节点原有的内容值</span><br><span class="line">   E oldVal &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F; 设置新值</span><br><span class="line">   x.item &#x3D; element;</span><br><span class="line">   &#x2F;&#x2F; 返回旧的值</span><br><span class="line">   return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-作为双向队列的增删改查"><a href="#LinkedList-作为双向队列的增删改查" class="headerlink" title="LinkedList 作为双向队列的增删改查"></a>LinkedList 作为双向队列的增删改查</h4><p><code>LinkedList</code>实现<code>Deque</code>接口，可实现双向队列。</p>
<h5 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h5><p><code>Queue</code> 是一个队列，遵循 FIFO 准则，我们也知道 <code>Stack</code> 是一个栈结构，遵循 FILO 准则。 而<code>Deque</code> 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。</p>
<p>Deque接口中的方法:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">头部</th>
<th align="center">头部</th>
<th align="center">尾部</th>
<th align="center">尾部</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="center">addFirst(e)</td>
<td align="center">offerFirst(e)</td>
<td align="center">addLast(e)</td>
<td align="center">offerLast(e)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="center">removeFirst()</td>
<td align="center">pollFirst()</td>
<td align="center">remveLast()</td>
<td align="center">pollLast</td>
</tr>
<tr>
<td align="left">获取</td>
<td align="center">getFirst()</td>
<td align="center">peekFirst()</td>
<td align="center">getLast()</td>
<td align="center">peekLast</td>
</tr>
</tbody></table>
<p>由于 <code>Deque</code> 接口继承 <code>Queue</code> 接口，<strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong>。我们现在复习下 <code>Queue</code> 中的方法及区别：</p>
<ul>
<li><code>Queue</code> 的 <code>offer</code> 和 <code>add</code> 都是在队列中插入一个元素，具体区别在于，对于一些 Queue 的实现的队列是有大小限制的，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。此时调用 <code>add()</code>方法会抛出异常，而 <code>offer()</code> 只是返回的 false。</li>
<li><code>remove()</code> 和 <code>poll()</code> 方法都是从队列中删除第一个元素。remove()也将抛出异常，而 <code>poll()</code> 则会返回 <code>null</code></li>
<li><code>element()</code> 和 <code>peek()</code> 用于在队列的头部查询元素。在队列为空时， <code>element()</code> 抛出一个异常，而 <code>peek()</code> 返回 <code>null</code>。</li>
</ul>
<h5 id="Deque-和-Queue-添加元素的方法"><a href="#Deque-和-Queue-添加元素的方法" class="headerlink" title="Deque 和 Queue 添加元素的方法"></a>Deque 和 Queue 添加元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">   return add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提及到 <code>Queue</code>的 <code>offer</code> 和 <code>add</code> 的区别针对容量有限制的实现，很明显 <code>LinkedList</code> 的大小并没有限制，所以在 <code>LinkedList</code> 中他们的实现并没有实质性不同。</p>
<h5 id="Deque-和-Queue-删除元素的方法"><a href="#Deque-和-Queue-删除元素的方法" class="headerlink" title="Deque 和 Queue 删除元素的方法"></a>Deque 和 Queue 删除元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 removeFirst 会抛出 NoSuchElement 异常</span><br><span class="line">public E remove() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的删除方法实现</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E poll() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deque-和-Queue-获取队列头部元素的实现"><a href="#Deque-和-Queue-获取队列头部元素的实现" class="headerlink" title="Deque 和 Queue 获取队列头部元素的实现"></a>Deque 和 Queue 获取队列头部元素的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line"> public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述我们分析了，双端队列作为队列使用的时候的各个方法的区别，也可是看出 <code>LinkedList</code> 对对应方法的实现，遵循了队列设计原则。</p>
<h4 id="LinkedList作为Stack-使用"><a href="#LinkedList作为Stack-使用" class="headerlink" title="LinkedList作为Stack`使用"></a>LinkedList<code>作为</code>Stack`使用</h4><p>下面我们来看看下双端队列作为栈 <code>Stack</code>使用的时候方法对应关系，与 <code>Queue</code> 不同，<code>Stack</code> 本身就是实现类，他拥有 FILO 的原则， <code>Stack</code> 的入栈操作通过 <code>push</code> 方法进行，出栈操作通过 <code>pop</code> 方法进行，查询操作通过 <code>peek</code> 操作进行。 <strong><code>Deque</code> 作为栈使用的时候，也遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的。</strong></p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFist(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><code>LinkedList</code>中的<code>push</code>、<code>pop</code>、<code>peek</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void push(E e) &#123;</span><br><span class="line">   addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pop() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-的遍历"><a href="#LinkedList-的遍历" class="headerlink" title="LinkedList 的遍历"></a>LinkedList 的遍历</h4><p>在 <code>ArrayList</code> 分析的时候，我们就知道 <code>List</code> 的实现类，有4中遍历方式：for 循环，高级 for 循环，<code>Iterator</code> 迭代器方法， <code>ListIterator</code> 迭代方法。</p>
<p><code>LinkedList</code> 没有单独 <code>Iterator</code> 实现类，它的 <code>iterator</code> 和 <code>listIterator</code> 方法均返回 <code>ListItr</code>的一个对象。 LinkedList 作为双向链表数据结构，获取上个元素和下个元素很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 上一个遍历的节点</span><br><span class="line">   private Node&lt;E&gt; lastReturned;</span><br><span class="line">   &#x2F;&#x2F; 下一次遍历返回的节点</span><br><span class="line">   private Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; cursor 指针下一次遍历返回的节点</span><br><span class="line">   private int nextIndex;</span><br><span class="line">   &#x2F;&#x2F; 期望的操作数</span><br><span class="line">   private int expectedModCount &#x3D; modCount;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; 根据参数 index 确定生成的迭代器 cursor 的位置</span><br><span class="line">   ListItr(int index) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert isPositionIndex(index);</span><br><span class="line">       &#x2F;&#x2F; 如果 index &#x3D;&#x3D; size 则 next 为 null 否则寻找 index 位置的节点</span><br><span class="line">       next &#x3D; (index &#x3D;&#x3D; size) ? null : node(index);</span><br><span class="line">       nextIndex &#x3D; index;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 判断指针是否还可以移动</span><br><span class="line">   public boolean hasNext() &#123;</span><br><span class="line">       return nextIndex &lt; size;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 返回下一个带遍历的元素</span><br><span class="line">  public E next() &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查操作数是否合法</span><br><span class="line">       checkForComodification();</span><br><span class="line">       &#x2F;&#x2F; 如果 hasNext 返回 false 抛出异常，所以我们在调用 next 前应先调用 hasNext 检查</span><br><span class="line">       if (!hasNext())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 移动 lastReturned 指针</span><br><span class="line">       lastReturned &#x3D; next;</span><br><span class="line">        &#x2F;&#x2F; 移动 next 指针</span><br><span class="line">       next &#x3D; next.next;</span><br><span class="line">       &#x2F;&#x2F; 移动 nextIndex cursor</span><br><span class="line">       nextIndex++;</span><br><span class="line">       &#x2F;&#x2F; 返回移动后 lastReturned</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前游标位置是否还有前一个元素</span><br><span class="line">   public boolean hasPrevious() &#123;</span><br><span class="line">       return nextIndex &gt; 0;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 当前游标位置的前一个元素</span><br><span class="line">   public E previous() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (!hasPrevious())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 等同于 lastReturned &#x3D; next；next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">        &#x2F;&#x2F; 发生在 index &#x3D; size 时</span><br><span class="line">       lastReturned &#x3D; next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">       nextIndex--;</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public int nextIndex() &#123;</span><br><span class="line">       return nextIndex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int previousIndex() &#123;</span><br><span class="line">       return nextIndex - 1;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 删除链表当前节点也就是调用 next&#x2F;previous 返回的这节点，也就 lastReturned</span><br><span class="line">   public void remove() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; lastNext &#x3D; lastReturned.next;</span><br><span class="line">       &#x2F;&#x2F;调用LinkedList 的删除节点的方法</span><br><span class="line">       unlink(lastReturned);</span><br><span class="line">       if (next &#x3D;&#x3D; lastReturned)</span><br><span class="line">           next &#x3D; lastNext;</span><br><span class="line">       else</span><br><span class="line">           nextIndex--;</span><br><span class="line">       &#x2F;&#x2F;上一次所操作的 节点置位空    </span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置当前遍历的节点的值</span><br><span class="line">   public void set(E e) &#123;</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned.item &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 在 next 节点位置插入及节点</span><br><span class="line">   public void add(E e) &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       if (next &#x3D;&#x3D; null)</span><br><span class="line">           linkLast(e);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(e, next);</span><br><span class="line">       nextIndex++;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;简单哈操作数是否合法</span><br><span class="line">   final void checkForComodification() &#123;</span><br><span class="line">       if (modCount !&#x3D; expectedModCount)</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>链表LinkedList和数组ArrayList的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同。实际使用时根据特定的需求选用合适的类。</p>
<ul>
<li><p>ArrayList基于数组；LinkedList基于双向链表。</p>
</li>
<li><p>查找方面。数组的效率更高，可以直接索引出查找；而链表必须从头查找。</p>
</li>
<li><p>插入删除方面。特别是在中间进行插入删除，这时候链表体现出了极大的便利性，只需要在插入或者删除的地方断掉链然后插入或者移除元素，然后再将前后链重新组装；但是数组必须重新复制一份将所有数据后移或者前移。</p>
</li>
<li><p>在内存申请方面，当数组达到初始的申请长度后，需要重新申请一个更大的数组然后把数据迁移过去才行。而链表只需要动态创建即可。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Vector-向量"><a href="#Vector-向量" class="headerlink" title="Vector 向量"></a>Vector 向量</h3><p>Vector非常类似ArrayList。<strong>Vector是同步的</strong>。当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p>
<h4 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h4><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。</p>
<h2 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a>Set子接口</h2><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。</p>
<h3 id="HashSet-散列集"><a href="#HashSet-散列集" class="headerlink" title="HashSet 散列集"></a>HashSet 散列集</h3><p>HashSet实现了Set接口，基于HashMap进行存储。遍历时不保证顺序，并且不保证下次遍历的顺序和之前一样。HashSet中允许null元素。</p>
<p>在初始化中，创建HashMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法调用的也是HashMap中的方法，key就是传入的元素，value是Object对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>意思就是HashSet的集合其实就是HashMap的key的集合，然后HashMap的val默认都是PRESENT。HashMap的定义即是key不重复的集合。使用HashMap实现，这样HashSet就不需要再实现一遍。</p>
<p>所以所有的add，remove等操作其实都是HashMap的add、remove操作。遍历操作其实就是HashMap的keySet的遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void clear() &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LinkedHashSet-链式散列集"><a href="#LinkedHashSet-链式散列集" class="headerlink" title="LinkedHashSet 链式散列集"></a>LinkedHashSet 链式散列集</h3><p>LinkedHashSet的核心概念相对于HashSet来说就是一个可以保持顺序的Set集合。HashSet是无序的，LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。这个顺序不是元素的大小顺序，而是可以保证2次遍历的顺序是一样的。</p>
<p>类似HashSet基于HashMap的源码实现，LinkedHashSet的数据结构是基于LinkedHashMap。</p>
<h3 id="TreeSet-树形集"><a href="#TreeSet-树形集" class="headerlink" title="TreeSet 树形集"></a>TreeSet 树形集</h3><p>TreeSet即是一组有次序的集合，如果没有指定排序规则Comparator，则会按照自然排序。（自然排序即e1.compareTo(e2) == 0作为比较）</p>
<p>TreeSet源码的算法即基于TreeMap，扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20190607103330622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。</p>
<ul>
<li><p><code>boolean add(E e)</code>：</p>
</li>
<li><p><code>boolean offer(E e)</code>：向队列添加一个元素</p>
</li>
<li><p><code>E poll()</code>：移除队列头部元素（队列为空返回null）</p>
</li>
<li><p><code>E remove()</code>：移除队列头部元素（队列为空抛出异常）</p>
</li>
<li><p><code>E element();</code>：获取头部元素</p>
</li>
<li><p><code>E peek();</code>：获取头部元素</p>
</li>
</ul>
<h3 id="Deque-双端队列-1"><a href="#Deque-双端队列-1" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h3><p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。</p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it &#x3D; collection.iterator(); &#x2F;&#x2F; 获得一个迭代子  </span><br><span class="line">while(it.hasNext()) &#123;  </span><br><span class="line">Object obj &#x3D; it.next(); &#x2F;&#x2F; 得到下一个元素  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638145a2ead2bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="这里写图片描述"></p>
<p>Map是图接口，存储键值对映射的容器类。Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。</p>
<ul>
<li>Map 是<strong>映射接口</strong>，Map中存储的内容是<strong>键值对</strong>(key-value)</li>
<li>AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。</li>
<li>SortedMap 是继承于Map的接口。SortedMap中的内容是<strong>排序的键值对</strong>，排序的方法是通过比较器(Comparator)</li>
<li>NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。 </li>
<li>TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“<strong>有序的键值对”</strong>！</li>
<li>HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“<strong>键值对，但不保证次序</strong>”！</li>
<li>Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“<strong>键值对，也不保证次序”</strong>。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。</li>
<li>WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，<strong>WeakHashMap的键是“弱键</strong>”。</li>
</ul>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    interface Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型&lt;K,V&gt;分别代表key和value的类型。这时候注意到还定义了一个内部接口Entry，其实每一个键值对都是一个Entry的实例关系对象，所以Map实际其实就是Entry的一个Collection，然后Entry里面包含key，value。再设定key不重复的规则，自然就演化成了Map。</p>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map集合提供3种遍历访问方法：</p>
<ul>
<li><p>Set keySet() 获得所有key的集合然后通过key访问value会返回所有key的Set集合，因为key不可以重复，所以返回的是Set格式，而不是List格式。（之后会说明Set，List区别。这里先告诉一点Set集合内元素是不可以重复的，而List内是可以重复的） 获取到所有key的Set集合后，由于Set是Collection类型的，所以可以通过Iterator去遍历所有的key，然后再通过get方法获取value。</p>
</li>
<li><p>Collection values() 获得value的集合。直接获取values的集合，无法再获取到key。所以如果只需要value的场景可以用这个方法。获取到后使用Iterator去遍历所有的value。</p>
</li>
<li><p>Set&lt; Map.Entry&lt; K, V&gt;&gt; entrySet() 获得key-value键值对的集合。</p>
</li>
</ul>
<p>通过以上3种遍历方式我们可以知道，如果你只想获取key，建议使用keySet。如果只想获取value，建议使用values。如果key value希望遍历，建议使用entrySet。</p>
<p>Map的访问顺序取决于Map的遍历访问方法的遍历顺序。 有的Map，比如TreeMap可以保证访问顺序，但是有的比如HashMap，无法保证访问顺序。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>常见的哈希函数：</p>
<ul>
<li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</li>
<li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</li>
<li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</li>
<li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li>
<li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li>
<li>伪随机数法：采用一个伪随机数当作哈希函数。</li>
</ul>
<p>哈希表是一种通过哈希函数将特定的键映射到特定值的一种数据结构，他维护者键和值之间一一对应关系。</p>
<ul>
<li>键(key)：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分。</li>
<li>桶(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将键(key)映射(map)到数据应该存放的槽(slot)所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的键映射到同一个索引的情况。</li>
</ul>
<p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p>
<p><strong>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</strong></p>
<h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>哈希冲突后，用链表去延展来解决。将所有关键字为同义词的记录存储在同一线性链表中。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190725082450961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="开地址法"><a href="#开地址法" class="headerlink" title="开地址法"></a>开地址法</h4><p>哈希冲突后，并不会在本身之外开拓新的空间，而是继续顺延下去某个位置来存放。</p>
<p>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)</p>
<p>其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。</p>
<p>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。</p>
<p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>就是同时构造多个不同的哈希函数：<br> Hi = RHi(key)   i= 1,2,3 … k;<br> 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h4 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h4><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。哈希表为解决冲突，采用了链地址法,简单来说，就是数组加链表的结合,当哈希冲突时，数组上的数据采用链表的方式把新数据插到链尾。</p>
<p>当出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当<strong>链表长度太长（默认超过8）时，链表就转换为红黑树</strong></p>
<p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>从结构实现来讲，HashMap是:<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210635_58179.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">		&#x2F;&#x2F;默认容量</span><br><span class="line">		static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">		&#x2F;&#x2F;最大容量</span><br><span class="line">		static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">		&#x2F;&#x2F;默认加载因子</span><br><span class="line">		static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">		&#x2F;&#x2F;链表转成红黑树的阈值</span><br><span class="line">		static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">		&#x2F;&#x2F;红黑树转为链表的阈值</span><br><span class="line">		static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">		&#x2F;&#x2F;哈希桶数组</span><br><span class="line">		transient Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 存放具体元素的集</span><br><span class="line">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存储方式由链表转成红黑树的容量的最小阈值</span><br><span class="line">		static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">		&#x2F;&#x2F;HashMap中存储的键值对的数量</span><br><span class="line">		transient int size;</span><br><span class="line">		&#x2F;&#x2F;扩容阈值，当size&gt;&#x3D;threshold时，就会扩容</span><br><span class="line">		int threshold;</span><br><span class="line">		&#x2F;&#x2F;HashMap的加载因子</span><br><span class="line">		final float loadFactor;</span><br><span class="line">		</span><br><span class="line">		public HashMap() &#123;</span><br><span class="line">        &#x2F;&#x2F;默认构造函数，赋值加载因子为默认的0.75f</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;指定初始化容量的构造函数</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;同时指定初始化容量 以及 加载因子， 用的很少，一般不会修改loadFactor</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;初始容量最大不能超过2的30次方</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F;显然加载因子不能为负数</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;新建一个哈希表，同时将另一个map m 里的所有元素加入表中</span><br><span class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">		static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue &#x3D; value;</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o &#x3D;&#x3D; this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;根据期望容量cap，返回2的n次方形式的 哈希桶的实际容量 length。 返回值一般会&gt;&#x3D;cap </span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    &#x2F;&#x2F;经过下面的 或 和位移 运算， n最终各位都是1。</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        &#x2F;&#x2F;判断n是否越界，返回 2的n次方作为 table（哈希桶）的阈值</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>一些重要的参数：</p>
<ul>
<li>初始容量（initialCapacity，默认为16）</li>
<li>如果initialCapacity不为2的幂值，HashMap会自动选择比initialCapacity大的下一个2的幂值作为初始容量。</li>
<li>负载系数（loadFactor，默认为0.75）</li>
<li>当HashMap.size()大于<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。</li>
</ul>
<h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123; &#x2F;&#x2F;jdk1.8 &amp; jdk1.7</span><br><span class="line"> int h;</span><br><span class="line"> &#x2F;&#x2F; h &#x3D; key.hashCode() 为第一步 取hashCode值</span><br><span class="line"> &#x2F;&#x2F; h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算</span><br><span class="line"> return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么所计算得到的Hash码值总是相同的。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210658_66827.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<h3 id="存储数据-put"><a href="#存储数据-put" class="headerlink" title="存储数据 put"></a>存储数据 put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先根据key，取得hash值。再插入节点</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        &#x2F;&#x2F;tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        &#x2F;&#x2F;如果当前哈希表是空的，代表是初始化，执行扩容</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        		&#x2F;&#x2F;扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        &#x2F;&#x2F;如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span><br><span class="line">        &#x2F;&#x2F;index 是利用 哈希值 &amp; 哈希桶的长度-1，替代模运算</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;&#x2F;&#x2F;发生了哈希冲突。</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            &#x2F;&#x2F;如果哈希值相等，key也相等，则是覆盖value操作</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F;将当前节点引用赋值给e</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)&#x2F;&#x2F;此处代表红黑树</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;&#x2F;&#x2F;此处代表链表</span><br><span class="line">	           		 &#x2F;&#x2F;遍历链表</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">		                    &#x2F;&#x2F;遍历到尾部，追加新节点到尾部</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        &#x2F;&#x2F;如果追加节点后，链表数量&gt;&#x3D;8，则转化为红黑树</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        &#x2F;&#x2F;treeifyBin首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，</span><br><span class="line">                        &#x2F;&#x2F;如果达到64，那么将冲突的存储结构为红黑树</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;如果找到了要覆盖的节点,结束遍历</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             &#x2F;&#x2F;如果e不是null，链表上有相同的key值，</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">		            &#x2F;&#x2F;则覆盖节点值，并返回原oldValue</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F;这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line">        &#x2F;&#x2F;修改modCount</span><br><span class="line">        ++modCount;</span><br><span class="line">    	  &#x2F;&#x2F;更新size，并判断是否需要扩容。</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        &#x2F;&#x2F;这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210713_35028.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ol>
<h3 id="获取数据-get"><a href="#获取数据-get" class="headerlink" title="获取数据 get"></a>获取数据 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F; 定位键值对所在桶的位置</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;直接命中</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            &#x2F;&#x2F; 桶中不止一个节点</span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果 first 是 TreeNode 类型，则调用黑红树查找方法</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">	                	&#x2F;&#x2F;对链表进行查找</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>get方法做了4件事：</p>
<ul>
<li>计算key的hash值；</li>
<li>找到key所在的桶及其第一个元素；</li>
<li>如果第一个元素的key等于待查找的key，直接返回；</li>
<li>如果第一个元素是树节点就按树的方式来查找，否则按链表方式查找；</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容(resize)就是重新计算容量，Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        &#x2F;&#x2F;oldTab 为当前表的哈希桶</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;当前哈希桶的容量 length</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        &#x2F;&#x2F;当前的阈值</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        &#x2F;&#x2F;初始化新的容量和阈值为0</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;如果当前容量大于0</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果当前容量已经到达上限</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                &#x2F;&#x2F;则设置阈值是2的31次方-1</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                &#x2F;&#x2F;同时返回当前的哈希桶，不再扩容</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;&#x2F;&#x2F;否则新的容量为旧的容量的两倍。 </span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)&#x2F;&#x2F;如果旧的容量大于等于默认初始容量16</span><br><span class="line">                &#x2F;&#x2F;那么新的阈值也等于旧的阈值的两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;&#x2F;&#x2F;如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;&#x2F;&#x2F;那么新表的容量就等于旧的阈值</span><br><span class="line">        else &#123;&#125;&#x2F;&#x2F;如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量&#x2F;阈值参数的情况               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;&#x2F;&#x2F;此时新表的容量为默认的容量 16</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&#x2F;&#x2F;新的阈值为默认容量16 * 默认加载因子0.75f &#x3D; 12</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		        &#x2F;&#x2F;根据新表容量 和 加载因子 求出新的阈值</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            &#x2F;&#x2F;进行越界修复</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新阈值 </span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        		&#x2F;&#x2F;根据新的容量 构建新的哈希桶</span><br><span class="line">            Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        &#x2F;&#x2F;更新哈希桶引用</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        &#x2F;&#x2F;如果以前的哈希桶中有元素</span><br><span class="line">        &#x2F;&#x2F;下面开始将当前哈希桶中的所有节点转移到新的哈希桶中</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历老的哈希桶</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                &#x2F;&#x2F;取出当前的节点 e</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                &#x2F;&#x2F;如果当前桶中有元素,则将链表赋值给e</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;将原哈希桶置空以便GC</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;如果当前链表中就一个元素，（没有发生哈希碰撞）</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        &#x2F;&#x2F;直接将这个元素放置在新的哈希桶里。</span><br><span class="line">                        &#x2F;&#x2F;注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    &#x2F;&#x2F;如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        &#x2F;&#x2F;新计算在新表的位置，并进行搬运</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;                   </span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;&#x2F;&#x2F;临时节点 存放e的下一个节点</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;&#x2F;这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                &#x2F;&#x2F;给头尾节点指针赋值</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;&#x2F;&#x2F;高位也是相同的逻辑</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;&#x2F;&#x2F;循环直到链表结束</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        &#x2F;&#x2F;将低位链表存放在原index处，</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F;将高位链表存放在新index处</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，根据hash值重新计算下角标（newTab[e.hash &amp; (newCap - 1)]），并把它们放置到合适的位置上去。</p>
<p>源码做了三件事：</p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。</p>
<p><strong>在并发的多线程使用场景中使用HashMap可能造成死循环。</strong></p>
<h3 id="重点及面试题"><a href="#重点及面试题" class="headerlink" title="重点及面试题"></a>重点及面试题</h3><ul>
<li>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；</li>
<li>HashMap的默认初始容量为16（1&lt;&lt;4），默认装载因子为0.75f，容量总是2的n次方；</li>
<li>HashMap扩容时每次容量变为原来的两倍；</li>
<li>当桶的数量小于64时不会进行树化，只会扩容；</li>
<li>当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；</li>
<li>当单个桶中元素数量小于6时，进行反树化；</li>
<li>HashMap查找添加元素的时间复杂度都为O(1)；</li>
<li>HashMap是非线程安全的容器</li>
<li>允许使用null值和null键(HashMap最多只允许一条记录的键为null，允许多条记录的值为null)。</li>
<li>HashMap中不允许出现重复的键（Key）</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。</p>
<p>添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。HashTable是<strong>同步</strong>方法，线程安全但是效率低。</p>
<p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashTable使用数组+单向列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class Hashtable&lt;K,V&gt;</span><br><span class="line">    extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    		</span><br><span class="line">        &#x2F;&#x2F; Hashtable保存key-value的数组。</span><br><span class="line">		    &#x2F;&#x2F; Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表</span><br><span class="line">        private transient HashtableEntry&lt;?,?&gt;[] table;</span><br><span class="line">		    &#x2F;&#x2F; Hashtable中元素的实际数量</span><br><span class="line">				private transient int count;</span><br><span class="line">				&#x2F;&#x2F; 阈值，用于判断是否需要调整Hashtable的容量（threshold &#x3D; 容量*加载因子）</span><br><span class="line">				private int threshold;</span><br><span class="line">				&#x2F;&#x2F; 加载因子</span><br><span class="line">				private float loadFactor;</span><br><span class="line">				</span><br><span class="line">		    &#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数</span><br><span class="line">				public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">        if (initialCapacity&#x3D;&#x3D;0)</span><br><span class="line">            initialCapacity &#x3D; 1;</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;创建对象时创建数组并非像HashMap那样懒加载</span><br><span class="line">        table &#x3D; new HashtableEntry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">        &#x2F;&#x2F; Android-changed: Ignore loadFactor when calculating threshold from initialCapacity</span><br><span class="line">        &#x2F;&#x2F; threshold &#x3D; (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        threshold &#x3D; (int)Math.min(initialCapacity, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 指定“容量大小”的构造函数</span><br><span class="line">     public Hashtable(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 默认构造函数。</span><br><span class="line">    public Hashtable() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认构造函数，指定的容量大小是11；加载因子是0.75</span><br><span class="line">        this(11, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</span><br><span class="line">        this(Math.max(2*t.size(), 11), 0.75f);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static class HashtableEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    		final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        HashtableEntry&lt;K,V&gt; next;</span><br><span class="line">    		</span><br><span class="line">    		 protected HashtableEntry(int hash, K key, V value, HashtableEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">    		 		&#x2F;**hash值*&#x2F;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">             &#x2F;**key表示键*&#x2F;</span><br><span class="line">            this.key &#x3D;  key;</span><br><span class="line">            &#x2F;**value表示值*&#x2F;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">             &#x2F;**节点下一个元素*&#x2F;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>put() 的作用是<strong>对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F; Make sure the value is not null</span><br><span class="line">        &#x2F;&#x2F; Hashtable中不能插入value为null的元素！！！</span><br><span class="line">        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F; Makes sure the key is not already in the hashtable.</span><br><span class="line">         &#x2F;&#x2F; 若“Hashtable中已存在键为key的键值对”，</span><br><span class="line">		    &#x2F;&#x2F; 则用“新的value”替换“旧的value”</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">        int hash &#x3D; key.hashCode();</span><br><span class="line">        int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        HashtableEntry&lt;K,V&gt; entry &#x3D; (HashtableEntry&lt;K,V&gt;)tab[index];</span><br><span class="line">        for(; entry !&#x3D; null ; entry &#x3D; entry.next) &#123;</span><br><span class="line">            if ((entry.hash &#x3D;&#x3D; hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old &#x3D; entry.value;</span><br><span class="line">                entry.value &#x3D; value;</span><br><span class="line">                return old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				&#x2F;&#x2F;“Hashtable中不存在键为key的键值对”，</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    		&#x2F;&#x2F;将“修改统计数”+1</span><br><span class="line">        modCount++;</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;若“Hashtable实际容量” &gt; “阈值”(阈值&#x3D;总的容量 * 加载因子)</span><br><span class="line">        if (count &gt;&#x3D; threshold) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rehash the table if the threshold is exceeded</span><br><span class="line">            &#x2F;&#x2F;则调整Hashtable的大小</span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab &#x3D; table;</span><br><span class="line">            hash &#x3D; key.hashCode();</span><br><span class="line">            index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Creates the new entry.</span><br><span class="line">        &#x2F;&#x2F;将“Hashtable中index”位置的Entry(链表)保存到e中</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        HashtableEntry&lt;K,V&gt; e &#x3D; (HashtableEntry&lt;K,V&gt;) tab[index];</span><br><span class="line">        &#x2F;&#x2F;创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。       </span><br><span class="line">        tab[index] &#x3D; new HashtableEntry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        &#x2F;&#x2F;将“Hashtable的实际容量”+1</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/ebdd7991f4634d4393568b0632d769ab.jpg" alt="img"></p>
<p>put方法执行流程：</p>
<ol>
<li>校验null值，value不允许null值。</li>
<li>计算出key的哈希值，用哈希值和数组的长度得到index下角标。</li>
<li>根据index找到节点。</li>
<li>如果节点中有元素则遍历链表如果找到则替换旧值并返回旧值。</li>
<li>如果没找到旧值则执行<code>addEntry</code>方法，创建节点并加入哈希桶中。<code>addEntry</code>方法：<ol>
<li>首先判断是否需要扩容</li>
<li>创建节点</li>
<li>添加哈希桶中</li>
</ol>
</li>
</ol>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">         &#x2F;&#x2F; 计算索引值，</span><br><span class="line">        int hash &#x3D; key.hashCode();</span><br><span class="line">        int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#x2F;&#x2F; 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span><br><span class="line">        for (HashtableEntry&lt;?,?&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">            if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                return (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据index直接找到节点，并进行比较，找到了就返回value，没找到返回null。</p>
<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/82a5ff28b5c14da29f3081db4cc2cd23.jpg" alt="img"></p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>remove() 的作用就是<strong>删除Hashtable中键为key的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#x2F;&#x2F; 找到“key对应的Entry(链表)”</span><br><span class="line">    &#x2F;&#x2F; 然后在链表中找出要删除的节点，并删除该节点。</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; tab[index], prev &#x3D; null ; e !&#x3D; null ; prev &#x3D; e, e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            &#x2F;&#x2F;重新排列链表</span><br><span class="line">            if (prev !&#x3D; null) &#123;</span><br><span class="line">                prev.next &#x3D; e.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/7486b49ac2f4410099b5764082a6d352.jpg" alt="img"></p>
<h4 id="rehash-扩容"><a href="#rehash-扩容" class="headerlink" title="rehash 扩容"></a>rehash 扩容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">				&#x2F;&#x2F;旧数组的长度</span><br><span class="line">        int oldCapacity &#x3D; table.length;</span><br><span class="line">        &#x2F;&#x2F;旧数组</span><br><span class="line">        HashtableEntry&lt;?,?&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;新数组的长度是&#x3D;将长度变成原来的(2倍+1)</span><br><span class="line">        int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">        &#x2F;&#x2F;是否超过可存储数量的最大值</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        		&#x2F;&#x2F;已经到了最大值直接返回，不允许扩容</span><br><span class="line">            if (oldCapacity &#x3D;&#x3D; MAX_ARRAY_SIZE)</span><br><span class="line">                &#x2F;&#x2F; Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">                return;</span><br><span class="line">            &#x2F;&#x2F;没有达到最大值，直接把新数组赋值到最大值</span><br><span class="line">            newCapacity &#x3D; MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建新的数组</span><br><span class="line">        HashtableEntry&lt;?,?&gt;[] newMap &#x3D; new HashtableEntry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        &#x2F;&#x2F;计算阀值 newCapacity * loadFactor 如果到达最大存储容量，以后都不会触法</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        table &#x3D; newMap;</span><br><span class="line">				&#x2F;&#x2F;循环获取获取所有节点</span><br><span class="line">        for (int i &#x3D; oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        		&#x2F;&#x2F;循环获取节点下的所有元素</span><br><span class="line">            for (HashtableEntry&lt;K,V&gt; old &#x3D; (HashtableEntry&lt;K,V&gt;)oldMap[i] ; old !&#x3D; null ; ) &#123;</span><br><span class="line">                HashtableEntry&lt;K,V&gt; e &#x3D; old;</span><br><span class="line">                old &#x3D; old.next;</span><br><span class="line">								&#x2F;&#x2F;获取元素新的index，并存入对应的哈希桶中</span><br><span class="line">                int index &#x3D; (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">                e.next &#x3D; (HashtableEntry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有操作数据的方法都是<code>synchronized</code>线程安全的，尽管，Hashtable 虽然是线程安全的，但是我们一般不推荐使用它，因为有比它更高效、更好的选择 ConcurrentHashMap，在后面我们也会讲到它。</p>
<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul>
<li>HashMap线程不安全；Hashtable线程安全。</li>
<li>因为线程安全的问题，HashMap 要比 HashTable 效率高一点。</li>
<li>HashMap使用时候初始化哈希桶；Hashtable创建对象时创建哈希桶。</li>
<li>HashMap扩容是原来的两倍；Hashtable扩容是原来的两倍+1。</li>
<li>HashMap的初始容量为16；Hashtable初始容量为11，两者的填充因子默认都是0.75</li>
<li>HashMap允许有null值；Hashtable不允许有null值。</li>
<li>HashMap数组+链表+红黑树；Hashtable数组+链表。</li>
</ul>
<h2 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h2><ul>
<li>HashMap实现Map接口；HashSet实现Set接口。</li>
<li>HashMap储存键值对；HashSet仅存储对象（<code>value</code>是空<code>Object</code>对象）。</li>
<li>HashSet基于HashMap，内部持有HashMap引用，核心方法调用都是HashMap。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap实现了Map接口。基本实现同HashMap一样，不同之处在于HashMap是无序的而LinkedHashMap保证了迭代的有序性。其内部维护了一个双向链表，解决了 HashMap不能随时保持遍历顺序和插入顺序一致的问题。</p>
<p><strong>默认情况下，LinkedHashMap的迭代顺序是按照插入节点的顺序。也可以通过改变accessOrder参数的值，使得其遍历顺序按照访问顺序输出。</strong></p>
<p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构。该结构由数组和链表或红黑树组成。本质上，HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。在LinkedHashMapMap中，所有put进来的Entry都保存在如下面第一个图所示的哈希表中，但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166327271293.jpg" alt="img"></p>
<p>LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。其结构可能如下图：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="img"></p>
<p>上图中，淡蓝色的箭头表示前驱引用，红色箭头表示后继引用。每当有新键值对节点插入，新节点最终会接在 tail 引用指向的节点后面。而 tail 引用则会移动到新的节点上，这样一个双向链表就建立起来了。</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line"></span><br><span class="line">		static class LinkedHashMapEntry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line">        LinkedHashMapEntry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     transient LinkedHashMapEntry&lt;K,V&gt; head;</span><br><span class="line">     </span><br><span class="line">     transient LinkedHashMapEntry&lt;K,V&gt; tail;</span><br><span class="line">     </span><br><span class="line">     final boolean accessOrder;</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F;默认初始容量 (16)和默认负载因子(0.75)的空 LinkedHashMap</span><br><span class="line">     public LinkedHashMap() &#123;</span><br><span class="line">     		&#x2F;&#x2F; 调用HashMap对应的构造函数</span><br><span class="line">        super();</span><br><span class="line">        &#x2F;&#x2F; 迭代顺序的默认值</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">        super(initialCapacity);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder &#x3D; accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header、tail</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p>
<p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。</p>
<p>Map 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。那么，LinkedHashMap 是怎样建立链表的呢？在展开说明之前，我们先看一下 LinkedHashMap 插入操作相关的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;...&#125;</span><br><span class="line">    &#x2F;&#x2F; 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#123;...&#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        else if (p instanceof TreeNode) &#123;...&#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历链表，并统计链表长度</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 未在单链表中找到要插入的节点，将新节点接在单链表的后面</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#123;...&#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 插入的节点已经存在于单链表中</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null) &#123;...&#125;</span><br><span class="line">            afterNodeAccess(e);    &#x2F;&#x2F; 回调方法，后续说明</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold) &#123;...&#125;</span><br><span class="line">    afterNodeInsertion(evict);    &#x2F;&#x2F; 回调方法，后续说明</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    &#x2F;&#x2F; 将 Entry 接在双向链表的尾部</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中实现</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail;</span><br><span class="line">    tail &#x3D; p;</span><br><span class="line">    &#x2F;&#x2F; last 为 null，表明链表还未建立</span><br><span class="line">    if (last &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; p;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新节点 p 接在链表尾部</span><br><span class="line">        p.before &#x3D; last;</span><br><span class="line">        last.after &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是 LinkedHashMap 插入相关的源码，这里省略了部分非关键的代码。我根据上面的代码，可以知道 LinkedHashMap 插入操作的调用过程。如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166881843975.jpg" alt="img"></p>
<p>newNode()这一步比较关键。LinkedHashMap 覆写了该方法。在这个方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。</p>
<p>HashMap中有三个回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>根据这三个方法的注释可以看出，这些方法的用途是在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的。上一节最后提到 HashMap 中三个回调方法运行 LinkedHashMap 对一些操作做出响应。所以，在删除及节点后，回调方法 <code>afterNodeRemoval</code> 会被调用。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。相关源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            node &#x3D; p;</span><br><span class="line">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">            if (p instanceof TreeNode) &#123;...&#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历单链表，寻找要删除的节点，并赋值给 node 变量</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                         (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node &#x3D; e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                             (value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode) &#123;...&#125;</span><br><span class="line">            &#x2F;&#x2F; 将要删除的节点从单链表中移除</span><br><span class="line">            else if (node &#x3D;&#x3D; p)</span><br><span class="line">                tab[index] &#x3D; node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next &#x3D; node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);    &#x2F;&#x2F; 调用删除回调方法进行后续操作</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">    &#x2F;&#x2F; 将 p 节点的前驱后后继引用置空</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; b 为 null，表明 p 是头节点</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    &#x2F;&#x2F; a 为 null，表明 p 是尾节点</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除的过程并不复杂，上面这么多代码其实就做了三件事：</p>
<ol>
<li>根据 hash 定位到桶位置</li>
<li>遍历链表或调用红黑树相关的删除方法</li>
<li>从 LinkedHashMap 维护的双链表中移除要删除的节点</li>
</ol>
<h3 id="访问顺序的维护过程"><a href="#访问顺序的维护过程" class="headerlink" title="访问顺序的维护过程"></a>访问顺序的维护过程</h3><p>默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。访问顺序的原理上并不复杂，当我们调用<code>get/getOrDefault/replace</code>等方法时，只需要将这些方法访问的节点移动到链表的尾部即可。相应的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    &#x2F;&#x2F; 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 如果 b 为 null，表明 p 为头节点</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">            </span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 这里存疑，父条件分支已经确保节点 e 不会是尾节点，</span><br><span class="line">         * 那么 e.after 必然不会为 null，不知道 else 分支有什么作用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">    </span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 将 p 接在链表的最后</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-LinkedHashMap-实现缓存"><a href="#基于-LinkedHashMap-实现缓存" class="headerlink" title="基于 LinkedHashMap 实现缓存"></a>基于 LinkedHashMap 实现缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    &#x2F;&#x2F; 根据条件判断是否移除最近最少被访问的节点</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是通过一些条件，判断是否移除最近最少被访问的节点。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写<code>removeEldestEntry</code>方法可以实现自定义策略的 LRU 缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等。本节所实现的缓存是基于判断节点数量是否超限的策略。在构造缓存对象时，传入最大节点数。当插入的节点数超过最大节点数时，移除最近最少被访问的节点。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_NODE_NUM &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    private int limit;</span><br><span class="line"></span><br><span class="line">    public SimpleCache() &#123;</span><br><span class="line">        this(MAX_NODE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SimpleCache(int limit) &#123;</span><br><span class="line">        super(limit, 0.75f, true);</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V save(K key, V val) &#123;</span><br><span class="line">        return put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V getOne(K key) &#123;</span><br><span class="line">        return get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean exists(K key) &#123;</span><br><span class="line">        return containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断节点数是否超限</span><br><span class="line">     * @param eldest</span><br><span class="line">     * @return 超限返回 true，否则返回 false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<p>举例：声明了两个Map对象，一个是HashMap，一个是WeakHashMap，同时向两个map中放入a、b两个对象，当HashMap remove掉a 并且将a、b都指向null时，WeakHashMap中的a将自动被回收掉。出现这个状况的原因是，对于a对象而言，当HashMap remove掉并且将a指向null后，除了WeakHashMap中还保存a外已经没有指向a的指针了，所以WeakHashMap会自动舍弃掉a，而对于b对象虽然指向了null，但HashMap中还有指向b的指针，所以WeakHashMap将会保留。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>在看TreeMap底层结构之前，必要先要了解下<strong>树</strong>！树是一种数据结构</p>
<p><strong>数组的特点是查询迅速</strong>，根据index可以快速定位到一个元素，如果要插入一个元素，就需要将这个元素位置之后的所有元素后移。序数组的插入的时间复杂度为O(N)，删除操作的时间复杂度也为O(N)。</p>
<p><strong>链表的插入和删除效率都很高</strong>，只要改变一些值的引用就行了，时间复杂度为O(1)。<strong>但是链表的查询效率很低，每次都要从头开始找，依次访问链表的每个数据项。</strong>时间复杂度为O(N)。</p>
<h3 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h3><p><img src="/Users/fengxing/Desktop/Android/%E6%A0%91%E6%9C%AF%E8%AF%AD.png" alt="树术语"></p>
<ul>
<li><strong>路径</strong>：从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径。</li>
<li><strong>根</strong>：树顶端的节点被称为根。从根出发到达任意一个节点只有一条路径。</li>
<li><strong>父节点</strong>：除了根节点之外，每个节点都可以向上找到一个唯一的节点，这个节点就是当前节点的父节点。相应的，父节点下方的就是子节点。</li>
<li><strong>叶子节点</strong>：没有子节点的“光杆司令”就被称为叶子节点。</li>
<li><strong>子树</strong>：每个子节点作为根节点的树都是一个子树。</li>
<li><strong>层</strong>：一个树结构的代数就是这个树的层。</li>
<li><strong>度</strong>：一棵树中，最大的节点的度称为树的度。</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点。</li>
</ul>
<p>二叉树</p>
<p>二叉树作为一种重要的数据结构，它结合了数组和链表的优点，有很多重要的应用。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。</p>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;比较器，是自然排序，还是定制排序 ，使用final修饰，表明一旦赋值便不允许改变</span><br><span class="line">		private final Comparator&lt;? super K&gt; comparator;  </span><br><span class="line">		private transient Entry&lt;K,V&gt; root &#x3D; null;  &#x2F;&#x2F;红黑树的根节点</span><br><span class="line">		private transient int size &#x3D; 0;     &#x2F;&#x2F;TreeMap中存放的键值对的数量</span><br><span class="line">		private transient int modCount &#x3D; 0;   &#x2F;&#x2F;修改的次数</span><br><span class="line">    </span><br><span class="line">    private static final boolean RED   &#x3D; false;</span><br><span class="line">    private static final boolean BLACK &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;    &#x2F;&#x2F;键</span><br><span class="line">    V value;    &#x2F;&#x2F;值</span><br><span class="line">    Entry&lt;K,V&gt; left &#x3D; null;     &#x2F;&#x2F;左孩子节点</span><br><span class="line">    Entry&lt;K,V&gt; right &#x3D; null;    &#x2F;&#x2F;右孩子节点</span><br><span class="line">    Entry&lt;K,V&gt; parent;          &#x2F;&#x2F;父节点</span><br><span class="line">    boolean color &#x3D; BLACK;      &#x2F;&#x2F;节点的颜色，在红黑树种，只有两种颜色，红色和黑色</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造方法，用指定的key,value ,parent初始化，color默认为黑色</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;构造方法，comparator用键的顺序做比较</span><br><span class="line">		public TreeMap() &#123;</span><br><span class="line">		    comparator &#x3D; null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;构造方法，提供比较器，用指定比较器排序</span><br><span class="line">		public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">		    his.comparator &#x3D; comparator;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;将m中的元素转化daoTreeMap中，按照键的顺序做比较排序</span><br><span class="line">		public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">		    comparator &#x3D; null;</span><br><span class="line">		    putAll(m);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;构造方法，指定的参数为SortedMap</span><br><span class="line">		&#x2F;&#x2F;采用m的比较器排序</span><br><span class="line">		public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123;</span><br><span class="line">		    comparator &#x3D; m.comparator();</span><br><span class="line">		    try &#123;</span><br><span class="line">		        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</span><br><span class="line">		    &#125; catch (java.io.IOException cannotHappen) &#123;</span><br><span class="line">		    &#125; catch (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序.</p>
<ul>
<li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li>
<li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li>
</ul>
<h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">				&#x2F;&#x2F;&#x2F;&#x2F;红黑树的根节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; t &#x3D; root;</span><br><span class="line">        &#x2F;&#x2F;红黑树是否为空</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">            compare(key, key); &#x2F;&#x2F; type (and possibly null) check</span><br><span class="line">            &#x2F;&#x2F;构造根节点，因为根节点没有父节点，传入null值。</span><br><span class="line">            root &#x3D; new TreeMapEntry&lt;&gt;(key, value, null);</span><br><span class="line">            size &#x3D; 1;</span><br><span class="line">            modCount++;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp;</span><br><span class="line">         &#x2F;&#x2F;定义节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; parent;</span><br><span class="line">        &#x2F;&#x2F; split comparator and comparable paths</span><br><span class="line">        &#x2F;&#x2F;获取比较器</span><br><span class="line">        Comparator&lt;? super K&gt; cpr &#x3D; comparator;</span><br><span class="line">        &#x2F;&#x2F;如果定义了比较器，采用自定义比较器进行比较</span><br><span class="line">        if (cpr !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;do while 做循环排序 找到父节点</span><br><span class="line">            do &#123;</span><br><span class="line">             &#x2F;&#x2F;将红黑树根节点赋值给parent</span><br><span class="line">                parent &#x3D; t;</span><br><span class="line">                 &#x2F;&#x2F;比较key, 与根节点的大小</span><br><span class="line">                cmp &#x3D; cpr.compare(key, t.key);</span><br><span class="line">                &#x2F;&#x2F;如果key &lt; t.key , 指向左子树</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                &#x2F;&#x2F;t &#x3D; t.left  , t &#x3D;&#x3D; 它的左孩子节点</span><br><span class="line">                    t &#x3D; t.left;</span><br><span class="line">                else if (cmp &gt; 0)&#x2F;&#x2F;如果key &gt; t.key , 指向它的右孩子节点</span><br><span class="line">                    t &#x3D; t.right;</span><br><span class="line">                else &#x2F;&#x2F;如果它们相等，替换key的值</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;自然排序方式，没有指定比较器</span><br><span class="line">        		&#x2F;&#x2F;key &#x3D;&#x3D; null 抛出异常</span><br><span class="line">            if (key &#x3D;&#x3D; null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">            &#x2F;&#x2F;一样 循环排序 找到父节点</span><br><span class="line">                parent &#x3D; t;</span><br><span class="line">                cmp &#x3D; k.compareTo(t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t &#x3D; t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t &#x3D; t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建新节点，并制定父节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; e &#x3D; new TreeMapEntry&lt;&gt;(key, value, parent);</span><br><span class="line">       &#x2F;&#x2F;根据比较结果，决定新节点为父节点的左孩子或者右孩子</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            parent.left &#x3D; e;</span><br><span class="line">        else</span><br><span class="line">            parent.right &#x3D; e;</span><br><span class="line">        &#x2F;&#x2F;新插入节点后重新调整红黑树</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="compare方法-比较器"><a href="#compare方法-比较器" class="headerlink" title="compare方法 比较器"></a>compare方法 比较器</h4><p>比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final int compare(Object k1, Object k2) &#123;</span><br><span class="line">        return comparator&#x3D;&#x3D;null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</span><br><span class="line">            : comparator.compare((K)k1, (K)k2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fixAfterInsertion-重新调整红黑树"><a href="#fixAfterInsertion-重新调整红黑树" class="headerlink" title="fixAfterInsertion 重新调整红黑树"></a>fixAfterInsertion 重新调整红黑树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void fixAfterInsertion(TreeMapEntry&lt;K,V&gt; x) &#123;</span><br><span class="line">		    &#x2F;&#x2F;插入的节点默认的颜色为红色</span><br><span class="line">        x.color &#x3D; RED;</span><br><span class="line">				 &#x2F;&#x2F;情形1：新节点x 是树的根节点，没有父节点不需要任何操作</span><br><span class="line">		    &#x2F;&#x2F;情形2：新节点x 的父节点颜色是黑色的，也不需要任何操作</span><br><span class="line">        while (x !&#x3D; null &amp;&amp; x !&#x3D; root &amp;&amp; x.parent.color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">            &#x2F;&#x2F;情形3：新节点x的父节点颜色是红色的</span><br><span class="line">				    &#x2F;&#x2F;判断x的节点的父节点位置，是否属于左孩子</span><br><span class="line">            if (parentOf(x) &#x3D;&#x3D; leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">              &#x2F;&#x2F;获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y &#x3D; rightOf(parentOf(parentOf(x)));</span><br><span class="line">               &#x2F;&#x2F;判断是否x节点的父节点的兄弟节点为红色。</span><br><span class="line">                if (colorOf(y) &#x3D;&#x3D; RED) &#123;</span><br><span class="line">		                &#x2F;&#x2F; x节点的父节点设置为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    &#x2F;&#x2F; y节点的颜色设置为黑色</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    &#x2F;&#x2F; x.parent.parent设置为红色</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    &#x2F;&#x2F; x &#x3D;&#x3D; x.parent.parent ,进行遍历。</span><br><span class="line">                    x &#x3D; parentOf(parentOf(x));</span><br><span class="line">                &#125; else &#123;&#x2F;&#x2F;x的父节点的兄弟节点是黑色或者缺少的</span><br><span class="line">	                  &#x2F;&#x2F;判断x节点是否为父节点的右孩子</span><br><span class="line">                    if (x &#x3D;&#x3D; rightOf(parentOf(x))) &#123;</span><br><span class="line">                   		 &#x2F;&#x2F;x &#x3D;&#x3D; 父节点</span><br><span class="line">                        x &#x3D; parentOf(x);</span><br><span class="line">                        &#x2F;&#x2F;左旋转操作</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;x节点是其父的左孩子</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    &#x2F;&#x2F;进行右旋转</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">		             &#x2F;&#x2F;y 是x 节点的祖父节点的左孩子</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y &#x3D; leftOf(parentOf(parentOf(x)));</span><br><span class="line">                if (colorOf(y) &#x3D;&#x3D; RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x &#x3D; parentOf(parentOf(x));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (x &#x3D;&#x3D; leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x &#x3D; parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色</span><br><span class="line">        root.color &#x3D; BLACK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>红黑树是一个更高效的检索二叉树，有如下特点：</p>
<ul>
<li>每个节点只能是红色或者黑色</li>
<li>根节点永远是黑色的</li>
<li>所有的叶子的子节点都是空节点，并且都是黑色的</li>
<li>每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点）</li>
<li>从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同）</li>
</ul>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          
            <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
          
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/" rel="next" title="第一次测试">
                <i class="fa fa-chevron-left"></i> 第一次测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="Java设计模式">
                Java设计模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java集合框架图"><span class="nav-number">1.</span> <span class="nav-text">java集合框架图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection-集合接口"><span class="nav-number">2.</span> <span class="nav-text">Collection 集合接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List子接口"><span class="nav-number">2.1.</span> <span class="nav-text">List子接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-数组"><span class="nav-number">2.1.1.</span> <span class="nav-text">ArrayList 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见源码分析"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">常见源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#add"><span class="nav-number">2.1.1.5.1.</span> <span class="nav-text">add()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-int-index-E-element-方法"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">add(int index, E element)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-int-index-方法"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">get(int index)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-int-index-方法"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">remove(int index)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for循环问题"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">for循环问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-链表"><span class="nav-number">2.1.2.</span> <span class="nav-text">LinkedList 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结点定义（双向链表）"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">结点定义（双向链表）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表定义"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">链表定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-的构造函数"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">LinkedList 的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-添加节点的方法"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">LinkedList 添加节点的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#linkXXX-方法：linkFirst、linkLast"><span class="nav-number">2.1.2.5.1.</span> <span class="nav-text">linkXXX 方法：linkFirst、linkLast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#add-int-index-E-element-、addAll"><span class="nav-number">2.1.2.5.2.</span> <span class="nav-text">add(int index, E element)、addAll</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#node-index-方法的实现"><span class="nav-number">2.1.2.5.2.1.</span> <span class="nav-text">node(index) 方法的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#linkBefore-E-e-Node-succ-实现"><span class="nav-number">2.1.2.5.2.2.</span> <span class="nav-text">linkBefore(E e, Node succ)实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-删除节点的方法"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">LinkedList 删除节点的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#removeFirst、removeLast"><span class="nav-number">2.1.2.6.1.</span> <span class="nav-text">removeFirst、removeLast</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unlinkFirst、unlinkLast"><span class="nav-number">2.1.2.6.1.1.</span> <span class="nav-text">unlinkFirst、unlinkLast</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove-int-index"><span class="nav-number">2.1.2.6.2.</span> <span class="nav-text">remove(int index)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#unlink-Node-x"><span class="nav-number">2.1.2.6.2.1.</span> <span class="nav-text">unlink(Node x)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-查询节点的方法"><span class="nav-number">2.1.2.7.</span> <span class="nav-text">LinkedList 查询节点的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get-int-index-、getFirst-、getLast"><span class="nav-number">2.1.2.7.1.</span> <span class="nav-text">get(int index)、getFirst() 、getLast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#indexOf-Object-o-、lastIndexOf-Object-o"><span class="nav-number">2.1.2.7.2.</span> <span class="nav-text">indexOf(Object o)、lastIndexOf(Object o)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#contains-Object-o"><span class="nav-number">2.1.2.7.3.</span> <span class="nav-text">contains(Object o)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-的修改节点方法"><span class="nav-number">2.1.2.8.</span> <span class="nav-text">LinkedList 的修改节点方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-作为双向队列的增删改查"><span class="nav-number">2.1.2.9.</span> <span class="nav-text">LinkedList 作为双向队列的增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Deque-双端队列"><span class="nav-number">2.1.2.9.1.</span> <span class="nav-text">Deque 双端队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Deque-和-Queue-添加元素的方法"><span class="nav-number">2.1.2.9.2.</span> <span class="nav-text">Deque 和 Queue 添加元素的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Deque-和-Queue-删除元素的方法"><span class="nav-number">2.1.2.9.3.</span> <span class="nav-text">Deque 和 Queue 删除元素的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque-和-Queue-获取队列头部元素的实现"><span class="nav-number">2.1.2.10.</span> <span class="nav-text">Deque 和 Queue 获取队列头部元素的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList作为Stack-使用"><span class="nav-number">2.1.2.11.</span> <span class="nav-text">LinkedList作为Stack&#96;使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList-的遍历"><span class="nav-number">2.1.2.12.</span> <span class="nav-text">LinkedList 的遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList与LinkedList"><span class="nav-number">2.1.3.</span> <span class="nav-text">ArrayList与LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector-向量"><span class="nav-number">2.1.4.</span> <span class="nav-text">Vector 向量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Stack-栈"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">Stack 栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set子接口"><span class="nav-number">2.2.</span> <span class="nav-text">Set子接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-散列集"><span class="nav-number">2.2.1.</span> <span class="nav-text">HashSet 散列集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet-链式散列集"><span class="nav-number">2.2.2.</span> <span class="nav-text">LinkedHashSet 链式散列集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet-树形集"><span class="nav-number">2.2.3.</span> <span class="nav-text">TreeSet 树形集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-队列"><span class="nav-number">2.3.</span> <span class="nav-text">Queue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Deque-双端队列-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">Deque 双端队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator迭代器"><span class="nav-number">2.4.</span> <span class="nav-text">Iterator迭代器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map"><span class="nav-number">3.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口定义"><span class="nav-number">3.1.</span> <span class="nav-text">接口定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历方法"><span class="nav-number">3.2.</span> <span class="nav-text">遍历方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希"><span class="nav-number">3.3.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表"><span class="nav-number">3.3.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决哈希冲突的方法"><span class="nav-number">3.3.2.</span> <span class="nav-text">解决哈希冲突的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拉链法"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">拉链法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开地址法"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">开地址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#再哈希法"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">再哈希法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立公共溢出区"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">建立公共溢出区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">3.4.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">3.4.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确定哈希桶数组索引位置"><span class="nav-number">3.4.2.</span> <span class="nav-text">确定哈希桶数组索引位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储数据-put"><span class="nav-number">3.4.3.</span> <span class="nav-text">存储数据 put</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取数据-get"><span class="nav-number">3.4.4.</span> <span class="nav-text">获取数据 get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容机制"><span class="nav-number">3.4.5.</span> <span class="nav-text">扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全性"><span class="nav-number">3.4.6.</span> <span class="nav-text">线程安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重点及面试题"><span class="nav-number">3.4.7.</span> <span class="nav-text">重点及面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashTable"><span class="nav-number">3.5.</span> <span class="nav-text">HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-1"><span class="nav-number">3.5.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法-1"><span class="nav-number">3.5.2.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#put"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">remove()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rehash-扩容"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">rehash 扩容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap和Hashtable的区别"><span class="nav-number">3.6.</span> <span class="nav-text">HashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap和HashSet的区别"><span class="nav-number">3.7.</span> <span class="nav-text">HashMap和HashSet的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">3.8.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-2"><span class="nav-number">3.8.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入数据"><span class="nav-number">3.8.2.</span> <span class="nav-text">插入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除数据"><span class="nav-number">3.8.3.</span> <span class="nav-text">删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问顺序的维护过程"><span class="nav-number">3.8.4.</span> <span class="nav-text">访问顺序的维护过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于-LinkedHashMap-实现缓存"><span class="nav-number">3.8.5.</span> <span class="nav-text">基于 LinkedHashMap 实现缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakHashMap"><span class="nav-number">3.9.</span> <span class="nav-text">WeakHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">3.10.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树的概念"><span class="nav-number">3.10.1.</span> <span class="nav-text">树的概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">3.11.</span> <span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-3"><span class="nav-number">3.11.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-1"><span class="nav-number">3.11.2.</span> <span class="nav-text">put</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#compare方法-比较器"><span class="nav-number">3.11.2.1.</span> <span class="nav-text">compare方法 比较器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fixAfterInsertion-重新调整红黑树"><span class="nav-number">3.11.2.2.</span> <span class="nav-text">fixAfterInsertion 重新调整红黑树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-1"><span class="nav-number">3.11.3.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-1"><span class="nav-number">3.11.4.</span> <span class="nav-text">remove</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
