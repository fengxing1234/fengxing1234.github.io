<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Handler," />










<meta name="description" content="Android消息机制1-Handler(Java层) 本文基于Android 6.0的源代码，来分析Java层的handler消息处理机制  12345framework&#x2F;base&#x2F;core&#x2F;java&#x2F;andorid&#x2F;os&#x2F;  - Handler.java  - Looper.java  - Message.java  - Messag">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler（Java层）">
<meta property="og:url" content="http://yoursite.com/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="Android消息机制1-Handler(Java层) 本文基于Android 6.0的源代码，来分析Java层的handler消息处理机制  12345framework&#x2F;base&#x2F;core&#x2F;java&#x2F;andorid&#x2F;os&#x2F;  - Handler.java  - Looper.java  - Message.java  - Messag">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://gityuan.com/images/handler/Main.jpg">
<meta property="og:image" content="http://gityuan.com/images/handler/java_sendmessage.png">
<meta property="og:image" content="http://gityuan.com/images/handler/handler_java.jpg">
<meta property="article:published_time" content="2020-05-25T08:03:39.000Z">
<meta property="article:modified_time" content="2020-05-25T08:12:13.300Z">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Handler">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://gityuan.com/images/handler/Main.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/25/Android/Handler/Handler（Java层）/"/>





  <title>Handler（Java层） | 冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Handler（Java层）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T16:03:39+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Android消息机制1-Handler-Java层"><a href="#Android消息机制1-Handler-Java层" class="headerlink" title="Android消息机制1-Handler(Java层)"></a>Android消息机制1-Handler(Java层)</h1><blockquote>
<p>本文基于Android 6.0的源代码，来分析Java层的handler消息处理机制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;andorid&#x2F;os&#x2F;</span><br><span class="line">  - Handler.java</span><br><span class="line">  - Looper.java</span><br><span class="line">  - Message.java</span><br><span class="line">  - MessageQueue.java</span><br></pre></td></tr></table></figure>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，，另一个便是消息机制(由Handler/Looper/MessageQueue等构成的)。关于Binder在<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列</a>中详细讲解过，有兴趣看看。</p>
<p>Android有大量的消息驱动方式来进行交互，比如Android的四剑客<code>Activity</code>, <code>Service</code>, <code>Broadcast</code>, <code>ContentProvider</code>的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。消息机制涉及MessageQueue/Message/Looper/Handler这4个类。</p>
<h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><p>消息机制主要包含：</p>
<ul>
<li><strong>Message</strong>：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li>
<li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li>
<li><strong>Looper</strong>：不断循环执行(<code>Looper.loop</code>)，按分发机制将消息分发给目标处理者。</li>
</ul>
<h3 id="1-2-架构图"><a href="#1-2-架构图" class="headerlink" title="1.2 架构图"></a>1.2 架构图</h3><p><img src="http://gityuan.com/images/handler/Main.jpg" alt="handler_java"></p>
<ul>
<li><strong>Looper</strong>有一个MessageQueue消息队列；</li>
<li><strong>MessageQueue</strong>有一组待处理的Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的Handler；</li>
<li><strong>Handler</strong>中有Looper和MessageQueue。</li>
</ul>
<h3 id="1-3-典型实例"><a href="#1-3-典型实例" class="headerlink" title="1.3 典型实例"></a>1.3 典型实例</h3><p>先展示一个典型的关于Handler/Looper的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();   &#x2F;&#x2F;【见 2.1】</span><br><span class="line"></span><br><span class="line">        mHandler &#x3D; new Handler() &#123;  &#x2F;&#x2F;【见 3.1】</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                &#x2F;&#x2F;TODO 定义消息处理逻辑. 【见 3.2】</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();  &#x2F;&#x2F;【见 2.2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，围绕着这个实例展开详细分析。</p>
<h2 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h2><h3 id="2-1-prepare"><a href="#2-1-prepare" class="headerlink" title="2.1 prepare()"></a>2.1 prepare()</h3><p>对于无参的情况，默认调用<code>prepare(true)</code>，表示的是这个Looper允许退出，而对于false的情况则表示当前Looper不允许退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>sThreadLocal</code>是ThreadLocal类型，下面，先说说ThreadLocal。</p>
<p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p>
<ul>
<li><code>ThreadLocal.set(T value)</code>：将value存储到当前线程的TLS区域，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存数据value到当前线程this</span></span><br><span class="line">    values.put(<span class="keyword">this</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal.get()</code>：获取当前线程TLS区域的数据，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] table = values.table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; values.mask;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) table[index + <span class="number">1</span>]; <span class="comment">//返回当前线程储存区中的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>); <span class="comment">//从目标线程存储区没有查询是则返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的<code>sThreadLocal</code>变量，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;()</span><br></pre></td></tr></table></figure>

<p>可见<code>sThreadLocal</code>的get()和set()操作的类型都是<code>Looper</code>类型。</p>
<p><strong>Looper.prepare()</strong></p>
<p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p>
<p>对于Looper类型的构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue &#x3D; new MessageQueue(quitAllowed);  &#x2F;&#x2F;创建MessageQueue对象. 【见4.1】</span><br><span class="line">    mThread &#x3D; Thread.currentThread();  &#x2F;&#x2F;记录当前线程.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，与prepare()相近功能的，还有一个<code>prepareMainLooper()</code>方法，该方法主要在ActivityThread类中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false); &#x2F;&#x2F;设置不允许退出的Looper</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        &#x2F;&#x2F;将当前的Looper保存为主Looper，每个线程只允许执行一次。</span><br><span class="line">        if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper &#x3D; myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-loop"><a href="#2-2-loop" class="headerlink" title="2.2 loop()"></a>2.2 loop()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me &#x3D; myLooper();  &#x2F;&#x2F;获取TLS存储的Looper对象 【见2.4】</span><br><span class="line">    final MessageQueue queue &#x3D; me.mQueue;  &#x2F;&#x2F;获取Looper对象中的消息队列</span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    &#x2F;&#x2F;确保在权限检查时基于本地进程，而不是调用进程。</span><br><span class="line">    final long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F;进入loop的主循环方法</span><br><span class="line">        Message msg &#x3D; queue.next(); &#x2F;&#x2F;可能会阻塞 【见4.2】</span><br><span class="line">        if (msg &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;没有消息，则退出循环</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span><br><span class="line">        Printer logging &#x3D; me.mLogging;  </span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg); &#x2F;&#x2F;用于分发Message 【见3.2】</span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;恢复调用者信息</span><br><span class="line">        final long newIdent &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        msg.recycleUnchecked();  &#x2F;&#x2F;将Message放入消息池 【见5.2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p>
<ul>
<li>读取MessageQueue的下一条Message；</li>
<li>把Message分发给相应的target；</li>
<li>再把分发后的Message回收到消息池，以便重复利用。</li>
</ul>
<p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下<code>logging == null</code>，通过设置setMessageLogging()用来开启debug工作。</p>
<h3 id="2-3-quit"><a href="#2-3-quit" class="headerlink" title="2.3 quit()"></a>2.3 quit()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void quit() &#123;</span><br><span class="line">    mQueue.quit(false); &#x2F;&#x2F;消息移除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true); &#x2F;&#x2F;安全地消息移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法</p>
<p><strong>MessageQueue.quit()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常</span><br><span class="line">        if (!mQuitAllowed) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123; &#x2F;&#x2F;防止多次执行退出操作</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting &#x3D; true;</span><br><span class="line">            if (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked(); &#x2F;&#x2F;移除尚未触发的所有消息</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                removeAllMessagesLocked(); &#x2F;&#x2F;移除所有的消息</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;mQuitting&#x3D;false，那么认定为 mPtr !&#x3D; 0</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消息退出的方式：</p>
<ul>
<li>当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；</li>
<li>当safe =flase时，移除所有的消息</li>
</ul>
<h3 id="2-4-常用方法"><a href="#2-4-常用方法" class="headerlink" title="2.4 常用方法"></a>2.4 常用方法</h3><h4 id="2-4-1-myLooper"><a href="#2-4-1-myLooper" class="headerlink" title="2.4.1 myLooper"></a>2.4.1 myLooper</h4><p>用于获取TLS存储的Looper对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-post"><a href="#2-4-2-post" class="headerlink" title="2.4.2 post"></a>2.4.2 post</h4><p>发送消息，并设置消息的callback，用于处理消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h2><h3 id="3-1-创建Handler"><a href="#3-1-创建Handler" class="headerlink" title="3.1 创建Handler"></a>3.1 创建Handler</h3><h4 id="3-1-1-无参构造"><a href="#3-1-1-无参构造" class="headerlink" title="3.1.1 无参构造"></a>3.1.1 无参构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">    &#x2F;&#x2F;匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span><br><span class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        final Class&lt;? extends Handler&gt; klass &#x3D; getClass();</span><br><span class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span><br><span class="line">    mLooper &#x3D; Looper.myLooper();  &#x2F;&#x2F;从当前线程的TLS中获取Looper对象【见2.1】</span><br><span class="line">    if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue &#x3D; mLooper.mQueue; &#x2F;&#x2F;消息队列，来自Looper对象</span><br><span class="line">    mCallback &#x3D; callback;  &#x2F;&#x2F;回调方法</span><br><span class="line">    mAsynchronous &#x3D; async; &#x2F;&#x2F;设置消息是否为异步处理方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p>
<h4 id="3-1-2-有参构造"><a href="#3-1-2-有参构造" class="headerlink" title="3.1.2 有参构造"></a>3.1.2 有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p>
<h3 id="3-2-消息分发机制"><a href="#3-2-消息分发机制" class="headerlink" title="3.2 消息分发机制"></a>3.2 消息分发机制</h3><p>在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;当Message存在回调方法，回调msg.callback.run()方法；</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;当Handler存在Callback成员变量时，回调方法handleMessage()；</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;Handler自身的回调方法handleMessage()</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分发消息流程：</strong></p>
<ol>
<li>当<code>Message</code>的回调方法不为空时，则回调方法<code>msg.callback.run()</code>，其中callBack数据类型为Runnable,否则进入步骤2；</li>
<li>当<code>Handler</code>的<code>mCallback</code>成员变量不为空时，则回调方法<code>mCallback.handleMessage(msg)</code>,否则进入步骤3；</li>
<li>调用<code>Handler</code>自身的回调方法<code>handleMessage()</code>，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。</li>
</ol>
<p>对于很多情况下，消息分发后的处理方法是第3种情况，即Handler.handleMessage()，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p>
<h3 id="3-3-消息发送"><a href="#3-3-消息发送" class="headerlink" title="3.3 消息发送"></a>3.3 消息发送</h3><p>发送消息调用链：</p>
<p><img src="http://gityuan.com/images/handler/java_sendmessage.png" alt="java_sendmessage"></p>
<p>从上图，可以发现所有的发消息方式，最终都是调用<code>MessageQueue.enqueueMessage()</code>;</p>
<h4 id="3-3-1-sendEmptyMessage"><a href="#3-3-1-sendEmptyMessage" class="headerlink" title="3.3.1 sendEmptyMessage"></a>3.3.1 sendEmptyMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendEmptyMessage(int what) &#123;</span><br><span class="line">    return sendEmptyMessageDelayed(what, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-sendEmptyMessageDelayed"><a href="#3-3-2-sendEmptyMessageDelayed" class="headerlink" title="3.3.2 sendEmptyMessageDelayed"></a>3.3.2 sendEmptyMessageDelayed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class="line">    Message msg &#x3D; Message.obtain();</span><br><span class="line">    msg.what &#x3D; what;</span><br><span class="line">    return sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-sendMessageDelayed"><a href="#3-3-3-sendMessageDelayed" class="headerlink" title="3.3.3 sendMessageDelayed"></a>3.3.3 sendMessageDelayed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-sendMessageAtTime"><a href="#3-3-4-sendMessageAtTime" class="headerlink" title="3.3.4 sendMessageAtTime"></a>3.3.4 sendMessageAtTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-sendMessageAtFrontOfQueue"><a href="#3-3-5-sendMessageAtFrontOfQueue" class="headerlink" title="3.3.5 sendMessageAtFrontOfQueue"></a>3.3.5 sendMessageAtFrontOfQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageAtFrontOfQueue(Message msg) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法通过设置消息的触发时间为0，从而使Message加入到消息队列的队头。</p>
<h4 id="3-3-6-post"><a href="#3-3-6-post" class="headerlink" title="3.3.6 post"></a>3.3.6 post</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-7-postAtFrontOfQueue"><a href="#3-3-7-postAtFrontOfQueue" class="headerlink" title="3.3.7 postAtFrontOfQueue"></a>3.3.7 postAtFrontOfQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean postAtFrontOfQueue(Runnable r) &#123;</span><br><span class="line">    return sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-8-enqueueMessage"><a href="#3-3-8-enqueueMessage" class="headerlink" title="3.3.8 enqueueMessage"></a>3.3.8 enqueueMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis); 【见4.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p><code>Handler.sendEmptyMessage()</code>等系列方法最终调用<code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code>，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p>
<h3 id="3-4-Handler其他方法"><a href="#3-4-Handler其他方法" class="headerlink" title="3.4 Handler其他方法"></a>3.4 Handler其他方法</h3><h4 id="3-4-1-obtainMessage"><a href="#3-4-1-obtainMessage" class="headerlink" title="3.4.1 obtainMessage"></a>3.4.1 obtainMessage</h4><p>获取消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final Message obtainMessage() &#123;</span><br><span class="line">    return Message.obtain(this); 【见5.2】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler.obtainMessage()</code>方法，最终调用<code>Message.obtainMessage(this)</code>，其中this为当前的Handler对象。</p>
<h4 id="3-4-2-removeMessages"><a href="#3-4-2-removeMessages" class="headerlink" title="3.4.2 removeMessages"></a>3.4.2 removeMessages</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void removeMessages(int what) &#123;</span><br><span class="line">    mQueue.removeMessages(this, what, null); 【见 4.5】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler</code>是消息机制中非常重要的辅助类，更多的实现都是<code>MessageQueue</code>, <code>Message</code>中的方法，Handler的目的是为了更加方便的使用消息机制。</p>
<h2 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h2><p>MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private native static long nativeInit();</span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br><span class="line">private native void nativePollOnce(long ptr, int timeoutMillis);</span><br><span class="line">private native static void nativeWake(long ptr);</span><br><span class="line">private native static boolean nativeIsPolling(long ptr);</span><br><span class="line">private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);</span><br></pre></td></tr></table></figure>

<p>关于这些native方法的介绍，见<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<h3 id="4-1-创建MessageQueue"><a href="#4-1-创建MessageQueue" class="headerlink" title="4.1 创建MessageQueue"></a>4.1 创建MessageQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed &#x3D; quitAllowed;</span><br><span class="line">    &#x2F;&#x2F;通过native方法初始化消息队列，其中mPtr是供native代码使用</span><br><span class="line">    mPtr &#x3D; nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-next"><a href="#4-2-next" class="headerlink" title="4.2 next()"></a>4.2 next()</h3><p>提取下一条message</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    final long ptr &#x3D; mPtr;</span><br><span class="line">    if (ptr &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;当消息循环已经退出，则直接返回</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; 循环迭代的首次为-1</span><br><span class="line">    int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis !&#x3D; 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg &#x3D; null;</span><br><span class="line">            Message msg &#x3D; mMessages;</span><br><span class="line">            &#x2F;&#x2F;当消息的Handler为空时，则查询异步消息</span><br><span class="line">            if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;当查询到异步消息，则立刻退出循环</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg &#x3D; msg;</span><br><span class="line">                    msg &#x3D; msg.next;</span><br><span class="line">                &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg !&#x3D; null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    &#x2F;&#x2F;当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取一条消息，并返回</span><br><span class="line">                    mBlocked &#x3D; false;</span><br><span class="line">                    if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                        prevMsg.next &#x3D; msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages &#x3D; msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;设置消息的使用状态，即flags |&#x3D; FLAG_IN_USE</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;   &#x2F;&#x2F;成功地获取MessageQueue中的下一条即将要执行的消息</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有消息</span><br><span class="line">                nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;消息正在退出，返回null</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当消息队列为空，或者是消息队列的第一个消息时</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages &#x3D;&#x3D; null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount &#x3D; mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;没有idle handlers 需要运行，则循环并等待。</span><br><span class="line">                mBlocked &#x3D; true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPendingIdleHandlers &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mPendingIdleHandlers &#x3D; new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers &#x3D; mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler &#x3D; mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] &#x3D; null; &#x2F;&#x2F;去掉handler的引用</span><br><span class="line">            boolean keep &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep &#x3D; idler.queueIdle();  &#x2F;&#x2F;idle时执行的方法</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;重置idle handler个数为0，以保证不会再次重复运行</span><br><span class="line">        pendingIdleHandlerCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span><br><span class="line">        nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nativePollOnce</code>是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p>
<p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当nativePollOnce()返回后，next()从<code>mMessages</code>中提取一个消息。</p>
<p><code>nativePollOnce()</code>在native做了大量的工作，想进一步了解可查看 <a href="http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<h3 id="4-3-enqueueMessage"><a href="#4-3-enqueueMessage" class="headerlink" title="4.3 enqueueMessage"></a>4.3 enqueueMessage</h3><p>添加一条消息到消息队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MessageQueue</code>是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<h3 id="4-4-removeMessages"><a href="#4-4-removeMessages" class="headerlink" title="4.4 removeMessages"></a>4.4 removeMessages</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">//从消息队列的头部开始，移除所有符合条件的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除剩余的符合要求的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked();</span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个移除消息的方法，采用了两个while循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h3 id="4-5-postSyncBarrier"><a href="#4-5-postSyncBarrier" class="headerlink" title="4.5 postSyncBarrier"></a>4.5 postSyncBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面小节[4.3]已说明每一个普通Message必须有一个target，对于特殊的message是没有target，即同步barrier token。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒Looper.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         Message prev = <span class="keyword">null</span>;</span><br><span class="line">         Message p = mMessages;</span><br><span class="line">         <span class="comment">//从消息队列找到 target为空,并且token相等的Message</span></span><br><span class="line">         <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">             prev = p;</span><br><span class="line">             p = p.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">             prev.next = p.next;</span><br><span class="line">             needWake = <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             mMessages = p.next;</span><br><span class="line">             needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">             nativeWake(mPtr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>postSyncBarrier只对同步消息产生影响，对于异步消息没有任何差别。</p>
<h2 id="五、-Message"><a href="#五、-Message" class="headerlink" title="五、 Message"></a>五、 Message</h2><h3 id="5-1-消息对象"><a href="#5-1-消息对象" class="headerlink" title="5.1 消息对象"></a>5.1 消息对象</h3><p>每个消息用<code>Message</code>表示，<code>Message</code>主要包含以下内容：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">成员变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">what</td>
<td align="left">消息类别</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">when</td>
<td align="left">消息触发时间</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg1</td>
<td align="left">参数1</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg2</td>
<td align="left">参数2</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">obj</td>
<td align="left">消息内容</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="left">target</td>
<td align="left">消息响应方</td>
</tr>
<tr>
<td align="left">Runnable</td>
<td align="left">callback</td>
<td align="left">回调方法</td>
</tr>
</tbody></table>
<p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p>
<h3 id="5-2-消息池"><a href="#5-2-消息池" class="headerlink" title="5.2 消息池"></a>5.2 消息池</h3><p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p>
<p>静态变量<code>sPool</code>的数据类型为Message，通过next成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。</p>
<p>消息池常用的操作方法是obtain()和recycle()。</p>
<h4 id="5-2-1-obtain"><a href="#5-2-1-obtain" class="headerlink" title="5.2.1 obtain"></a>5.2.1 obtain</h4><p>从消息池中获取消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool !&#x3D; null) &#123;</span><br><span class="line">            Message m &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; m.next;</span><br><span class="line">            m.next &#x3D; null; &#x2F;&#x2F;从sPool中取出一个Message对象，并消息链表断开</span><br><span class="line">            m.flags &#x3D; 0; &#x2F;&#x2F; 清除in-use flag</span><br><span class="line">            sPoolSize--; &#x2F;&#x2F;消息池的可用大小进行减1操作</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message(); &#x2F;&#x2F; 当消息池为空时，直接创建Message对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p>
<h4 id="5-2-2-recycle"><a href="#5-2-2-recycle" class="headerlink" title="5.2.2 recycle"></a>5.2.2 recycle</h4><p>把不再使用的消息加入消息池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123; &#x2F;&#x2F;判断消息是否正在使用</span><br><span class="line">        if (gCheckRecycle) &#123; &#x2F;&#x2F;Android 5.0以后的版本默认为true,之前的版本默认为false.</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于不再使用的消息，加入到消息池</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    &#x2F;&#x2F;将消息标示位置为IN_USE，并清空消息所有的参数。</span><br><span class="line">    flags &#x3D; FLAG_IN_USE;</span><br><span class="line">    what &#x3D; 0;</span><br><span class="line">    arg1 &#x3D; 0;</span><br><span class="line">    arg2 &#x3D; 0;</span><br><span class="line">    obj &#x3D; null;</span><br><span class="line">    replyTo &#x3D; null;</span><br><span class="line">    sendingUid &#x3D; -1;</span><br><span class="line">    when &#x3D; 0;</span><br><span class="line">    target &#x3D; null;</span><br><span class="line">    callback &#x3D; null;</span><br><span class="line">    data &#x3D; null;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123; &#x2F;&#x2F;当消息池没有满时，将Message对象加入消息池</span><br><span class="line">            next &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; this;</span><br><span class="line">            sPoolSize++; &#x2F;&#x2F;消息池的可用大小进行加1操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最后用一张图，来表示整个消息机制</p>
<p><img src="http://gityuan.com/images/handler/handler_java.jpg" alt="handler_java"></p>
<p><strong>图解：</strong></p>
<ul>
<li>Handler通过sendMessage()发送Message到MessageQueue队列；</li>
<li>Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；</li>
<li>经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。</li>
<li>将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。</li>
</ul>
<p><strong>消息分发的优先级：</strong></p>
<ol>
<li>Message的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，优先级仅次于1；</li>
<li>Handler的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<p><strong>消息缓存：</strong></p>
<p>为了提供效率，提供了一个大小为50的Message缓存队列，减少对象不断创建与销毁的过程。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Handler/" rel="tag"># Handler</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" rel="next" title="Android系统架构">
                <i class="fa fa-chevron-left"></i> Android系统架构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/" rel="prev" title="Android中为什么主线程不会因为Looper.loop()里的死循环卡死？">
                Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android消息机制1-Handler-Java层"><span class="nav-number">1.</span> <span class="nav-text">Android消息机制1-Handler(Java层)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-number">1.1.</span> <span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-模型"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-架构图"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 架构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-典型实例"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 典型实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Looper"><span class="nav-number">1.2.</span> <span class="nav-text">二、Looper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-prepare"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 prepare()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-loop"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 loop()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-quit"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 quit()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-常用方法"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-myLooper"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1 myLooper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-post"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2 post</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Handler"><span class="nav-number">1.3.</span> <span class="nav-text">三、Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-创建Handler"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 创建Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-无参构造"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1 无参构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-有参构造"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2 有参构造</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-消息分发机制"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 消息分发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-消息发送"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-sendEmptyMessage"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 sendEmptyMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-sendEmptyMessageDelayed"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 sendEmptyMessageDelayed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-sendMessageDelayed"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3 sendMessageDelayed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-sendMessageAtTime"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">3.3.4 sendMessageAtTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-sendMessageAtFrontOfQueue"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">3.3.5 sendMessageAtFrontOfQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-6-post"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">3.3.6 post</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-7-postAtFrontOfQueue"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">3.3.7 postAtFrontOfQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-8-enqueueMessage"><span class="nav-number">1.3.3.8.</span> <span class="nav-text">3.3.8 enqueueMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小节"><span class="nav-number">1.3.3.9.</span> <span class="nav-text">小节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Handler其他方法"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 Handler其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-obtainMessage"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">3.4.1 obtainMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-removeMessages"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">3.4.2 removeMessages</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、MessageQueue"><span class="nav-number">1.4.</span> <span class="nav-text">四、MessageQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-创建MessageQueue"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 创建MessageQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-next"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 next()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-enqueueMessage"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 enqueueMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-removeMessages"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 removeMessages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-postSyncBarrier"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 postSyncBarrier</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、-Message"><span class="nav-number">1.5.</span> <span class="nav-text">五、 Message</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-消息对象"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 消息对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-消息池"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 消息池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-obtain"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">5.2.1 obtain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-recycle"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">5.2.2 recycle</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、总结"><span class="nav-number">1.6.</span> <span class="nav-text">六、总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
