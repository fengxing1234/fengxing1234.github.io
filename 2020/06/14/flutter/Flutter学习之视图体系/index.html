<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="flutter," />










<meta name="description" content="Flutter学习之视图体系一、前言经过之前的学习，可以知道Flutter是一种全新的响应式跨平台的移动开发框架，越来越多的开发者参与学习或者研究中，在iOS和Android平台上能够用一套代码构建出性能比较高的应用程序。我刚开始接触FlutterFlutter中文网看到这么一句话：Widget是Flutter应用程序用户界面的基本构建块。每个Widget都是用户界面一部分的不可变声明。与其他将视">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter学习之视图体系">
<meta property="og:url" content="http://yoursite.com/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="Flutter学习之视图体系一、前言经过之前的学习，可以知道Flutter是一种全新的响应式跨平台的移动开发框架，越来越多的开发者参与学习或者研究中，在iOS和Android平台上能够用一套代码构建出性能比较高的应用程序。我刚开始接触FlutterFlutter中文网看到这么一句话：Widget是Flutter应用程序用户界面的基本构建块。每个Widget都是用户界面一部分的不可变声明。与其他将视">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c2dc43541e51a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c2e6861c9534a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c2eff26313931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c2f8f6f8577bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c3322c6d67e23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c346cd1a92ea9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c38d8bd7b5dce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c4793b37168d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2020-06-14T12:38:51.000Z">
<meta property="article:modified_time" content="2020-06-17T13:56:11.923Z">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="flutter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/3/28/169c2dc43541e51a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/14/flutter/Flutter学习之视图体系/"/>





  <title>Flutter学习之视图体系 | 冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Flutter学习之视图体系</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-14T20:38:51+08:00">
                2020-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Flutter学习之视图体系"><a href="#Flutter学习之视图体系" class="headerlink" title="Flutter学习之视图体系"></a>Flutter学习之视图体系</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>经过之前的学习，可以知道<strong>Flutter</strong>是一种全新的响应式跨平台的移动开发框架，越来越多的开发者参与学习或者研究中，在<strong>iOS</strong>和<strong>Android</strong>平台上能够用一套代码构建出性能比较高的应用程序。我刚开始接触<strong>Flutter</strong><a href="https://flutterchina.club/technical-overview/" target="_blank" rel="noopener">Flutter中文网</a>看到这么一句话：<code>Widget</code>是<strong>Flutter</strong>应用程序用户界面的基本构建块。每个<code>Widget</code>都是用户界面一部分的不可变声明。与其他将视图、控制器、布局和其他属性分离的框架不同，<strong>Flutter</strong>具有一致的统一对象模型：Widget。在开发过程中也可以知道<code>Widget</code>可以被定义按钮(button)、样式(style)、填充(Padding)、布局(Row)、手势(GestureDetector)等，我刚开始以为这个<code>Widget</code>就是眼中所看到的视图，然而并不是这样的，下面慢慢讲述。</p>
<h2 id="二、视图基础"><a href="#二、视图基础" class="headerlink" title="二、视图基础"></a>二、视图基础</h2><h3 id="1-Widget"><a href="#1-Widget" class="headerlink" title="1.Widget"></a>1.Widget</h3><p>在<a href="https://flutter.dev/docs/development/ui/widgets-intro" target="_blank" rel="noopener">Flutter官方网站</a>介绍<code>Widgets</code>开篇有这么一段话：</p>
<blockquote>
<p>Flutter widgets are built using a modern react-style framework, which takes inspiration from React. The central idea is that you build your UI out of widgets. Widgets describe what their view should look like given their current configuration and state. When a widget’s state changes, the widget rebuilds its description, which the framework diffs against the previous description in order to determine the minimal changes needed in the underlying render tree to transition from one state to the next.</p>
</blockquote>
<p>这段话的意思是：<code>Flutter widgets</code>是采取React思想使用响应式框架构建的。核心思想就是使用<code>widgets</code>构建出UI(界面)。<code>Widgets</code>根据其当前配置和状态描述了它们的视图。当某个<code>widget</code>的状态发生更改时，<code>widget</code>会重新构建所描述的视图，framework会根据前面所描述的视图(状态没改变时)进行区分，以确定底层呈现树从一个状态转换到下一个状态所需的最小更改步骤。</p>
<p>在<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html" target="_blank" rel="noopener">Flutter开发者文档</a>对<code>Widget</code>的定义如下：</p>
<blockquote>
<p>Describes the configuration for an Element.</p>
<p>Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.</p>
</blockquote>
<p>意思是：<code>widget</code>为<code>element</code>(下面再描述)提供配置信息，这里可以知道<code>widget</code>和<code>element</code>存在某种联系。<code>Widgets</code>在Flutter framework是中心类层次结构，<code>widget</code>是不可变的对象并且是界面的一部分，<code>widget</code>会被渲染在<code>elements</code>上，并(elelments)管理底层渲染树(render tree)，这里可以得到一个信息：<code>widget</code>在渲染的时候会最终转换成<code>element</code>。继续往下看：</p>
<blockquote>
<p>Widgets themselves have no mutable state (all their fields must be final). If you wish to associate mutable state with a widget, consider using a StatefulWidget, which creates a State object (via StatefulWidget.createState) whenever it is inflated into an element and incorporated into the tree.</p>
</blockquote>
<p>意思是：<code>Wigets</code>本身是没有可变的状态(其所有的字段必须是final)。如果你想吧可变状态和一个<code>widget</code>关联起来，可以使用<code>StatefulWidget</code>，<code>StatefulWidget</code>通过使用<code>StatefulWidget.createState</code>方法创建<code>State</code>对象，并且扩充到<code>element</code>和合并到树中。那么这段可以得出的信息是：<code>widget</code>并不会直接渲染和管理状态，管理状态是交给<code>State</code>对象负责。继续往下一段看：</p>
<blockquote>
<p>A given widget can be included in the tree zero or more times. In particular a given widget can be placed in the tree multiple times. Each time a widget is placed in the tree, it is inflated into an Element, which means a widget that is incorporated into the tree multiple times will be inflated multiple times.</p>
</blockquote>
<p>意思是：给定的<code>widget</code>可以<strong>零次或者多次</strong>被包含在树中，一个给定的<code>widget</code>可以多次放置在树中，每次将一个<code>widget</code>放入树中，他都会被扩充到一个<code>Element</code>，这就意味着多次并入树中的<code>widget</code>将会多次扩充到对应的<code>Element</code>。这段可以这么理解：在一个界面中，有多个<code>Text</code>被挂载在视图树上，这些<code>Text</code>的<code>widget</code>会被填充进自己独立的<code>Element</code>中，就算<code>widget</code>被重复使用，还是会创建多个不同的<code>element</code>对象。继续往下看：</p>
<blockquote>
<p>The key property controls how one widget replaces another widget in the tree. If the runtimeType and key properties of the two widgets are operator==, respectively, then the new widget replaces the old widget by updating the underlying element (i.e., by calling Element.update with the new widget). Otherwise, the old element is removed from the tree, the new widget is inflated into an element, and the new element is inserted into the tree.</p>
</blockquote>
<p>每一个<code>widget</code>都有自己的唯一的<strong>key</strong>，这里也很容易理解，就是借助<strong>key</strong>作为唯一标识符。这段话的意思是：<strong>key</strong>这个属性控制一个<code>widget</code>如何替换树中的另一个<code>widget</code>。如果两个<code>widget</code>的<strong>runtimeType</strong>和<strong>key</strong>属性相等==，则新的<code>widget</code>通过更新<code>Element</code>(通过新的<code>widget</code>来来调用<strong>Element.update</strong>)来替换旧的<code>widget</code>。否则，如果两个<code>widget</code>的<strong>runtimeType</strong>和<strong>key</strong>属性不相等，则旧的<code>Element</code>将从树中被移除，新的<code>widget</code>将被扩充到一个新的<code>Element</code>中，这个新的<code>Element</code>将被插入树中。这里可以得出：如果涉及到<code>widget</code>的移动或者删除操作前，会根据<code>widget</code>的<strong>runtime</strong>和<strong>key</strong>进行对比。</p>
<p>综上所述：</p>
<ul>
<li>widget向Element提供配置信息(数据)，界面构造出来的widget树其实只是一颗配置信息树，为了构造出Element树。</li>
<li>Element和widget有对应关系，因为，element是通过widget来生成的。</li>
<li>同一个widget可以创建多个element，<strong>也就是一个widget对象可以对应多个element对象</strong>。</li>
</ul>
<p>下面初步看看widget源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class Widget extends DiagnosticableTree &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Initializes [key] for subclasses.</span><br><span class="line">  const Widget(&#123; this.key &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;省略注释</span><br><span class="line">  final Key key;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;构建出element</span><br><span class="line">  @protected</span><br><span class="line">  Element createElement();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;简短文字描述这个widget</span><br><span class="line">  @override</span><br><span class="line">  String toStringShort() &#123;</span><br><span class="line">    return key &#x3D;&#x3D; null ? &#39;$runtimeType&#39; : &#39;$runtimeType-$key&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;根据字面意思 应该是调试诊断树的信息</span><br><span class="line">  @override</span><br><span class="line">  void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    super.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle &#x3D; DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态方法，跟上一段解释一样，就是是否用新的widget对象去更新旧UI渲染树的配置</span><br><span class="line">  &#x2F;&#x2F;如果oldWidget和newWidget的runtimeType和key同时相等就会用newWidget对象去更新对应element信息</span><br><span class="line">  static bool canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    return oldWidget.runtimeType &#x3D;&#x3D; newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key &#x3D;&#x3D; newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>还要注意:<code>widget</code>是抽象类，在平时，一般继续<code>StatelessWidget</code>和<code>StatefulWidget</code>，而这两个类其实也是继承<code>Widget</code>，这两个类肯定会实现这个<code>createElement</code>方法，简单看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StatelessWidget</span><br><span class="line">abstract class StatelessWidget extends Widget &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Initializes [key] for subclasses.</span><br><span class="line">  const StatelessWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  ....</span><br><span class="line">  @override</span><br><span class="line">  StatelessElement createElement() &#x3D;&gt; StatelessElement(this);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatefulWidget</span><br><span class="line">abstract class StatefulWidget extends Widget &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Initializes [key] for subclasses.</span><br><span class="line">  const StatefulWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  .....</span><br><span class="line">  @override</span><br><span class="line">  StatefulElement createElement() &#x3D;&gt; StatefulElement(this);</span><br><span class="line">  .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>确实可以看出，都会创建<code>Element</code>，只是<code>StatelessWidget</code>和<code>StatefulWidget</code>所创建的<code>Element</code>类型不一样，这里就先不深入了。上面可以知道<code>widget</code>和<code>element</code>存在对应的关系，那下面看看<code>element</code>。</p>
<h3 id="2-Element"><a href="#2-Element" class="headerlink" title="2.Element"></a>2.Element</h3><p>看看<a href="https://api.flutter.dev/flutter/widgets/Element-class.html" target="_blank" rel="noopener">官方开发者文档</a>中开篇看到：</p>
<blockquote>
<p>An instantiation of a Widget at a particular location in the tree.</p>
</blockquote>
<p>意思是：<code>element</code>是树中特定位置的<code>widget</code>实例。这里描述的很明显，也就是<code>Widget</code>是总监，部署技术规划，而<code>element</code>就是员工，真正干活。继续往下阅读：</p>
<blockquote>
<p>Widgets describe how to configure a subtree but the same widget can be used to configure multiple subtrees simultaneously because widgets are immutable. An Element represents the use of a widget to configure a specific location in the tree. Over time, the widget associated with a given element can change, for example, if the parent widget rebuilds and creates a new widget for this location.</p>
</blockquote>
<p>意思是：<code>widget</code>描述如何配置子树，由于<code>widgets</code>是不可变的，所以可以用相同的<code>widget</code>来同时配置多个子树，<code>Element</code>表示<code>widget</code>配置树中的特定位置的实例，随着时间的推移，和给定的<code>Element</code>关联的<code>Widget</code>可能会随时变化，例如，如果父<code>widget</code>重建并为此位置创建新的<code>widget</code>。</p>
<blockquote>
<p>Elements form a tree. Most elements have a unique child, but some widgets (e.g., subclasses of RenderObjectElement) can have multiple children.</p>
</blockquote>
<p><code>Elements</code>构成一棵树，大多数<code>elements</code>都会有<strong>唯一</strong>的孩子，但是一些<code>widgets</code>(如RenderObjectElement)可以有多个孩子。</p>
<blockquote>
<p>Elements have the following lifecycle:</p>
<ul>
<li>The framework creates an element by calling Widget.createElement on the widget that will be used as the element’s initial configuration.</li>
<li>The framework calls mount to add the newly created element to the tree at a given slot in a given parent. The mount method is responsible for inflating any child widgets and calling attachRenderObject as necessary to attach any associated render objects to the render tree.</li>
<li>At this point, the element is considered “active” and might appear on screen.</li>
<li>At some point, the parent might decide to change the widget used to configure this element, for example because the parent rebuilt with new state. When this happens, the framework will call update with the new widget. The new widget will always have the same runtimeType and key as old widget. If the parent wishes to change the runtimeType or key of the widget at this location in the tree, can do so by unmounting this element and inflating the new widget at this location.</li>
<li>At some point, an ancestor might decide to remove this element (or an intermediate ancestor) from the tree, which the ancestor does by calling deactivateChild on itself. Deactivating the intermediate ancestor will remove that element’s render object from the render tree and add this element to the owner’s list of inactive elements, causing the framework to call deactivate on this element.</li>
<li>At this point, the element is considered “inactive” and will not appear on screen. An element can remain in the inactive state only until the end of the current animation frame. At the end of the animation frame, any elements that are still inactive will be unmounted. *If the element gets reincorporated into the tree (e.g., because it or one of its ancestors has a global key that is reused), the framework will remove the element from the owner’s list of inactive elements, call activate on the element, and reattach the element’s render object to the render tree. (At this point, the element is again considered “active” and might appear on screen.)</li>
<li>If the element does not get reincorporated into the tree by the end of the current animation frame, the framework will call unmount on the element. At this point, the element is considered “defunct” and will not be incorporated into the tree in the future.</li>
<li>At this point, the element is considered “defunct” and will not be incorporated into the tree in the future.</li>
</ul>
</blockquote>
<p>意思如下： Element具有以下生命周期：</p>
<ul>
<li>framework通过调用即将用来作<code>element</code>的初始化配置信息的<code>Widget</code>的<strong>Widget.createElement</strong>方法来创建一个<code>element</code>。</li>
<li>framework通过调用mount方法以将新创建的Element添加到给定父级中给定槽点的树上。 mount方法负责将任何子<code>Widget</code>扩充到<code>Widget</code>并根据需要调用<code>attachRenderObject</code>，以将任何关联的渲染对象附加到渲染树上。</li>
<li>此时，<code>element</code>被视为<code>激活</code>，可能出现在屏幕上。</li>
<li>在某些情况下，父可能会更改用于配置此<code>Element</code>的Widget，例如因为父重新创建了新状态。发生这种情况时，framework将调用新的<code>Widget</code>的update方法。新<code>Widget</code>将始终具有与旧<code>Widget</code>相同的<strong>runtimeType</strong>和<strong>key</strong>属性。如果父希望在树中的此位置更改<code>Widget</code>的<strong>runtimeType</strong>或<strong>key</strong>，可以通过unmounting(卸载)此Element并在此位置扩充新<code>Widget</code>来实现。</li>
<li>在某些时候，祖先(Element)可能会决定从树中移除该<code>element</code>（或中间祖先），祖先自己通过调用<strong>deactivateChild</strong>来完成该操作。停用中间祖先将从渲染树中移除该<code>element</code>的渲染对象，并将此<code>element</code>添加到所有者属性中的非活动元素列表中，从而framework调用<strong>deactivate</strong>方法作用在此<code>element</code>上。</li>
<li>此时，该<code>element</code>被视为“无效”，不会出现在屏幕上。一个<code>element</code>直到动画帧结束前都可以保存“非活动”状态。动画帧结束时，将卸载仍处于非活动状态的所有<code>element</code>。</li>
<li>如果<code>element</code>被重写组合到树中(例如，因为它或其祖先之一有一个全局建(global key)被重用)，framework将从所有者的非活动<code>elements</code>列表中移除该<code>element</code>，并调用该<code>element</code>的<strong>activate方法</strong>，并重新附加到<code>element</code>的渲染对象到渲染树上。(此时，该元素再次被视为“活动”并可能出现在屏幕上)</li>
<li>如果<code>element</code>在当前动画帧的末尾(最后一帧)没有被重新组合到树中，那么framework将会调用该元素的<strong>unmount方法</strong>。</li>
</ul>
<p>这里可以知道<code>element</code>的生命周期。并且平时开发没有接触到<code>Element</code>，都是直接操控<code>widget</code>，也就是说Flutter已经帮我们对<code>widget</code>的操作映射到<code>element</code>上，我这里想象到的有点事降低开发复杂。下面结合一个例子(绘制Text)，看看<code>element</code>是不是最后渲染出来的view：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Text(&quot;hello flutter&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面看下<code>new Text</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final DefaultTextStyle defaultTextStyle &#x3D; DefaultTextStyle.of(context);</span><br><span class="line">    TextStyle effectiveTextStyle &#x3D; style;</span><br><span class="line">    if (style &#x3D;&#x3D; null || style.inherit)</span><br><span class="line">      effectiveTextStyle &#x3D; defaultTextStyle.style.merge(style);</span><br><span class="line">    if (MediaQuery.boldTextOverride(context))</span><br><span class="line">      effectiveTextStyle &#x3D; effectiveTextStyle.merge(const TextStyle(fontWeight: FontWeight.bold));</span><br><span class="line">    Widget result &#x3D; RichText( ----&gt;Text原来是通过RichText这个widget来构建树</span><br><span class="line">      textAlign: textAlign ?? defaultTextStyle.textAlign ?? TextAlign.start,</span><br><span class="line">      textDirection: textDirection, &#x2F;&#x2F; RichText uses Directionality.of to obtain a default if this is null.</span><br><span class="line">      locale: locale, &#x2F;&#x2F; RichText uses Localizations.localeOf to obtain a default if this is null</span><br><span class="line">      softWrap: softWrap ?? defaultTextStyle.softWrap,</span><br><span class="line">      overflow: overflow ?? defaultTextStyle.overflow,</span><br><span class="line">      textScaleFactor: textScaleFactor ?? MediaQuery.textScaleFactorOf(context),</span><br><span class="line">      maxLines: maxLines ?? defaultTextStyle.maxLines,</span><br><span class="line">      strutStyle: strutStyle,</span><br><span class="line">      text: TextSpan(</span><br><span class="line">        style: effectiveTextStyle,</span><br><span class="line">        text: data,</span><br><span class="line">        children: textSpan !&#x3D; null ? &lt;TextSpan&gt;[textSpan] : null,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    ....</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>继续往<code>RichText</code>里面看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ....</span><br><span class="line">  @override</span><br><span class="line">  RenderParagraph createRenderObject(BuildContext context) &#123;</span><br><span class="line">    assert(textDirection !&#x3D; null || debugCheckHasDirectionality(context));</span><br><span class="line">    &#x2F;&#x2F;返回RenderParagraph widget </span><br><span class="line">    return RenderParagraph(text,</span><br><span class="line">      textAlign: textAlign,</span><br><span class="line">      textDirection: textDirection ?? Directionality.of(context),</span><br><span class="line">      softWrap: softWrap,</span><br><span class="line">      overflow: overflow,</span><br><span class="line">      textScaleFactor: textScaleFactor,</span><br><span class="line">      maxLines: maxLines,</span><br><span class="line">      strutStyle: strutStyle,</span><br><span class="line">      locale: locale ?? Localizations.localeOf(context, nullOk: true),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>发现最终它会返回<code>RenderParagraph</code>widget，继续往里看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class RichText extends LeafRenderObjectWidget &#123;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以发现<code>RichText</code>继承<code>LeafRenderObjectWidget</code>，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于配置RenderObject子类的RenderObjectWidgets的超类，没有孩子，也就是没有字节点(child)</span><br><span class="line">abstract class LeafRenderObjectWidget extends RenderObjectWidget &#123;</span><br><span class="line">  const LeafRenderObjectWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;构建出类型是LeafRenderObjectElement</span><br><span class="line">  @override</span><br><span class="line">  LeafRenderObjectElement createElement() &#x3D;&gt; LeafRenderObjectElement(this);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到<code>LeafRenderObjectWidget</code>是抽象类，并且继承了<code>RenderObjectWidget</code>，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; RenderObjectWidgets provide the configuration for [RenderObjectElement]s,</span><br><span class="line">&#x2F;&#x2F;&#x2F; which wrap [RenderObject]s, which provide the actual rendering of the</span><br><span class="line">&#x2F;&#x2F;&#x2F; application.</span><br><span class="line">&#x2F;&#x2F;上面注释是：RenderObjectWidgets向[RenderObjectElement]提供了配置信息，包装了[RenderObject]，在应用程序了提供了实际的渲染</span><br><span class="line">abstract class RenderObjectWidget extends Widget &#123;</span><br><span class="line"></span><br><span class="line">  const RenderObjectWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;创建element</span><br><span class="line">  @override</span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line">  &#x2F;&#x2F;创建RenderObject</span><br><span class="line">  @protected</span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;更新RenderObject</span><br><span class="line">  @protected</span><br><span class="line">  void updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;卸载RenderObject</span><br><span class="line">  @protected</span><br><span class="line">  void didUnmountRenderObject(covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由注释可以知道<code>RenderObject</code>才是绘制UI背后的真正对象，那下面继续简单跟踪：</p>
<h3 id="3-RenderObjectWidget"><a href="#3-RenderObjectWidget" class="headerlink" title="3.RenderObjectWidget"></a>3.RenderObjectWidget</h3><p>先看看<code>RenderObjectWidget</code>继承关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2dc43541e51a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="RenderObjectWidget继承关系"></p>
<p>看看文档的一一介绍：</p>
<h4 id="3-1-SingleChildRenderObjectWidget"><a href="#3-1-SingleChildRenderObjectWidget" class="headerlink" title="3.1.SingleChildRenderObjectWidget"></a>3.1.SingleChildRenderObjectWidget</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2e6861c9534a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SingleChildRenderObjectWidget"></p>
<p>官方文档写的很清楚： 是<code>RenderObjectWidgets</code>的超类，用于配置有单个孩子的<code>RenderObject</code>子类(为子类提供存储，实际不提供更新逻辑)，并列了具体的实际<code>widget</code>,如常用的Align、ClipRect、DecoratedBox都是属于这类。</p>
<h4 id="3-2-MultiChildRenderObjectWidget"><a href="#3-2-MultiChildRenderObjectWidget" class="headerlink" title="3.2.MultiChildRenderObjectWidget"></a>3.2.MultiChildRenderObjectWidget</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2eff26313931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="MultiChildRenderObjectWidget"></p>
<p>同样也是<code>RenderObjectWidgets</code>的超类，用于配置有单个<strong>children</strong>(也就是多个child)的<code>RenderObject</code>子类，如Flex、Flow、Stack都属于这类。</p>
<h4 id="3-3-LeafRenderObjectWidget"><a href="#3-3-LeafRenderObjectWidget" class="headerlink" title="3.3.LeafRenderObjectWidget"></a>3.3.LeafRenderObjectWidget</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2f8f6f8577bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="LeafRenderObjectWidget"></p>
<p>同样也是<code>RenderObjectWidgets</code>的超类，用于配置没有孩子的<code>RenderObject</code>子类，如：RichText(平时的Text)、RawImage、Texture等。 这里总结一下：</p>
<ul>
<li><code>SingleChildRenderObjectWidget</code>用作只有一个child的<code>widget</code>。</li>
<li><code>MultiChildRenderObjectWidget</code>用作有children(多个孩子)的<code>widget</code>。</li>
<li><code>LeafRenderObjectWidget</code>用作没有child的<code>widget</code>。</li>
<li><code>RenderObjectWidget</code>定义了创建，更新，删除RenderObject的方法，子类必须实现，<code>RenderObject</code>是最终布局、UI渲染的实际对象。</li>
</ul>
<p>那么假如我现在界面上，假如布局如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c3322c6d67e23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="例子布局"></p>
<p>那么渲染流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c346cd1a92ea9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="渲染转换"></p>
<p>这时候会想：为什么要加中间层<code>Element</code>呢，不直接由<code>Widget</code>直接转换成<code>RendObject</code>不是直接更好么？其实并不是这样的。首先知道Flutter是响应式框架，在某一个时刻，可能会受到不同的输入流影响，中间层<code>Element</code>对这一时刻的事件做了汇总，最后将需要修改的部分同步到<code>RendObject</code>tree上，也就是：</p>
<ul>
<li>尽可能的降低<code>RenderObject</code>tree的更改，提高页面渲染效率。</li>
<li>没有直接操作UI，通过数据驱动视图，代码更容易理解和简洁。</li>
</ul>
<p>上面得出UI树是由一个个<code>element</code>节点组成，但是最终的渲染是通过<code>RenderObject</code>来完成，一个<code>widget</code>从创建到显示到界面的流程是：widget生成element，然后通过<strong>createRenderObject</strong>方法创建对应的<code>RenderObject</code>关联到<code>Element.renderObject</code>上，最后通过<code>RenderObject</code>来完成绘制。</p>
<h2 id="三、启动到显示"><a href="#三、启动到显示" class="headerlink" title="三、启动到显示"></a>三、启动到显示</h2><p>上面知道，<code>widget</code>并不是真正显示的对象，知道了一个<code>widget</code>是怎样渲染在屏幕上显示，那下面就从main()方法入口，看看一个app从点击启动到运行的流程：</p>
<h3 id="1-WidgetsFlutterBinding-ensureInitialized"><a href="#1-WidgetsFlutterBinding-ensureInitialized" class="headerlink" title="1.WidgetsFlutterBinding.ensureInitialized"></a>1.WidgetsFlutterBinding.ensureInitialized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;app入口</span><br><span class="line">void main() &#x3D;&gt; runApp(MyApp());</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>app入口函数就是调用了<strong>runApp</strong>方法，看看<strong>runApp</strong>方法里面做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先参数(Widget app)是一个<code>widget</code>，下面一行一行分析，进入<strong>WidgetsFlutterBinding.ensureInitialized()</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A concrete binding for applications based on the Widgets framework.</span><br><span class="line">&#x2F;&#x2F;&#x2F; This is the glue that binds the framework to the Flutter engine.</span><br><span class="line">&#x2F;&#x2F;意思：基于widget framework的应用程序的具体绑定</span><br><span class="line">&#x2F;&#x2F;这是将framework widget和Flutter engine绑定的桥梁</span><br><span class="line">class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; Returns an instance of the [WidgetsBinding], creating and</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initializing it if necessary. If one is created, it will be a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding]. If one was previously initialized, then</span><br><span class="line">  &#x2F;&#x2F;&#x2F; it will at least implement [WidgetsBinding].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; You only need to call this method if you need the binding to be</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initialized before calling [runApp].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; In the &#96;flutter_test&#96; framework, [testWidgets] initializes the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; binding instance to a [TestWidgetsFlutterBinding], not a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding].</span><br><span class="line">  &#x2F;&#x2F;上面注释意思是：返回[WidgetsBinding]的具体实例，必须创建和初始化，如果已&#x2F;&#x2F;经创建了，那么它就是一个[WidgetsFlutterBinding]，如果已经初始化了，那么&#x2F;&#x2F;至少要实现[WidgetsBinding]</span><br><span class="line">  &#x2F;&#x2F;如果你只想调用这个方法，那么你需要在调用runApp之前绑定并且初始化</span><br><span class="line">  static WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    if (WidgetsBinding.instance &#x3D;&#x3D; null)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    return WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看到这个<code>WidgetsFlutterBinding</code>混入(with)很多的<code>Binding</code>，下面先看父类<code>BindingBase</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">abstract class BindingBase &#123;</span><br><span class="line">  BindingBase() &#123;</span><br><span class="line">    developer.Timeline.startSync(&#39;Framework initialization&#39;);</span><br><span class="line"></span><br><span class="line">    assert(!_debugInitialized);</span><br><span class="line">    initInstances();</span><br><span class="line">    assert(_debugInitialized);</span><br><span class="line"></span><br><span class="line">    assert(!_debugServiceExtensionsRegistered);</span><br><span class="line">    initServiceExtensions();</span><br><span class="line">    assert(_debugServiceExtensionsRegistered);</span><br><span class="line"></span><br><span class="line">    developer.postEvent(&#39;Flutter.FrameworkInitialization&#39;, &lt;String, String&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    developer.Timeline.finishSync();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static bool _debugInitialized &#x3D; false;</span><br><span class="line">  static bool _debugServiceExtensionsRegistered &#x3D; false;</span><br><span class="line">  ui.Window get window &#x3D;&gt; ui.window;&#x2F;&#x2F;获取window实例</span><br><span class="line">  @protected</span><br><span class="line">  @mustCallSuper</span><br><span class="line">  void initInstances() &#123;</span><br><span class="line">    assert(!_debugInitialized);</span><br><span class="line">    assert(() &#123; _debugInitialized &#x3D; true; return true; &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看到有句代码<strong>ui.Window get window =&gt; ui.window;</strong>，在Android中所有的视图都是通过<code>window</code>来呈现的，那Flutter中也有<code>window</code>，那看看<code>window</code>在Flutter中的作用看看官方对它的定义：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c38d8bd7b5dce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="window定义"></p>
<p>意思是：链接宿主操作系统的接口，也就是Flutter framework 链接宿主操作系统的接口。系统中有一个Window实例，可以从window属性来获取，看看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">class Window &#123;</span><br><span class="line">  Window._();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;返回DPI，DPI是每英寸的像素点数，是设备屏幕的固件属性</span><br><span class="line">  &#x2F;&#x2F;获取可能不准确</span><br><span class="line">  double get devicePixelRatio &#x3D;&gt; _devicePixelRatio;</span><br><span class="line">  double _devicePixelRatio &#x3D; 1.0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;绘制UI的区域大小</span><br><span class="line">  Size get physicalSize &#x3D;&gt; _physicalSize;</span><br><span class="line">  Size _physicalSize &#x3D; Size.zero;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取矩形的物理像素</span><br><span class="line">  WindowPadding get viewInsets &#x3D;&gt; _viewInsets;</span><br><span class="line">  WindowPadding _viewInsets &#x3D; WindowPadding.zero;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取内边距</span><br><span class="line">  WindowPadding get padding &#x3D;&gt; _padding;</span><br><span class="line">  WindowPadding _padding &#x3D; WindowPadding.zero;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当绘制区域改变时触发</span><br><span class="line">  VoidCallback get onMetricsChanged &#x3D;&gt; _onMetricsChanged;</span><br><span class="line">  VoidCallback _onMetricsChanged;</span><br><span class="line">  Zone _onMetricsChangedZone;</span><br><span class="line">  set onMetricsChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onMetricsChanged &#x3D; callback;</span><br><span class="line">    _onMetricsChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当系统语言发生变化时触发回调</span><br><span class="line">  Locale get locale &#123;</span><br><span class="line">    if (_locales !&#x3D; null &amp;&amp; _locales.isNotEmpty) &#123;</span><br><span class="line">      return _locales.first;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取系统语言</span><br><span class="line">  List&lt;Locale&gt; get locales &#x3D;&gt; _locales;</span><br><span class="line">  List&lt;Locale&gt; _locales;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当Local发生改变时触发回调</span><br><span class="line">  VoidCallback get onLocaleChanged &#x3D;&gt; _onLocaleChanged;</span><br><span class="line">  VoidCallback _onLocaleChanged;</span><br><span class="line">  Zone _onLocaleChangedZone;</span><br><span class="line">  set onLocaleChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onLocaleChanged &#x3D; callback;</span><br><span class="line">    _onLocaleChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当系统字体大小改变时触发回调</span><br><span class="line">  VoidCallback get onTextScaleFactorChanged &#x3D;&gt; _onTextScaleFactorChanged;</span><br><span class="line">  VoidCallback _onTextScaleFactorChanged;</span><br><span class="line">  Zone _onTextScaleFactorChangedZone;</span><br><span class="line">  set onTextScaleFactorChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onTextScaleFactorChanged &#x3D; callback;</span><br><span class="line">    _onTextScaleFactorChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;屏幕亮度改变时触发回调</span><br><span class="line">  VoidCallback get onPlatformBrightnessChanged &#x3D;&gt; _onPlatformBrightnessChanged;</span><br><span class="line">  VoidCallback _onPlatformBrightnessChanged;</span><br><span class="line">  Zone _onPlatformBrightnessChangedZone;</span><br><span class="line">  set onPlatformBrightnessChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onPlatformBrightnessChanged &#x3D; callback;</span><br><span class="line">    _onPlatformBrightnessChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;屏幕刷新时会回调</span><br><span class="line">  FrameCallback get onBeginFrame &#x3D;&gt; _onBeginFrame;</span><br><span class="line">  FrameCallback _onBeginFrame;</span><br><span class="line">  Zone _onBeginFrameZone;</span><br><span class="line">  set onBeginFrame(FrameCallback callback) &#123;</span><br><span class="line">    _onBeginFrame &#x3D; callback;</span><br><span class="line">    _onBeginFrameZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;绘制屏幕时回调</span><br><span class="line">  VoidCallback get onDrawFrame &#x3D;&gt; _onDrawFrame;</span><br><span class="line">  VoidCallback _onDrawFrame;</span><br><span class="line">  Zone _onDrawFrameZone;</span><br><span class="line">  set onDrawFrame(VoidCallback callback) &#123;</span><br><span class="line">    _onDrawFrame &#x3D; callback;</span><br><span class="line">    _onDrawFrameZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;点击或者指针事件触发回调</span><br><span class="line">  PointerDataPacketCallback get onPointerDataPacket &#x3D;&gt; _onPointerDataPacket;</span><br><span class="line">  PointerDataPacketCallback _onPointerDataPacket;</span><br><span class="line">  Zone _onPointerDataPacketZone;</span><br><span class="line">  set onPointerDataPacket(PointerDataPacketCallback callback) &#123;</span><br><span class="line">    _onPointerDataPacket &#x3D; callback;</span><br><span class="line">    _onPointerDataPacketZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取请求的默认路由</span><br><span class="line">  String get defaultRouteName &#x3D;&gt; _defaultRouteName();</span><br><span class="line">  String _defaultRouteName() native &#39;Window_defaultRouteName&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;该方法被调用后，onBeginFrame和onDrawFrame将紧连着会在合适时机调用</span><br><span class="line">  void scheduleFrame() native &#39;Window_scheduleFrame&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;更新应用在GPU上的渲染，这方法会直接调用Flutter engine的Window_render方法</span><br><span class="line">  void render(Scene scene) native &#39;Window_render&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;窗口的语义内容是否改变</span><br><span class="line">  bool get semanticsEnabled &#x3D;&gt; _semanticsEnabled;</span><br><span class="line">  bool _semanticsEnabled &#x3D; false;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当窗口语言发生改变时回调 </span><br><span class="line">  VoidCallback get onSemanticsEnabledChanged &#x3D;&gt; _onSemanticsEnabledChanged;</span><br><span class="line">  VoidCallback _onSemanticsEnabledChanged;</span><br><span class="line">  Zone _onSemanticsEnabledChangedZone;</span><br><span class="line">  set onSemanticsEnabledChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onSemanticsEnabledChanged &#x3D; callback;</span><br><span class="line">    _onSemanticsEnabledChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当用户表达写的动作时回调</span><br><span class="line">  SemanticsActionCallback get onSemanticsAction &#x3D;&gt; _onSemanticsAction;</span><br><span class="line">  SemanticsActionCallback _onSemanticsAction;</span><br><span class="line">  Zone _onSemanticsActionZone;</span><br><span class="line">  set onSemanticsAction(SemanticsActionCallback callback) &#123;</span><br><span class="line">    _onSemanticsAction &#x3D; callback;</span><br><span class="line">    _onSemanticsActionZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;启用其他辅助功能回调</span><br><span class="line">  VoidCallback get onAccessibilityFeaturesChanged &#x3D;&gt; _onAccessibilityFeaturesChanged;</span><br><span class="line">  VoidCallback _onAccessibilityFeaturesChanged;</span><br><span class="line">  Zone _onAccessibilityFlagsChangedZone;</span><br><span class="line">  set onAccessibilityFeaturesChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onAccessibilityFeaturesChanged &#x3D; callback;</span><br><span class="line">    _onAccessibilityFlagsChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;更新此窗口的语义数据</span><br><span class="line">  void updateSemantics(SemanticsUpdate update) native &#39;Window_updateSemantics&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;设置Isolate调试名称</span><br><span class="line">  void setIsolateDebugName(String name) native &#39;Window_setIsolateDebugName&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;向特定平台发送消息</span><br><span class="line">  void sendPlatformMessage(String name,</span><br><span class="line">                           ByteData data,</span><br><span class="line">                           PlatformMessageResponseCallback callback) &#123;</span><br><span class="line">    final String error &#x3D;</span><br><span class="line">        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);</span><br><span class="line">    if (error !&#x3D; null)</span><br><span class="line">      throw new Exception(error);</span><br><span class="line">  &#125;</span><br><span class="line">  String _sendPlatformMessage(String name,</span><br><span class="line">                              PlatformMessageResponseCallback callback,</span><br><span class="line">                              ByteData data) native &#39;Window_sendPlatformMessage&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取平台消息的回调</span><br><span class="line">  PlatformMessageCallback get onPlatformMessage &#x3D;&gt; _onPlatformMessage;</span><br><span class="line">  PlatformMessageCallback _onPlatformMessage;</span><br><span class="line">  Zone _onPlatformMessageZone;</span><br><span class="line">  set onPlatformMessage(PlatformMessageCallback callback) &#123;</span><br><span class="line">    _onPlatformMessage &#x3D; callback;</span><br><span class="line">    _onPlatformMessageZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;由_dispatchPlatformMessage调用</span><br><span class="line">  void _respondToPlatformMessage(int responseId, ByteData data)</span><br><span class="line">      native &#39;Window_respondToPlatformMessage&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;平台信息响应回调</span><br><span class="line">  static PlatformMessageResponseCallback _zonedPlatformMessageResponseCallback(PlatformMessageResponseCallback callback) &#123;</span><br><span class="line">    if (callback &#x3D;&#x3D; null)</span><br><span class="line">      return null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Store the zone in which the callback is being registered.</span><br><span class="line">    final Zone registrationZone &#x3D; Zone.current;</span><br><span class="line"></span><br><span class="line">    return (ByteData data) &#123;</span><br><span class="line">      registrationZone.runUnaryGuarded(callback, data);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以知道<code>window</code>包含当前设备系统的一些信息和回调，那么现在看看混入的各种<code>Binding</code>:</p>
<ul>
<li>GestureBinding：绑定手势子系统，提供<code>onPointerDataPacket</code>回调。</li>
<li>ServicesBinding：绑定平台消息通道，提供<code>onPlatformMessage</code>回调。</li>
<li>SchedulerBinding：绑定绘制调度子系统，提供<code>onBeginFrame</code>和<code>onDrawFrame</code>回调。</li>
<li>PaintingBinding：绑定绘制库，处理图像缓存。</li>
<li>SemanticsBinding：语义层和flutter engine的桥梁，对辅助功能的底层支持。</li>
<li>RendererBinding：是渲染树和Flutter engine的桥梁，提供<code>onMetricsChanged</code>和<code>onTextScaleFactorChanged</code>回调。</li>
<li>WidgetsBinding：是Flutter widget和engine的桥梁，提供<code>onLocaleChanged</code>，<code>onBuildSchedule</code>回调。</li>
</ul>
<p>也就是<code>WidgetsFlutterBinding.ensureInitialized()</code>这行代码看名字是将<code>WidgetsFlutterBinding</code>实例初始化。其实并非那么简单，另外<strong>获取一些系统基本信息和初始化监听<code>window</code>对象的一些事件，然后将这些事件按照上层Framework模型规则进行包装、抽象最后分发</strong>。简而言之<code>WidgetsFlutterBinding</code>是<code>Flutter engine</code>和<code>Framework</code>的桥梁。</p>
<h3 id="2-attachRootWidget-app"><a href="#2-attachRootWidget-app" class="headerlink" title="2.attachRootWidget(app)"></a>2.attachRootWidget(app)</h3><p>第二行是<code>attachRootWidget(app)</code>，看名字意思是将根<code>RootWidget</code>挂载。点进去看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;如果这个widget有必要创建，就将它附加到[renderViewElement]</span><br><span class="line">  void attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement &#x3D; RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: &#39;[root]&#39;,</span><br><span class="line">      child: rootWidget,</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>renderView</code>是UI渲染树的根节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; The render tree that&#39;s attached to the output surface.</span><br><span class="line">  &#x2F;&#x2F;挂载在渲染树 rootNode根节点</span><br><span class="line">  RenderView get renderView &#x3D;&gt; _pipelineOwner.rootNode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>rootWidget</code>是外面所传进来的根<code>Widget</code>，这里不用管它，下面看<code>attachToRenderTree(buildOwner, renderViewElement)</code>这个方法，根据意思，这个方法应该构建<code>RenderTree</code>，这个方法需要两个参数，首先看<code>buildOwner</code>这个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; The [BuildOwner] in charge of executing the build pipeline for the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; widget tree rooted at this binding.</span><br><span class="line">  BuildOwner get buildOwner &#x3D;&gt; _buildOwner;</span><br><span class="line">  final BuildOwner _buildOwner &#x3D; BuildOwner();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看官网对它的定义：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c4793b37168d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="BuildOwner"></p>
<p>意思是：是widget framework的管理类，用来跟踪哪些widget需要重建，并处理widget树的其他任务，例如管理树的非活动元素列表，<strong>并在调试时在热重载期间在必要时触发“重组”命令</strong>，下面看另外一个参数<code>renderViewElement</code>，代码注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; The [Element] that is at the root of the hierarchy (and which wraps the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [RenderView] object at the root of the rendering hierarchy).</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; This is initialized the first time [runApp] is called.</span><br><span class="line">  Element get renderViewElement &#x3D;&gt; _renderViewElement;</span><br><span class="line">  Element _renderViewElement;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>renderViewElement</code>是<code>renderView</code>对应的<code>Element</code>对象，因为<code>renderView</code>是树的根，所以<code>renderViewElement</code>位于层次结构的根部，那下面点击<code>attachToRenderTree</code>的源码看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; Inflate this widget and actually set the resulting [RenderObject] as the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; child of [container].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; If &#96;element&#96; is null, this function will create a new element. Otherwise,</span><br><span class="line">  &#x2F;&#x2F;&#x2F; the given element will have an update scheduled to switch to this widget.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Used by [runApp] to bootstrap applications.</span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt; element ]) &#123;</span><br><span class="line">    if (element &#x3D;&#x3D; null) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element &#x3D; createElement();</span><br><span class="line">        assert(element !&#x3D; null);</span><br><span class="line">        element.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      owner.buildScope(element, () &#123;</span><br><span class="line">        element.mount(null, null);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element._newWidget &#x3D; this;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    return element;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>跟着代码往下走如果根<code>element</code>没有创建，那么就调用<code>createElement</code>创建根<code>element</code>，<code>element</code>和<code>widget</code>进行关联。接着调用<code>element.assignOwner(owner)</code>，这个方法其实就是设置这个<code>element</code>的跟踪，最后调用<code>owner.buildScope</code>这个方法，这个方法是确定更新<code>widget</code>的范围。如果<code>element</code>已经创建了，将根<code>element</code>和关联的<code>widget</code>设为新的，并且重新构建这个<code>element</code>，为了后面的复用。</p>
<h3 id="3-scheduleWarmUpFrame"><a href="#3-scheduleWarmUpFrame" class="headerlink" title="3.scheduleWarmUpFrame"></a>3.scheduleWarmUpFrame</h3><p>runApp()方法最后一行执行<code>scheduleWarmUpFrame</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; Schedule a frame to run as soon as possible, rather than waiting for</span><br><span class="line">  &#x2F;&#x2F;&#x2F; the engine to request a frame in response to a system &quot;Vsync&quot; signal.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; This is used during application startup so that the first frame (which is</span><br><span class="line">  &#x2F;&#x2F;&#x2F; likely to be quite expensive) gets a few extra milliseconds to run.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Locks events dispatching until the scheduled frame has completed.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; If a frame has already been scheduled with [scheduleFrame] or</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [scheduleForcedFrame], this call may delay that frame.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; If any scheduled frame has already begun or if another</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [scheduleWarmUpFrame] was already called, this call will be ignored.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Prefer [scheduleFrame] to update the display in normal operation.</span><br><span class="line">  void scheduleWarmUpFrame() &#123;</span><br><span class="line">    if (_warmUpFrame || schedulerPhase !&#x3D; SchedulerPhase.idle)</span><br><span class="line">      return;</span><br><span class="line"></span><br><span class="line">    _warmUpFrame &#x3D; true;</span><br><span class="line">    Timeline.startSync(&#39;Warm-up frame&#39;);</span><br><span class="line">    final bool hadScheduledFrame &#x3D; _hasScheduledFrame;</span><br><span class="line">    &#x2F;&#x2F; We use timers here to ensure that microtasks flush in between.</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      assert(_warmUpFrame);</span><br><span class="line">      handleBeginFrame(null);---&gt;1</span><br><span class="line">    &#125;);</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      assert(_warmUpFrame);</span><br><span class="line">      handleDrawFrame(); ----&gt;2</span><br><span class="line">      &#x2F;&#x2F; We call resetEpoch after this frame so that, in the hot reload case,</span><br><span class="line">      &#x2F;&#x2F; the very next frame pretends to have occurred immediately after this</span><br><span class="line">      &#x2F;&#x2F; warm-up frame. The warm-up frame&#39;s timestamp will typically be far in</span><br><span class="line">      &#x2F;&#x2F; the past (the time of the last real frame), so if we didn&#39;t reset the</span><br><span class="line">      &#x2F;&#x2F; epoch we would see a sudden jump from the old time in the warm-up frame</span><br><span class="line">      &#x2F;&#x2F; to the new time in the &quot;real&quot; frame. The biggest problem with this is</span><br><span class="line">      &#x2F;&#x2F; that implicit animations end up being triggered at the old time and</span><br><span class="line">      &#x2F;&#x2F; then skipping every frame and finishing in the new time.</span><br><span class="line">      resetEpoch();</span><br><span class="line">      _warmUpFrame &#x3D; false;</span><br><span class="line">      if (hadScheduledFrame)</span><br><span class="line">        scheduleFrame();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Lock events so touch events etc don&#39;t insert themselves until the</span><br><span class="line">    &#x2F;&#x2F; scheduled frame has finished.</span><br><span class="line">    lockEvents(() async &#123;</span><br><span class="line">      await endOfFrame;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先这个方法在<code>SchedulerBinding</code>里，这两个方法主要执行了<code>handleBeginFrame</code>和<code>handleDrawFrame</code>方法：</p>
<h4 id="3-1-handleBeginFrame"><a href="#3-1-handleBeginFrame" class="headerlink" title="3.1.handleBeginFrame"></a>3.1.handleBeginFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  void handleBeginFrame(Duration rawTimeStamp) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; TRANSIENT FRAME CALLBACKS</span><br><span class="line">      Timeline.startSync(&#39;Animate&#39;, arguments: timelineWhitelistArguments);</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.transientCallbacks;</span><br><span class="line">      final Map&lt;int, _FrameCallbackEntry&gt; callbacks &#x3D; _transientCallbacks;</span><br><span class="line">      _transientCallbacks &#x3D; &lt;int, _FrameCallbackEntry&gt;&#123;&#125;;</span><br><span class="line">      callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) &#123;</span><br><span class="line">        if (!_removedIds.contains(id))</span><br><span class="line">          _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);</span><br><span class="line">      &#125;);</span><br><span class="line">      _removedIds.clear();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.midFrameMicrotasks;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到主要是对<code>transientCallbacks</code>队列操作，这个集合主要是放一些临时回调，存放动画回调。</p>
<h4 id="3-2-handleDrawFrame"><a href="#3-2-handleDrawFrame" class="headerlink" title="3.2.handleDrawFrame"></a>3.2.handleDrawFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  void handleDrawFrame() &#123;</span><br><span class="line">    assert(_schedulerPhase &#x3D;&#x3D; SchedulerPhase.midFrameMicrotasks);</span><br><span class="line">    Timeline.finishSync(); &#x2F;&#x2F; end the &quot;Animate&quot; phase</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; PERSISTENT FRAME CALLBACKS -----&gt;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.persistentCallbacks;</span><br><span class="line">      for (FrameCallback callback in _persistentCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; POST-FRAME CALLBACKS  ------&gt;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.postFrameCallbacks;</span><br><span class="line">      final List&lt;FrameCallback&gt; localPostFrameCallbacks &#x3D;</span><br><span class="line">          List&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">      _postFrameCallbacks.clear();</span><br><span class="line">      for (FrameCallback callback in localPostFrameCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.idle;</span><br><span class="line">      Timeline.finishSync(); &#x2F;&#x2F; end the Frame</span><br><span class="line">      profile(() &#123;</span><br><span class="line">        _profileFrameStopwatch.stop();</span><br><span class="line">        _profileFramePostEvent();</span><br><span class="line">      &#125;);</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        if (debugPrintEndFrameBanner)</span><br><span class="line">          debugPrint(&#39;▀&#39; * _debugBanner.length);</span><br><span class="line">        _debugBanner &#x3D; null;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">      _currentFrameTimeStamp &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到执行<code>persistentCallbacks</code>队列，这个队列用于存放一些持久的回调，不能再此类回调中在请求新的绘制帧，持久回调一经注册则不能移除。接着执行<code>postFrameCallbacks</code>这个队列在每一<code>Frame</code>(一次绘制)结束时只会调用一次，调用后被系统移除。</p>
<p>也就是<code>scheduleWarmUpFrame</code>这个方法安排帧尽快执行，当一次帧绘制结束之前不会响应各种事件，这样保证绘制过程中不触发重绘。上面说过：</p>
<blockquote>
<p>RendererBinding：是渲染树和Flutter engine的桥梁，提供onMetricsChanged和onTextScaleFactorChanged回调</p>
</blockquote>
<p>Flutter真正渲染和绘制是在这个绑定里：</p>
<h3 id="4-渲染绘制"><a href="#4-渲染绘制" class="headerlink" title="4.渲染绘制"></a>4.渲染绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  void initInstances() &#123;</span><br><span class="line">    super.initInstances();</span><br><span class="line">    _instance &#x3D; this;&#x2F;&#x2F;初始化</span><br><span class="line">    _pipelineOwner &#x3D; PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F;添加设置监听</span><br><span class="line">    window</span><br><span class="line">      ..onMetricsChanged &#x3D; handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged &#x3D; handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged &#x3D; handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged &#x3D; _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction &#x3D; _handleSemanticsAction;</span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    assert(renderView !&#x3D; null);</span><br><span class="line">    &#x2F;&#x2F;添加persistentFrameCallback</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    &#x2F;&#x2F;创建触摸管理</span><br><span class="line">    _mouseTracker &#x3D; _createMouseTracker();</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>addPersistentFrameCallback</code>这个方法主要向<strong>persistentFrameCallback</strong>添加了回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  void addPersistentFrameCallback(FrameCallback callback) &#123;</span><br><span class="line">    _persistentCallbacks.add(callback);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再看<code>_handlePersistentFrameCallback</code>这个回调做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  void _handlePersistentFrameCallback(Duration timeStamp) &#123;</span><br><span class="line">    drawFrame();</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br><span class="line">  @protected</span><br><span class="line">  void drawFrame() &#123;</span><br><span class="line">    assert(renderView !&#x3D; null);</span><br><span class="line">    pipelineOwner.flushLayout();&#x2F;&#x2F;更新布局信息</span><br><span class="line">    pipelineOwner.flushCompositingBits();&#x2F;&#x2F;在flushLayout只后调用，在flushPaint之前调用，更新RenderObject是否需要重绘</span><br><span class="line">    pipelineOwner.flushPaint();&#x2F;&#x2F;更新绘制RenderObject</span><br><span class="line">    renderView.compositeFrame(); &#x2F;&#x2F; 发送bit数据给GPU</span><br><span class="line">    pipelineOwner.flushSemantics(); &#x2F;&#x2F; 发送语义数据给操作系统</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面一个一个方法走：</p>
<h4 id="4-1-flushLayout"><a href="#4-1-flushLayout" class="headerlink" title="4.1.flushLayout"></a>4.1.flushLayout</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  void flushLayout() &#123;</span><br><span class="line">    profile(() &#123;</span><br><span class="line">      Timeline.startSync(&#39;Layout&#39;, arguments: timelineWhitelistArguments);</span><br><span class="line">    &#125;);</span><br><span class="line">    assert(() &#123;</span><br><span class="line">      _debugDoingLayout &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;());</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; TODO(ianh): assert that we&#39;re not allowing previously dirty nodes to redirty themselves</span><br><span class="line">      while (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">        final List&lt;RenderObject&gt; dirtyNodes &#x3D; _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout &#x3D; &lt;RenderObject&gt;[];</span><br><span class="line">        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) &#x3D;&gt; a.depth - b.depth)) &#123;</span><br><span class="line">          if (node._needsLayout &amp;&amp; node.owner &#x3D;&#x3D; this)</span><br><span class="line">            node._layoutWithoutResize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        _debugDoingLayout &#x3D; false;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">      profile(() &#123;</span><br><span class="line">        Timeline.finishSync();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看源码得知首先获取哪些标记为<code>脏</code>的<code>RenderObject</code>的布局信息，然后通过<code>ode._layoutWithoutResize();</code>重新调整这些<code>RenderObject</code>。</p>
<h4 id="4-2-flushCompositingBits"><a href="#4-2-flushCompositingBits" class="headerlink" title="4.2.flushCompositingBits"></a>4.2.flushCompositingBits</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  void flushCompositingBits() &#123;</span><br><span class="line">    profile(() &#123; Timeline.startSync(&#39;Compositing bits&#39;); &#125;);</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) &#x3D;&gt; a.depth - b.depth);</span><br><span class="line">    for (RenderObject node in _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      if (node._needsCompositingBitsUpdate &amp;&amp; node.owner &#x3D;&#x3D; this)</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">    profile(() &#123; Timeline.finishSync(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>检查<code>RenderObject</code>是否需要重绘，并且通过<code>node._updateCompositingBits();</code>更新<code>_needsCompositing</code>这个属性，若为<code>true</code>就要重新绘制，否则不需要。</p>
<h4 id="4-3-flushPaint"><a href="#4-3-flushPaint" class="headerlink" title="4.3.flushPaint"></a>4.3.flushPaint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  void flushPaint() &#123;</span><br><span class="line">    profile(() &#123; Timeline.startSync(&#39;Paint&#39;, arguments: timelineWhitelistArguments); &#125;);</span><br><span class="line">    assert(() &#123;</span><br><span class="line">      _debugDoingPaint &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;());</span><br><span class="line">    try &#123;</span><br><span class="line">      final List&lt;RenderObject&gt; dirtyNodes &#x3D; _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint &#x3D; &lt;RenderObject&gt;[];</span><br><span class="line">      &#x2F;&#x2F; Sort the dirty nodes in reverse order (deepest first).</span><br><span class="line">      &#x2F;&#x2F;方向遍历这些标记过的node</span><br><span class="line">      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) &#x3D;&gt; b.depth - a.depth)) &#123;</span><br><span class="line">        assert(node._layer !&#x3D; null);</span><br><span class="line">        if (node._needsPaint &amp;&amp; node.owner &#x3D;&#x3D; this) &#123;</span><br><span class="line">          if (node._layer.attached) &#123;</span><br><span class="line">            &#x2F;&#x2F;重新绘制</span><br><span class="line">            PaintingContext.repaintCompositedChild(node);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            node._skippedPaintingOnLayer();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_nodesNeedingPaint.isEmpty);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        _debugDoingPaint &#x3D; false;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">      profile(() &#123; Timeline.finishSync(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个方法通过反向遍历(<code>dirty</code>标记)取得需要重绘的<code>RenderObject</code>，最后通过<code>PaintingContext.repaintCompositedChild(node);</code>重绘。</p>
<h4 id="4-4-compositeFrame"><a href="#4-4-compositeFrame" class="headerlink" title="4.4.compositeFrame"></a>4.4.compositeFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  void compositeFrame() &#123;</span><br><span class="line">    Timeline.startSync(&#39;Compositing&#39;, arguments: timelineWhitelistArguments);</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;创建Scene对象</span><br><span class="line">      final ui.SceneBuilder builder &#x3D; ui.SceneBuilder();</span><br><span class="line">      final ui.Scene scene &#x3D; layer.buildScene(builder);</span><br><span class="line">      if (automaticSystemUiAdjustment)</span><br><span class="line">        _updateSystemChrome();</span><br><span class="line">      &#x2F;&#x2F;使用render方法将Scene对象显示在屏幕上    </span><br><span class="line">      _window.render(scene);&#x2F;&#x2F;调用flutter engine的渲染API</span><br><span class="line">      scene.dispose();</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        if (debugRepaintRainbowEnabled || debugRepaintTextRainbowEnabled)</span><br><span class="line">          debugCurrentRepaintColor &#x3D; debugCurrentRepaintColor.withHue((debugCurrentRepaintColor.hue + 2.0) % 360.0);</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>Scene</code>是用来保存渲染后的最终像素信息，这个方法将<code>Canvas</code>画好的<code>Scene</code>对象传给<code>window.render()</code>方法，该方法会直接将<code>Scene</code>信息发送给Flutter engine，最终Flutter engine将图像画在设备屏幕上，这样整个绘制流程就算完了。</p>
<p>注意：<code>RendererBinding</code>只是混入对象，最终混入到<code>WidgetsBinding</code>，回到最开始来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; Returns an instance of the [WidgetsBinding], creating and</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initializing it if necessary. If one is created, it will be a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding]. If one was previously initialized, then</span><br><span class="line">  &#x2F;&#x2F;&#x2F; it will at least implement [WidgetsBinding].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; You only need to call this method if you need the binding to be</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initialized before calling [runApp].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; In the &#96;flutter_test&#96; framework, [testWidgets] initializes the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; binding instance to a [TestWidgetsFlutterBinding], not a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding].</span><br><span class="line">  static WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    if (WidgetsBinding.instance &#x3D;&#x3D; null)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    return WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以应该<code>WidgetsBinding</code>来重写实现<code>drawFrame</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  @override</span><br><span class="line">  void drawFrame() &#123;</span><br><span class="line">    assert(!debugBuildingDirtyElements);</span><br><span class="line">    assert(() &#123;</span><br><span class="line">      debugBuildingDirtyElements &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;());</span><br><span class="line">    try &#123;</span><br><span class="line">      if (renderViewElement !&#x3D; null)</span><br><span class="line">        buildOwner.buildScope(renderViewElement);</span><br><span class="line">      super.drawFrame(); &#x2F;&#x2F;调用Renderbinding的drawFrame方法</span><br><span class="line">      buildOwner.finalizeTree();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        debugBuildingDirtyElements &#x3D; false;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">    profile(() &#123;</span><br><span class="line">      if (_needToReportFirstFrame &amp;&amp; _reportFirstFrame) &#123;</span><br><span class="line">        developer.Timeline.instantSync(&#39;Widgets completed first useful frame&#39;);</span><br><span class="line">        developer.postEvent(&#39;Flutter.FirstFrame&#39;, &lt;String, dynamic&gt;&#123;&#125;);</span><br><span class="line">        _needToReportFirstFrame &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li><code>widget</code>的功能是向<code>element</code>提供配置信息，每一个<code>widget</code>在Flutter里是一份配置数据，而代表屏幕背后的元素是<code>element</code>，而真正的布局、渲染是通过<code>RenderObject</code>来完成的，从创建到渲染的主要流程是：<code>widget</code>信息生成<code>element</code>，创建对应的<code>RenderObject</code>关联到<code>Element.renderObject</code>属性上，最后通过<code>RenderObject</code>布局和绘制。</li>
<li>Flutter从启动到显示图像在屏幕主要经过：首先监听处理<code>window</code>对象的事件，将这些事件处理包装为Framework模型进行分发，通过<code>widget</code>创建<code>element</code>树，接着通过<code>scheduleWarmUpFrame</code>进行渲染，接着通过<code>Rendererbinding</code>进行布局，绘制，最后通过调用<code>ui.window.render(scene)</code>Scene信息发给Flutter engine，Flutter engine最后调用渲染API把图像画在屏幕上。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/flutter/" rel="tag"># flutter</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/12/flutter/dart/drat%E6%96%B0%E9%A2%96%E8%AF%AD%E6%B3%95%E7%B3%96/" rel="next" title="drat新颖语法糖">
                <i class="fa fa-chevron-left"></i> drat新颖语法糖
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/17/flutter/widget%E7%BB%84%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/" rel="prev" title="文本组件">
                文本组件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Flutter学习之视图体系"><span class="nav-number">1.</span> <span class="nav-text">Flutter学习之视图体系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、前言"><span class="nav-number">1.1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、视图基础"><span class="nav-number">1.2.</span> <span class="nav-text">二、视图基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Widget"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.Widget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Element"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-RenderObjectWidget"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.RenderObjectWidget</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-SingleChildRenderObjectWidget"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">3.1.SingleChildRenderObjectWidget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-MultiChildRenderObjectWidget"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">3.2.MultiChildRenderObjectWidget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-LeafRenderObjectWidget"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3.3.LeafRenderObjectWidget</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、启动到显示"><span class="nav-number">1.3.</span> <span class="nav-text">三、启动到显示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-WidgetsFlutterBinding-ensureInitialized"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.WidgetsFlutterBinding.ensureInitialized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-attachRootWidget-app"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.attachRootWidget(app)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-scheduleWarmUpFrame"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.scheduleWarmUpFrame</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-handleBeginFrame"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.1.handleBeginFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-handleDrawFrame"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.2.handleDrawFrame</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-渲染绘制"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.渲染绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-flushLayout"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">4.1.flushLayout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-flushCompositingBits"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">4.2.flushCompositingBits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-flushPaint"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">4.3.flushPaint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-compositeFrame"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">4.4.compositeFrame</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、总结"><span class="nav-number">1.4.</span> <span class="nav-text">四、总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
