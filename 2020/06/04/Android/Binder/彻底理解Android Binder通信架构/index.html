<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,Binder," />










<meta name="description" content="一. 引言1.1 Binder架构的思考Android内核是基于Linux系统, 而Linux现存多种进程间IPC方式:管道, 消息队列, 共享内存, 套接字, 信号量, 信号. 为什么Android非要用Binder来进行进程间通信呢. 从我个人的理解角度, 曾尝试着在知乎回答同样一个问题 为什么Android要采用Binder作为IPC机制？. 这是Gityuan第一次认认真真地在知乎上回答问">
<meta property="og:type" content="article">
<meta property="og:title" content="彻底理解Android Binder通信架构">
<meta property="og:url" content="http://yoursite.com/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="一. 引言1.1 Binder架构的思考Android内核是基于Linux系统, 而Linux现存多种进程间IPC方式:管道, 消息队列, 共享内存, 套接字, 信号量, 信号. 为什么Android非要用Binder来进行进程间通信呢. 从我个人的理解角度, 曾尝试着在知乎回答同样一个问题 为什么Android要采用Binder作为IPC机制？. 这是Gityuan第一次认认真真地在知乎上回答问">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/tcp_ip_arch.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/binder_ipc_arch.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/start_server_binder.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/ams_ipc.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/binder_ipc_process.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/binder_transaction.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_start_service/binder_transaction_oneway.jpg">
<meta property="og:image" content="http://gityuan.com/images/binder/binder_transaction_data.jpg">
<meta property="article:published_time" content="2020-06-04T05:52:26.000Z">
<meta property="article:modified_time" content="2020-06-04T06:17:56.874Z">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Binder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://gityuan.com/images/binder/binder_start_service/tcp_ip_arch.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/04/Android/Binder/彻底理解Android Binder通信架构/"/>





  <title>彻底理解Android Binder通信架构 | 冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">彻底理解Android Binder通信架构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T13:52:26+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-引言"><a href="#一-引言" class="headerlink" title="一. 引言"></a>一. 引言</h2><h4 id="1-1-Binder架构的思考"><a href="#1-1-Binder架构的思考" class="headerlink" title="1.1 Binder架构的思考"></a>1.1 Binder架构的思考</h4><p>Android内核是基于Linux系统, 而Linux现存多种进程间IPC方式:管道, 消息队列, 共享内存, 套接字, 信号量, 信号. 为什么Android非要用Binder来进行进程间通信呢. 从我个人的理解角度, 曾尝试着在知乎回答同样一个问题 <a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a>. 这是Gityuan第一次认认真真地在知乎上回答问题, 收到很多网友的点赞与回复, 让我很受鼓舞, 也决心分享更多优先地文章回报读者和粉丝, 为Android圈贡献自己的微薄之力。</p>
<p>在说到Binder架构之前, 先简单说说大家熟悉的TCP/IP的五层通信体系结构:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/tcp_ip_arch.jpg" alt="tcp_ip_arch"></p>
<ul>
<li>应用层: 直接为用户提供服务;</li>
<li>传输层: 传输的是报文(TCP数据)或者用户数据报(UDP数据)</li>
<li>网络层: 传输的是包(Packet), 例如路由器</li>
<li>数据链路层: 传输的是帧(Frame), 例如以太网交换机</li>
<li>物理层: 相邻节点间传输bit, 例如集线器,双绞线等</li>
</ul>
<p>这是经典的五层TPC/IP协议体系, 这样分层设计的思想, 让每一个子问题都设计成一个独立的协议, 这协议的设计/分析/实现/测试都变得更加简单:</p>
<ul>
<li>层与层具有独立性, 例如应用层可以使用传输层提供的功能而无需知晓其实现原理;</li>
<li>设计灵活, 层与层之间都定义好接口, 即便层内方法发生变化,只有接口不变, 对这个系统便毫无影响;</li>
<li>结构的解耦合, 让每一层可以用更适合的技术方案, 更合适的语言;</li>
<li>方便维护, 可分层调试和定位问题;</li>
</ul>
<p>Binder架构也是采用分层架构设计, 每一层都有其不同的功能:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/binder_ipc_arch.jpg" alt="binder_ipc_arch"></p>
<ul>
<li><strong>Java应用层:</strong> 对于上层应用通过调用AMP.startService, 完全可以不用关心底层,经过层层调用,最终必然会调用到AMS.startService.</li>
<li><strong>Java IPC层:</strong> Binder通信是采用C/S架构, Android系统的基础架构便已设计好Binder在Java framework层的Binder客户类BinderProxy和服务类Binder;</li>
<li><strong>Native IPC层:</strong> 对于Native层,如果需要直接使用Binder(比如media相关), 则可以直接使用BpBinder和BBinder(当然这里还有JavaBBinder)即可, 对于上一层Java IPC的通信也是基于这个层面.</li>
<li><strong>Kernel物理层:</strong> 这里是Binder Driver, 前面3层都跑在用户空间,对于用户空间的内存资源是不共享的,每个Android的进程只能运行在自己进程所拥有的虚拟地址空间, 而内核空间却是可共享的. 真正通信的核心环节还是在Binder Driver.</li>
</ul>
<h4 id="1-2-分析起点"><a href="#1-2-分析起点" class="headerlink" title="1.2 分析起点"></a>1.2 分析起点</h4><p>前面通过一个<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列-开篇</a>来从源码讲解了Binder的各个层面, 但是Binder牵涉颇为广泛, 几乎是整个Android架构的顶梁柱, 虽说用了十几篇文章来阐述Binder的各个过程. 但依然还是没有将Binder IPC(进程间通信)的过程彻底说透.</p>
<p>Binder系统如此庞大, 那么这里需要寻求一个出发点来穿针引线, 一窥视Binder全貌. 那么本文将从全新的视角,以<a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService流程分析</a>为例子来说说Binder所其作用. 首先在发起方进程调用AMP.startService，经过binder驱动，最终调用系统进程AMS.startService,如下图:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/start_server_binder.jpg" alt="start_server_binder"></p>
<p>AMP和AMN都是实现了IActivityManager接口,AMS继承于AMN. 其中AMP作为Binder的客户端,运行在各个app所在进程, AMN(或AMS)运行在系统进程system_server.</p>
<h4 id="1-3-Binder-IPC原理"><a href="#1-3-Binder-IPC原理" class="headerlink" title="1.3 Binder IPC原理"></a>1.3 Binder IPC原理</h4><p>Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。下面说说startService过程所涉及的Binder对象的架构图：</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/ams_ipc.jpg" alt="ams_ipc"></p>
<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务, 当然查找到目标信息可以缓存起来则不需要每次都向ServiceManager请求。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li><strong>注册服务</strong>：首先AMS注册到ServiceManager。该过程：AMS所在进程(system_server)是客户端，ServiceManager是服务端。</li>
<li><strong>获取服务</strong>：Client进程使用AMS前，须先向ServiceManager中获取AMS的代理类AMP。该过程：AMP所在进程(app process)是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>： app进程根据得到的代理类AMP,便可以直接与AMS所在进程交互。该过程：AMP所在进程(app process)是客户端，AMS所在进程(system_server)是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder Driver进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层.</p>
<p>这3大过程每一次都是一个完整的Binder IPC过程, 接下来从源码角度, 仅介绍<strong>第3过程使用服务</strong>, 即展开<code>AMP.startService是如何调用到AMS.startService的过程</code>.</p>
<p><strong>Tips:</strong> 如果你只想了解大致过程,并不打算细扣源码, 那么你可以略过通信过程源码分析, 仅看本文第一段落和最后段落也能对Binder所有理解.</p>
<h2 id="二-通信过程"><a href="#二-通信过程" class="headerlink" title="二. 通信过程"></a>二. 通信过程</h2><h3 id="2-1-AMP-startService"><a href="#2-1-AMP-startService" class="headerlink" title="2.1 AMP.startService"></a>2.1 AMP.startService</h3><p>[-&gt; ActivityManagerNative.java ::ActivityManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F;获取或创建Parcel对象【见小节2.2】</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller !&#x3D; null ? caller.asBinder() : null);</span><br><span class="line">    service.writeToParcel(data, 0);</span><br><span class="line">    &#x2F;&#x2F;写入Parcel数据 【见小节2.3】</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过Binder传递数据【见小节2.5】</span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    &#x2F;&#x2F;读取应答消息的异常情况</span><br><span class="line">    reply.readException();</span><br><span class="line">    &#x2F;&#x2F;根据reply数据来创建ComponentName对象</span><br><span class="line">    ComponentName res &#x3D; ComponentName.readFromParcel(reply);</span><br><span class="line">    &#x2F;&#x2F;【见小节2.2.3】</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能:</p>
<ul>
<li>获取或创建两个Parcel对象,data用于发送数据，reply用于接收应答数据.</li>
<li>将startService相关数据都封装到Parcel对象data, 其中descriptor = “android.app.IActivityManager”;</li>
<li>通过Binder传递数据,并将应答消息写入reply;</li>
<li>读取reply应答消息的异常情况和组件对象;</li>
</ul>
<h3 id="2-2-Parcel-obtain"><a href="#2-2-Parcel-obtain" class="headerlink" title="2.2 Parcel.obtain"></a>2.2 Parcel.obtain</h3><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static Parcel obtain() &#123;</span><br><span class="line">    final Parcel[] pool &#x3D; sOwnedPool;</span><br><span class="line">    synchronized (pool) &#123;</span><br><span class="line">        Parcel p;</span><br><span class="line">        &#x2F;&#x2F;POOL_SIZE &#x3D; 6</span><br><span class="line">        for (int i&#x3D;0; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            p &#x3D; pool[i];</span><br><span class="line">            if (p !&#x3D; null) &#123;</span><br><span class="line">                pool[i] &#x3D; null;</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当缓存池没有现成的Parcel对象，则直接创建[见流程2.2.1]</span><br><span class="line">    return new Parcel(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sOwnedPool</code>是一个大小为6，存放着parcel对象的缓存池,这样设计的目标是用于节省每次都创建Parcel对象的开销。obtain()方法的作用：</p>
<ol>
<li>先尝试从缓存池<code>sOwnedPool</code>中查询是否存在缓存Parcel对象，当存在则直接返回该对象;</li>
<li>如果没有可用的Parcel对象，则直接创建Parcel对象。</li>
</ol>
<h4 id="2-2-1-new-Parcel"><a href="#2-2-1-new-Parcel" class="headerlink" title="2.2.1 new Parcel"></a>2.2.1 new Parcel</h4><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Parcel(long nativePtr) &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化本地指针</span><br><span class="line">    init(nativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void init(long nativePtr) &#123;</span><br><span class="line">    if (nativePtr !&#x3D; 0) &#123;</span><br><span class="line">        mNativePtr &#x3D; nativePtr;</span><br><span class="line">        mOwnsNativeParcelObject &#x3D; false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 首次创建,进入该分支[见流程2.2.2]</span><br><span class="line">        mNativePtr &#x3D; nativeCreate();</span><br><span class="line">        mOwnsNativeParcelObject &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeCreate这是native方法,经过JNI进入native层, 调用android_os_Parcel_create()方法.</p>
<h4 id="2-2-2-android-os-Parcel-create"><a href="#2-2-2-android-os-Parcel-create" class="headerlink" title="2.2.2 android_os_Parcel_create"></a>2.2.2 android_os_Parcel_create</h4><p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static jlong android_os_Parcel_create(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    Parcel* parcel &#x3D; new Parcel();</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建C++层的Parcel对象, 该对象指针强制转换为long型, 并保存到Java层的<code>mNativePtr</code>对象. 创建完Parcel对象利用Parcel对象写数据. 接下来以writeString为例.</p>
<h4 id="2-2-3-Parcel-recycle"><a href="#2-2-3-Parcel-recycle" class="headerlink" title="2.2.3 Parcel.recycle"></a>2.2.3 Parcel.recycle</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void recycle() &#123;</span><br><span class="line">    &#x2F;&#x2F;释放native parcel对象</span><br><span class="line">    freeBuffer();</span><br><span class="line">    final Parcel[] pool;</span><br><span class="line">    &#x2F;&#x2F;根据情况来选择加入相应池</span><br><span class="line">    if (mOwnsNativeParcelObject) &#123;</span><br><span class="line">        pool &#x3D; sOwnedPool;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mNativePtr &#x3D; 0;</span><br><span class="line">        pool &#x3D; sHolderPool;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (pool) &#123;</span><br><span class="line">        for (int i&#x3D;0; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            if (pool[i] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                pool[i] &#x3D; this;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将不再使用的Parcel对象放入缓存池，可回收重复利用，当缓存池已满则不再加入缓存池。这里有两个Parcel线程池,<code>mOwnsNativeParcelObject</code>变量来决定:</p>
<ul>
<li><code>mOwnsNativeParcelObject</code>=true, 即调用不带参数obtain()方法获取的对象, 回收时会放入<code>sOwnedPool</code>对象池;</li>
<li><code>mOwnsNativeParcelObject</code>=false, 即调用带nativePtr参数的obtain(long)方法获取的对象, 回收时会放入<code>sHolderPool</code>对象池;</li>
</ul>
<h3 id="2-3-writeString"><a href="#2-3-writeString" class="headerlink" title="2.3 writeString"></a>2.3 writeString</h3><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void writeString(String val) &#123;</span><br><span class="line">    &#x2F;&#x2F;[见流程2.3.1]</span><br><span class="line">    nativeWriteString(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-nativeWriteString"><a href="#2-3-1-nativeWriteString" class="headerlink" title="2.3.1 nativeWriteString"></a>2.3.1 nativeWriteString</h4><p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_Parcel_writeString(JNIEnv* env, jclass clazz, jlong nativePtr, jstring val) &#123;</span><br><span class="line">    Parcel* parcel &#x3D; reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel !&#x3D; NULL) &#123;</span><br><span class="line">        status_t err &#x3D; NO_MEMORY;</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            const jchar* str &#x3D; env-&gt;GetStringCritical(val, 0);</span><br><span class="line">            if (str) &#123;</span><br><span class="line">                &#x2F;&#x2F;[见流程2.3.2]</span><br><span class="line">                err &#x3D; parcel-&gt;writeString16(</span><br><span class="line">                    reinterpret_cast&lt;const char16_t*&gt;(str),</span><br><span class="line">                    env-&gt;GetStringLength(val));</span><br><span class="line">                env-&gt;ReleaseStringCritical(val, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            err &#x3D; parcel-&gt;writeString16(NULL, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-writeString16"><a href="#2-3-2-writeString16" class="headerlink" title="2.3.2 writeString16"></a>2.3.2 writeString16</h4><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeString16(const char16_t* str, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    if (str &#x3D;&#x3D; NULL) return writeInt32(-1);</span><br><span class="line"></span><br><span class="line">    status_t err &#x3D; writeInt32(len);</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        len *&#x3D; sizeof(char16_t);</span><br><span class="line">        uint8_t* data &#x3D; (uint8_t*)writeInplace(len+sizeof(char16_t));</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            &#x2F;&#x2F;数据拷贝到data所指向的位置</span><br><span class="line">            memcpy(data, str, len);</span><br><span class="line">            *reinterpret_cast&lt;char16_t*&gt;(data+len) &#x3D; 0;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        err &#x3D; mError;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 除了writeString(),在<code>Parcel.java</code>中大量的native方法, 都是调用<code>android_os_Parcel.cpp</code>相对应的方法, 该方法再调用<code>Parcel.cpp</code>中对应的方法.<br>调用流程: Parcel.java –&gt; android_os_Parcel.cpp –&gt; Parcel.cpp.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/Parcel.java</span><br><span class="line">frameworks/base/core/jni/android_os_Parcel.cpp</span><br><span class="line">frameworks/<span class="keyword">native</span>/libs/binder/Parcel.cpp</span><br></pre></td></tr></table></figure>

<p>简单说,就是</p>
<h3 id="2-4-mRemote究竟为何物"><a href="#2-4-mRemote究竟为何物" class="headerlink" title="2.4 mRemote究竟为何物"></a>2.4 mRemote究竟为何物</h3><p>mRemote的出生,要出先说说ActivityManagerProxy对象(简称AMP)创建说起, AMP是通过ActivityManagerNative.getDefault()来获取的.</p>
<h4 id="2-4-1-AMN-getDefault"><a href="#2-4-1-AMN-getDefault" class="headerlink" title="2.4.1 AMN.getDefault"></a>2.4.1 AMN.getDefault</h4><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [见流程2.4.2]</span></span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gDefault的数据类型为<code>Singleton&lt;IActivityManager&gt;</code>, 这是一个单例模式, 接下来看看Singleto.get()的过程</p>
<h4 id="2-4-2-gDefault-get"><a href="#2-4-2-gDefault-get" class="headerlink" title="2.4.2 gDefault.get"></a>2.4.2 gDefault.get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Singleton&lt;IActivityManager&gt; &#123;</span><br><span class="line">    public final IActivityManager get() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;首次调用create()来获取AMP对象[见流程2.4.3]</span><br><span class="line">                mInstance &#x3D; create();</span><br><span class="line">            &#125;</span><br><span class="line">            return mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次调用时需要创建,创建完之后保持到mInstance对象,之后可直接使用.</p>
<h4 id="2-4-3-gDefault-create"><a href="#2-4-3-gDefault-create" class="headerlink" title="2.4.3 gDefault.create"></a>2.4.3 gDefault.create</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取名为&quot;activity&quot;的服务</span><br><span class="line">        IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建AMP对象[见流程2.4.4]</span><br><span class="line">        IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文章<a href="http://gityuan.com/2015/11/21/binder-framework/#section-4" target="_blank" rel="noopener">Binder系列7—framework层分析</a>，可知ServiceManager.getService(“activity”)返回的是指向目标服务AMS的代理对象<code>BinderProxy</code>对象，由该代理对象可以找到目标服务AMS所在进程</p>
<h4 id="2-4-4-AMN-asInterface"><a href="#2-4-4-AMN-asInterface" class="headerlink" title="2.4.4 AMN.asInterface"></a>2.4.4 AMN.asInterface</h4><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager &#123;</span><br><span class="line">    static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;此处obj &#x3D; BinderProxy, descriptor &#x3D; &quot;android.app.IActivityManager&quot;; [见流程2.4.5]</span><br><span class="line">        IActivityManager in &#x3D; (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123; &#x2F;&#x2F;此处为null</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;[见流程2.4.6]</span><br><span class="line">        return new ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时obj为BinderProxy对象, 记录着远程进程system_server中AMS服务的binder线程的handle.</p>
<h4 id="2-4-5-queryLocalInterface"><a href="#2-4-5-queryLocalInterface" class="headerlink" title="2.4.5 queryLocalInterface"></a>2.4.5 queryLocalInterface</h4><p>[Binder.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    &#x2F;&#x2F;对于Binder对象的调用,则返回值不为空</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        &#x2F;&#x2F;mDescriptor的初始化在attachInterface()过程中赋值</span><br><span class="line">        if (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">            return mOwner;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;由上一小节[2.4.4]调用的流程便是此处,返回Null</span><br><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    &#x2F;&#x2F;BinderProxy对象的调用, 则返回值为空</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Binder IPC的过程中, 同一个进程的调用则会是asInterface()方法返回的便是本地的Binder对象;对于不同进程的调用则会是远程代理对象BinderProxy.</p>
<h4 id="2-4-6-创建AMP"><a href="#2-4-6-创建AMP" class="headerlink" title="2.4.6 创建AMP"></a>2.4.6 创建AMP</h4><p>[-&gt; ActivityManagerNative.java :: AMP]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager &#123;</span><br><span class="line">    public ActivityManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知<code>mRemote</code>便是指向AMS服务的<code>BinderProxy</code>对象。</p>
<h3 id="2-5-mRemote-transact"><a href="#2-5-mRemote-transact" class="headerlink" title="2.5 mRemote.transact"></a>2.5 mRemote.transact</h3><p>[-&gt; Binder.java ::BinderProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        &#x2F;&#x2F;用于检测Parcel大小是否大于800k</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">        &#x2F;&#x2F;【见2.6】</span><br><span class="line">        return transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote.transact()方法中的code=START_SERVICE_TRANSACTION, data保存了<code>descriptor</code>，<code>caller</code>, <code>intent</code>, <code>resolvedType</code>, <code>callingPackage</code>, <code>userId</code>这6项信息。</p>
<p>transactNative是native方法，经过jni调用android_os_BinderProxy_transact方法。</p>
<h3 id="2-6-android-os-BinderProxy-transact"><a href="#2-6-android-os-BinderProxy-transact" class="headerlink" title="2.6 android_os_BinderProxy_transact"></a>2.6 android_os_BinderProxy_transact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">    jint code, jobject dataObj, jobject replyObj, jint flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;将java Parcel转为c++ Parcel</span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;gBinderProxyOffsets.mObject中保存的是new BpBinder(handle)对象</span><br><span class="line">    IBinder* target &#x3D; (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此处便是BpBinder::transact()【见小节2.7】</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;最后根据transact执行具体情况，抛出相应的Exception</span><br><span class="line">    signalExceptionForError(env, obj, err, true , data-&gt;dataSize());</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gBinderProxyOffsets.mObject中保存的是<code>BpBinder</code>对象, 这是开机时Zygote调用<code>AndroidRuntime::startReg</code>方法来完成jni方法的注册.</p>
<p>其中register_android_os_Binder()过程就有一个初始并注册BinderProxy的操作,完成gBinderProxyOffsets的赋值过程. 接下来就进入该方法.</p>
<h3 id="2-7-BpBinder-transact"><a href="#2-7-BpBinder-transact" class="headerlink" title="2.7 BpBinder.transact"></a>2.7 BpBinder.transact</h3><p>[-&gt; BpBinder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        &#x2F;&#x2F; 【见小节2.8】</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState::self()采用单例模式，保证每个线程只有一个实例对象。</p>
<h3 id="2-8-IPC-transact"><a href="#2-8-IPC-transact" class="headerlink" title="2.8 IPC.transact"></a>2.8 IPC.transact</h3><p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err &#x3D; data.errorCheck(); &#x2F;&#x2F;数据错误检查</span><br><span class="line">    flags |&#x3D; TF_ACCEPT_FDS;</span><br><span class="line">    ....</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">         &#x2F;&#x2F; 传输数据 【见小节2.9】</span><br><span class="line">        err &#x3D; writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError &#x3D; err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果</span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            &#x2F;&#x2F;reply对象不为空 【见小节2.10】</span><br><span class="line">            err &#x3D; waitForResponse(reply);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err &#x3D; waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err &#x3D; waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transact主要过程:</p>
<ul>
<li>先执行writeTransactionData()已向Parcel数据类型的<code>mOut</code>写入数据，此时<code>mIn</code>还没有数据；</li>
<li>然后执行waitForResponse()方法，循环执行，直到收到应答消息. 调用talkWithDriver()跟驱动交互，收到应答消息，便会写入<code>mIn</code>, 则根据收到的不同响应吗，执行相应的操作。</li>
</ul>
<p>此处调用waitForResponse根据是否有设置<code>TF_ONE_WAY</code>的标记:</p>
<ul>
<li>当已设置oneway时, 则调用waitForResponse(NULL, NULL);</li>
<li>当未设置oneway时, 则调用waitForResponse(reply) 或 waitForResponse(&amp;fakeReply)</li>
</ul>
<h3 id="2-9-IPC-writeTransactionData"><a href="#2-9-IPC-writeTransactionData" class="headerlink" title="2.9 IPC.writeTransactionData"></a>2.9 IPC.writeTransactionData</h3><p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</span><br><span class="line">    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr &#x3D; 0;</span><br><span class="line">    tr.target.handle &#x3D; handle; &#x2F;&#x2F; handle指向AMS</span><br><span class="line">    tr.code &#x3D; code;            &#x2F;&#x2F; START_SERVICE_TRANSACTION</span><br><span class="line">    tr.flags &#x3D; binderFlags;    &#x2F;&#x2F; 0</span><br><span class="line">    tr.cookie &#x3D; 0;</span><br><span class="line">    tr.sender_pid &#x3D; 0;</span><br><span class="line">    tr.sender_euid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    const status_t err &#x3D; data.errorCheck();</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        &#x2F;&#x2F; data为startService相关信息</span><br><span class="line">        tr.data_size &#x3D; data.ipcDataSize();   &#x2F;&#x2F; mDataSize</span><br><span class="line">        tr.data.ptr.buffer &#x3D; data.ipcData(); &#x2F;&#x2F; mData指针</span><br><span class="line">        tr.offsets_size &#x3D; data.ipcObjectsCount()*sizeof(binder_size_t); &#x2F;&#x2F;mObjectsSize</span><br><span class="line">        tr.data.ptr.offsets &#x3D; data.ipcObjects(); &#x2F;&#x2F;mObjects指针</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mOut.writeInt32(cmd);         &#x2F;&#x2F;cmd &#x3D; BC_TRANSACTION</span><br><span class="line">    mOut.write(&amp;tr, sizeof(tr));  &#x2F;&#x2F;写入binder_transaction_data数据</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将数据写入mOut</p>
<h3 id="2-10-IPC-waitForResponse"><a href="#2-10-IPC-waitForResponse" class="headerlink" title="2.10 IPC.waitForResponse"></a>2.10 IPC.waitForResponse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break; &#x2F;&#x2F; 【见小节2.11】</span><br><span class="line">        err &#x3D; mIn.errorCheck();</span><br><span class="line">        if (err &lt; NO_ERROR) break; &#x2F;&#x2F;当存在error则退出循环</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;每当跟Driver交互一次，若mIn收到数据则往下执行一次BR命令</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd &#x3D; mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            &#x2F;&#x2F;只有当不需要reply, 也就是oneway时 才会跳出循环,否则还需要等待.</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish; break;</span><br><span class="line"></span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            err &#x3D; DEAD_OBJECT;         goto finish;</span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            err &#x3D; FAILED_TRANSACTION;  goto finish;</span><br><span class="line">        case BR_REPLY: ...             goto finish;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; executeCommand(cmd);  &#x2F;&#x2F;【见小节2.12】</span><br><span class="line">            if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err); &#x2F;&#x2F;将发送的错误代码返回给最初的调用者</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中, 收到以下任一BR_命令，处理后便会退出waitForResponse()的状态:</p>
<ul>
<li>BR_TRANSACTION_COMPLETE: binder驱动收到BC_TRANSACTION事件后的应答消息; 对于oneway transaction,当收到该消息,则完成了本次Binder通信;</li>
<li>BR_DEAD_REPLY: 回复失败，往往是线程或节点为空. 则结束本次通信Binder;</li>
<li>BR_FAILED_REPLY:回复失败，往往是transaction出错导致. 则结束本次通信Binder;</li>
<li>BR_REPLY: Binder驱动向Client端发送回应消息; 对于非oneway transaction时,当收到该消息,则完整地完成本次Binder通信;</li>
</ul>
<p>除了以上命令，其他命令的处理流程【见小节2.12】</p>
<h3 id="2-11-IPC-talkWithDriver"><a href="#2-11-IPC-talkWithDriver" class="headerlink" title="2.11 IPC.talkWithDriver"></a>2.11 IPC.talkWithDriver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;mOut有数据，mIn还没有数据。doReceive默认值为true</span><br><span class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    const bool needRead &#x3D; mIn.dataPosition() &gt;&#x3D; mIn.dataSize();</span><br><span class="line">    const size_t outAvail &#x3D; (!doReceive || needRead) ? mOut.dataSize() : 0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; outAvail;</span><br><span class="line">    bwr.write_buffer &#x3D; (uintptr_t)mOut.data();</span><br><span class="line"></span><br><span class="line">    if (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        &#x2F;&#x2F;接收数据缓冲区信息的填充。当收到驱动的数据，则写入mIn</span><br><span class="line">        bwr.read_size &#x3D; mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t)mIn.data();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bwr.read_size &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当同时没有输入和输出数据则直接返回</span><br><span class="line">    if ((bwr.write_size &#x3D;&#x3D; 0) &amp;&amp; (bwr.read_size &#x3D;&#x3D; 0)) return NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.read_consumed &#x3D; 0;</span><br><span class="line">    status_t err;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;ioctl执行binder读写操作，经过syscall，进入Binder驱动。调用Binder_ioctl【小节3.1】</span><br><span class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;&#x3D; 0)</span><br><span class="line">            err &#x3D; NO_ERROR;</span><br><span class="line">        else</span><br><span class="line">            err &#x3D; -errno;</span><br><span class="line">        ...</span><br><span class="line">    &#125; while (err &#x3D;&#x3D; -EINTR);</span><br><span class="line"></span><br><span class="line">    if (err &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (bwr.write_consumed &gt; 0) &#123;</span><br><span class="line">            if (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(0, bwr.write_consumed);</span><br><span class="line">            else</span><br><span class="line">                mOut.setDataSize(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bwr.read_consumed &gt; 0) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://gityuan.com/2015/11/01/binder-driver/#binderwriteread" target="_blank" rel="noopener">binder_write_read结构体</a>用来与Binder设备交换数据的结构, 通过ioctl与mDriverFD通信，是真正与Binder驱动进行数据读写交互的过程。</p>
<h3 id="2-12-IPC-executeCommand"><a href="#2-12-IPC-executeCommand" class="headerlink" title="2.12 IPC.executeCommand"></a>2.12 IPC.executeCommand</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">    case BR_ERROR: ...</span><br><span class="line">    case BR_OK: ...</span><br><span class="line">    case BR_ACQUIRE: ...</span><br><span class="line">    case BR_RELEASE: ...</span><br><span class="line">    case BR_INCREFS: ...</span><br><span class="line">    case BR_TRANSACTION: ... &#x2F;&#x2F;Binder驱动向Server端发送消息</span><br><span class="line">    case BR_DEAD_BINDER: ...</span><br><span class="line">    case BR_CLEAR_DEATH_NOTIFICATION_DONE: ...</span><br><span class="line">    case BR_NOOP: ...</span><br><span class="line">    case BR_SPAWN_LOOPER: ... &#x2F;&#x2F;创建新binder线程</span><br><span class="line">    default: ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到【小节2.11】，可知ioctl()方法经过syscall最终调用到Binder_ioctl()方法.</p>
<h2 id="三、Binder-driver"><a href="#三、Binder-driver" class="headerlink" title="三、Binder driver"></a>三、Binder driver</h2><h4 id="3-1-binder-ioctl"><a href="#3-1-binder-ioctl" class="headerlink" title="3.1 binder_ioctl"></a>3.1 binder_ioctl</h4><p>[-&gt; Binder.c]</p>
<p>由【小节2.11】传递过出来的参数 cmd=<code>BINDER_WRITE_READ</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line">    struct binder_thread *thread;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当binder_stop_on_user_error&gt;&#x3D;2时，则该线程加入等待队列并进入休眠状态. 该值默认为0</span><br><span class="line">    ret &#x3D; wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">    ...</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    &#x2F;&#x2F;查找或创建binder_thread结构体</span><br><span class="line">    thread &#x3D; binder_get_thread(proc);</span><br><span class="line">    ...</span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">        case BINDER_WRITE_READ:</span><br><span class="line">            &#x2F;&#x2F;【见小节3.2】</span><br><span class="line">            ret &#x3D; binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    if (thread)</span><br><span class="line">        thread-&gt;looper &amp;&#x3D; ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先,根据传递过来的文件句柄指针获取相应的binder_proc结构体, 再从中查找binder_thread,如果当前线程已经加入到proc的线程队列则直接返回， 如果不存在则创建binder_thread，并将当前线程添加到当前的proc.</p>
<ul>
<li>当返回值为-ENOMEM，则意味着内存不足，往往会出现创建binder_thread对象失败;</li>
<li>当返回值为-EINVAL，则意味着CMD命令参数无效；</li>
</ul>
<h4 id="3-2-binder-ioctl-write-read"><a href="#3-2-binder-ioctl-write-read" class="headerlink" title="3.2 binder_ioctl_write_read"></a>3.2 binder_ioctl_write_read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static int binder_ioctl_write_read(struct file *filp,</span><br><span class="line">                unsigned int cmd, unsigned long arg,</span><br><span class="line">                struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line">    unsigned int size &#x3D; _IOC_SIZE(cmd);</span><br><span class="line">    void __user *ubuf &#x3D; (void __user *)arg;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    if (size !&#x3D; sizeof(struct binder_write_read)) &#123;</span><br><span class="line">        ret &#x3D; -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将用户空间bwr结构体拷贝到内核空间</span><br><span class="line">    if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123;</span><br><span class="line">        ret &#x3D; -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;将数据放入目标进程【见小节3.3】</span><br><span class="line">        ret &#x3D; binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer,</span><br><span class="line">                      bwr.write_size,</span><br><span class="line">                      &amp;bwr.write_consumed);</span><br><span class="line">        &#x2F;&#x2F;当执行失败，则直接将内核bwr结构体写回用户空间，并跳出该方法</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            bwr.read_consumed &#x3D; 0;</span><br><span class="line">            if (copy_to_user_preempt_disabled(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">                ret &#x3D; -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;读取自己队列的数据 【见小节3.5】</span><br><span class="line">        ret &#x3D; binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">             bwr.read_size,</span><br><span class="line">             &amp;bwr.read_consumed,</span><br><span class="line">             filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        &#x2F;&#x2F;当进程的todo队列有数据,则唤醒在该队列等待的进程</span><br><span class="line">        if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">            wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">        &#x2F;&#x2F;当执行失败，则直接将内核bwr结构体写回用户空间，并跳出该方法</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            if (copy_to_user_preempt_disabled(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">                ret &#x3D; -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">        ret &#x3D; -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时arg是一个<code>binder_write_read</code>结构体，<code>mOut</code>数据保存在write_buffer，所以write_size&gt;0，但此时read_size=0。首先,将用户空间bwr结构体拷贝到内核空间,然后执行binder_thread_write()操作.</p>
<h4 id="3-3-binder-thread-write"><a href="#3-3-binder-thread-write" class="headerlink" title="3.3 binder_thread_write"></a>3.3 binder_thread_write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">            struct binder_thread *thread,</span><br><span class="line">            binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">            binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    void __user *buffer &#x3D; (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">    void __user *ptr &#x3D; buffer + *consumed;</span><br><span class="line">    void __user *end &#x3D; buffer + size;</span><br><span class="line">    while (ptr &lt; end &amp;&amp; thread-&gt;return_error &#x3D;&#x3D; BR_OK) &#123;</span><br><span class="line">        &#x2F;&#x2F;拷贝用户空间的cmd命令，此时为BC_TRANSACTION</span><br><span class="line">        if (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BC_TRANSACTION:</span><br><span class="line">        case BC_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data tr;</span><br><span class="line">            &#x2F;&#x2F;拷贝用户空间的binder_transaction_data</span><br><span class="line">            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))   return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(tr);</span><br><span class="line">            &#x2F;&#x2F; 见小节3.4】</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd &#x3D;&#x3D; BC_REPLY);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    *consumed &#x3D; ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断从binder_buffer所指向的地址获取cmd, 当只有<code>BC_TRANSACTION</code>或者<code>BC_REPLY</code>时, 则调用binder_transaction()来处理事务.</p>
<h4 id="3-4-binder-transaction"><a href="#3-4-binder-transaction" class="headerlink" title="3.4 binder_transaction"></a>3.4 binder_transaction</h4><p>发送的是BC_TRANSACTION时，此时reply=0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">               struct binder_thread *thread,</span><br><span class="line">               struct binder_transaction_data *tr, int reply)&#123;</span><br><span class="line">     struct binder_transaction *t;</span><br><span class="line">     struct binder_work *tcomplete;</span><br><span class="line">     binder_size_t *offp, *off_end;</span><br><span class="line">     binder_size_t off_min;</span><br><span class="line">     struct binder_proc *target_proc;</span><br><span class="line">     struct binder_thread *target_thread &#x3D; NULL;</span><br><span class="line">     struct binder_node *target_node &#x3D; NULL;</span><br><span class="line">     struct list_head *target_list;</span><br><span class="line">     wait_queue_head_t *target_wait;</span><br><span class="line">     struct binder_transaction *in_reply_to &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            &#x2F;&#x2F; 由handle 找到相应 binder_ref, 由binder_ref 找到相应 binder_node</span><br><span class="line">            ref &#x3D; binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            target_node &#x3D; ref-&gt;node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target_node &#x3D; binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 由binder_node 找到相应 binder_proc</span><br><span class="line">        target_proc &#x3D; target_node-&gt;proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread &#x3D; target_thread-&gt;pid;</span><br><span class="line">        target_list &#x3D; &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait &#x3D; &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;首次执行target_thread为空</span><br><span class="line">        target_list &#x3D; &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait &#x3D; &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t &#x3D; kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">    tcomplete &#x3D; kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;非oneway的通信方式，把当前thread保存到transaction的from字段</span><br><span class="line">    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from &#x3D; thread;</span><br><span class="line">    else</span><br><span class="line">        t-&gt;from &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    t-&gt;sender_euid &#x3D; task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc &#x3D; target_proc; &#x2F;&#x2F;此次通信目标进程为system_server</span><br><span class="line">    t-&gt;to_thread &#x3D; target_thread;</span><br><span class="line">    t-&gt;code &#x3D; tr-&gt;code;  &#x2F;&#x2F;此次通信code &#x3D; START_SERVICE_TRANSACTION</span><br><span class="line">    t-&gt;flags &#x3D; tr-&gt;flags;  &#x2F;&#x2F; 此次通信flags &#x3D; 0</span><br><span class="line">    t-&gt;priority &#x3D; task_nice(current);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从目标进程target_proc中分配内存空间【3.4.1】</span><br><span class="line">    t-&gt;buffer &#x3D; binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line"></span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free &#x3D; 0;</span><br><span class="line">    t-&gt;buffer-&gt;transaction &#x3D; t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node &#x3D; target_node;</span><br><span class="line"></span><br><span class="line">    if (target_node)</span><br><span class="line">        binder_inc_node(target_node, 1, 0, NULL); &#x2F;&#x2F;引用计数加1</span><br><span class="line">    &#x2F;&#x2F;binder对象的偏移量</span><br><span class="line">    offp &#x3D; (binder_size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到目标进程的binder_buffer</span><br><span class="line">    copy_from_user(t-&gt;buffer-&gt;data,</span><br><span class="line">        (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp,</span><br><span class="line">        (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    off_end &#x3D; (void *)offp + tr-&gt;offsets_size;</span><br><span class="line"></span><br><span class="line">    for (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        struct flat_binder_object *fp;</span><br><span class="line">        fp &#x3D; (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        off_min &#x3D; *offp + sizeof(struct flat_binder_object);</span><br><span class="line">        switch (fp-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case BINDER_TYPE_HANDLE:</span><br><span class="line">        case BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            &#x2F;&#x2F;处理引用计数情况</span><br><span class="line">            struct binder_ref *ref &#x3D; binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">            if (ref-&gt;node-&gt;proc &#x3D;&#x3D; target_proc) &#123;</span><br><span class="line">                if (fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type &#x3D; BINDER_TYPE_BINDER;</span><br><span class="line">                else</span><br><span class="line">                    fp-&gt;type &#x3D; BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder &#x3D; ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie &#x3D; ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_BINDER, 0, NULL);</span><br><span class="line">            &#125; else &#123;    </span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                new_ref &#x3D; binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                fp-&gt;handle &#x3D; new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            goto err_bad_object_type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        &#x2F;&#x2F;BC_REPLY的过程</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        &#x2F;&#x2F;BC_TRANSACTION 且 非oneway,则设置事务栈信息</span><br><span class="line">        t-&gt;need_reply &#x3D; 1;</span><br><span class="line">        t-&gt;from_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;BC_TRANSACTION 且 oneway,则加入异步todo队列</span><br><span class="line">        if (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">            target_list &#x3D; &amp;target_node-&gt;async_todo;</span><br><span class="line">            target_wait &#x3D; NULL;</span><br><span class="line">        &#125; else</span><br><span class="line">            target_node-&gt;has_async_transaction &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION添加到目标队列,即target_proc-&gt;todo</span><br><span class="line">    t-&gt;work.type &#x3D; BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程队列，即thread-&gt;todo</span><br><span class="line">    tcomplete-&gt;type &#x3D; BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;唤醒等待队列，本次通信的目标队列为target_proc-&gt;wait</span><br><span class="line">    if (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能:</p>
<ol>
<li><p>查询目标进程的过程： handle -&gt; binder_ref -&gt; binder_node -&gt; binder_proc</p>
</li>
<li><p>将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BINDER_WORK_TRANSACTION</span><br></pre></td></tr></table></figure>

<p>添加到目标队列target_list:</p>
<ul>
<li>call事务， 则目标队列target_list=<code>target_proc-&gt;todo</code>;</li>
<li>reply事务，则目标队列target_list=<code>target_thread-&gt;todo</code>;</li>
<li>async事务，则目标队列target_list=<code>target_node-&gt;async_todo</code>.</li>
</ul>
</li>
<li><p>数据拷贝</p>
<ul>
<li>将用户空间binder_transaction_data中ptr.buffer和ptr.offsets拷贝到目标进程的binder_buffer-&gt;data；</li>
<li>这就是只拷贝一次的真理所在；</li>
</ul>
</li>
<li><p>设置事务栈信息</p>
<ul>
<li>BC_TRANSACTION且非oneway, 则将当前事务添加到thread-&gt;transaction_stack；</li>
</ul>
</li>
<li><p>事务分发过程：</p>
<ul>
<li>将<code>BINDER_WORK_TRANSACTION</code>添加到目标队列(此时为target_proc-&gt;todo队列);</li>
<li>将<code>BINDER_WORK_TRANSACTION_COMPLETE</code>添加到当前线程thread-&gt;todo队列;</li>
</ul>
</li>
<li><p>唤醒目标进程target_proc开始执行事务。</p>
</li>
</ol>
<p>该方法中proc/thread是指当前发起方的进程信息，而binder_proc是指目标接收端进程。 此时当前线程thread的todo队列已经有事务, 接下来便会进入binder_thread_read来处理相关的事务.</p>
<h4 id="3-4-1-binder-alloc-buf"><a href="#3-4-1-binder-alloc-buf" class="headerlink" title="3.4.1 binder_alloc_buf"></a>3.4.1 binder_alloc_buf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,</span><br><span class="line">                          size_t data_size, size_t offsets_size, int is_async)</span><br><span class="line">&#123;</span><br><span class="line">    struct rb_node *n &#x3D; proc-&gt;free_buffers.rb_node;</span><br><span class="line">    struct binder_buffer *buffer;</span><br><span class="line">    size_t buffer_size;</span><br><span class="line">    struct rb_node *best_fit &#x3D; NULL;</span><br><span class="line">    void *has_page_addr;</span><br><span class="line">    void *end_page_addr;</span><br><span class="line">    size_t size;</span><br><span class="line">    ..</span><br><span class="line">    size &#x3D; ALIGN(data_size, sizeof(void *)) + ALIGN(offsets_size, sizeof(void *));</span><br><span class="line">    if (is_async &amp;&amp; proc-&gt;free_async_space &lt; size + sizeof(struct binder_buffer)) &#123;</span><br><span class="line">        return NULL; &#x2F;&#x2F; 剩余可用的异步空间，小于所需的大小</span><br><span class="line">    &#125;</span><br><span class="line">    while (n) &#123;  &#x2F;&#x2F;从binder_buffer的红黑树中查找大小相等的buffer块</span><br><span class="line">        buffer &#x3D; rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size &#x3D; binder_buffer_size(proc, buffer);</span><br><span class="line">        if (size &lt; buffer_size) &#123;</span><br><span class="line">            best_fit &#x3D; n;</span><br><span class="line">            n &#x3D; n-&gt;rb_left;</span><br><span class="line">        &#125; else if (size &gt; buffer_size)</span><br><span class="line">            n &#x3D; n-&gt;rb_right;</span><br><span class="line">        else &#123;</span><br><span class="line">            best_fit &#x3D; n;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    if (n &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        buffer &#x3D; rb_entry(best_fit, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size &#x3D; binder_buffer_size(proc, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has_page_addr &#x3D;(void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">    if (n &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        if (size + sizeof(struct binder_buffer) + 4 &gt;&#x3D; buffer_size)</span><br><span class="line">            buffer_size &#x3D; size;</span><br><span class="line">        else</span><br><span class="line">            buffer_size &#x3D; size + sizeof(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;末端地址</span><br><span class="line">    end_page_addr &#x3D;     (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + buffer_size);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;分配物理页</span><br><span class="line">    if (binder_update_page_range(proc, 1,</span><br><span class="line">        (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr, NULL))</span><br><span class="line">        return NULL;</span><br><span class="line">    rb_erase(best_fit, &amp;proc-&gt;free_buffers);</span><br><span class="line">    buffer-&gt;free &#x3D; 0;</span><br><span class="line">    binder_insert_allocated_buffer(proc, buffer);</span><br><span class="line">    if (buffer_size !&#x3D; size) &#123;</span><br><span class="line">        struct binder_buffer *new_buffer &#x3D; (void *)buffer-&gt;data + size;</span><br><span class="line">        list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">        new_buffer-&gt;free &#x3D; 1;</span><br><span class="line">        binder_insert_free_buffer(proc, new_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;data_size &#x3D; data_size;</span><br><span class="line">    buffer-&gt;offsets_size &#x3D; offsets_size;</span><br><span class="line">    buffer-&gt;async_transaction &#x3D; is_async;</span><br><span class="line">    if (is_async) &#123; &#x2F;&#x2F;调整异步可用内存空间大小</span><br><span class="line">        proc-&gt;free_async_space -&#x3D; size + sizeof(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-binder-thread-read"><a href="#3-5-binder-thread-read" class="headerlink" title="3.5 binder_thread_read"></a>3.5 binder_thread_read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">    &#x2F;&#x2F;当已使用字节数为0时，将BR_NOOP响应码放入指针ptr</span><br><span class="line">    if (*consumed &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            if (put_user(BR_NOOP, (uint32_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    &#x2F;&#x2F;binder_transaction()已设置transaction_stack不为空，则wait_for_proc_work为false.</span><br><span class="line">    wait_for_proc_work &#x3D; thread-&gt;transaction_stack &#x3D;&#x3D; NULL &amp;&amp;</span><br><span class="line">            list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    if (wait_for_proc_work)</span><br><span class="line">      proc-&gt;ready_threads++; &#x2F;&#x2F;进程中空闲binder线程加1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;只有当前线程todo队列为空，并且transaction_stack也为空，才会开始处于当前进程的事务</span><br><span class="line">    if (wait_for_proc_work) &#123;</span><br><span class="line">        if (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else</span><br><span class="line">            &#x2F;&#x2F;当进程todo队列没有数据,则进入休眠等待状态</span><br><span class="line">            ret &#x3D; wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else</span><br><span class="line">            &#x2F;&#x2F;当线程todo队列有数据则执行往下执行；当线程todo队列没有数据，则进入休眠等待状态</span><br><span class="line">            ret &#x3D; wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (wait_for_proc_work)</span><br><span class="line">      proc-&gt;ready_threads--; &#x2F;&#x2F;退出等待状态, 则进程中空闲binder线程减1</span><br><span class="line">    thread-&gt;looper &amp;&#x3D; ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        uint32_t cmd;</span><br><span class="line">        struct binder_transaction_data tr;</span><br><span class="line">        struct binder_work *w;</span><br><span class="line">        struct binder_transaction *t &#x3D; NULL;</span><br><span class="line">        &#x2F;&#x2F;先从线程todo队列获取事务数据</span><br><span class="line">        if (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">            w &#x3D; list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#x2F;&#x2F; 线程todo队列没有数据, 则从进程todo对获取事务数据</span><br><span class="line">        &#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">            w &#x3D; list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;没有数据,则返回retry</span><br><span class="line">            if (ptr - buffer &#x3D;&#x3D; 4 &amp;&amp;</span><br><span class="line">                !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))</span><br><span class="line">                goto retry;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (w-&gt;type) &#123;</span><br><span class="line">            case BINDER_WORK_TRANSACTION:</span><br><span class="line">                &#x2F;&#x2F;获取transaction数据</span><br><span class="line">                t &#x3D; container_of(w, struct binder_transaction, work);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case BINDER_WORK_TRANSACTION_COMPLETE:</span><br><span class="line">                cmd &#x3D; BR_TRANSACTION_COMPLETE;</span><br><span class="line">                &#x2F;&#x2F;将BR_TRANSACTION_COMPLETE写入*ptr，并跳出循环。</span><br><span class="line">                put_user(cmd, (uint32_t __user *)ptr)；</span><br><span class="line">                list_del(&amp;w-&gt;entry);</span><br><span class="line">                kfree(w);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case BINDER_WORK_NODE: ...    break;</span><br><span class="line">            case BINDER_WORK_DEAD_BINDER:</span><br><span class="line">            case BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">            case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: ...   break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;只有BINDER_WORK_TRANSACTION命令才能继续往下执行</span><br><span class="line">        if (!t)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        if (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取目标node</span><br><span class="line">            struct binder_node *target_node &#x3D; t-&gt;buffer-&gt;target_node;</span><br><span class="line">            tr.target.ptr &#x3D; target_node-&gt;ptr;</span><br><span class="line">            tr.cookie &#x3D;  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority &#x3D; task_nice(current);</span><br><span class="line">            ...</span><br><span class="line">            cmd &#x3D; BR_TRANSACTION;  &#x2F;&#x2F;设置命令为BR_TRANSACTION</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tr.target.ptr &#x3D; NULL;</span><br><span class="line">            tr.cookie &#x3D; NULL;</span><br><span class="line">            cmd &#x3D; BR_REPLY; &#x2F;&#x2F;设置命令为BR_REPLY</span><br><span class="line">        &#125;</span><br><span class="line">        tr.code &#x3D; t-&gt;code;</span><br><span class="line">        tr.flags &#x3D; t-&gt;flags;</span><br><span class="line">        tr.sender_euid &#x3D; t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        if (t-&gt;from) &#123;</span><br><span class="line">            struct task_struct *sender &#x3D; t-&gt;from-&gt;proc-&gt;tsk;</span><br><span class="line">            &#x2F;&#x2F;当非oneway的情况下,将调用者进程的pid保存到sender_pid</span><br><span class="line">            tr.sender_pid &#x3D; task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;当oneway的的情况下,则该值为0</span><br><span class="line">            tr.sender_pid &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr.data_size &#x3D; t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size &#x3D; t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        tr.data.ptr.buffer &#x3D; (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets &#x3D; tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将cmd和数据写回用户空间</span><br><span class="line">        if (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(tr);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free &#x3D; 1;</span><br><span class="line">        if (cmd &#x3D;&#x3D; BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread &#x3D; thread;</span><br><span class="line">            thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            kfree(t); &#x2F;&#x2F;通信完成,则运行释放</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    *consumed &#x3D; ptr - buffer;</span><br><span class="line">    &#x2F;&#x2F;当满足请求线程加已准备线程数等于0，已启动线程数小于最大线程数(15)，</span><br><span class="line">    &#x2F;&#x2F;且looper状态为已注册或已进入时创建新的线程。</span><br><span class="line">    if (proc-&gt;requested_threads + proc-&gt;ready_threads &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        &#x2F;&#x2F; 生成BR_SPAWN_LOOPER命令，用于创建新的线程</span><br><span class="line">        put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法功能说明:</p>
<p>此处wait_for_proc_work是指当前线程todo队列为空，并且transaction_stack也为空,该值为true.</p>
<ol>
<li>当wait_for_proc_work = false, 则进入线程的等待队列thread-&gt;wait, 直到thread-&gt;todo队列有事务才往下执行;<ul>
<li>获取并处理thread-&gt;todo队列中的事务;将相应的cmd和数据写回用户空间.</li>
</ul>
</li>
<li>当wait_for_proc_work = true, 则进入线程的等待队列proc-&gt;wait, 直到proc-&gt;todo队列有事务才往下执行;<ul>
<li>获取并处理proc-&gt;todo队列中的事务;将相应的cmd和数据写回用户空间.</li>
</ul>
</li>
</ol>
<p>到这里,可能有人好奇,对于[小节3.4]介绍了target_list有3种, 这里只会处理前2种:thread-&gt;todo, proc-&gt;todo.那么对于 target_node-&gt;async_todo的处理过程时间呢? [见小节5.4]</p>
<h4 id="3-6-下一步何去何从"><a href="#3-6-下一步何去何从" class="headerlink" title="3.6 下一步何去何从"></a>3.6 下一步何去何从</h4><ol>
<li>执行完binder_thread_write方法后, 通过binder_transaction()首先写入<code>BINDER_WORK_TRANSACTION_COMPLETE</code>写入当前线程.</li>
<li>这时bwr.read_size &gt; 0, 回到binder_ioctl_write_read方法, 便开始执行binder_thread_read();</li>
<li>在binder_thread_read()方法, 将获取cmd=BR_TRANSACTION_COMPLETE, 再将cmd和数据写回用户空间;</li>
<li>一次Binder_ioctl完成,接着回调用户空间方法talkWithDriver(),刚才的数据以写入mIn.</li>
<li>这时mIn有可读数据, 回到【小节2.10】IPC.waitForResponse()方法,完成BR_TRANSACTION_COMPLETE过程. 如果本次transaction采用非oneway方式, 这次Binder通信便完成, 否则还是要等待Binder服务端的返回。</li>
</ol>
<p>对于startService过程, 采用的便是非oneway方式,那么发起者进程还会继续停留在waitForResponse()方法,继续talkWithDriver()，然后休眠在binder_thread_read()的wait_event_freezable()过程，等待当前线程的todo队列有数据的到来，即等待收到BR_REPLY消息.</p>
<p>由于在前面binder_transaction()除了向自己所在线程写入了<code>BINDER_WORK_TRANSACTION_COMPLETE</code>, 还向目标进程(此处为system_server)写入了<code>BINDER_WORK_TRANSACTION</code>命令，那么接下里介绍system_server进程的工作。</p>
<h2 id="四-回到用户空间"><a href="#四-回到用户空间" class="headerlink" title="四. 回到用户空间"></a>四. 回到用户空间</h2><p><code>system_server</code>的binder线程是如何运转的，那么就需要从Binder线程的创建开始说起， Binder线程的创建有两种方式：</p>
<ul>
<li>ProcessState::self()-&gt;startThreadPool();</li>
<li>IPCThreadState::self()-&gt;joinThreadPool();</li>
</ul>
<p>从文章<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">addService 小节4.1</a>，可知，调用链如下： startThreadPool()过程会创建新Binder线程，再经过层层调用也会进入joinThreadPool()方法。 <code>system_server</code>的binder线程从IPC.joinThreadPool –&gt; IPC.getAndExecuteCommand() -&gt; IPC.talkWithDriver() ,但talkWithDriver收到事务之后, 便进入IPC.executeCommand()方法。</p>
<p>接下来从joinThreadPool说起：</p>
<h3 id="4-1-IPC-joinThreadPool"><a href="#4-1-IPC-joinThreadPool" class="headerlink" title="4.1 IPC.joinThreadPool"></a>4.1 IPC.joinThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        processPendingDerefs(); &#x2F;&#x2F;处理对象引用</span><br><span class="line">        result &#x3D; getAndExecuteCommand();&#x2F;&#x2F;获取并执行命令【见小节4.2】</span><br><span class="line"></span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result !&#x3D; TIMED_OUT &amp;&amp; result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF) &#123;</span><br><span class="line">            ALOGE(&quot;getAndExecuteCommand(fd&#x3D;%d) returned unexpected error %d, aborting&quot;,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;对于binder非主线程不再使用，则退出</span><br><span class="line">        if(result &#x3D;&#x3D; TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-IPC-getAndExecuteCommand"><a href="#4-2-IPC-getAndExecuteCommand" class="headerlink" title="4.2 IPC.getAndExecuteCommand"></a>4.2 IPC.getAndExecuteCommand</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line"></span><br><span class="line">    result &#x3D; talkWithDriver(); &#x2F;&#x2F;该Binder Driver进行交互</span><br><span class="line">    if (result &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        size_t IN &#x3D; mIn.dataAvail();</span><br><span class="line">        if (IN &lt; sizeof(int32_t)) return result;</span><br><span class="line">        cmd &#x3D; mIn.readInt32(); &#x2F;&#x2F;读取命令</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        result &#x3D; executeCommand(cmd); &#x2F;&#x2F;【见小节4.3】</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        set_sched_policy(mMyThreadId, SP_FOREGROUND);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时system_server的binder线程空闲便是停留在binder_thread_read()方法来处理进程/线程新的事务。 由【小节3.4】可知收到的是<code>BINDER_WORK_TRANSACTION</code>命令, 再经过inder_thread_read()后生成命令cmd=<code>BR_TRANSACTION</code>.再将cmd和数据写回用户空间。</p>
<h3 id="4-3-IPC-executeCommand"><a href="#4-3-IPC-executeCommand" class="headerlink" title="4.3 IPC.executeCommand"></a>4.3 IPC.executeCommand</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result &#x3D; mIn.read(&amp;tr, sizeof(tr)); &#x2F;&#x2F;读取mIn数据</span><br><span class="line">            if (result !&#x3D; NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            &#x2F;&#x2F;当buffer对象回收时，则会调用freeBuffer来回收内存【见小节4.3.1】</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size&#x2F;sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid &#x3D; mCallingPid;</span><br><span class="line">            const uid_t origUid &#x3D; mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy &#x3D; mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags &#x3D; mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;设置调用者的pid和uid</span><br><span class="line">            mCallingPid &#x3D; tr.sender_pid;</span><br><span class="line">            mCallingUid &#x3D; tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; tr.flags;</span><br><span class="line"></span><br><span class="line">            int curPrio &#x3D; getpriority(PRIO_PROCESS, mMyThreadId);</span><br><span class="line">            if (gDisableBackgroundScheduling) &#123;</span><br><span class="line">                ... &#x2F;&#x2F;不进入此分支</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (curPrio &gt;&#x3D; ANDROID_PRIORITY_BACKGROUND) &#123;</span><br><span class="line">                    set_sched_policy(mMyThreadId, SP_BACKGROUND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                &#x2F;&#x2F;尝试通过弱引用获取强引用</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; tr.cookie里存放的是BBinder子类JavaBBinder [见流程4.4]</span><br><span class="line">                    error &#x3D; reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error &#x3D; UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error &#x3D; the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                &#x2F;&#x2F;对于非oneway, 需要reply通信过程,则向Binder驱动发送BC_REPLY命令【见小节4.3.1】</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;恢复pid和uid信息</span><br><span class="line">            mCallingPid &#x3D; origPid;</span><br><span class="line">            mCallingUid &#x3D; origUid;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">        case ...</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            result &#x3D; UNKNOWN_ERROR;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mLastError &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于oneway的场景, 执行完本次transact()则全部结束.</li>
<li>对于非oneway, 需要reply的通信过程,则向Binder驱动发送BC_REPLY命令【见小节5.1】</li>
</ul>
<h4 id="4-3-1-ipcSetDataReference"><a href="#4-3-1-ipcSetDataReference" class="headerlink" title="4.3.1 ipcSetDataReference"></a>4.3.1 ipcSetDataReference</h4><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,</span><br><span class="line">    const binder_size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    binder_size_t minOffset &#x3D; 0;</span><br><span class="line">    freeDataNoInit(); &#x2F;&#x2F;【见小节4.3.2】</span><br><span class="line">    mError &#x3D; NO_ERROR;</span><br><span class="line">    mData &#x3D; const_cast&lt;uint8_t*&gt;(data);</span><br><span class="line">    mDataSize &#x3D; mDataCapacity &#x3D; dataSize;</span><br><span class="line">    mDataPos &#x3D; 0;</span><br><span class="line">    mObjects &#x3D; const_cast&lt;binder_size_t*&gt;(objects);</span><br><span class="line">    mObjectsSize &#x3D; mObjectsCapacity &#x3D; objectsCount;</span><br><span class="line">    mNextObjectHint &#x3D; 0;</span><br><span class="line">    mOwner &#x3D; relFunc;</span><br><span class="line">    mOwnerCookie &#x3D; relCookie;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        binder_size_t offset &#x3D; mObjects[i];</span><br><span class="line">        if (offset &lt; minOffset) &#123;</span><br><span class="line">            mObjectsSize &#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset &#x3D; offset + sizeof(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的功能，Parcel成员变量说明：</p>
<ul>
<li>mData：parcel数据起始地址</li>
<li>mDataSize：parcel数据大小</li>
<li>mObjects：flat_binder_object地址偏移量</li>
<li>mObjectsSize：parcel中flat_binder_object个数</li>
<li>mOwner：释放函数freebuffer</li>
<li>mOwnerCookie：释放函数所需信息</li>
</ul>
<h4 id="4-3-2-freeDataNoInit"><a href="#4-3-2-freeDataNoInit" class="headerlink" title="4.3.2 freeDataNoInit"></a>4.3.2 freeDataNoInit</h4><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::freeDataNoInit()</span><br><span class="line">&#123;</span><br><span class="line">    if (mOwner) &#123;</span><br><span class="line">        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F;mOwner为空， 进入该分支</span><br><span class="line">        releaseObjects(); &#x2F;&#x2F;【见小节4.3.3】</span><br><span class="line">        if (mData) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;gParcelGlobalAllocSizeLock);</span><br><span class="line">            if (mDataCapacity &lt;&#x3D; gParcelGlobalAllocSize) &#123;</span><br><span class="line">              gParcelGlobalAllocSize &#x3D; gParcelGlobalAllocSize - mDataCapacity;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              gParcelGlobalAllocSize &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (gParcelGlobalAllocCount &gt; 0) &#123;</span><br><span class="line">              gParcelGlobalAllocCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;gParcelGlobalAllocSizeLock);</span><br><span class="line">            free(mData);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mObjects) free(mObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-releaseObjects"><a href="#4-3-3-releaseObjects" class="headerlink" title="4.3.3 releaseObjects"></a>4.3.3 releaseObjects</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::releaseObjects()</span><br><span class="line">&#123;</span><br><span class="line">    const sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    size_t i &#x3D; mObjectsSize;</span><br><span class="line">    uint8_t* const data &#x3D; mData;</span><br><span class="line">    binder_size_t* const objects &#x3D; mObjects;</span><br><span class="line">    while (i &gt; 0) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        const flat_binder_object* flat</span><br><span class="line">            &#x3D; reinterpret_cast&lt;flat_binder_object*&gt;(data+objects[i]);</span><br><span class="line">        &#x2F;&#x2F;【见小节4.3.4】</span><br><span class="line">        release_object(proc, *flat, this, &amp;mOpenAshmemSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-release-object"><a href="#4-3-4-release-object" class="headerlink" title="4.3.4 release_object"></a>4.3.4 release_object</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void release_object(const sp&lt;ProcessState&gt;&amp; proc, const flat_binder_object&amp; obj, const void* who, size_t* outAshmemSize) &#123;</span><br><span class="line">    switch (obj.type) &#123;</span><br><span class="line">        case BINDER_TYPE_BINDER:</span><br><span class="line">            if (obj.binder) &#123;</span><br><span class="line">                reinterpret_cast&lt;IBinder*&gt;(obj.cookie)-&gt;decStrong(who);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        case BINDER_TYPE_WEAK_BINDER:</span><br><span class="line">            if (obj.binder)</span><br><span class="line">                reinterpret_cast&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;decWeak(who);</span><br><span class="line">            return;</span><br><span class="line">        case BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">            const sp&lt;IBinder&gt; b &#x3D; proc-&gt;getStrongProxyForHandle(obj.handle);</span><br><span class="line">            if (b !&#x3D; NULL) &#123;</span><br><span class="line">                b-&gt;decStrong(who);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            const wp&lt;IBinder&gt; b &#x3D; proc-&gt;getWeakProxyForHandle(obj.handle);</span><br><span class="line">            if (b !&#x3D; NULL) b.get_refs()-&gt;decWeak(who);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case BINDER_TYPE_FD: &#123;</span><br><span class="line">            ...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据flat_binder_object的类型，来决定减少相应的强弱引用。</p>
<h4 id="4-3-5-Parcel"><a href="#4-3-5-Parcel" class="headerlink" title="4.3.5 ~Parcel"></a>4.3.5 ~Parcel</h4><p>[-&gt; Parcel.cpp]</p>
<p>当[小节4.3]executeCommand执行完成后， 便会释放局部变量Parcel buffer，则会析构Parcel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parcel::~Parcel()</span><br><span class="line">&#123;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Parcel::freeDataNoInit()</span><br><span class="line">&#123;</span><br><span class="line">    if (mOwner) &#123; &#x2F;&#x2F;此处mOwner等于freeBuffer 【见小节4.3.6】</span><br><span class="line">        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，进入IPC的freeBuffer过程。</p>
<h4 id="4-3-6-freeBuffer"><a href="#4-3-6-freeBuffer" class="headerlink" title="4.3.6 freeBuffer"></a>4.3.6 freeBuffer</h4><p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data,</span><br><span class="line">                                size_t &#x2F;*dataSize*&#x2F;,</span><br><span class="line">                                const binder_size_t* &#x2F;*objects*&#x2F;,</span><br><span class="line">                                size_t &#x2F;*objectsSize*&#x2F;, void* &#x2F;*cookie*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    if (parcel !&#x3D; NULL) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state &#x3D; self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((uintptr_t)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向Binder驱动写入BC_FREE_BUFFER命令。</p>
<h3 id="4-4-BBinder-transact"><a href="#4-4-BBinder-transact" class="headerlink" title="4.4 BBinder.transact"></a>4.4 BBinder.transact</h3><p>[-&gt; Binder.cpp ::BBinder ]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">status_t BBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">    status_t err &#x3D; NO_ERROR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; onTransact(code, data, reply, flags); &#x2F;&#x2F;【见流程4.5】</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reply !&#x3D; NULL) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-JavaBBinder-onTransact"><a href="#4-5-JavaBBinder-onTransact" class="headerlink" title="4.5 JavaBBinder.onTransact"></a>4.5 JavaBBinder.onTransact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">virtual status_t onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags &#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv* env &#x3D; javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">    IPCThreadState* thread_state &#x3D; IPCThreadState::self();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用Binder.execTransact [见流程4.6]</span><br><span class="line">    jboolean res &#x3D; env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">        code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags);</span><br><span class="line"></span><br><span class="line">    jthrowable excep &#x3D; env-&gt;ExceptionOccurred();</span><br><span class="line">    if (excep) &#123;</span><br><span class="line">        res &#x3D; JNI_FALSE;</span><br><span class="line">        &#x2F;&#x2F;发生异常, 则清理JNI本地引用</span><br><span class="line">        env-&gt;DeleteLocalRef(excep);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return res !&#x3D; JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得AndroidRuntime::startReg过程吗, 其中有一个过程便是register_android_os_Binder(),该过程会把gBinderOffsets.mExecTransact便是Binder.java中的execTransact()方法.详见见<a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Binder系列7—framework层分析</a>文章中的第二节初始化的过程.</p>
<p>另外,此处mObject是在服务注册addService过程,会调用writeStrongBinder方法, 将Binder对象传入了JavaBBinder构造函数的参数, 最终赋值给mObject. 在本次通信过程中Object为ActivityManagerNative对象.</p>
<p>此处斗转星移, 从C++代码回到了Java代码. 进入AMN.execTransact, 由于AMN继续于Binder对象, 接下来进入Binder.execTransact</p>
<h3 id="4-6-Binder-execTransact"><a href="#4-6-Binder-execTransact" class="headerlink" title="4.6 Binder.execTransact"></a>4.6 Binder.execTransact</h3><p>[Binder.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain(dataObj);</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain(replyObj);</span><br><span class="line"></span><br><span class="line">    boolean res;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用子类AMN.onTransact方法 [见流程4.7]</span><br><span class="line">        res &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;非oneway的方式,则会将异常写回reply</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; true;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; true;</span><br><span class="line">    &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">        RuntimeException re &#x3D; new RuntimeException(&quot;Out of memory&quot;, e);</span><br><span class="line">        reply.setDataPosition(0);</span><br><span class="line">        reply.writeException(re);</span><br><span class="line">        res &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生RemoteException, RuntimeException, OutOfMemoryError, 对于非oneway的情况下都会把异常传递给调用者.</p>
<h3 id="4-7-AMN-onTransact"><a href="#4-7-AMN-onTransact" class="headerlink" title="4.7 AMN.onTransact"></a>4.7 AMN.onTransact</h3><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    ...</span><br><span class="line">     case START_SERVICE_TRANSACTION: &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b &#x3D; data.readStrongBinder();</span><br><span class="line">        &#x2F;&#x2F;生成ApplicationThreadNative的代理对象，即ApplicationThreadProxy对象</span><br><span class="line">        IApplicationThread app &#x3D; ApplicationThreadNative.asInterface(b);</span><br><span class="line">        Intent service &#x3D; Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType &#x3D; data.readString();</span><br><span class="line">        String callingPackage &#x3D; data.readString();</span><br><span class="line">        int userId &#x3D; data.readInt();</span><br><span class="line">        &#x2F;&#x2F;调用ActivityManagerService的startService()方法【见流程4.8】</span><br><span class="line">        ComponentName cn &#x3D; startService(app, service, resolvedType, callingPackage, userId);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        ComponentName.writeToParcel(cn, reply);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-AMS-startService"><a href="#4-8-AMS-startService" class="headerlink" title="4.8 AMS.startService"></a>4.8 AMS.startService</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ComponentName res &#x3D; mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>历经千山万水, 总算是进入了AMS.startService. 当system_server收到BR_TRANSACTION的过程后，通信并没有完全结束，还需将服务启动完成的回应消息 告诉给发起端进程。</p>
<h2 id="五-Reply流程"><a href="#五-Reply流程" class="headerlink" title="五. Reply流程"></a>五. Reply流程</h2><p>还记得前面【小节2.10】IPC.waitForResponse()过程，对于非oneway的方式，还仍在一直等待system_server这边的响应呢，只有收到BR_REPLY，或者BR_DEAD_REPLY，或者BR_FAILED_REPLY，再或许其他BR_命令执行出错的情况下，该waitForResponse()才会退出。</p>
<p>BR_REPLY命令是如何来的呢？【小节4.3】IPC.executeCommand()过程处理完BR_TRANSACTION命令的同时，还会通过sendReply()向Binder Driver发送BC_REPLY消息，接下来从该方法说起。</p>
<h4 id="5-1-IPC-sendReply"><a href="#5-1-IPC-sendReply" class="headerlink" title="5.1 IPC.sendReply"></a>5.1 IPC.sendReply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::sendReply(const Parcel&amp; reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line">    status_t statusBuffer;</span><br><span class="line">    &#x2F;&#x2F;[见小节2.10]</span><br><span class="line">    err &#x3D; writeTransactionData(BC_REPLY, flags, -1, 0, reply, &amp;statusBuffer);</span><br><span class="line">    if (err &lt; NO_ERROR) return err;</span><br><span class="line">    &#x2F;&#x2F;[见小节5.3]</span><br><span class="line">    return waitForResponse(NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将数据写入mOut；再进waitForResponse，等待应答，此时同理也是等待BR_TRANSACTION_COMPLETE。 同理经过IPC.talkWithDriver -&gt; binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write， 再就是进入binder_transaction方法。</p>
<h4 id="5-2-BC-REPLY"><a href="#5-2-BC-REPLY" class="headerlink" title="5.2 BC_REPLY"></a>5.2 BC_REPLY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reply &#x3D;true</span><br><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">             struct binder_thread *thread,</span><br><span class="line">             struct binder_transaction_data *tr, int reply)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  if (reply) &#123;</span><br><span class="line">    in_reply_to &#x3D; thread-&gt;transaction_stack; &#x2F;&#x2F;接收端的事务栈</span><br><span class="line">    ...</span><br><span class="line">    thread-&gt;transaction_stack &#x3D; in_reply_to-&gt;to_parent;</span><br><span class="line">    target_thread &#x3D; in_reply_to-&gt;from; &#x2F;&#x2F;发起端的线程</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发起端线程不能为空</span><br><span class="line">    if (target_thread &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">      return_error &#x3D; BR_DEAD_REPLY;</span><br><span class="line">      goto err_dead_binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发起端线程的事务栈 要等于 接收端的事务栈</span><br><span class="line">    if (target_thread-&gt;transaction_stack !&#x3D; in_reply_to) &#123;</span><br><span class="line">      return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">      in_reply_to &#x3D; NULL;</span><br><span class="line">      target_thread &#x3D; NULL;</span><br><span class="line">      goto err_dead_binder;</span><br><span class="line">    &#125;</span><br><span class="line">    target_proc &#x3D; target_thread-&gt;proc; &#x2F;&#x2F;发起端的进程</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (target_thread) &#123;</span><br><span class="line">      &#x2F;&#x2F;发起端的线程</span><br><span class="line">      target_list &#x3D; &amp;target_thread-&gt;todo;</span><br><span class="line">      target_wait &#x3D; &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t &#x3D; kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">    tcomplete &#x3D; kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">      t-&gt;from &#x3D; thread;</span><br><span class="line">    else</span><br><span class="line">      t-&gt;from &#x3D; NULL; &#x2F;&#x2F;进入该分支</span><br><span class="line">    t-&gt;sender_euid &#x3D; task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc &#x3D; target_proc;</span><br><span class="line">    t-&gt;to_thread &#x3D; target_thread;</span><br><span class="line">    t-&gt;code &#x3D; tr-&gt;code;</span><br><span class="line">    t-&gt;flags &#x3D; tr-&gt;flags;</span><br><span class="line">    t-&gt;priority &#x3D; task_nice(current);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发起端进程分配buffer</span><br><span class="line">    t-&gt;buffer &#x3D; binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">      tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free &#x3D; 0;</span><br><span class="line">    t-&gt;buffer-&gt;transaction &#x3D; t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node &#x3D; target_node;</span><br><span class="line">    if (target_node)</span><br><span class="line">      binder_inc_node(target_node, 1, 0, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到内核</span><br><span class="line">    copy_from_user(t-&gt;buffer-&gt;data,</span><br><span class="line">       (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp,</span><br><span class="line">       (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">      binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION添加到目标队列，本次通信的目标队列为target_thread-&gt;todo</span><br><span class="line">    t-&gt;work.type &#x3D; BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程的todo队列</span><br><span class="line">    tcomplete-&gt;type &#x3D; BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;唤醒等待队列，本次通信的目标队列为target_thread-&gt;wait</span><br><span class="line">    if (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>

<p>binder_transaction -&gt; binder_thread_read -&gt; IPC.waitForResponse，收到BR_REPLY来回收buffer.</p>
<h4 id="5-3-BR-REPLY"><a href="#5-3-BR-REPLY" class="headerlink" title="5.3 BR_REPLY"></a>5.3 BR_REPLY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break; &#x2F;&#x2F; 【见小节2.11】</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line">        ...</span><br><span class="line">        cmd &#x3D; mIn.readInt32();</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">          ...</span><br><span class="line">          case BR_REPLY:</span><br><span class="line">           &#123;</span><br><span class="line">               binder_transaction_data tr;</span><br><span class="line">               err &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">               if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line"></span><br><span class="line">               if (reply) &#123;</span><br><span class="line">                   ...</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F; 释放buffer[见小节5.4]</span><br><span class="line">                   freeBuffer(NULL,</span><br><span class="line">                       reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                       tr.data_size,</span><br><span class="line">                       reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                       tr.offsets_size&#x2F;sizeof(binder_size_t), this);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           goto finish;</span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; executeCommand(cmd);</span><br><span class="line">            ...</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-IPC-freeBuffer"><a href="#5-4-IPC-freeBuffer" class="headerlink" title="5.4 IPC.freeBuffer"></a>5.4 IPC.freeBuffer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data,</span><br><span class="line">                                size_t &#x2F;*dataSize*&#x2F;,</span><br><span class="line">                                const binder_size_t* &#x2F;*objects*&#x2F;,</span><br><span class="line">                                size_t &#x2F;*objectsSize*&#x2F;, void* &#x2F;*cookie*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    if (parcel !&#x3D; NULL) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state &#x3D; self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((uintptr_t)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将BC_FREE_BUFFER写入mOut,再talkWithDriver()</p>
<h5 id="5-5-BC-FREE-BUFFER"><a href="#5-5-BC-FREE-BUFFER" class="headerlink" title="5.5 BC_FREE_BUFFER"></a>5.5 BC_FREE_BUFFER</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">            struct binder_thread *thread,</span><br><span class="line">            binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">            binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    void __user *buffer &#x3D; (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">    void __user *ptr &#x3D; buffer + *consumed;</span><br><span class="line">    void __user *end &#x3D; buffer + size;</span><br><span class="line">    while (ptr &lt; end &amp;&amp; thread-&gt;return_error &#x3D;&#x3D; BR_OK) &#123;</span><br><span class="line">        &#x2F;&#x2F;拷贝用户空间的cmd命令，此时为BC_FREE_BUFFER</span><br><span class="line">        if (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BC_TRANSACTION:</span><br><span class="line">        case BC_REPLY: ...</span><br><span class="line">        case BC_FREE_BUFFER: &#123;</span><br><span class="line">            void __user *data_ptr;</span><br><span class="line">            struct binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">            if (get_user(data_ptr, (void * __user *)ptr)) return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(void *);</span><br><span class="line"></span><br><span class="line">            buffer &#x3D; binder_buffer_lookup(proc, data_ptr);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            if (buffer-&gt;transaction) &#123;</span><br><span class="line">                buffer-&gt;transaction-&gt;buffer &#x3D; NULL;</span><br><span class="line">                buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; binder_buffer存在异步事务,且binder_node不为空</span><br><span class="line">            if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123;</span><br><span class="line">                if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))</span><br><span class="line">                    buffer-&gt;target_node-&gt;has_async_transaction &#x3D; 0;</span><br><span class="line">                else</span><br><span class="line">                    &#x2F;&#x2F;当异步队列async_todo也不为空,则事务追加到该线程todo队列.</span><br><span class="line">                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            binder_transaction_buffer_release(proc, buffer, NULL);</span><br><span class="line">            binder_free_buf(proc, buffer);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *consumed &#x3D; ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收端线程处理BC_FREE_BUFFER命令:</p>
<ul>
<li>当binder_buffer存在异步事务,当异步队列async_todo也不为空,则事务追加到该线程todo队列.</li>
<li>释放当前的buffer.</li>
</ul>
<h5 id="5-6-binder-thread-read"><a href="#5-6-binder-thread-read" class="headerlink" title="5.6 binder_thread_read"></a>5.6 binder_thread_read</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">    ...</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        uint32_t cmd;</span><br><span class="line">        struct binder_transaction_data tr;</span><br><span class="line">        struct binder_work *w;</span><br><span class="line">        struct binder_transaction *t &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从线程todo队列获取事务数据</span><br><span class="line">        if (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">            w &#x3D; list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (w-&gt;type) &#123;</span><br><span class="line">            case BINDER_WORK_TRANSACTION:</span><br><span class="line">                &#x2F;&#x2F;获取transaction数据</span><br><span class="line">                t &#x3D; container_of(w, struct binder_transaction, work);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取目标node</span><br><span class="line">            struct binder_node *target_node &#x3D; t-&gt;buffer-&gt;target_node;</span><br><span class="line">            tr.target.ptr &#x3D; target_node-&gt;ptr;</span><br><span class="line">            tr.cookie &#x3D;  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority &#x3D; task_nice(current);</span><br><span class="line">            ...</span><br><span class="line">            cmd &#x3D; BR_TRANSACTION;  &#x2F;&#x2F;设置命令为BR_TRANSACTION</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tr.target.ptr &#x3D; NULL;</span><br><span class="line">            tr.cookie &#x3D; NULL;</span><br><span class="line">            cmd &#x3D; BR_REPLY; &#x2F;&#x2F;设置命令为BR_REPLY</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr.code &#x3D; t-&gt;code;</span><br><span class="line">        tr.flags &#x3D; t-&gt;flags;</span><br><span class="line">        tr.sender_euid &#x3D; t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;将cmd和数据写回用户空间</span><br><span class="line">        if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))  return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(tr);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free &#x3D; 1;</span><br><span class="line">        if (cmd &#x3D;&#x3D; BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread &#x3D; thread;</span><br><span class="line">            thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            kfree(t); &#x2F;&#x2F;通信完成,则运行释放</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>本文详细地介绍如何从AMP.startService是如何通过Binder一步步调用进入到system_server进程的AMS.startService. 整个过程涉及Java framework, native, kernel driver各个层面知识. 仅仅一个Binder IPC调用, 就花费了如此大篇幅来讲解, 可见系统之庞大. 整个过程的调用流程:</p>
<h3 id="6-1-通信流程"><a href="#6-1-通信流程" class="headerlink" title="6.1 通信流程"></a>6.1 通信流程</h3><p>从通信流程角度来看整个过程:<img src="http://gityuan.com/images/binder/binder_start_service/binder_ipc_process.jpg" alt="binder_ipc_process"></p>
<p>图解:</p>
<ol>
<li>发起端线程向Binder Driver发起binder ioctl请求后, 便采用环不断talkWithDriver,此时该线程处于阻塞状态, 直到收到如下BR_XXX命令才会结束该过程.<ul>
<li>BR_TRANSACTION_COMPLETE: oneway模式下,收到该命令则退出</li>
<li>BR_REPLY: 非oneway模式下,收到该命令才退出;</li>
<li>BR_DEAD_REPLY: 目标进程/线程/binder实体为空, 以及释放正在等待reply的binder thread或者binder buffer;</li>
<li>BR_FAILED_REPLY: 情况较多,比如非法handle, 错误事务栈, security, 内存不足, buffer不足, 数据拷贝失败, 节点创建失败, 各种不匹配等问题</li>
<li>BR_ACQUIRE_RESULT: 目前未使用的协议;</li>
</ul>
</li>
<li>左图中waitForResponse收到BR_TRANSACTION_COMPLETE,则直接退出循环, 则没有机会执行executeCommand()方法, 故将其颜色画为灰色. 除以上5种BR_XXX命令, 当收到其他BR命令,则都会执行executeCommand过程.</li>
<li>目标Binder线程创建后, 便进入joinThreadPool()方法, 采用循环不断地循环执行getAndExecuteCommand()方法, 当bwr的读写buffer都没有数据时,则阻塞在binder_thread_read的wait_event过程. 另外,正常情况下binder线程一旦创建则不会退出.</li>
</ol>
<h3 id="6-2-通信协议"><a href="#6-2-通信协议" class="headerlink" title="6.2 通信协议"></a>6.2 通信协议</h3><p>从通信协议的角度来看这个过程:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/binder_transaction.jpg" alt="binder_transaction"></p>
<ul>
<li>Binder客户端或者服务端向Binder Driver发送的命令都是以BC_开头,例如本文的<code>BC_TRANSACTION</code>和<code>BC_REPLY</code>, 所有Binder Driver向Binder客户端或者服务端发送的命令则都是以BR_开头, 例如本文中的<code>BR_TRANSACTION</code>和<code>BR_REPLY</code>.</li>
<li>只有当<code>BC_TRANSACTION</code>或者<code>BC_REPLY</code>时, 才调用binder_transaction()来处理事务. 并且都会回应调用者一个<code>BINDER_WORK_TRANSACTION_COMPLETE</code>事务, 经过binder_thread_read()会转变成<code>BR_TRANSACTION_COMPLETE</code>.</li>
<li>startService过程便是一个非oneway的过程, 那么oneway的通信过程如下所述.</li>
</ul>
<h3 id="6-3-说一说oneway"><a href="#6-3-说一说oneway" class="headerlink" title="6.3 说一说oneway"></a>6.3 说一说oneway</h3><p>上图是非oneway通信过程的协议图, 下图则是对于oneway场景下的通信协议图:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/binder_transaction_oneway.jpg" alt="binder_transaction_oneway"></p>
<p>当收到BR_TRANSACTION_COMPLETE则程序返回,有人可能觉得好奇,为何oneway怎么还要等待回应消息? 我举个例子,你就明白了.</p>
<p>你(app进程)要给远方的家人(system_server进程)邮寄一封信(transaction), 你需要通过邮寄员(Binder Driver)来完成.整个过程如下:</p>
<ol>
<li>你把信交给邮寄员(<code>BC_TRANSACTION</code>);</li>
<li>邮寄员收到信后, 填一张单子给你作为一份回执(<code>BR_TRANSACTION_COMPLETE</code>). 这样你才放心知道邮递员已确定接收信, 否则就这样走了,信到底有没有交到邮递员手里都不知道,这样的通信实在太让人不省心, 长时间收不到远方家人的回信, 无法得知是在路的中途信件丢失呢,还是压根就没有交到邮递员的手里. 所以说oneway也得知道信是投递状态是否成功.</li>
<li>邮递员利用交通工具(Binder Driver),将信交给了你的家人(<code>BR_TRANSACTION</code>);</li>
</ol>
<p>当你收到回执(BR_TRANSACTION_COMPLETE)时心里也不期待家人回信, 那么这便是一次oneway的通信过程.</p>
<p>如果你希望家人回信, 那便是非oneway的过程,在上述步骤2后并不是直接返回,而是继续等待着收到家人的回信, 经历前3个步骤之后继续执行:</p>
<ol>
<li>家人收到信后, 立马写了个回信交给邮递员<code>BC_REPLY</code>;</li>
<li>同样,邮递员要写一个回执(<code>BR_TRANSACTION_COMPLETE</code>)给你家人;</li>
<li>邮递员再次利用交通工具(Binder Driver), 将回信成功交到你的手上(<code>BR_REPLY</code>)</li>
</ol>
<p>这便是一次完成的非oneway通信过程.</p>
<p>oneway与非oneway: 都是需要等待Binder Driver的回应消息BR_TRANSACTION_COMPLETE. 主要区别在于oneway的通信收到BR_TRANSACTION_COMPLETE则返回,而不会再等待BR_REPLY消息的到来. 另外，oneway的binder IPC则接收端无法获取对方的pid.</p>
<h3 id="6-4-小规律"><a href="#6-4-小规律" class="headerlink" title="6.4 小规律"></a>6.4 小规律</h3><ul>
<li>BC_TRANSACTION + BC_REPLY = BR_TRANSACTION_COMPLETE + BR_DEAD_REPLY + BR_FAILED_REPLY</li>
<li>Binder线程只有当本线程的thread-&gt;todo队列为空，并且thread-&gt;transaction_stack也为空，才会去处理当前进程的事务， 否则会继续处理或等待当前线程的todo队列事务。换句话说，就是只有当前线程的事务;</li>
<li>binder_thread_write: 添加成员到todo队列;</li>
<li>binder_thread_read: 消耗todo队列;</li>
<li>对于处于空闲可用的,或者Ready的binder线程是指停在binder_thread_read()的wait_event地方的Binder线程;</li>
<li>每一次BR_TRANSACTION或者BR_REPLY结束之后都会调用freeBuffer().</li>
<li>ProcessState.mHandleToObject记录着handle与对应的BpBinder信息。</li>
</ul>
<p>整个过程copy once便是指binder_transaction()过程把binder_transaction_data-&gt;data拷贝到目标进程的buffer。</p>
<h3 id="6-5-数据流"><a href="#6-5-数据流" class="headerlink" title="6.5 数据流"></a>6.5 数据流</h3><p><img src="http://gityuan.com/images/binder/binder_transaction_data.jpg" alt="binder_transaction_data"></p>
<ul>
<li>[2.1]AMP.startService：组装flat_binder_object对象等组成的Parcel data；</li>
<li>[2.9]IPC.writeTransactionData：组装BC_TRANSACTION和binder_transaction_data结构体，写入mOut;</li>
<li>[2.11]IPC.talkWithDriver: 组装BINDER_WRITE_READ和binder_write_read结构体，通过ioctl传输到驱动层。</li>
</ul>
<p>进入驱动后</p>
<ul>
<li>[3.3]binder_thread_write: 处理binder_write_read.write_buffer数据</li>
<li>[3.4]binder_transaction: 处理write_buffer.binder_transaction_data数据；<ul>
<li>创建binder_transaction结构体，记录事务通信的线程来源以及事务链条等相关信息；</li>
<li>分配binder_buffer结构体，拷贝当前线程binder_transaction_data的data数据到binder_buffer-&gt;data；</li>
</ul>
</li>
<li>[3.5]binder_thread_read: 处理binder_transaction结构体数据<ul>
<li>组装cmd=BR_TRANSACTION和binder_transaction_data结构体，写入binder_write_read.read_buffer数据</li>
</ul>
</li>
</ul>
<p>回到用户空间</p>
<ul>
<li>[4.3]IPC.executeCommand：处理BR_TRANSACTION命令, 将binder_transaction_data数据解析成BBinder.transact()所需的参数</li>
<li>[4.7] AMN.onTransact: 层层回调，进入该方法，反序列化数据后，调用startService()方法。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Binder/" rel="tag"># Binder</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Service/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" rel="next" title="startService启动过程分析">
                <i class="fa fa-chevron-left"></i> startService启动过程分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/04/Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" rel="prev" title="Binder通信架构">
                Binder通信架构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-引言"><span class="nav-number">1.</span> <span class="nav-text">一. 引言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Binder架构的思考"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.1 Binder架构的思考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-分析起点"><span class="nav-number">1.0.2.</span> <span class="nav-text">1.2 分析起点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-Binder-IPC原理"><span class="nav-number">1.0.3.</span> <span class="nav-text">1.3 Binder IPC原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-通信过程"><span class="nav-number">2.</span> <span class="nav-text">二. 通信过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-AMP-startService"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 AMP.startService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Parcel-obtain"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Parcel.obtain</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-new-Parcel"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 new Parcel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-android-os-Parcel-create"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 android_os_Parcel_create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-Parcel-recycle"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 Parcel.recycle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-writeString"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 writeString</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-nativeWriteString"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 nativeWriteString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-writeString16"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 writeString16</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-mRemote究竟为何物"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 mRemote究竟为何物</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-AMN-getDefault"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 AMN.getDefault</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-gDefault-get"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 gDefault.get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-gDefault-create"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3 gDefault.create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-AMN-asInterface"><span class="nav-number">2.4.4.</span> <span class="nav-text">2.4.4 AMN.asInterface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-queryLocalInterface"><span class="nav-number">2.4.5.</span> <span class="nav-text">2.4.5 queryLocalInterface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-6-创建AMP"><span class="nav-number">2.4.6.</span> <span class="nav-text">2.4.6 创建AMP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-mRemote-transact"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 mRemote.transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-android-os-BinderProxy-transact"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 android_os_BinderProxy_transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-BpBinder-transact"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 BpBinder.transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-IPC-transact"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 IPC.transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-IPC-writeTransactionData"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 IPC.writeTransactionData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-IPC-waitForResponse"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 IPC.waitForResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-IPC-talkWithDriver"><span class="nav-number">2.11.</span> <span class="nav-text">2.11 IPC.talkWithDriver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-IPC-executeCommand"><span class="nav-number">2.12.</span> <span class="nav-text">2.12 IPC.executeCommand</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Binder-driver"><span class="nav-number">3.</span> <span class="nav-text">三、Binder driver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-binder-ioctl"><span class="nav-number">3.0.1.</span> <span class="nav-text">3.1 binder_ioctl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-binder-ioctl-write-read"><span class="nav-number">3.0.2.</span> <span class="nav-text">3.2 binder_ioctl_write_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-binder-thread-write"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.3 binder_thread_write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-binder-transaction"><span class="nav-number">3.0.4.</span> <span class="nav-text">3.4 binder_transaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-binder-alloc-buf"><span class="nav-number">3.0.5.</span> <span class="nav-text">3.4.1 binder_alloc_buf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-binder-thread-read"><span class="nav-number">3.0.6.</span> <span class="nav-text">3.5 binder_thread_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-下一步何去何从"><span class="nav-number">3.0.7.</span> <span class="nav-text">3.6 下一步何去何从</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-回到用户空间"><span class="nav-number">4.</span> <span class="nav-text">四. 回到用户空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-IPC-joinThreadPool"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 IPC.joinThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-IPC-getAndExecuteCommand"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 IPC.getAndExecuteCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-IPC-executeCommand"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 IPC.executeCommand</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-ipcSetDataReference"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 ipcSetDataReference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-freeDataNoInit"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 freeDataNoInit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-releaseObjects"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 releaseObjects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-release-object"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4 release_object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-Parcel"><span class="nav-number">4.3.5.</span> <span class="nav-text">4.3.5 ~Parcel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-6-freeBuffer"><span class="nav-number">4.3.6.</span> <span class="nav-text">4.3.6 freeBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BBinder-transact"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 BBinder.transact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-JavaBBinder-onTransact"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 JavaBBinder.onTransact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-Binder-execTransact"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 Binder.execTransact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-AMN-onTransact"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 AMN.onTransact</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-AMS-startService"><span class="nav-number">4.8.</span> <span class="nav-text">4.8 AMS.startService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-Reply流程"><span class="nav-number">5.</span> <span class="nav-text">五. Reply流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-IPC-sendReply"><span class="nav-number">5.0.1.</span> <span class="nav-text">5.1 IPC.sendReply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-BC-REPLY"><span class="nav-number">5.0.2.</span> <span class="nav-text">5.2 BC_REPLY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-BR-REPLY"><span class="nav-number">5.0.3.</span> <span class="nav-text">5.3 BR_REPLY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-IPC-freeBuffer"><span class="nav-number">5.0.4.</span> <span class="nav-text">5.4 IPC.freeBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-BC-FREE-BUFFER"><span class="nav-number">5.0.4.1.</span> <span class="nav-text">5.5 BC_FREE_BUFFER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-binder-thread-read"><span class="nav-number">5.0.4.2.</span> <span class="nav-text">5.6 binder_thread_read</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-总结"><span class="nav-number">6.</span> <span class="nav-text">六. 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-通信流程"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 通信流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-通信协议"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-说一说oneway"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 说一说oneway</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-小规律"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 小规律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-数据流"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 数据流</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
