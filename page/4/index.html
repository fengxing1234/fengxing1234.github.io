<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/flutter/widget%E7%BB%84%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/flutter/widget%E7%BB%84%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/" itemprop="url">文本组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-17T23:34:01+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">文本组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/17/flutter/widget%E7%BB%84%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/17/flutter/widget%E7%BB%84%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text是显示文本的组件，最常用的组件，没有之一。基本用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'老孟'</span>)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-328059fa4e353358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>注意：Text组件一定要包裹在Scaffold组件下，否则效果如下：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-9f7f6b43e05ee1fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>文本的样式在<code>style</code>中设置，类型为<code>TextStyle</code>，<code>TextStyle</code>中包含很多文本样式属性，下面介绍一些常用的。</p>
<p>设置文本大小和颜色：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'老孟'</span>,style: TextStyle(color: Colors.red,fontSize: <span class="number">20</span>),),复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-c73b3977c657af7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上面黑色的字体为没有设置的效果，作为对比。</p>
<p>设置字体粗细：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'老孟'</span>,style: TextStyle(fontWeight: FontWeight.bold))复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-5ecdaa3bd56a7a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>字体粗细共有9个级别，为<code>w100</code>至<code>w900</code>，<strong>FontWeight.bold</strong>是<code>w700</code>。</p>
<p>设置斜体：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'老孟'</span>,style: TextStyle(fontStyle: FontStyle.italic,))复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-ca7dfcdf47fd81d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>设置自定义的字体：</p>
<ol>
<li>首先下载字体库（比如中华字体库）</li>
<li>将字体文件拷贝的项目中，一般目录是：assets/fonts/，assets和fonts都需要手动创建，此目录不是必须的，而是约定俗成，资源一般都放在assets目录下。</li>
<li>配置<code>pubspec.yaml</code>：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fonts:</span><br><span class="line">  - family: maobi </span><br><span class="line">    fonts:</span><br><span class="line">      - asset: assets/fonts/maobi.ttf复制代码</span><br></pre></td></tr></table></figure>

<p>maobi：是自己对当前字体的命名，有意义即可。</p>
<p>asset：字体文件的目录。</p>
<p>使用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'老孟'</span>, style: TextStyle(fontFamily: <span class="string">'maobi'</span>,)),复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-ddda82bcb6c6fa46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>设置对齐方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  color: Colors.blue.withOpacity(<span class="number">.4</span>),</span><br><span class="line">  child: Text(<span class="string">'老孟'</span>, textAlign: TextAlign.center),</span><br><span class="line">),复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-a2b56b1f8e551cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>textAlign</code>只是控制水平方向的对齐方式，值说明如下：</p>
<ul>
<li>left：左对齐</li>
<li>right：右对齐</li>
<li>center：居中</li>
<li>justify：两端对齐，此属性中文存在bug（Flutter版本：1.17.3）也可以在<a href="https://github.com/flutter/flutter/issues/35734" target="_blank" rel="noopener">官方issue中关注此问题</a></li>
<li>start：前端对齐，和<code>TextDirection</code>属性有关，如果设置<code>TextDirection.ltr</code>，则左对齐，设置<code>TextDirection.rtl</code>则右对齐。</li>
<li>end：末端对齐，和<code>TextDirection</code>属性有关，如果设置<code>TextDirection.ltr</code>，则右对齐，设置<code>TextDirection.rtl</code>则左对齐。</li>
</ul>
<p>设置文本自动换行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  color: Colors.blue.withOpacity(<span class="number">.4</span>),</span><br><span class="line">  child: Text(<span class="string">'老孟，专注分享Flutter技术和应用实战'</span>,softWrap: <span class="keyword">true</span>,),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-6832d2dc062a0599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>文本超出范围时的处理：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  color: Colors.blue.withOpacity(<span class="number">.4</span>),</span><br><span class="line">  child: Text(<span class="string">'老孟，专注分享Flutter技术和应用实战'</span>,overflow: TextOverflow.ellipsis,),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-3a92280079c3ec1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>溢出的处理方式：</p>
<ul>
<li>clip：直接裁剪。</li>
<li>fade：越来越透明。</li>
<li>ellipsis：省略号结尾。</li>
<li>visible：依然显示，此时将会溢出父组件。</li>
</ul>
<p>设置全局字体样式：</p>
<p>在<code>MaterialApp</code>的<code>theme</code>中设置如下</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">   ...</span><br><span class="line">    textTheme: TextTheme(</span><br><span class="line">        bodyText2: TextStyle(color: Colors.red,fontSize: <span class="number">24</span>),</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  home: Scaffold(</span><br><span class="line">    body: TextDemo(),</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>Text组件默认为红色，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'老孟'</span>),</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'老孟'</span>,style: TextStyle(color: Colors.blue,fontSize: <span class="number">20</span>),),复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-4cf4abe5c34df25f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h3><p>RichText的属性和Text基本一样，使用如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RichText(</span><br><span class="line">  text: TextSpan(</span><br><span class="line">      style: DefaultTextStyle.of(context).style,</span><br><span class="line">      children: &lt;InlineSpan&gt;[</span><br><span class="line">        TextSpan(text: <span class="string">'老孟'</span>, style: TextStyle(color: Colors.red)),</span><br><span class="line">        TextSpan(text: <span class="string">'，'</span>),</span><br><span class="line">        TextSpan(text: <span class="string">'专注分享Flutter技术和应用实战'</span>),</span><br><span class="line">      ]),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-d2e42861c5427a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><p>TextField是文本输入组件，即输入框，常用组件之一。基本用法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextField()复制代码</span><br></pre></td></tr></table></figure>

<p>不需要任何参数，一个最简单的文本输入组件就出来了，效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-e3e7a2d63fff19aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>decoration</code>是TextField组件的装饰（外观）参数，类型是InputDecoration。</p>
<p><code>icon</code>显示在输入框的前面，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    icon: Icon(Icons.person),</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a1d408eb70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>当输入框是空而且没有焦点时，labelText显示在输入框上边，当获取焦点或者不为空时labelText往上移动一点，<code>labelStyle</code>参数表示文本样式，具体参考<code>TextStyle</code>， 用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    labelText: <span class="string">'姓名：'</span>,</span><br><span class="line">    labelStyle: TextStyle(color:Colors.red)</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a20fd89d2a?imageslim" alt="img"></p>
<p><code>hasFloatingPlaceholder</code>参数控制当输入框获取焦点或者不为空时是否还显示<code>labelText</code>，默认为true，显示。</p>
<p><code>helperText</code>显示在输入框的左下部，用于提示用户，<code>helperStyle</code>参数表示文本样式，具体参考<code>TextStyle</code>用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    helperText: <span class="string">'用户名长度为6-10个字母'</span>,</span><br><span class="line">    helperStyle: TextStyle(color: Colors.blue),</span><br><span class="line">    helperMaxLines: <span class="number">1</span></span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a250c4ddba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>hintText</code>是当输入框为空时的提示，不为空时不在显示，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    hintText: <span class="string">'请输入用户名'</span>,</span><br><span class="line">    hintStyle: TextStyle(color: Colors.grey),</span><br><span class="line">    hintMaxLines: <span class="number">1</span></span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a27d2b9d26?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>errorText</code>显示在输入框的左下部，默认字体为红色，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    errorText: <span class="string">'用户名输入错误'</span>,</span><br><span class="line">    errorStyle: TextStyle(fontSize: <span class="number">12</span>),</span><br><span class="line">    errorMaxLines: <span class="number">1</span>,</span><br><span class="line">    errorBorder: OutlineInputBorder(borderSide: BorderSide(color: Colors.red)),</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a2aabcb155?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>prefix</code>系列的组件是输入框前面的部分，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    prefixIcon: Icon(Icons.person)</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a2da628012?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>注意prefix和icon的区别，icon是在输入框边框的外部，而prefix在里面。</p>
<p>suffix和prefix相反，suffix在输入框的尾部，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">      suffixIcon: Icon(Icons.person)</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a2fec27b09?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>counter</code>组件统计输入框文字的个数，counter仅仅是展示效果，不具备自动统计字数的功能， 自动统计字数代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _textFieldValue = <span class="string">''</span>;</span><br><span class="line">TextField(</span><br><span class="line">  onChanged: (value)&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _textFieldValue = value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    counterText: <span class="string">'<span class="subst">$&#123;_textFieldValue.length&#125;</span>/32'</span></span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a08a349afb673?imageslim" alt="img"></p>
<p><code>filled</code>为true时，输入框将会被<code>fillColor</code>填充，仿QQ登录输入框代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">60</span>,</span><br><span class="line">  width: <span class="number">250</span>,</span><br><span class="line">  child: TextField(</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">      fillColor: Color(<span class="number">0x30cccccc</span>),</span><br><span class="line">      filled: <span class="keyword">true</span>,</span><br><span class="line">      enabledBorder: OutlineInputBorder(</span><br><span class="line">          borderSide: BorderSide(color: Color(<span class="number">0x00FF0000</span>)),</span><br><span class="line">          borderRadius: BorderRadius.all(Radius.circular(<span class="number">100</span>))),</span><br><span class="line">      hintText: <span class="string">'QQ号/手机号/邮箱'</span>,</span><br><span class="line">      focusedBorder: OutlineInputBorder(</span><br><span class="line">          borderSide: BorderSide(color: Color(<span class="number">0x00000000</span>)),</span><br><span class="line">          borderRadius: BorderRadius.all(Radius.circular(<span class="number">100</span>))),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-4edd61c6c2861489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>controller</code>是输入框文本编辑的控制器，可以获取TextField的内容、设置TextField的内容，下面将输入的英文变为大写：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TextEditingController _controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  _controller = TextEditingController()</span><br><span class="line">    ..addListener(() &#123;</span><br><span class="line">      <span class="comment">//获取输入框的内容，变为大写</span></span><br><span class="line">      _controller.text = _controller.text.toUpperCase();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> TextField(</span><br><span class="line">    controller: _controller,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">dispose() &#123;</span><br><span class="line">  <span class="keyword">super</span>.dispose();</span><br><span class="line">  _controller.dispose();</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>有时输入框后面带有“清除”功能，需要controller来实现。如果需要2个TextField的内容进行同步，只需要给2个TextField设置同一个controller即可实现。</p>
<p><code>keyboardType</code>参数控制软键盘的类型，说明如下：</p>
<ul>
<li>text：通用键盘。</li>
<li>multiline：当TextField为多行时（maxLines设置大于1），右下角的为“换行” 按键。</li>
<li>number：数字键盘。</li>
<li>phone：手机键盘，比数字键盘多”*”和 “#”。</li>
<li>datetime：在ios上和text一样，在android上出现数字键盘、”:”和 “-“。</li>
<li>emailAddress：邮箱键盘，有”@” 和 “.”按键。</li>
<li>url：url键盘，有”/“ 和 “.”按键。</li>
<li>visiblePassword：既有字幕又有数字的键盘。</li>
</ul>
<p><code>textInputAction</code>参数控制软键盘右下角的按键，说明如下：</p>
<ul>
<li>none：android上显示返回键，ios不支持。</li>
<li>unspecified：让操作系统自己决定哪个合适，一般情况下，android显示“完成”或者“返回”。 </li>
<li>done：android显示代表“完成”的按钮，ios显示“Done”（中文：完成）。</li>
<li>go：android显示表达用户去向目的地的图标，比如向右的箭头，ios显示“Go”（中文：前往）。</li>
<li>search：android显示表达搜索的按钮，ios显示”Search”（中文：搜索）。</li>
<li>send：android显示表达发送意思的按钮，比如“纸飞机”按钮，ios显示”Send”（中文：发送）。</li>
<li>next：android显示表达“前进”的按钮，比如“向右的箭头”,ios显示”Next”（中文：下一项）。</li>
<li>previous：android显示表达“后退”的按钮，比如“向左的箭头”,ios不支持。</li>
<li>continueAction：android 不支持，ios仅在ios9.0+显示”Continue”（中文：继续）。</li>
<li>join：Android和ios显示”Join”（中文：加入）。</li>
<li>route：android 不支持，ios显示”Route”（中文：路线）。</li>
<li>emergencyCall：android 不支持，ios显示”Emergency Call”（中文：紧急电话）。</li>
<li>newline：android显示表达“换行”的按钮，ios显示”换行“。</li>
</ul>
<p>大家可能发现了，Android上显示的按钮大部分是不确定的，比如<code>next</code>有的显示向右的箭头，有的显示前进，这是因为各大厂商对Android ROM定制引发的。</p>
<p><code>textCapitalization</code>参数是配置键盘是大写还是小写，仅支持键盘模式为<code>text</code>，其他模式下忽略此配置，说明如下：</p>
<ul>
<li>words：每一个单词的首字母大写。</li>
<li>sentences：每一句话的首字母大写。</li>
<li>characters：每个字母都大写</li>
<li>none：都小写</li>
</ul>
<p>这里仅仅是控制软键盘是大写模式还是小写模式，你也可以切换大小写，系统并不会改变输入框内的内容。</p>
<p><code>textAlignVertical</code>表示垂直方向的对齐方式，<code>textDirection</code>表示文本方向，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textAlignVertical: TextAlignVertical.center,</span><br><span class="line">  textDirection: TextDirection.rtl,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><code>toolbarOptions</code>表示长按时弹出的菜单，有<code>copy</code>、<code>cut</code>、<code>paste</code>、<code>selectAll</code>，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  toolbarOptions: ToolbarOptions(</span><br><span class="line">    copy: <span class="keyword">true</span>,</span><br><span class="line">    cut: <span class="keyword">true</span>,</span><br><span class="line">    paste: <span class="keyword">true</span>,</span><br><span class="line">    selectAll: <span class="keyword">true</span></span><br><span class="line">  ),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><code>cursor</code>表示光标，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  showCursor: <span class="keyword">true</span>,</span><br><span class="line">  cursorWidth: <span class="number">3</span>,</span><br><span class="line">  cursorRadius: Radius.circular(<span class="number">10</span>),</span><br><span class="line">  cursorColor: Colors.red,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-be65bac24ebf9421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>将输入框设置为密码框，只需<code>obscureText</code>属性设置true即可，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  obscureText: <span class="keyword">true</span>,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>通过<code>inputFormatters</code>可以限制用户输入的内容，比如只想让用户输入字符，设置如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  inputFormatters: [</span><br><span class="line">    WhitelistingTextInputFormatter(<span class="built_in">RegExp</span>(<span class="string">"[a-zA-Z]"</span>)),</span><br><span class="line">  ],</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>这时用户是无法输入数字的。</p>
<p><code>onChanged</code>是当内容发生变化时回调，<code>onSubmitted</code>是点击回车或者点击软键盘上的完成回调，<code>onTap</code>点击输入框时回调，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  onChanged: (value)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'onChanged:<span class="subst">$value</span>'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onEditingComplete: ()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'onEditingComplete'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onTap: ()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'onTap'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>输入框右下角经常需要字数统计，除了使用上面介绍的方法外，还可以使用<code>buildCounter</code>，建议使用此方法，用法如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  maxLength: <span class="number">100</span>,</span><br><span class="line">  buildCounter: (</span><br><span class="line">    BuildContext context, &#123;</span><br><span class="line">    <span class="built_in">int</span> currentLength,</span><br><span class="line">    <span class="built_in">int</span> maxLength,</span><br><span class="line">    <span class="built_in">bool</span> isFocused,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line">      <span class="string">'<span class="subst">$currentLength</span>/<span class="subst">$maxLength</span>'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>动态获取焦点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FocusScope.of(context).requestFocus(_focusNode);复制代码</span><br></pre></td></tr></table></figure>

<p><code>_focusNode</code>为TextField的focusNode：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_focusNode = FocusNode();</span><br><span class="line"></span><br><span class="line">TextField(</span><br><span class="line">    focusNode: _focusNode,</span><br><span class="line">    ...</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p>动态失去焦点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_focusNode.unfocus();复制代码</span><br></pre></td></tr></table></figure>

<h3 id="过渡颜色的文字"><a href="#过渡颜色的文字" class="headerlink" title="过渡颜色的文字"></a>过渡颜色的文字</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Builder(</span><br><span class="line">  builder: (BuildContext context) &#123;</span><br><span class="line">    RenderBox box = context.findRenderObject();</span><br><span class="line">    <span class="keyword">final</span> Shader linearGradient = LinearGradient(</span><br><span class="line">      colors: &lt;Color&gt;[Colors.purple, Colors.blue],</span><br><span class="line">    ).createShader(</span><br><span class="line">        Rect.fromLTWH(<span class="number">0.0</span>, <span class="number">0.0</span>, box?.size?.width, box?.size?.height));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line">      <span class="string">'老孟，专注分享Flutter技术和应用实战'</span>,</span><br><span class="line">      style: <span class="keyword">new</span> TextStyle(</span><br><span class="line">          fontSize: <span class="number">18.0</span>,</span><br><span class="line">          fontWeight: FontWeight.bold,</span><br><span class="line">          foreground: Paint()..shader = linearGradient),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-11c2a9f7cbb9ac94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>Builder</code>组件是为了计算当前Text组件大小，生成LinearGradient。</p>
<h3 id="带前后置标签的文本"><a href="#带前后置标签的文本" class="headerlink" title="带前后置标签的文本"></a>带前后置标签的文本</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RichText(</span><br><span class="line">  text: TextSpan(</span><br><span class="line">      style: DefaultTextStyle.of(context).style,</span><br><span class="line">      children: &lt;InlineSpan&gt;[</span><br><span class="line">        WidgetSpan(</span><br><span class="line">            child: Container(</span><br><span class="line">              margin: EdgeInsets.only(right: <span class="number">10</span>),</span><br><span class="line">              padding: EdgeInsets.symmetric(horizontal: <span class="number">10</span>),</span><br><span class="line">              decoration: BoxDecoration(</span><br><span class="line">                  shape: BoxShape.rectangle,</span><br><span class="line">                  borderRadius: BorderRadius.all(Radius.circular(<span class="number">20</span>)),</span><br><span class="line">                  color: Colors.blue),</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">'判断题'</span>,</span><br><span class="line">                style: TextStyle(color: Colors.white),</span><br><span class="line">              ),</span><br><span class="line">            )),</span><br><span class="line">        TextSpan(text: <span class="string">'泡沫灭火器可用于带电灭火'</span>),</span><br><span class="line"></span><br><span class="line">      ]),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-34261fddb5ad29c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="“服务协议”"><a href="#“服务协议”" class="headerlink" title="“服务协议”"></a>“服务协议”</h3><p>通常在登录页面的底部会出现<strong>登录即代表同意并阅读 《服务协议》</strong>，其中<strong>《服务协议》</strong>为蓝色且可点击：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Text.rich(</span><br><span class="line">  TextSpan(</span><br><span class="line">      text: <span class="string">'登录即代表同意并阅读'</span>,</span><br><span class="line">      style: TextStyle(fontSize: <span class="number">11</span>, color: Color(<span class="number">0xFF999999</span>)),</span><br><span class="line">      children: [</span><br><span class="line">        TextSpan(</span><br><span class="line">          text: <span class="string">'《服务协议》'</span>,</span><br><span class="line">          style: TextStyle(color: Colors.blue, fontWeight: FontWeight.bold),</span><br><span class="line">          recognizer: TapGestureRecognizer()</span><br><span class="line">            ..onTap = () &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'onTap'</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ]),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-565918c864581b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="登录密码输入框"><a href="#登录密码输入框" class="headerlink" title="登录密码输入框"></a>登录密码输入框</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    fillColor: Color(<span class="number">0x30cccccc</span>),</span><br><span class="line">    filled: <span class="keyword">true</span>,</span><br><span class="line">    enabledBorder: OutlineInputBorder(</span><br><span class="line">        borderSide: BorderSide(color: Color(<span class="number">0x00FF0000</span>)),</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(<span class="number">100</span>))),</span><br><span class="line">    hintText: <span class="string">'输入密码'</span>,</span><br><span class="line">    focusedBorder: OutlineInputBorder(</span><br><span class="line">        borderSide: BorderSide(color: Color(<span class="number">0x00000000</span>)),</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(<span class="number">100</span>))),</span><br><span class="line"></span><br><span class="line">  ),</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">  obscureText: <span class="keyword">true</span>,</span><br><span class="line">  onChanged: (value) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-d9d82e5998a098cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="评论回复"><a href="#评论回复" class="headerlink" title="评论回复"></a>评论回复</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Text.rich(</span><br><span class="line">  TextSpan(</span><br><span class="line">      text: <span class="string">'回复'</span>,</span><br><span class="line">      style: TextStyle(fontSize: <span class="number">11</span>, color: Color(<span class="number">0xFF999999</span>)),</span><br><span class="line">      children: [</span><br><span class="line">        TextSpan(</span><br><span class="line">          text: <span class="string">'@老孟：'</span>,</span><br><span class="line">          style: TextStyle(color: Colors.blue, fontWeight: FontWeight.bold),</span><br><span class="line">          recognizer: TapGestureRecognizer()</span><br><span class="line">            ..onTap = () &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">'onTap'</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">        TextSpan(</span><br><span class="line">          text: <span class="string">'你好，想知道Flutter发展前景如何？'</span>,</span><br><span class="line">        ),</span><br><span class="line">      ]),</span><br><span class="line">)复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-b560dc681b7fe9cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>作者：老孟Flutter<br>链接：<a href="https://juejin.im/post/5ee16b1751882542fd35284e" target="_blank" rel="noopener">https://juejin.im/post/5ee16b1751882542fd35284e</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/" itemprop="url">Flutter学习之视图体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-14T20:38:51+08:00">
                2020-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/flutter/Flutter%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E5%9B%BE%E4%BD%93%E7%B3%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flutter学习之视图体系"><a href="#Flutter学习之视图体系" class="headerlink" title="Flutter学习之视图体系"></a>Flutter学习之视图体系</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>经过之前的学习，可以知道<strong>Flutter</strong>是一种全新的响应式跨平台的移动开发框架，越来越多的开发者参与学习或者研究中，在<strong>iOS</strong>和<strong>Android</strong>平台上能够用一套代码构建出性能比较高的应用程序。我刚开始接触<strong>Flutter</strong><a href="https://flutterchina.club/technical-overview/" target="_blank" rel="noopener">Flutter中文网</a>看到这么一句话：<code>Widget</code>是<strong>Flutter</strong>应用程序用户界面的基本构建块。每个<code>Widget</code>都是用户界面一部分的不可变声明。与其他将视图、控制器、布局和其他属性分离的框架不同，<strong>Flutter</strong>具有一致的统一对象模型：Widget。在开发过程中也可以知道<code>Widget</code>可以被定义按钮(button)、样式(style)、填充(Padding)、布局(Row)、手势(GestureDetector)等，我刚开始以为这个<code>Widget</code>就是眼中所看到的视图，然而并不是这样的，下面慢慢讲述。</p>
<h2 id="二、视图基础"><a href="#二、视图基础" class="headerlink" title="二、视图基础"></a>二、视图基础</h2><h3 id="1-Widget"><a href="#1-Widget" class="headerlink" title="1.Widget"></a>1.Widget</h3><p>在<a href="https://flutter.dev/docs/development/ui/widgets-intro" target="_blank" rel="noopener">Flutter官方网站</a>介绍<code>Widgets</code>开篇有这么一段话：</p>
<blockquote>
<p>Flutter widgets are built using a modern react-style framework, which takes inspiration from React. The central idea is that you build your UI out of widgets. Widgets describe what their view should look like given their current configuration and state. When a widget’s state changes, the widget rebuilds its description, which the framework diffs against the previous description in order to determine the minimal changes needed in the underlying render tree to transition from one state to the next.</p>
</blockquote>
<p>这段话的意思是：<code>Flutter widgets</code>是采取React思想使用响应式框架构建的。核心思想就是使用<code>widgets</code>构建出UI(界面)。<code>Widgets</code>根据其当前配置和状态描述了它们的视图。当某个<code>widget</code>的状态发生更改时，<code>widget</code>会重新构建所描述的视图，framework会根据前面所描述的视图(状态没改变时)进行区分，以确定底层呈现树从一个状态转换到下一个状态所需的最小更改步骤。</p>
<p>在<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html" target="_blank" rel="noopener">Flutter开发者文档</a>对<code>Widget</code>的定义如下：</p>
<blockquote>
<p>Describes the configuration for an Element.</p>
<p>Widgets are the central class hierarchy in the Flutter framework. A widget is an immutable description of part of a user interface. Widgets can be inflated into elements, which manage the underlying render tree.</p>
</blockquote>
<p>意思是：<code>widget</code>为<code>element</code>(下面再描述)提供配置信息，这里可以知道<code>widget</code>和<code>element</code>存在某种联系。<code>Widgets</code>在Flutter framework是中心类层次结构，<code>widget</code>是不可变的对象并且是界面的一部分，<code>widget</code>会被渲染在<code>elements</code>上，并(elelments)管理底层渲染树(render tree)，这里可以得到一个信息：<code>widget</code>在渲染的时候会最终转换成<code>element</code>。继续往下看：</p>
<blockquote>
<p>Widgets themselves have no mutable state (all their fields must be final). If you wish to associate mutable state with a widget, consider using a StatefulWidget, which creates a State object (via StatefulWidget.createState) whenever it is inflated into an element and incorporated into the tree.</p>
</blockquote>
<p>意思是：<code>Wigets</code>本身是没有可变的状态(其所有的字段必须是final)。如果你想吧可变状态和一个<code>widget</code>关联起来，可以使用<code>StatefulWidget</code>，<code>StatefulWidget</code>通过使用<code>StatefulWidget.createState</code>方法创建<code>State</code>对象，并且扩充到<code>element</code>和合并到树中。那么这段可以得出的信息是：<code>widget</code>并不会直接渲染和管理状态，管理状态是交给<code>State</code>对象负责。继续往下一段看：</p>
<blockquote>
<p>A given widget can be included in the tree zero or more times. In particular a given widget can be placed in the tree multiple times. Each time a widget is placed in the tree, it is inflated into an Element, which means a widget that is incorporated into the tree multiple times will be inflated multiple times.</p>
</blockquote>
<p>意思是：给定的<code>widget</code>可以<strong>零次或者多次</strong>被包含在树中，一个给定的<code>widget</code>可以多次放置在树中，每次将一个<code>widget</code>放入树中，他都会被扩充到一个<code>Element</code>，这就意味着多次并入树中的<code>widget</code>将会多次扩充到对应的<code>Element</code>。这段可以这么理解：在一个界面中，有多个<code>Text</code>被挂载在视图树上，这些<code>Text</code>的<code>widget</code>会被填充进自己独立的<code>Element</code>中，就算<code>widget</code>被重复使用，还是会创建多个不同的<code>element</code>对象。继续往下看：</p>
<blockquote>
<p>The key property controls how one widget replaces another widget in the tree. If the runtimeType and key properties of the two widgets are operator==, respectively, then the new widget replaces the old widget by updating the underlying element (i.e., by calling Element.update with the new widget). Otherwise, the old element is removed from the tree, the new widget is inflated into an element, and the new element is inserted into the tree.</p>
</blockquote>
<p>每一个<code>widget</code>都有自己的唯一的<strong>key</strong>，这里也很容易理解，就是借助<strong>key</strong>作为唯一标识符。这段话的意思是：<strong>key</strong>这个属性控制一个<code>widget</code>如何替换树中的另一个<code>widget</code>。如果两个<code>widget</code>的<strong>runtimeType</strong>和<strong>key</strong>属性相等==，则新的<code>widget</code>通过更新<code>Element</code>(通过新的<code>widget</code>来来调用<strong>Element.update</strong>)来替换旧的<code>widget</code>。否则，如果两个<code>widget</code>的<strong>runtimeType</strong>和<strong>key</strong>属性不相等，则旧的<code>Element</code>将从树中被移除，新的<code>widget</code>将被扩充到一个新的<code>Element</code>中，这个新的<code>Element</code>将被插入树中。这里可以得出：如果涉及到<code>widget</code>的移动或者删除操作前，会根据<code>widget</code>的<strong>runtime</strong>和<strong>key</strong>进行对比。</p>
<p>综上所述：</p>
<ul>
<li>widget向Element提供配置信息(数据)，界面构造出来的widget树其实只是一颗配置信息树，为了构造出Element树。</li>
<li>Element和widget有对应关系，因为，element是通过widget来生成的。</li>
<li>同一个widget可以创建多个element，<strong>也就是一个widget对象可以对应多个element对象</strong>。</li>
</ul>
<p>下面初步看看widget源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class Widget extends DiagnosticableTree &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Initializes [key] for subclasses.</span><br><span class="line">  const Widget(&#123; this.key &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;省略注释</span><br><span class="line">  final Key key;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;构建出element</span><br><span class="line">  @protected</span><br><span class="line">  Element createElement();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;简短文字描述这个widget</span><br><span class="line">  @override</span><br><span class="line">  String toStringShort() &#123;</span><br><span class="line">    return key &#x3D;&#x3D; null ? &#39;$runtimeType&#39; : &#39;$runtimeType-$key&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;根据字面意思 应该是调试诊断树的信息</span><br><span class="line">  @override</span><br><span class="line">  void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    super.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle &#x3D; DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态方法，跟上一段解释一样，就是是否用新的widget对象去更新旧UI渲染树的配置</span><br><span class="line">  &#x2F;&#x2F;如果oldWidget和newWidget的runtimeType和key同时相等就会用newWidget对象去更新对应element信息</span><br><span class="line">  static bool canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    return oldWidget.runtimeType &#x3D;&#x3D; newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key &#x3D;&#x3D; newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>还要注意:<code>widget</code>是抽象类，在平时，一般继续<code>StatelessWidget</code>和<code>StatefulWidget</code>，而这两个类其实也是继承<code>Widget</code>，这两个类肯定会实现这个<code>createElement</code>方法，简单看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StatelessWidget</span><br><span class="line">abstract class StatelessWidget extends Widget &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Initializes [key] for subclasses.</span><br><span class="line">  const StatelessWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  ....</span><br><span class="line">  @override</span><br><span class="line">  StatelessElement createElement() &#x3D;&gt; StatelessElement(this);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatefulWidget</span><br><span class="line">abstract class StatefulWidget extends Widget &#123;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Initializes [key] for subclasses.</span><br><span class="line">  const StatefulWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  .....</span><br><span class="line">  @override</span><br><span class="line">  StatefulElement createElement() &#x3D;&gt; StatefulElement(this);</span><br><span class="line">  .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>确实可以看出，都会创建<code>Element</code>，只是<code>StatelessWidget</code>和<code>StatefulWidget</code>所创建的<code>Element</code>类型不一样，这里就先不深入了。上面可以知道<code>widget</code>和<code>element</code>存在对应的关系，那下面看看<code>element</code>。</p>
<h3 id="2-Element"><a href="#2-Element" class="headerlink" title="2.Element"></a>2.Element</h3><p>看看<a href="https://api.flutter.dev/flutter/widgets/Element-class.html" target="_blank" rel="noopener">官方开发者文档</a>中开篇看到：</p>
<blockquote>
<p>An instantiation of a Widget at a particular location in the tree.</p>
</blockquote>
<p>意思是：<code>element</code>是树中特定位置的<code>widget</code>实例。这里描述的很明显，也就是<code>Widget</code>是总监，部署技术规划，而<code>element</code>就是员工，真正干活。继续往下阅读：</p>
<blockquote>
<p>Widgets describe how to configure a subtree but the same widget can be used to configure multiple subtrees simultaneously because widgets are immutable. An Element represents the use of a widget to configure a specific location in the tree. Over time, the widget associated with a given element can change, for example, if the parent widget rebuilds and creates a new widget for this location.</p>
</blockquote>
<p>意思是：<code>widget</code>描述如何配置子树，由于<code>widgets</code>是不可变的，所以可以用相同的<code>widget</code>来同时配置多个子树，<code>Element</code>表示<code>widget</code>配置树中的特定位置的实例，随着时间的推移，和给定的<code>Element</code>关联的<code>Widget</code>可能会随时变化，例如，如果父<code>widget</code>重建并为此位置创建新的<code>widget</code>。</p>
<blockquote>
<p>Elements form a tree. Most elements have a unique child, but some widgets (e.g., subclasses of RenderObjectElement) can have multiple children.</p>
</blockquote>
<p><code>Elements</code>构成一棵树，大多数<code>elements</code>都会有<strong>唯一</strong>的孩子，但是一些<code>widgets</code>(如RenderObjectElement)可以有多个孩子。</p>
<blockquote>
<p>Elements have the following lifecycle:</p>
<ul>
<li>The framework creates an element by calling Widget.createElement on the widget that will be used as the element’s initial configuration.</li>
<li>The framework calls mount to add the newly created element to the tree at a given slot in a given parent. The mount method is responsible for inflating any child widgets and calling attachRenderObject as necessary to attach any associated render objects to the render tree.</li>
<li>At this point, the element is considered “active” and might appear on screen.</li>
<li>At some point, the parent might decide to change the widget used to configure this element, for example because the parent rebuilt with new state. When this happens, the framework will call update with the new widget. The new widget will always have the same runtimeType and key as old widget. If the parent wishes to change the runtimeType or key of the widget at this location in the tree, can do so by unmounting this element and inflating the new widget at this location.</li>
<li>At some point, an ancestor might decide to remove this element (or an intermediate ancestor) from the tree, which the ancestor does by calling deactivateChild on itself. Deactivating the intermediate ancestor will remove that element’s render object from the render tree and add this element to the owner’s list of inactive elements, causing the framework to call deactivate on this element.</li>
<li>At this point, the element is considered “inactive” and will not appear on screen. An element can remain in the inactive state only until the end of the current animation frame. At the end of the animation frame, any elements that are still inactive will be unmounted. *If the element gets reincorporated into the tree (e.g., because it or one of its ancestors has a global key that is reused), the framework will remove the element from the owner’s list of inactive elements, call activate on the element, and reattach the element’s render object to the render tree. (At this point, the element is again considered “active” and might appear on screen.)</li>
<li>If the element does not get reincorporated into the tree by the end of the current animation frame, the framework will call unmount on the element. At this point, the element is considered “defunct” and will not be incorporated into the tree in the future.</li>
<li>At this point, the element is considered “defunct” and will not be incorporated into the tree in the future.</li>
</ul>
</blockquote>
<p>意思如下： Element具有以下生命周期：</p>
<ul>
<li>framework通过调用即将用来作<code>element</code>的初始化配置信息的<code>Widget</code>的<strong>Widget.createElement</strong>方法来创建一个<code>element</code>。</li>
<li>framework通过调用mount方法以将新创建的Element添加到给定父级中给定槽点的树上。 mount方法负责将任何子<code>Widget</code>扩充到<code>Widget</code>并根据需要调用<code>attachRenderObject</code>，以将任何关联的渲染对象附加到渲染树上。</li>
<li>此时，<code>element</code>被视为<code>激活</code>，可能出现在屏幕上。</li>
<li>在某些情况下，父可能会更改用于配置此<code>Element</code>的Widget，例如因为父重新创建了新状态。发生这种情况时，framework将调用新的<code>Widget</code>的update方法。新<code>Widget</code>将始终具有与旧<code>Widget</code>相同的<strong>runtimeType</strong>和<strong>key</strong>属性。如果父希望在树中的此位置更改<code>Widget</code>的<strong>runtimeType</strong>或<strong>key</strong>，可以通过unmounting(卸载)此Element并在此位置扩充新<code>Widget</code>来实现。</li>
<li>在某些时候，祖先(Element)可能会决定从树中移除该<code>element</code>（或中间祖先），祖先自己通过调用<strong>deactivateChild</strong>来完成该操作。停用中间祖先将从渲染树中移除该<code>element</code>的渲染对象，并将此<code>element</code>添加到所有者属性中的非活动元素列表中，从而framework调用<strong>deactivate</strong>方法作用在此<code>element</code>上。</li>
<li>此时，该<code>element</code>被视为“无效”，不会出现在屏幕上。一个<code>element</code>直到动画帧结束前都可以保存“非活动”状态。动画帧结束时，将卸载仍处于非活动状态的所有<code>element</code>。</li>
<li>如果<code>element</code>被重写组合到树中(例如，因为它或其祖先之一有一个全局建(global key)被重用)，framework将从所有者的非活动<code>elements</code>列表中移除该<code>element</code>，并调用该<code>element</code>的<strong>activate方法</strong>，并重新附加到<code>element</code>的渲染对象到渲染树上。(此时，该元素再次被视为“活动”并可能出现在屏幕上)</li>
<li>如果<code>element</code>在当前动画帧的末尾(最后一帧)没有被重新组合到树中，那么framework将会调用该元素的<strong>unmount方法</strong>。</li>
</ul>
<p>这里可以知道<code>element</code>的生命周期。并且平时开发没有接触到<code>Element</code>，都是直接操控<code>widget</code>，也就是说Flutter已经帮我们对<code>widget</code>的操作映射到<code>element</code>上，我这里想象到的有点事降低开发复杂。下面结合一个例子(绘制Text)，看看<code>element</code>是不是最后渲染出来的view：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Text(&quot;hello flutter&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面看下<code>new Text</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final DefaultTextStyle defaultTextStyle &#x3D; DefaultTextStyle.of(context);</span><br><span class="line">    TextStyle effectiveTextStyle &#x3D; style;</span><br><span class="line">    if (style &#x3D;&#x3D; null || style.inherit)</span><br><span class="line">      effectiveTextStyle &#x3D; defaultTextStyle.style.merge(style);</span><br><span class="line">    if (MediaQuery.boldTextOverride(context))</span><br><span class="line">      effectiveTextStyle &#x3D; effectiveTextStyle.merge(const TextStyle(fontWeight: FontWeight.bold));</span><br><span class="line">    Widget result &#x3D; RichText( ----&gt;Text原来是通过RichText这个widget来构建树</span><br><span class="line">      textAlign: textAlign ?? defaultTextStyle.textAlign ?? TextAlign.start,</span><br><span class="line">      textDirection: textDirection, &#x2F;&#x2F; RichText uses Directionality.of to obtain a default if this is null.</span><br><span class="line">      locale: locale, &#x2F;&#x2F; RichText uses Localizations.localeOf to obtain a default if this is null</span><br><span class="line">      softWrap: softWrap ?? defaultTextStyle.softWrap,</span><br><span class="line">      overflow: overflow ?? defaultTextStyle.overflow,</span><br><span class="line">      textScaleFactor: textScaleFactor ?? MediaQuery.textScaleFactorOf(context),</span><br><span class="line">      maxLines: maxLines ?? defaultTextStyle.maxLines,</span><br><span class="line">      strutStyle: strutStyle,</span><br><span class="line">      text: TextSpan(</span><br><span class="line">        style: effectiveTextStyle,</span><br><span class="line">        text: data,</span><br><span class="line">        children: textSpan !&#x3D; null ? &lt;TextSpan&gt;[textSpan] : null,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    ....</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>继续往<code>RichText</code>里面看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ....</span><br><span class="line">  @override</span><br><span class="line">  RenderParagraph createRenderObject(BuildContext context) &#123;</span><br><span class="line">    assert(textDirection !&#x3D; null || debugCheckHasDirectionality(context));</span><br><span class="line">    &#x2F;&#x2F;返回RenderParagraph widget </span><br><span class="line">    return RenderParagraph(text,</span><br><span class="line">      textAlign: textAlign,</span><br><span class="line">      textDirection: textDirection ?? Directionality.of(context),</span><br><span class="line">      softWrap: softWrap,</span><br><span class="line">      overflow: overflow,</span><br><span class="line">      textScaleFactor: textScaleFactor,</span><br><span class="line">      maxLines: maxLines,</span><br><span class="line">      strutStyle: strutStyle,</span><br><span class="line">      locale: locale ?? Localizations.localeOf(context, nullOk: true),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>发现最终它会返回<code>RenderParagraph</code>widget，继续往里看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class RichText extends LeafRenderObjectWidget &#123;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以发现<code>RichText</code>继承<code>LeafRenderObjectWidget</code>，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于配置RenderObject子类的RenderObjectWidgets的超类，没有孩子，也就是没有字节点(child)</span><br><span class="line">abstract class LeafRenderObjectWidget extends RenderObjectWidget &#123;</span><br><span class="line">  const LeafRenderObjectWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;构建出类型是LeafRenderObjectElement</span><br><span class="line">  @override</span><br><span class="line">  LeafRenderObjectElement createElement() &#x3D;&gt; LeafRenderObjectElement(this);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到<code>LeafRenderObjectWidget</code>是抽象类，并且继承了<code>RenderObjectWidget</code>，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; RenderObjectWidgets provide the configuration for [RenderObjectElement]s,</span><br><span class="line">&#x2F;&#x2F;&#x2F; which wrap [RenderObject]s, which provide the actual rendering of the</span><br><span class="line">&#x2F;&#x2F;&#x2F; application.</span><br><span class="line">&#x2F;&#x2F;上面注释是：RenderObjectWidgets向[RenderObjectElement]提供了配置信息，包装了[RenderObject]，在应用程序了提供了实际的渲染</span><br><span class="line">abstract class RenderObjectWidget extends Widget &#123;</span><br><span class="line"></span><br><span class="line">  const RenderObjectWidget(&#123; Key key &#125;) : super(key: key);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;创建element</span><br><span class="line">  @override</span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line">  &#x2F;&#x2F;创建RenderObject</span><br><span class="line">  @protected</span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;更新RenderObject</span><br><span class="line">  @protected</span><br><span class="line">  void updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;卸载RenderObject</span><br><span class="line">  @protected</span><br><span class="line">  void didUnmountRenderObject(covariant RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由注释可以知道<code>RenderObject</code>才是绘制UI背后的真正对象，那下面继续简单跟踪：</p>
<h3 id="3-RenderObjectWidget"><a href="#3-RenderObjectWidget" class="headerlink" title="3.RenderObjectWidget"></a>3.RenderObjectWidget</h3><p>先看看<code>RenderObjectWidget</code>继承关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2dc43541e51a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="RenderObjectWidget继承关系"></p>
<p>看看文档的一一介绍：</p>
<h4 id="3-1-SingleChildRenderObjectWidget"><a href="#3-1-SingleChildRenderObjectWidget" class="headerlink" title="3.1.SingleChildRenderObjectWidget"></a>3.1.SingleChildRenderObjectWidget</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2e6861c9534a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SingleChildRenderObjectWidget"></p>
<p>官方文档写的很清楚： 是<code>RenderObjectWidgets</code>的超类，用于配置有单个孩子的<code>RenderObject</code>子类(为子类提供存储，实际不提供更新逻辑)，并列了具体的实际<code>widget</code>,如常用的Align、ClipRect、DecoratedBox都是属于这类。</p>
<h4 id="3-2-MultiChildRenderObjectWidget"><a href="#3-2-MultiChildRenderObjectWidget" class="headerlink" title="3.2.MultiChildRenderObjectWidget"></a>3.2.MultiChildRenderObjectWidget</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2eff26313931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="MultiChildRenderObjectWidget"></p>
<p>同样也是<code>RenderObjectWidgets</code>的超类，用于配置有单个<strong>children</strong>(也就是多个child)的<code>RenderObject</code>子类，如Flex、Flow、Stack都属于这类。</p>
<h4 id="3-3-LeafRenderObjectWidget"><a href="#3-3-LeafRenderObjectWidget" class="headerlink" title="3.3.LeafRenderObjectWidget"></a>3.3.LeafRenderObjectWidget</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c2f8f6f8577bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="LeafRenderObjectWidget"></p>
<p>同样也是<code>RenderObjectWidgets</code>的超类，用于配置没有孩子的<code>RenderObject</code>子类，如：RichText(平时的Text)、RawImage、Texture等。 这里总结一下：</p>
<ul>
<li><code>SingleChildRenderObjectWidget</code>用作只有一个child的<code>widget</code>。</li>
<li><code>MultiChildRenderObjectWidget</code>用作有children(多个孩子)的<code>widget</code>。</li>
<li><code>LeafRenderObjectWidget</code>用作没有child的<code>widget</code>。</li>
<li><code>RenderObjectWidget</code>定义了创建，更新，删除RenderObject的方法，子类必须实现，<code>RenderObject</code>是最终布局、UI渲染的实际对象。</li>
</ul>
<p>那么假如我现在界面上，假如布局如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c3322c6d67e23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="例子布局"></p>
<p>那么渲染流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c346cd1a92ea9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="渲染转换"></p>
<p>这时候会想：为什么要加中间层<code>Element</code>呢，不直接由<code>Widget</code>直接转换成<code>RendObject</code>不是直接更好么？其实并不是这样的。首先知道Flutter是响应式框架，在某一个时刻，可能会受到不同的输入流影响，中间层<code>Element</code>对这一时刻的事件做了汇总，最后将需要修改的部分同步到<code>RendObject</code>tree上，也就是：</p>
<ul>
<li>尽可能的降低<code>RenderObject</code>tree的更改，提高页面渲染效率。</li>
<li>没有直接操作UI，通过数据驱动视图，代码更容易理解和简洁。</li>
</ul>
<p>上面得出UI树是由一个个<code>element</code>节点组成，但是最终的渲染是通过<code>RenderObject</code>来完成，一个<code>widget</code>从创建到显示到界面的流程是：widget生成element，然后通过<strong>createRenderObject</strong>方法创建对应的<code>RenderObject</code>关联到<code>Element.renderObject</code>上，最后通过<code>RenderObject</code>来完成绘制。</p>
<h2 id="三、启动到显示"><a href="#三、启动到显示" class="headerlink" title="三、启动到显示"></a>三、启动到显示</h2><p>上面知道，<code>widget</code>并不是真正显示的对象，知道了一个<code>widget</code>是怎样渲染在屏幕上显示，那下面就从main()方法入口，看看一个app从点击启动到运行的流程：</p>
<h3 id="1-WidgetsFlutterBinding-ensureInitialized"><a href="#1-WidgetsFlutterBinding-ensureInitialized" class="headerlink" title="1.WidgetsFlutterBinding.ensureInitialized"></a>1.WidgetsFlutterBinding.ensureInitialized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;app入口</span><br><span class="line">void main() &#x3D;&gt; runApp(MyApp());</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>app入口函数就是调用了<strong>runApp</strong>方法，看看<strong>runApp</strong>方法里面做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先参数(Widget app)是一个<code>widget</code>，下面一行一行分析，进入<strong>WidgetsFlutterBinding.ensureInitialized()</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A concrete binding for applications based on the Widgets framework.</span><br><span class="line">&#x2F;&#x2F;&#x2F; This is the glue that binds the framework to the Flutter engine.</span><br><span class="line">&#x2F;&#x2F;意思：基于widget framework的应用程序的具体绑定</span><br><span class="line">&#x2F;&#x2F;这是将framework widget和Flutter engine绑定的桥梁</span><br><span class="line">class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; Returns an instance of the [WidgetsBinding], creating and</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initializing it if necessary. If one is created, it will be a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding]. If one was previously initialized, then</span><br><span class="line">  &#x2F;&#x2F;&#x2F; it will at least implement [WidgetsBinding].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; You only need to call this method if you need the binding to be</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initialized before calling [runApp].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; In the &#96;flutter_test&#96; framework, [testWidgets] initializes the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; binding instance to a [TestWidgetsFlutterBinding], not a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding].</span><br><span class="line">  &#x2F;&#x2F;上面注释意思是：返回[WidgetsBinding]的具体实例，必须创建和初始化，如果已&#x2F;&#x2F;经创建了，那么它就是一个[WidgetsFlutterBinding]，如果已经初始化了，那么&#x2F;&#x2F;至少要实现[WidgetsBinding]</span><br><span class="line">  &#x2F;&#x2F;如果你只想调用这个方法，那么你需要在调用runApp之前绑定并且初始化</span><br><span class="line">  static WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    if (WidgetsBinding.instance &#x3D;&#x3D; null)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    return WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看到这个<code>WidgetsFlutterBinding</code>混入(with)很多的<code>Binding</code>，下面先看父类<code>BindingBase</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">abstract class BindingBase &#123;</span><br><span class="line">  BindingBase() &#123;</span><br><span class="line">    developer.Timeline.startSync(&#39;Framework initialization&#39;);</span><br><span class="line"></span><br><span class="line">    assert(!_debugInitialized);</span><br><span class="line">    initInstances();</span><br><span class="line">    assert(_debugInitialized);</span><br><span class="line"></span><br><span class="line">    assert(!_debugServiceExtensionsRegistered);</span><br><span class="line">    initServiceExtensions();</span><br><span class="line">    assert(_debugServiceExtensionsRegistered);</span><br><span class="line"></span><br><span class="line">    developer.postEvent(&#39;Flutter.FrameworkInitialization&#39;, &lt;String, String&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    developer.Timeline.finishSync();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static bool _debugInitialized &#x3D; false;</span><br><span class="line">  static bool _debugServiceExtensionsRegistered &#x3D; false;</span><br><span class="line">  ui.Window get window &#x3D;&gt; ui.window;&#x2F;&#x2F;获取window实例</span><br><span class="line">  @protected</span><br><span class="line">  @mustCallSuper</span><br><span class="line">  void initInstances() &#123;</span><br><span class="line">    assert(!_debugInitialized);</span><br><span class="line">    assert(() &#123; _debugInitialized &#x3D; true; return true; &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看到有句代码<strong>ui.Window get window =&gt; ui.window;</strong>，在Android中所有的视图都是通过<code>window</code>来呈现的，那Flutter中也有<code>window</code>，那看看<code>window</code>在Flutter中的作用看看官方对它的定义：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c38d8bd7b5dce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="window定义"></p>
<p>意思是：链接宿主操作系统的接口，也就是Flutter framework 链接宿主操作系统的接口。系统中有一个Window实例，可以从window属性来获取，看看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">class Window &#123;</span><br><span class="line">  Window._();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;返回DPI，DPI是每英寸的像素点数，是设备屏幕的固件属性</span><br><span class="line">  &#x2F;&#x2F;获取可能不准确</span><br><span class="line">  double get devicePixelRatio &#x3D;&gt; _devicePixelRatio;</span><br><span class="line">  double _devicePixelRatio &#x3D; 1.0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;绘制UI的区域大小</span><br><span class="line">  Size get physicalSize &#x3D;&gt; _physicalSize;</span><br><span class="line">  Size _physicalSize &#x3D; Size.zero;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取矩形的物理像素</span><br><span class="line">  WindowPadding get viewInsets &#x3D;&gt; _viewInsets;</span><br><span class="line">  WindowPadding _viewInsets &#x3D; WindowPadding.zero;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取内边距</span><br><span class="line">  WindowPadding get padding &#x3D;&gt; _padding;</span><br><span class="line">  WindowPadding _padding &#x3D; WindowPadding.zero;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当绘制区域改变时触发</span><br><span class="line">  VoidCallback get onMetricsChanged &#x3D;&gt; _onMetricsChanged;</span><br><span class="line">  VoidCallback _onMetricsChanged;</span><br><span class="line">  Zone _onMetricsChangedZone;</span><br><span class="line">  set onMetricsChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onMetricsChanged &#x3D; callback;</span><br><span class="line">    _onMetricsChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当系统语言发生变化时触发回调</span><br><span class="line">  Locale get locale &#123;</span><br><span class="line">    if (_locales !&#x3D; null &amp;&amp; _locales.isNotEmpty) &#123;</span><br><span class="line">      return _locales.first;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取系统语言</span><br><span class="line">  List&lt;Locale&gt; get locales &#x3D;&gt; _locales;</span><br><span class="line">  List&lt;Locale&gt; _locales;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当Local发生改变时触发回调</span><br><span class="line">  VoidCallback get onLocaleChanged &#x3D;&gt; _onLocaleChanged;</span><br><span class="line">  VoidCallback _onLocaleChanged;</span><br><span class="line">  Zone _onLocaleChangedZone;</span><br><span class="line">  set onLocaleChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onLocaleChanged &#x3D; callback;</span><br><span class="line">    _onLocaleChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当系统字体大小改变时触发回调</span><br><span class="line">  VoidCallback get onTextScaleFactorChanged &#x3D;&gt; _onTextScaleFactorChanged;</span><br><span class="line">  VoidCallback _onTextScaleFactorChanged;</span><br><span class="line">  Zone _onTextScaleFactorChangedZone;</span><br><span class="line">  set onTextScaleFactorChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onTextScaleFactorChanged &#x3D; callback;</span><br><span class="line">    _onTextScaleFactorChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;屏幕亮度改变时触发回调</span><br><span class="line">  VoidCallback get onPlatformBrightnessChanged &#x3D;&gt; _onPlatformBrightnessChanged;</span><br><span class="line">  VoidCallback _onPlatformBrightnessChanged;</span><br><span class="line">  Zone _onPlatformBrightnessChangedZone;</span><br><span class="line">  set onPlatformBrightnessChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onPlatformBrightnessChanged &#x3D; callback;</span><br><span class="line">    _onPlatformBrightnessChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;屏幕刷新时会回调</span><br><span class="line">  FrameCallback get onBeginFrame &#x3D;&gt; _onBeginFrame;</span><br><span class="line">  FrameCallback _onBeginFrame;</span><br><span class="line">  Zone _onBeginFrameZone;</span><br><span class="line">  set onBeginFrame(FrameCallback callback) &#123;</span><br><span class="line">    _onBeginFrame &#x3D; callback;</span><br><span class="line">    _onBeginFrameZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;绘制屏幕时回调</span><br><span class="line">  VoidCallback get onDrawFrame &#x3D;&gt; _onDrawFrame;</span><br><span class="line">  VoidCallback _onDrawFrame;</span><br><span class="line">  Zone _onDrawFrameZone;</span><br><span class="line">  set onDrawFrame(VoidCallback callback) &#123;</span><br><span class="line">    _onDrawFrame &#x3D; callback;</span><br><span class="line">    _onDrawFrameZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;点击或者指针事件触发回调</span><br><span class="line">  PointerDataPacketCallback get onPointerDataPacket &#x3D;&gt; _onPointerDataPacket;</span><br><span class="line">  PointerDataPacketCallback _onPointerDataPacket;</span><br><span class="line">  Zone _onPointerDataPacketZone;</span><br><span class="line">  set onPointerDataPacket(PointerDataPacketCallback callback) &#123;</span><br><span class="line">    _onPointerDataPacket &#x3D; callback;</span><br><span class="line">    _onPointerDataPacketZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取请求的默认路由</span><br><span class="line">  String get defaultRouteName &#x3D;&gt; _defaultRouteName();</span><br><span class="line">  String _defaultRouteName() native &#39;Window_defaultRouteName&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;该方法被调用后，onBeginFrame和onDrawFrame将紧连着会在合适时机调用</span><br><span class="line">  void scheduleFrame() native &#39;Window_scheduleFrame&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;更新应用在GPU上的渲染，这方法会直接调用Flutter engine的Window_render方法</span><br><span class="line">  void render(Scene scene) native &#39;Window_render&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;窗口的语义内容是否改变</span><br><span class="line">  bool get semanticsEnabled &#x3D;&gt; _semanticsEnabled;</span><br><span class="line">  bool _semanticsEnabled &#x3D; false;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当窗口语言发生改变时回调 </span><br><span class="line">  VoidCallback get onSemanticsEnabledChanged &#x3D;&gt; _onSemanticsEnabledChanged;</span><br><span class="line">  VoidCallback _onSemanticsEnabledChanged;</span><br><span class="line">  Zone _onSemanticsEnabledChangedZone;</span><br><span class="line">  set onSemanticsEnabledChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onSemanticsEnabledChanged &#x3D; callback;</span><br><span class="line">    _onSemanticsEnabledChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;当用户表达写的动作时回调</span><br><span class="line">  SemanticsActionCallback get onSemanticsAction &#x3D;&gt; _onSemanticsAction;</span><br><span class="line">  SemanticsActionCallback _onSemanticsAction;</span><br><span class="line">  Zone _onSemanticsActionZone;</span><br><span class="line">  set onSemanticsAction(SemanticsActionCallback callback) &#123;</span><br><span class="line">    _onSemanticsAction &#x3D; callback;</span><br><span class="line">    _onSemanticsActionZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;启用其他辅助功能回调</span><br><span class="line">  VoidCallback get onAccessibilityFeaturesChanged &#x3D;&gt; _onAccessibilityFeaturesChanged;</span><br><span class="line">  VoidCallback _onAccessibilityFeaturesChanged;</span><br><span class="line">  Zone _onAccessibilityFlagsChangedZone;</span><br><span class="line">  set onAccessibilityFeaturesChanged(VoidCallback callback) &#123;</span><br><span class="line">    _onAccessibilityFeaturesChanged &#x3D; callback;</span><br><span class="line">    _onAccessibilityFlagsChangedZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;更新此窗口的语义数据</span><br><span class="line">  void updateSemantics(SemanticsUpdate update) native &#39;Window_updateSemantics&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;设置Isolate调试名称</span><br><span class="line">  void setIsolateDebugName(String name) native &#39;Window_setIsolateDebugName&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;向特定平台发送消息</span><br><span class="line">  void sendPlatformMessage(String name,</span><br><span class="line">                           ByteData data,</span><br><span class="line">                           PlatformMessageResponseCallback callback) &#123;</span><br><span class="line">    final String error &#x3D;</span><br><span class="line">        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);</span><br><span class="line">    if (error !&#x3D; null)</span><br><span class="line">      throw new Exception(error);</span><br><span class="line">  &#125;</span><br><span class="line">  String _sendPlatformMessage(String name,</span><br><span class="line">                              PlatformMessageResponseCallback callback,</span><br><span class="line">                              ByteData data) native &#39;Window_sendPlatformMessage&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取平台消息的回调</span><br><span class="line">  PlatformMessageCallback get onPlatformMessage &#x3D;&gt; _onPlatformMessage;</span><br><span class="line">  PlatformMessageCallback _onPlatformMessage;</span><br><span class="line">  Zone _onPlatformMessageZone;</span><br><span class="line">  set onPlatformMessage(PlatformMessageCallback callback) &#123;</span><br><span class="line">    _onPlatformMessage &#x3D; callback;</span><br><span class="line">    _onPlatformMessageZone &#x3D; Zone.current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;由_dispatchPlatformMessage调用</span><br><span class="line">  void _respondToPlatformMessage(int responseId, ByteData data)</span><br><span class="line">      native &#39;Window_respondToPlatformMessage&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;平台信息响应回调</span><br><span class="line">  static PlatformMessageResponseCallback _zonedPlatformMessageResponseCallback(PlatformMessageResponseCallback callback) &#123;</span><br><span class="line">    if (callback &#x3D;&#x3D; null)</span><br><span class="line">      return null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Store the zone in which the callback is being registered.</span><br><span class="line">    final Zone registrationZone &#x3D; Zone.current;</span><br><span class="line"></span><br><span class="line">    return (ByteData data) &#123;</span><br><span class="line">      registrationZone.runUnaryGuarded(callback, data);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以知道<code>window</code>包含当前设备系统的一些信息和回调，那么现在看看混入的各种<code>Binding</code>:</p>
<ul>
<li>GestureBinding：绑定手势子系统，提供<code>onPointerDataPacket</code>回调。</li>
<li>ServicesBinding：绑定平台消息通道，提供<code>onPlatformMessage</code>回调。</li>
<li>SchedulerBinding：绑定绘制调度子系统，提供<code>onBeginFrame</code>和<code>onDrawFrame</code>回调。</li>
<li>PaintingBinding：绑定绘制库，处理图像缓存。</li>
<li>SemanticsBinding：语义层和flutter engine的桥梁，对辅助功能的底层支持。</li>
<li>RendererBinding：是渲染树和Flutter engine的桥梁，提供<code>onMetricsChanged</code>和<code>onTextScaleFactorChanged</code>回调。</li>
<li>WidgetsBinding：是Flutter widget和engine的桥梁，提供<code>onLocaleChanged</code>，<code>onBuildSchedule</code>回调。</li>
</ul>
<p>也就是<code>WidgetsFlutterBinding.ensureInitialized()</code>这行代码看名字是将<code>WidgetsFlutterBinding</code>实例初始化。其实并非那么简单，另外<strong>获取一些系统基本信息和初始化监听<code>window</code>对象的一些事件，然后将这些事件按照上层Framework模型规则进行包装、抽象最后分发</strong>。简而言之<code>WidgetsFlutterBinding</code>是<code>Flutter engine</code>和<code>Framework</code>的桥梁。</p>
<h3 id="2-attachRootWidget-app"><a href="#2-attachRootWidget-app" class="headerlink" title="2.attachRootWidget(app)"></a>2.attachRootWidget(app)</h3><p>第二行是<code>attachRootWidget(app)</code>，看名字意思是将根<code>RootWidget</code>挂载。点进去看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;如果这个widget有必要创建，就将它附加到[renderViewElement]</span><br><span class="line">  void attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement &#x3D; RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: &#39;[root]&#39;,</span><br><span class="line">      child: rootWidget,</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>renderView</code>是UI渲染树的根节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; The render tree that&#39;s attached to the output surface.</span><br><span class="line">  &#x2F;&#x2F;挂载在渲染树 rootNode根节点</span><br><span class="line">  RenderView get renderView &#x3D;&gt; _pipelineOwner.rootNode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>rootWidget</code>是外面所传进来的根<code>Widget</code>，这里不用管它，下面看<code>attachToRenderTree(buildOwner, renderViewElement)</code>这个方法，根据意思，这个方法应该构建<code>RenderTree</code>，这个方法需要两个参数，首先看<code>buildOwner</code>这个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; The [BuildOwner] in charge of executing the build pipeline for the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; widget tree rooted at this binding.</span><br><span class="line">  BuildOwner get buildOwner &#x3D;&gt; _buildOwner;</span><br><span class="line">  final BuildOwner _buildOwner &#x3D; BuildOwner();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看官网对它的定义：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c4793b37168d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="BuildOwner"></p>
<p>意思是：是widget framework的管理类，用来跟踪哪些widget需要重建，并处理widget树的其他任务，例如管理树的非活动元素列表，<strong>并在调试时在热重载期间在必要时触发“重组”命令</strong>，下面看另外一个参数<code>renderViewElement</code>，代码注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; The [Element] that is at the root of the hierarchy (and which wraps the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [RenderView] object at the root of the rendering hierarchy).</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; This is initialized the first time [runApp] is called.</span><br><span class="line">  Element get renderViewElement &#x3D;&gt; _renderViewElement;</span><br><span class="line">  Element _renderViewElement;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>renderViewElement</code>是<code>renderView</code>对应的<code>Element</code>对象，因为<code>renderView</code>是树的根，所以<code>renderViewElement</code>位于层次结构的根部，那下面点击<code>attachToRenderTree</code>的源码看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; Inflate this widget and actually set the resulting [RenderObject] as the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; child of [container].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; If &#96;element&#96; is null, this function will create a new element. Otherwise,</span><br><span class="line">  &#x2F;&#x2F;&#x2F; the given element will have an update scheduled to switch to this widget.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Used by [runApp] to bootstrap applications.</span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt; element ]) &#123;</span><br><span class="line">    if (element &#x3D;&#x3D; null) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element &#x3D; createElement();</span><br><span class="line">        assert(element !&#x3D; null);</span><br><span class="line">        element.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      owner.buildScope(element, () &#123;</span><br><span class="line">        element.mount(null, null);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element._newWidget &#x3D; this;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    return element;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>跟着代码往下走如果根<code>element</code>没有创建，那么就调用<code>createElement</code>创建根<code>element</code>，<code>element</code>和<code>widget</code>进行关联。接着调用<code>element.assignOwner(owner)</code>，这个方法其实就是设置这个<code>element</code>的跟踪，最后调用<code>owner.buildScope</code>这个方法，这个方法是确定更新<code>widget</code>的范围。如果<code>element</code>已经创建了，将根<code>element</code>和关联的<code>widget</code>设为新的，并且重新构建这个<code>element</code>，为了后面的复用。</p>
<h3 id="3-scheduleWarmUpFrame"><a href="#3-scheduleWarmUpFrame" class="headerlink" title="3.scheduleWarmUpFrame"></a>3.scheduleWarmUpFrame</h3><p>runApp()方法最后一行执行<code>scheduleWarmUpFrame</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;&#x2F; Schedule a frame to run as soon as possible, rather than waiting for</span><br><span class="line">  &#x2F;&#x2F;&#x2F; the engine to request a frame in response to a system &quot;Vsync&quot; signal.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; This is used during application startup so that the first frame (which is</span><br><span class="line">  &#x2F;&#x2F;&#x2F; likely to be quite expensive) gets a few extra milliseconds to run.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Locks events dispatching until the scheduled frame has completed.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; If a frame has already been scheduled with [scheduleFrame] or</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [scheduleForcedFrame], this call may delay that frame.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; If any scheduled frame has already begun or if another</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [scheduleWarmUpFrame] was already called, this call will be ignored.</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Prefer [scheduleFrame] to update the display in normal operation.</span><br><span class="line">  void scheduleWarmUpFrame() &#123;</span><br><span class="line">    if (_warmUpFrame || schedulerPhase !&#x3D; SchedulerPhase.idle)</span><br><span class="line">      return;</span><br><span class="line"></span><br><span class="line">    _warmUpFrame &#x3D; true;</span><br><span class="line">    Timeline.startSync(&#39;Warm-up frame&#39;);</span><br><span class="line">    final bool hadScheduledFrame &#x3D; _hasScheduledFrame;</span><br><span class="line">    &#x2F;&#x2F; We use timers here to ensure that microtasks flush in between.</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      assert(_warmUpFrame);</span><br><span class="line">      handleBeginFrame(null);---&gt;1</span><br><span class="line">    &#125;);</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      assert(_warmUpFrame);</span><br><span class="line">      handleDrawFrame(); ----&gt;2</span><br><span class="line">      &#x2F;&#x2F; We call resetEpoch after this frame so that, in the hot reload case,</span><br><span class="line">      &#x2F;&#x2F; the very next frame pretends to have occurred immediately after this</span><br><span class="line">      &#x2F;&#x2F; warm-up frame. The warm-up frame&#39;s timestamp will typically be far in</span><br><span class="line">      &#x2F;&#x2F; the past (the time of the last real frame), so if we didn&#39;t reset the</span><br><span class="line">      &#x2F;&#x2F; epoch we would see a sudden jump from the old time in the warm-up frame</span><br><span class="line">      &#x2F;&#x2F; to the new time in the &quot;real&quot; frame. The biggest problem with this is</span><br><span class="line">      &#x2F;&#x2F; that implicit animations end up being triggered at the old time and</span><br><span class="line">      &#x2F;&#x2F; then skipping every frame and finishing in the new time.</span><br><span class="line">      resetEpoch();</span><br><span class="line">      _warmUpFrame &#x3D; false;</span><br><span class="line">      if (hadScheduledFrame)</span><br><span class="line">        scheduleFrame();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Lock events so touch events etc don&#39;t insert themselves until the</span><br><span class="line">    &#x2F;&#x2F; scheduled frame has finished.</span><br><span class="line">    lockEvents(() async &#123;</span><br><span class="line">      await endOfFrame;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先这个方法在<code>SchedulerBinding</code>里，这两个方法主要执行了<code>handleBeginFrame</code>和<code>handleDrawFrame</code>方法：</p>
<h4 id="3-1-handleBeginFrame"><a href="#3-1-handleBeginFrame" class="headerlink" title="3.1.handleBeginFrame"></a>3.1.handleBeginFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  void handleBeginFrame(Duration rawTimeStamp) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; TRANSIENT FRAME CALLBACKS</span><br><span class="line">      Timeline.startSync(&#39;Animate&#39;, arguments: timelineWhitelistArguments);</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.transientCallbacks;</span><br><span class="line">      final Map&lt;int, _FrameCallbackEntry&gt; callbacks &#x3D; _transientCallbacks;</span><br><span class="line">      _transientCallbacks &#x3D; &lt;int, _FrameCallbackEntry&gt;&#123;&#125;;</span><br><span class="line">      callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) &#123;</span><br><span class="line">        if (!_removedIds.contains(id))</span><br><span class="line">          _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);</span><br><span class="line">      &#125;);</span><br><span class="line">      _removedIds.clear();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.midFrameMicrotasks;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到主要是对<code>transientCallbacks</code>队列操作，这个集合主要是放一些临时回调，存放动画回调。</p>
<h4 id="3-2-handleDrawFrame"><a href="#3-2-handleDrawFrame" class="headerlink" title="3.2.handleDrawFrame"></a>3.2.handleDrawFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  void handleDrawFrame() &#123;</span><br><span class="line">    assert(_schedulerPhase &#x3D;&#x3D; SchedulerPhase.midFrameMicrotasks);</span><br><span class="line">    Timeline.finishSync(); &#x2F;&#x2F; end the &quot;Animate&quot; phase</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; PERSISTENT FRAME CALLBACKS -----&gt;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.persistentCallbacks;</span><br><span class="line">      for (FrameCallback callback in _persistentCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; POST-FRAME CALLBACKS  ------&gt;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.postFrameCallbacks;</span><br><span class="line">      final List&lt;FrameCallback&gt; localPostFrameCallbacks &#x3D;</span><br><span class="line">          List&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">      _postFrameCallbacks.clear();</span><br><span class="line">      for (FrameCallback callback in localPostFrameCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _schedulerPhase &#x3D; SchedulerPhase.idle;</span><br><span class="line">      Timeline.finishSync(); &#x2F;&#x2F; end the Frame</span><br><span class="line">      profile(() &#123;</span><br><span class="line">        _profileFrameStopwatch.stop();</span><br><span class="line">        _profileFramePostEvent();</span><br><span class="line">      &#125;);</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        if (debugPrintEndFrameBanner)</span><br><span class="line">          debugPrint(&#39;▀&#39; * _debugBanner.length);</span><br><span class="line">        _debugBanner &#x3D; null;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">      _currentFrameTimeStamp &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到执行<code>persistentCallbacks</code>队列，这个队列用于存放一些持久的回调，不能再此类回调中在请求新的绘制帧，持久回调一经注册则不能移除。接着执行<code>postFrameCallbacks</code>这个队列在每一<code>Frame</code>(一次绘制)结束时只会调用一次，调用后被系统移除。</p>
<p>也就是<code>scheduleWarmUpFrame</code>这个方法安排帧尽快执行，当一次帧绘制结束之前不会响应各种事件，这样保证绘制过程中不触发重绘。上面说过：</p>
<blockquote>
<p>RendererBinding：是渲染树和Flutter engine的桥梁，提供onMetricsChanged和onTextScaleFactorChanged回调</p>
</blockquote>
<p>Flutter真正渲染和绘制是在这个绑定里：</p>
<h3 id="4-渲染绘制"><a href="#4-渲染绘制" class="headerlink" title="4.渲染绘制"></a>4.渲染绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  void initInstances() &#123;</span><br><span class="line">    super.initInstances();</span><br><span class="line">    _instance &#x3D; this;&#x2F;&#x2F;初始化</span><br><span class="line">    _pipelineOwner &#x3D; PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F;添加设置监听</span><br><span class="line">    window</span><br><span class="line">      ..onMetricsChanged &#x3D; handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged &#x3D; handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged &#x3D; handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged &#x3D; _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction &#x3D; _handleSemanticsAction;</span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    assert(renderView !&#x3D; null);</span><br><span class="line">    &#x2F;&#x2F;添加persistentFrameCallback</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    &#x2F;&#x2F;创建触摸管理</span><br><span class="line">    _mouseTracker &#x3D; _createMouseTracker();</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>addPersistentFrameCallback</code>这个方法主要向<strong>persistentFrameCallback</strong>添加了回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  void addPersistentFrameCallback(FrameCallback callback) &#123;</span><br><span class="line">    _persistentCallbacks.add(callback);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再看<code>_handlePersistentFrameCallback</code>这个回调做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  void _handlePersistentFrameCallback(Duration timeStamp) &#123;</span><br><span class="line">    drawFrame();</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br><span class="line">  @protected</span><br><span class="line">  void drawFrame() &#123;</span><br><span class="line">    assert(renderView !&#x3D; null);</span><br><span class="line">    pipelineOwner.flushLayout();&#x2F;&#x2F;更新布局信息</span><br><span class="line">    pipelineOwner.flushCompositingBits();&#x2F;&#x2F;在flushLayout只后调用，在flushPaint之前调用，更新RenderObject是否需要重绘</span><br><span class="line">    pipelineOwner.flushPaint();&#x2F;&#x2F;更新绘制RenderObject</span><br><span class="line">    renderView.compositeFrame(); &#x2F;&#x2F; 发送bit数据给GPU</span><br><span class="line">    pipelineOwner.flushSemantics(); &#x2F;&#x2F; 发送语义数据给操作系统</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面一个一个方法走：</p>
<h4 id="4-1-flushLayout"><a href="#4-1-flushLayout" class="headerlink" title="4.1.flushLayout"></a>4.1.flushLayout</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  void flushLayout() &#123;</span><br><span class="line">    profile(() &#123;</span><br><span class="line">      Timeline.startSync(&#39;Layout&#39;, arguments: timelineWhitelistArguments);</span><br><span class="line">    &#125;);</span><br><span class="line">    assert(() &#123;</span><br><span class="line">      _debugDoingLayout &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;());</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; TODO(ianh): assert that we&#39;re not allowing previously dirty nodes to redirty themselves</span><br><span class="line">      while (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">        final List&lt;RenderObject&gt; dirtyNodes &#x3D; _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout &#x3D; &lt;RenderObject&gt;[];</span><br><span class="line">        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) &#x3D;&gt; a.depth - b.depth)) &#123;</span><br><span class="line">          if (node._needsLayout &amp;&amp; node.owner &#x3D;&#x3D; this)</span><br><span class="line">            node._layoutWithoutResize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        _debugDoingLayout &#x3D; false;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">      profile(() &#123;</span><br><span class="line">        Timeline.finishSync();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看源码得知首先获取哪些标记为<code>脏</code>的<code>RenderObject</code>的布局信息，然后通过<code>ode._layoutWithoutResize();</code>重新调整这些<code>RenderObject</code>。</p>
<h4 id="4-2-flushCompositingBits"><a href="#4-2-flushCompositingBits" class="headerlink" title="4.2.flushCompositingBits"></a>4.2.flushCompositingBits</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  void flushCompositingBits() &#123;</span><br><span class="line">    profile(() &#123; Timeline.startSync(&#39;Compositing bits&#39;); &#125;);</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) &#x3D;&gt; a.depth - b.depth);</span><br><span class="line">    for (RenderObject node in _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      if (node._needsCompositingBitsUpdate &amp;&amp; node.owner &#x3D;&#x3D; this)</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">    profile(() &#123; Timeline.finishSync(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>检查<code>RenderObject</code>是否需要重绘，并且通过<code>node._updateCompositingBits();</code>更新<code>_needsCompositing</code>这个属性，若为<code>true</code>就要重新绘制，否则不需要。</p>
<h4 id="4-3-flushPaint"><a href="#4-3-flushPaint" class="headerlink" title="4.3.flushPaint"></a>4.3.flushPaint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  void flushPaint() &#123;</span><br><span class="line">    profile(() &#123; Timeline.startSync(&#39;Paint&#39;, arguments: timelineWhitelistArguments); &#125;);</span><br><span class="line">    assert(() &#123;</span><br><span class="line">      _debugDoingPaint &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;());</span><br><span class="line">    try &#123;</span><br><span class="line">      final List&lt;RenderObject&gt; dirtyNodes &#x3D; _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint &#x3D; &lt;RenderObject&gt;[];</span><br><span class="line">      &#x2F;&#x2F; Sort the dirty nodes in reverse order (deepest first).</span><br><span class="line">      &#x2F;&#x2F;方向遍历这些标记过的node</span><br><span class="line">      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) &#x3D;&gt; b.depth - a.depth)) &#123;</span><br><span class="line">        assert(node._layer !&#x3D; null);</span><br><span class="line">        if (node._needsPaint &amp;&amp; node.owner &#x3D;&#x3D; this) &#123;</span><br><span class="line">          if (node._layer.attached) &#123;</span><br><span class="line">            &#x2F;&#x2F;重新绘制</span><br><span class="line">            PaintingContext.repaintCompositedChild(node);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            node._skippedPaintingOnLayer();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_nodesNeedingPaint.isEmpty);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        _debugDoingPaint &#x3D; false;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">      profile(() &#123; Timeline.finishSync(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个方法通过反向遍历(<code>dirty</code>标记)取得需要重绘的<code>RenderObject</code>，最后通过<code>PaintingContext.repaintCompositedChild(node);</code>重绘。</p>
<h4 id="4-4-compositeFrame"><a href="#4-4-compositeFrame" class="headerlink" title="4.4.compositeFrame"></a>4.4.compositeFrame</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  void compositeFrame() &#123;</span><br><span class="line">    Timeline.startSync(&#39;Compositing&#39;, arguments: timelineWhitelistArguments);</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;创建Scene对象</span><br><span class="line">      final ui.SceneBuilder builder &#x3D; ui.SceneBuilder();</span><br><span class="line">      final ui.Scene scene &#x3D; layer.buildScene(builder);</span><br><span class="line">      if (automaticSystemUiAdjustment)</span><br><span class="line">        _updateSystemChrome();</span><br><span class="line">      &#x2F;&#x2F;使用render方法将Scene对象显示在屏幕上    </span><br><span class="line">      _window.render(scene);&#x2F;&#x2F;调用flutter engine的渲染API</span><br><span class="line">      scene.dispose();</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        if (debugRepaintRainbowEnabled || debugRepaintTextRainbowEnabled)</span><br><span class="line">          debugCurrentRepaintColor &#x3D; debugCurrentRepaintColor.withHue((debugCurrentRepaintColor.hue + 2.0) % 360.0);</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>Scene</code>是用来保存渲染后的最终像素信息，这个方法将<code>Canvas</code>画好的<code>Scene</code>对象传给<code>window.render()</code>方法，该方法会直接将<code>Scene</code>信息发送给Flutter engine，最终Flutter engine将图像画在设备屏幕上，这样整个绘制流程就算完了。</p>
<p>注意：<code>RendererBinding</code>只是混入对象，最终混入到<code>WidgetsBinding</code>，回到最开始来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; Returns an instance of the [WidgetsBinding], creating and</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initializing it if necessary. If one is created, it will be a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding]. If one was previously initialized, then</span><br><span class="line">  &#x2F;&#x2F;&#x2F; it will at least implement [WidgetsBinding].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; You only need to call this method if you need the binding to be</span><br><span class="line">  &#x2F;&#x2F;&#x2F; initialized before calling [runApp].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; In the &#96;flutter_test&#96; framework, [testWidgets] initializes the</span><br><span class="line">  &#x2F;&#x2F;&#x2F; binding instance to a [TestWidgetsFlutterBinding], not a</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [WidgetsFlutterBinding].</span><br><span class="line">  static WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    if (WidgetsBinding.instance &#x3D;&#x3D; null)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    return WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以应该<code>WidgetsBinding</code>来重写实现<code>drawFrame</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  @override</span><br><span class="line">  void drawFrame() &#123;</span><br><span class="line">    assert(!debugBuildingDirtyElements);</span><br><span class="line">    assert(() &#123;</span><br><span class="line">      debugBuildingDirtyElements &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;());</span><br><span class="line">    try &#123;</span><br><span class="line">      if (renderViewElement !&#x3D; null)</span><br><span class="line">        buildOwner.buildScope(renderViewElement);</span><br><span class="line">      super.drawFrame(); &#x2F;&#x2F;调用Renderbinding的drawFrame方法</span><br><span class="line">      buildOwner.finalizeTree();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      assert(() &#123;</span><br><span class="line">        debugBuildingDirtyElements &#x3D; false;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">    profile(() &#123;</span><br><span class="line">      if (_needToReportFirstFrame &amp;&amp; _reportFirstFrame) &#123;</span><br><span class="line">        developer.Timeline.instantSync(&#39;Widgets completed first useful frame&#39;);</span><br><span class="line">        developer.postEvent(&#39;Flutter.FirstFrame&#39;, &lt;String, dynamic&gt;&#123;&#125;);</span><br><span class="line">        _needToReportFirstFrame &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li><code>widget</code>的功能是向<code>element</code>提供配置信息，每一个<code>widget</code>在Flutter里是一份配置数据，而代表屏幕背后的元素是<code>element</code>，而真正的布局、渲染是通过<code>RenderObject</code>来完成的，从创建到渲染的主要流程是：<code>widget</code>信息生成<code>element</code>，创建对应的<code>RenderObject</code>关联到<code>Element.renderObject</code>属性上，最后通过<code>RenderObject</code>布局和绘制。</li>
<li>Flutter从启动到显示图像在屏幕主要经过：首先监听处理<code>window</code>对象的事件，将这些事件处理包装为Framework模型进行分发，通过<code>widget</code>创建<code>element</code>树，接着通过<code>scheduleWarmUpFrame</code>进行渲染，接着通过<code>Rendererbinding</code>进行布局，绘制，最后通过调用<code>ui.window.render(scene)</code>Scene信息发给Flutter engine，Flutter engine最后调用渲染API把图像画在屏幕上。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/flutter/dart/drat%E6%96%B0%E9%A2%96%E8%AF%AD%E6%B3%95%E7%B3%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/12/flutter/dart/drat%E6%96%B0%E9%A2%96%E8%AF%AD%E6%B3%95%E7%B3%96/" itemprop="url">drat新颖语法糖</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-12T13:53:54+08:00">
                2020-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/dart/" itemprop="url" rel="index">
                    <span itemprop="name">dart</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/12/flutter/dart/drat%E6%96%B0%E9%A2%96%E8%AF%AD%E6%B3%95%E7%B3%96/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/12/flutter/dart/drat%E6%96%B0%E9%A2%96%E8%AF%AD%E6%B3%95%E7%B3%96/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="避空运算符"><a href="#避空运算符" class="headerlink" title="避空运算符"></a>避空运算符</h3><p>Dart 提供了一系列方便的运算符用于处理可能会为空值的变量。其中一个是 <code>??=</code> 赋值运算符，仅当该变量为空值时才为其赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a; &#x2F;&#x2F; The initial value of any object is null.</span><br><span class="line">a ??&#x3D; 3;</span><br><span class="line">print(a); &#x2F;&#x2F; &lt;-- Prints 3.</span><br><span class="line"></span><br><span class="line">a ??&#x3D; 5;</span><br><span class="line">print(a); &#x2F;&#x2F; &lt;-- Still prints 3.</span><br></pre></td></tr></table></figure>

<p>另外一个避空运算符是 <code>??</code>，如果该运算符左边的表达式返回的是空值，则会计算并返回右边的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(1 ?? 3); &#x2F;&#x2F; &lt;-- Prints 1.</span><br><span class="line">print(null ?? 12); &#x2F;&#x2F; &lt;-- Prints 12.</span><br></pre></td></tr></table></figure>

<h3 id="条件属性访问"><a href="#条件属性访问" class="headerlink" title="条件属性访问"></a>条件属性访问</h3><p>要保护可能会为空的属性的正常访问，请在点（<code>.</code>）之前加一个问号（<code>?</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject?.someProperty</span><br></pre></td></tr></table></figure>

<p>上述代码等效于以下内容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(myObject != <span class="keyword">null</span>) ? myObject.someProperty : <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>你可以在一个表达式中连续使用多个 <code>?.</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject?.someProperty?.someMethod()</span><br></pre></td></tr></table></figure>

<p>如果 <code>myObject</code> 或 <code>myObject.someProperty</code> 为空，则前面的代码返回 null（并不再调用 <code>someMethod</code>）。</p>
<h3 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h3><p>Dart 内置了对 list、map 以及 set 的支持。你可以通过字面量直接创建它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final aListOfStrings &#x3D; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];</span><br><span class="line">final aSetOfStrings &#x3D; &#123;&#39;one&#39;, &#39;two&#39;, &#39;three&#39;&#125;;</span><br><span class="line">final aMapOfStringsToInts &#x3D; &#123;</span><br><span class="line">  &#39;one&#39;: 1,</span><br><span class="line">  &#39;two&#39;: 2,</span><br><span class="line">  &#39;three&#39;: 3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Dart 的类型推断可以自动帮你分配这些变量的类型。在这个例子中，推断类型是 <code>List&lt;String&gt;</code>、<code>Set&lt;String&gt;</code>和 <code>Map&lt;String, int&gt;</code>。</p>
<p>你也可以手动指定类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> aListOfInts = &lt;<span class="built_in">int</span>&gt;[];</span><br><span class="line"><span class="keyword">final</span> aSetOfInts = &lt;<span class="built_in">int</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">final</span> aMapOfIntToDouble = &lt;<span class="built_in">int</span>, <span class="built_in">double</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在使用子类型的内容初始化列表，但仍希望列表为 <code>List &lt;BaseType&gt;</code> 时，指定其类型很方便：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> aListOfBaseType = &lt;BaseType&gt;[SubType(), SubType()];</span><br></pre></td></tr></table></figure>

<h3 id="箭头语法"><a href="#箭头语法" class="headerlink" title="箭头语法"></a>箭头语法</h3><p>你也许已经在 Dart 代码中见到过 <code>=&gt;</code> 符号。这种箭头语法是一种定义函数的方法，该函数将在其右侧执行表达式并返回其值。</p>
<p>例如，考虑调用这个 <code>List</code> 类中的 <code>any</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hasEmpty = aListOfStrings.any((s) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.isEmpty;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里是一个更简单的代码实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hasEmpty = aListOfStrings.any((s) =&gt; s.isEmpty);</span><br></pre></td></tr></table></figure>

<h3 id="级连"><a href="#级连" class="headerlink" title="级连"></a>级连</h3><p>要对同一对象执行一系列操作，请使用级联（<code>..</code>）。我们都看到过这样的表达式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.someMethod()</span><br></pre></td></tr></table></figure>

<p>它在 <code>myObject</code> 上调用 <code>someMethod</code> 方法，而表达式的结果是 <code>someMethod</code> 的返回值。</p>
<p>下面是一个使用级连语法的相同表达式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject..someMethod()</span><br></pre></td></tr></table></figure>

<p>虽然它仍然在 <code>myObject</code> 上调用了 <code>someMethod</code>，但表达式的结果却<strong>不是</strong>该方法返回值，而是是 <code>myObject</code> 对象的引用！使用级联，你可以将需要单独操作的语句链接在一起。例如，请考虑以下代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>);</span><br><span class="line">button.text = <span class="string">'Confirm'</span>;</span><br><span class="line">button.classes.add(<span class="string">'important'</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure>

<p>使用级连能够让代码变得更加简洁，而且你也不再需要 <code>button</code> 变量了。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>)</span><br><span class="line">..text = <span class="string">'Confirm'</span></span><br><span class="line">..classes.add(<span class="string">'important'</span>)</span><br><span class="line">..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure>

<h3 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a>Getters and setters</h3><p>任何需要对属性进行更多控制而不是允许简单字段访问的时候，你都可以自定义 getter 和 setter。</p>
<p>例如，你可以用来确保属性值合法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _aProperty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> aProperty =&gt; _aProperty;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> aProperty(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      _aProperty = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以使用 getter 来定义计算属性：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; _values = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addValue(<span class="built_in">int</span> value) &#123;</span><br><span class="line">    _values.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A computed property.</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count &#123;</span><br><span class="line">    <span class="keyword">return</span> _values.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h3><p>Dart 有两种传参方法：位置参数和命名参数。位置参数你可能会比较熟悉：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sumUp(<span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> total = sumUp(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在 Dart 中，你可以通过将这些参数包裹在大括号中使其变成可选位置参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sumUpToFive(<span class="built_in">int</span> a, [<span class="built_in">int</span> b, <span class="built_in">int</span> c, <span class="built_in">int</span> d, <span class="built_in">int</span> e]) &#123;</span><br><span class="line">  <span class="built_in">int</span> sum = a;</span><br><span class="line">  <span class="keyword">if</span> (b != <span class="keyword">null</span>) sum += b;</span><br><span class="line">  <span class="keyword">if</span> (c != <span class="keyword">null</span>) sum += c;</span><br><span class="line">  <span class="keyword">if</span> (d != <span class="keyword">null</span>) sum += d;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="keyword">null</span>) sum += e;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> total = sumUptoFive(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">int</span> otherTotal = sumUpToFive(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>可选位置参数永远放在方法参数列表的最后。除非你给它们提供一个默认值，否则默认为 null。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sumUpToFive(<span class="built_in">int</span> a, [<span class="built_in">int</span> b = <span class="number">2</span>, <span class="built_in">int</span> c = <span class="number">3</span>, <span class="built_in">int</span> d = <span class="number">4</span>, <span class="built_in">int</span> e = <span class="number">5</span>]) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> newTotal = sumUpToFive(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(newTotal); <span class="comment">// &lt;-- p</span></span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Dart 代码可以抛出和捕获异常。与 Java 相比，Dart 的所有异常都是 unchecked exception。方法不会声明它们可能抛出的异常，你也不需要捕获任何异常。</p>
<p>虽然 Dart 提供了 Exception 和 Error 类型，但是你可以抛出任何非空对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Exception(<span class="string">'Something bad happened.'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'Waaaaaaah!'</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>try</code>、<code>on</code> 以及 <code>catch</code> 关键字来处理异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Something really unknown: <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try</code> 关键字作用与其他大多数语言一样。使用 <code>on</code> 关键字按类型过滤特定异常，而 <code>catch</code> 关键字则能够获取捕捉到的异常对象的引用。</p>
<p>如果你无法完全处理该异常，请使用 <code>rethrow</code> 关键字再次抛出异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'I was just trying to breed llamas!.'</span>);</span><br><span class="line">  <span class="keyword">rethrow</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要执行一段无论是否抛出异常都会执行的代码，请使用 <code>finally</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  … handle exception ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Always clean up, even if an exception is thrown.</span></span><br><span class="line">  cleanLlamaStalls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在构造方法中使用-this"><a href="#在构造方法中使用-this" class="headerlink" title="在构造方法中使用 this"></a>在构造方法中使用 <code>this</code></h3><p>Dart 提供了一个方便的快捷方式，用于为构造方法中的属性赋值：在声明构造方法时使用 <code>this.propertyName</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> red;</span><br><span class="line">  <span class="built_in">int</span> green;</span><br><span class="line">  <span class="built_in">int</span> blue;</span><br><span class="line"></span><br><span class="line">  MyColor(<span class="keyword">this</span>.red, <span class="keyword">this</span>.green, <span class="keyword">this</span>.blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> color = MyColor(<span class="number">80</span>, <span class="number">80</span>, <span class="number">128</span>);</span><br></pre></td></tr></table></figure>

<p>此技巧同样也适用于命名参数。属性名为参数的名称：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  MyColor(&#123;<span class="keyword">this</span>.red, <span class="keyword">this</span>.green, <span class="keyword">this</span>.blue&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> color = MyColor(red: <span class="number">80</span>, green: <span class="number">80</span>, blue: <span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p>对于可选参数，默认值为期望值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyColor([<span class="keyword">this</span>.red = <span class="number">0</span>, <span class="keyword">this</span>.green = <span class="number">0</span>, <span class="keyword">this</span>.blue = <span class="number">0</span>]);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">MyColor(&#123;<span class="keyword">this</span>.red = <span class="number">0</span>, <span class="keyword">this</span>.green = <span class="number">0</span>, <span class="keyword">this</span>.blue = <span class="number">0</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Initializer-lists"><a href="#Initializer-lists" class="headerlink" title="Initializer lists"></a>Initializer lists</h3><p>有时，当你在实现构造函数时，您需要在构造函数体执行之前进行一些初始化。例如，final 修饰的字段必须在构造函数体执行之前赋值。在初始化列表中执行此操作，该列表位于构造函数的签名与其函数体之间：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">num</span>&gt; json)</span><br><span class="line">    : x = json[<span class="string">'x'</span>],</span><br><span class="line">      y = json[<span class="string">'y'</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表也是放置断言的便利位置，它仅会在开发期间运行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NonNegativePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y)</span><br><span class="line">    : <span class="keyword">assert</span>(x &gt;= <span class="number">0</span>),</span><br><span class="line">      <span class="keyword">assert</span>(y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'I just made a NonNegativePoint: (<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名构造方法"><a href="#命名构造方法" class="headerlink" title="命名构造方法"></a>命名构造方法</h3><p>为了允许一个类具有多个构造方法，Dart 支持命名构造方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使用命名构造方法，请使用全名调用它：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> myPoint = Point.origin();</span><br></pre></td></tr></table></figure>

<h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><p>Dart 支持工厂构造方法。它能够返回其子类甚至 null 对象。要创建一个工厂构造方法，请使用 <code>factory</code> 关键字。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Shape();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Shape.fromTypeName(<span class="built_in">String</span> typeName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="string">'square'</span>) <span class="keyword">return</span> Square();</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="string">'circle'</span>) <span class="keyword">return</span> Circle();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'I don\'t recognize <span class="subst">$typeName</span>'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重定向构造方法"><a href="#重定向构造方法" class="headerlink" title="重定向构造方法"></a>重定向构造方法</h3><p>有时一个构造方法仅仅用来重定向到该类的另一个构造方法。重定向方法没有主体，它在冒号（<code>:</code>）之后调用另一个构造方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> make;</span><br><span class="line">  <span class="built_in">String</span> model;</span><br><span class="line">  <span class="built_in">int</span> mpg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Automobile(<span class="keyword">this</span>.make, <span class="keyword">this</span>.model, <span class="keyword">this</span>.mpg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Automobile.hybrid(<span class="built_in">String</span> make, <span class="built_in">String</span> model) : <span class="keyword">this</span>(make, model, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to a named constructor</span></span><br><span class="line">  Automobile.fancyHybrid() : <span class="keyword">this</span>.hybrid(<span class="string">'Futurecar'</span>, <span class="string">'Mark 2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Const-构造方法"><a href="#Const-构造方法" class="headerlink" title="Const 构造方法"></a>Const 构造方法</h3><p>如果你的类生成的对象永远都不会更改，则可以让这些对象成为编译时常量。为此，请定义 <code>const</code> 构造方法并确保所有实例变量都是 final 的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ImmutablePoint origin =</span><br><span class="line">      ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/flutter/dart/drat%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/11/flutter/dart/drat%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/" itemprop="url">dart开发语言基础（2）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-11T22:21:02+08:00">
                2020-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/dart/" itemprop="url" rel="index">
                    <span itemprop="name">dart</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/11/flutter/dart/drat%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/11/flutter/dart/drat%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h2><p>Dart 是支持基于 mixin 继承机制的面向对象语言，所有对象都是一个类的实例，而所有的类都继承自 <a href="https://api.dart.dev/stable/dart-core/Object-class.html" target="_blank" rel="noopener">Object</a> 类。基于 <em>mixin 的继承</em> 意味着每个除 Object 类之外的类都只有一个超类，一个类的代码可以在其它多个类继承中重复使用。 <a href="https://dart.cn/guides/language/language-tour#extension-methods" target="_blank" rel="noopener">Extension 方法</a> 是一种在不更改类或创建子类的情况下向类添加功能的方式。</p>
<h3 id="1-1-使用类的成员"><a href="#1-1-使用类的成员" class="headerlink" title="1.1 使用类的成员"></a>1.1 使用类的成员</h3><p>对象的 <em>成员</em> 由函数和数据（即 <em>方法</em> 和 <em>实例变量*）组成。方法的 *调用</em> 要通过对象来完成，这种方式可以访问对象的函数和数据。</p>
<p>使用（<code>.</code>）来访问对象的实例变量或方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; Point(2, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为实例变量 y 赋值。</span><br><span class="line">p.y &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 y 的值。</span><br><span class="line">assert(p.y &#x3D;&#x3D; 3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用变量 p 的 distanceTo() 方法。</span><br><span class="line">double distance &#x3D; p.distanceTo(Point(4, 4));</span><br></pre></td></tr></table></figure>

<p>使用 <code>?.</code> 代替 <code>.</code> 可以避免因为左边表达式为 null 而导致的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; If p is non-null, set its y value to 4.</span><br><span class="line">&#x2F;&#x2F; 如果 p 为非空则将其属性 y 的值设为 4</span><br><span class="line">p?.y &#x3D; 4;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用构造函数"><a href="#1-2-使用构造函数" class="headerlink" title="1.2 使用构造函数"></a>1.2 使用构造函数</h3><p>可以使用 <em>构造函数</em> 来创建一个对象。构造函数的命名方式可以为 <code>*类名*</code> 或 <code>*类名* . *标识符*</code>的形式。例如下述代码分别使用 <code>Point()</code> 和 <code>Point.fromJson()</code> 两种构造器创建了 <code>Point</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; Point(2, 2);</span><br><span class="line">var p2 &#x3D; Point.fromJson(&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;);</span><br></pre></td></tr></table></figure>

<p>以下代码具有相同的效果，但是构造函数名前面的的 <code>new</code> 关键字是可选的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2, 2);</span><br><span class="line">var p2 &#x3D; new Point.fromJson(&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;);</span><br></pre></td></tr></table></figure>

<p> <strong>版本提示:</strong></p>
<p>从 Dart 2 开始，<code>new</code> 关键字是可选的。</p>
<p>一些类提供了<a href="https://dart.cn/guides/language/language-tour#constant-constructors" target="_blank" rel="noopener">常量构造函数</a>。使用常量构造函数，在构造函数名之前加 <code>const</code> 关键字，来创建编译时常量时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; const ImmutablePoint(2, 2);</span><br></pre></td></tr></table></figure>

<p>两个使用相同构造函数相同参数值构造的编译时常量是同一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; const ImmutablePoint(1, 1);</span><br><span class="line">var b &#x3D; const ImmutablePoint(1, 1);</span><br><span class="line"></span><br><span class="line">assert(identical(a, b)); &#x2F;&#x2F; 它们是同一个实例 (They are the same instance!)</span><br></pre></td></tr></table></figure>

<p>根据使用 <em>常量上下文</em> 的场景，你可以省略掉构造函数或字面量前的 <code>const</code> 关键字。例如下面的例子中我们创建了一个常量 Map：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lots of const keywords here.</span><br><span class="line">&#x2F;&#x2F; 这里有很多 const 关键字</span><br><span class="line">const pointAndLine &#x3D; const &#123;</span><br><span class="line">  &#39;point&#39;: const [const ImmutablePoint(0, 0)],</span><br><span class="line">  &#39;line&#39;: const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上下文，你可以只保留第一个 <code>const</code> 关键字，其余的全部省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Only one const, which establishes the constant context.</span><br><span class="line">&#x2F;&#x2F; 只需要一个 const 关键字，其它的则会隐式地根据上下文进行关联。</span><br><span class="line">const pointAndLine &#x3D; &#123;</span><br><span class="line">  &#39;point&#39;: [ImmutablePoint(0, 0)],</span><br><span class="line">  &#39;line&#39;: [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是如果无法根据上下文判断是否可以省略 <code>cosnt</code>，则不能省略掉 <code>const</code> 关键字，否则将会创建一个 <strong>非常量对象</strong> 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; const ImmutablePoint(1, 1); &#x2F;&#x2F; 创建一个常量 (Creates a constant)</span><br><span class="line">var b &#x3D; ImmutablePoint(1, 1); &#x2F;&#x2F; 不会创建一个常量 (Does NOT create a constant)</span><br><span class="line"></span><br><span class="line">assert(!identical(a, b)); &#x2F;&#x2F; 这两变量并不相同 (NOT the same instance!)</span><br></pre></td></tr></table></figure>

<p> <strong>版本提示:</strong></p>
<p>只有从 Dart 2 开始才能根据上下文判断省略 <code>const</code> 关键字。</p>
<h3 id="1-3-获取对象的类型"><a href="#1-3-获取对象的类型" class="headerlink" title="1.3 获取对象的类型"></a>1.3 获取对象的类型</h3><p>可以使用 Object 对象的 <code>runtimeType</code> 属性在运行时获取一个对象的类型，该对象类型是 <a href="https://api.dart.dev/stable/dart-core/Type-class.html" target="_blank" rel="noopener">Type</a> 的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;The type of a is $&#123;a.runtimeType&#125;&#39;);</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们已经解了如何 <em>使用</em> 类。本节的其余部分将向你介绍如何 <em>实现</em> 一个类。</p>
<h3 id="1-4-实例变量"><a href="#1-4-实例变量" class="headerlink" title="1.4 实例变量"></a>1.4 实例变量</h3><p>下面是声明实例变量的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  double x; &#x2F;&#x2F; 声明 double 变量 x 并初始化为 null。</span><br><span class="line">  double y; &#x2F;&#x2F; 声明 double 变量 y 并初始化为 null</span><br><span class="line">  double z &#x3D; 0; &#x2F;&#x2F; 声明 double 变量 z 并初始化为 0。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有未初始化的实例变量其值均为 <code>null</code>。</p>
<p>所有实例变量均会隐式地声明一个 <em>Getter</em> 方法，非 final 类型的实例变量还会隐式地声明一个 <em>Setter</em> 方法。你可以查阅 <a href="https://dart.cn/guides/language/language-tour#getters-and-setters" target="_blank" rel="noopener">Getter 和 Setter</a> 获取更多相关信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  double x;</span><br><span class="line">  double y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var point &#x3D; Point();</span><br><span class="line">  point.x &#x3D; 4; &#x2F;&#x2F; 使用 x 的 Setter 方法。</span><br><span class="line">  assert(point.x &#x3D;&#x3D; 4); &#x2F;&#x2F; 使用 x 的 Getter 方法。</span><br><span class="line">  assert(point.y &#x3D;&#x3D; null); &#x2F;&#x2F; 默认值为 null。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你在声明一个实例变量的时候就将其初始化（而不是在构造函数或其它方法中），那么该实例变量的值就会在对象实例创建的时候被设置，该过程会在构造函数以及它的初始化器列表执行前。</p>
<h3 id="1-5-构造函数"><a href="#1-5-构造函数" class="headerlink" title="1.5 构造函数"></a>1.5 构造函数</h3><p>声明一个与类名一样的函数即可声明一个构造函数（对于<a href="https://dart.cn/guides/language/language-tour#named-constructors" target="_blank" rel="noopener">命名式构造函数</a> 还可以添加额外的标识符）。大部分的构造函数形式是生成式构造函数，其用于创建一个类的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line"></span><br><span class="line">  Point(double x, double y) &#123;</span><br><span class="line">    &#x2F;&#x2F; 还会有更好的方式来实现此逻辑，敬请期待。</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>this</code> 关键字引用当前实例。</p>
<p> <strong>备忘:</strong></p>
<blockquote>
<p>当且仅当命名冲突时使用 <code>this</code> 关键字才有意义，否则 Dart 会忽略 <code>this</code> 关键字。</p>
</blockquote>
<p>对于大多数编程语言来说在构造函数中为实例变量赋值的过程都是类似的，而 Dart 则提供了一种特殊的语法糖来简化该步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在构造函数体执行前用于设置 x 和 y 的语法糖。</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-默认构造函数"><a href="#1-5-1-默认构造函数" class="headerlink" title="1.5.1 默认构造函数"></a>1.5.1 默认构造函数</h4><p>如果你没有声明构造函数，那么 Dart 会自动生成一个无参数的构造函数并且该构造函数会调用其父类的无参数构造方法。</p>
<h4 id="1-5-2-构造函数不被继承"><a href="#1-5-2-构造函数不被继承" class="headerlink" title="1.5.2 构造函数不被继承"></a>1.5.2 构造函数不被继承</h4><p>子类不会继承父类的构造函数，如果子类没有声明构造函数，那么只会有一个默认无参数的构造函数。</p>
<h4 id="1-5-3-命名式构造函数"><a href="#1-5-3-命名式构造函数" class="headerlink" title="1.5.3 命名式构造函数"></a>1.5.3 命名式构造函数</h4><p>可以为一个类声明多个命名式构造函数来表达更明确的意图：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名式构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住构造函数是不能被继承的，这将意味着子类不能继承父类的命名式构造函数，如果你想在子类中提供一个与父类命名构造函数名字一样的命名构造函数，则需要在子类中显式地声明。</p>
<h4 id="1-5-4-调用父类非默认构造函数"><a href="#1-5-4-调用父类非默认构造函数" class="headerlink" title="1.5.4 调用父类非默认构造函数"></a>1.5.4 调用父类非默认构造函数</h4><p>默认情况下，子类的构造函数会调用父类的匿名无参数构造方法，并且该调用会在子类构造函数的函数体代码执行前，如果子类构造函数还有一个 <a href="https://dart.cn/guides/language/language-tour#initializer-list" target="_blank" rel="noopener">初始化列表</a>，那么该初始化列表会在调用父类的该构造函数之前被执行，总的来说，这三者的调用顺序如下：</p>
<ol>
<li>初始化列表</li>
<li>父类的无参数构造函数</li>
<li>当前类的构造函数</li>
</ol>
<p>如果父类没有匿名无参数构造函数，那么子类必须调用父类的其中一个构造函数，为子类的构造函数指定一个父类的构造函数只需在构造函数体前使用（<code>:</code>）指定。</p>
<p>下面的示例中，Employee 类的构造函数调用了父类 Person 的命名构造函数。点击运行按钮执行示例代码。</p>
<iframe src="https://dartpad.cn/embed-inline.html?id=e57aa06401e6618d4eb8&amp;split=90&amp;ga_id=non_default_superclass_constructor" width="100%" height="500px" style="box-sizing: border-box; color: rgb(33, 37, 41); font-family: &quot;Noto Sans SC&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; border: 1px solid rgb(204, 204, 204);"></iframe>

<p>因为参数会在子类构造函数被执行前传递给父类的构造函数，因此该参数也可以是一个表达式，比如一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Employee extends Person &#123;</span><br><span class="line">  Employee() : super.fromJson(defaultData);</span><br><span class="line">  &#x2F;&#x2F; ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>请注意:</strong></p>
<blockquote>
<p>传递给父类构造函数的参数不能使用 <code>this</code> 关键字，因为在参数传递的这一步骤，子类构造函数尚未执行，子类的实例对象也就还未初始化，因此所有的实例成员都不能被访问，但是类成员可以。</p>
</blockquote>
<h4 id="1-5-5-初始化列表"><a href="#1-5-5-初始化列表" class="headerlink" title="1.5.5 初始化列表"></a>1.5.5 初始化列表</h4><p>除了调用父类构造函数之外，还可以在构造函数体执行之前初始化实例变量。每个实例变量之间使用逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initializer list sets instance variables before</span><br><span class="line">&#x2F;&#x2F; the constructor body runs.</span><br><span class="line">&#x2F;&#x2F; 使用初始化列表在构造函数体执行前设置实例变量。</span><br><span class="line">Point.fromJson(Map&lt;String, double&gt; json)</span><br><span class="line">    : x &#x3D; json[&#39;x&#39;],</span><br><span class="line">      y &#x3D; json[&#39;y&#39;] &#123;</span><br><span class="line">  print(&#39;In Point.fromJson(): ($x, $y)&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>请注意:</strong></p>
<blockquote>
<p>初始化列表表达式 = 右边的语句不能使用 <code>this</code> 关键字。</p>
</blockquote>
<p>在开发模式下，你可以在初始化列表中使用 <code>assert</code> 来验证输入数据：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point.withAssert(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : <span class="keyword">assert</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In Point.withAssert(): (<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表用来设置 <code>final</code> 字段是非常好用的，下面的示例中就使用初始化列表来设置了三个 <code>final</code> 变量的值。点击运行按钮执行示例代码。</p>
<iframe src="https://dartpad.cn/embed-inline.html?id=7a9764702c0608711e08&amp;split=90&amp;ga_id=initializer_list" width="100%" height="420px" style="box-sizing: border-box; color: rgb(33, 37, 41); font-family: &quot;Noto Sans SC&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; border: 1px solid rgb(204, 204, 204);"></iframe>

<h4 id="1-5-6-重定向构造函数"><a href="#1-5-6-重定向构造函数" class="headerlink" title="1.5.6 重定向构造函数"></a>1.5.6 重定向构造函数</h4><p>有时候类中的构造函数会调用类中其它的构造函数，该重定向构造函数没有函数体，只需在函数签名后使用（:）指定需要重定向到的其它构造函数即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 该类的主构造函数。</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 委托实现给主构造函数。</span><br><span class="line">  Point.alongXAxis(double x) : this(x, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-7-常量构造函数"><a href="#1-5-7-常量构造函数" class="headerlink" title="1.5.7 常量构造函数"></a>1.5.7 常量构造函数</h4><p>如果类生成的对象都是不会变的，那么可以在生成这些对象时就将其变为编译时常量。你可以在类的构造函数前加上 <code>const</code> 关键字并确保所有实例变量均为 <code>final</code> 来实现该功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ImmutablePoint &#123;</span><br><span class="line">  static final ImmutablePoint origin &#x3D;</span><br><span class="line">      const ImmutablePoint(0, 0);</span><br><span class="line"></span><br><span class="line">  final double x, y;</span><br><span class="line"></span><br><span class="line">  const ImmutablePoint(this.x, this.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量构造函数创建的实例并不总是常量，具体可以参考<a href="https://dart.cn/guides/language/language-tour#using-constructors" target="_blank" rel="noopener">使用构造函数</a>章节。</p>
<h4 id="1-5-8-工厂构造函数"><a href="#1-5-8-工厂构造函数" class="headerlink" title="1.5.8 工厂构造函数"></a>1.5.8 工厂构造函数</h4><p>使用 <code>factory</code> 关键字标识类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时并非总是会返回新的实例对象。例如，工厂构造函数可能会从缓存中返回一个实例，或者返回一个子类型的实例。</p>
<p>以下示例演示了从缓存中返回对象的工厂构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  bool mute &#x3D; false;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; _cache 变量是库私有的，因为在其名字前面有下划线。</span><br><span class="line">  static final Map&lt;String, Logger&gt; _cache &#x3D;</span><br><span class="line">      &lt;String, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  factory Logger(String name) &#123;</span><br><span class="line">    return _cache.putIfAbsent(</span><br><span class="line">        name, () &#x3D;&gt; Logger._internal(name));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(this.name);</span><br><span class="line"></span><br><span class="line">  void log(String msg) &#123;</span><br><span class="line">    if (!mute) print(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<blockquote>
<p>在工厂构造函数中无法访问 <code>this</code>。</p>
</blockquote>
<p>工厂构造函的调用方式与其他构造函数一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var logger &#x3D; Logger(&#39;UI&#39;);</span><br><span class="line">logger.log(&#39;Button clicked&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="1-6-方法"><a href="#1-6-方法" class="headerlink" title="1.6 方法"></a>1.6 方法</h3><p>方法是对象提供行为的函数。</p>
<h4 id="1-6-1-实例方法"><a href="#1-6-1-实例方法" class="headerlink" title="1.6.1 实例方法"></a>1.6.1 实例方法</h4><p>对象的实例方法可以访问实例变量和 <code>this</code>。下面的 <code>distanceTo()</code> 方法就是一个实例方法的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39;;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line"></span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line"></span><br><span class="line">  double distanceTo(Point other) &#123;</span><br><span class="line">    var dx &#x3D; x - other.x;</span><br><span class="line">    var dy &#x3D; y - other.y;</span><br><span class="line">    return sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-Getter-和-Setter"><a href="#1-6-2-Getter-和-Setter" class="headerlink" title="1.6.2 Getter 和 Setter"></a>1.6.2 Getter 和 Setter</h4><p>Getter 和 Setter 是一对用来读写对象属性的特殊方法，上面说过实例对象的每一个属性都有一个隐式的 Getter 方法，如果为非 final 属性的话还会有一个 Setter 方法，你可以使用 <code>get</code> 和 <code>set</code> 关键字为额外的属性添加 Getter 和 Setter 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">  double left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(this.left, this.top, this.width, this.height);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 定义两个计算产生的属性：right 和 bottom。</span><br><span class="line">  double get right &#x3D;&gt; left + width;</span><br><span class="line">  set right(double value) &#x3D;&gt; left &#x3D; value - width;</span><br><span class="line">  double get bottom &#x3D;&gt; top + height;</span><br><span class="line">  set bottom(double value) &#x3D;&gt; top &#x3D; value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var rect &#x3D; Rectangle(3, 4, 20, 15);</span><br><span class="line">  assert(rect.left &#x3D;&#x3D; 3);</span><br><span class="line">  rect.right &#x3D; 12;</span><br><span class="line">  assert(rect.left &#x3D;&#x3D; -8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Getter 和 Setter 的好处是，你可以先使用你的实例变量，过一段时间过再将它们包裹成方法且不需要改动任何代码，即先定义后更改且不影响原有逻辑。</p>
<p> <strong>备忘:</strong></p>
<blockquote>
<p>像自增（++）这样的操作符不管是否定义了 Getter 方法都会正确地执行。为了避免一些不必要的异常情况，运算符只会调用 Getter 一次，然后将其值存储在一个临时变量中。</p>
</blockquote>
<h3 id="1-7-抽象类"><a href="#1-7-抽象类" class="headerlink" title="1.7 抽象类"></a>1.7 抽象类</h3><p>使用关键字 <code>abstract</code> 标识类可以让该类成为 <em>抽象类</em>，抽象类将无法被实例化。抽象类常用于声明接口方法、有时也会有具体的方法实现。如果想让抽象类同时可被实例化，可以为其定义 <a href="https://dart.cn/guides/language/language-tour#工厂构造函数" target="_blank" rel="noopener">工厂构造函数</a>。</p>
<p>抽象类常常会包含 <a href="https://dart.cn/guides/language/language-tour#abstract-methods" target="_blank" rel="noopener">抽象方法</a>。下面是一个声明具有抽象方法的抽象类示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; This class is declared abstract and thus</span><br><span class="line">&#x2F;&#x2F; can&#39;t be instantiated.</span><br><span class="line">&#x2F;&#x2F; 该类被声明为抽象的，因此它不能被实例化。</span><br><span class="line">abstract class AbstractContainer &#123;</span><br><span class="line">  &#x2F;&#x2F; 定义构造函数、字段、方法等……</span><br><span class="line"></span><br><span class="line">  void updateChildren(); &#x2F;&#x2F; 抽象方法。</span><br></pre></td></tr></table></figure>

<h3 id="1-8-隐式接口"><a href="#1-8-隐式接口" class="headerlink" title="1.8 隐式接口"></a>1.8 隐式接口</h3><p>每一个类都隐式地定义了一个接口并实现了该接口，这个接口包含所有这个类的实例成员以及这个类所实现的其它接口。如果想要创建一个 A 类支持调用 B 类的 API 且不想继承 B 类，则可以实现 B 类的接口。</p>
<p>一个类可以通过关键字 <code>implements</code> 来实现一个或多个接口并实现每个接口定义的 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A person. The implicit interface contains greet().</span><br><span class="line">&#x2F;&#x2F; Person 类的隐式接口中包含 greet() 方法。</span><br><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; _name 变量同样包含在接口中，但它只是库内可见的。</span><br><span class="line">  final _name;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 构造函数不在接口中。</span><br><span class="line">  Person(this._name);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; greet() 方法在接口中。</span><br><span class="line">  String greet(String who) &#x3D;&gt; &#39;你好，$who。我是$_name。&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Person 接口的一个实现。</span><br><span class="line">class Impostor implements Person &#123;</span><br><span class="line">  get _name &#x3D;&gt; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">  String greet(String who) &#x3D;&gt; &#39;你好$who。你知道我是谁吗？&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String greetBob(Person person) &#x3D;&gt; person.greet(&#39;小芳&#39;);</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  print(greetBob(Person(&#39;小芸&#39;)));</span><br><span class="line">  print(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要实现多个类接口，可以使用逗号分割每个接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Point implements Comparable, Location &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Point implements Comparable, Location &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-扩展一个类"><a href="#1-8-扩展一个类" class="headerlink" title="1.8 扩展一个类"></a>1.8 扩展一个类</h3><p>使用 <code>extends</code> 关键字来创建一个子类，并可使用 <code>super</code> 关键字引用一个父类：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-1-重写类成员"><a href="#1-8-1-重写类成员" class="headerlink" title="1.8.1 重写类成员"></a>1.8.1 重写类成员</h4><p>子类可以重写父类的实例方法、Getter 以及 Setter 方法。你可以使用 <code>@override</code> 注解来表示你重写了一个成员：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限定方法参数以及实例变量的类型可以让代码更加 <a href="https://dart.cn/guides/language/sound-dart" target="_blank" rel="noopener">类型安全</a>，你可以使用 <a href="https://dart.cn/guides/language/sound-problems#the-covariant-keyword" target="_blank" rel="noopener">协变关键字</a>。</p>
<h4 id="重写运算符"><a href="#重写运算符" class="headerlink" title="重写运算符"></a>重写运算符</h4><p>可以在一个类中重写下表所罗列出的所有运算符。比如如果定一个 Vector 表示矢量的类，那么可以考虑重写 <code>+</code> 操作符来处理两个矢量的相加。</p>
<p>| <code>&lt;</code>  | <code>+</code>  | <code>|</code>  | <code>[]</code>  |<br>| —- | —- | —- | —– |<br>| <code>&gt;</code>  | <code>/</code>  | <code>^</code>  | <code>[]=</code> |<br>| <code>&lt;=</code> | <code>~/</code> | <code>&amp;</code>  | <code>~</code>   |<br>| <code>&gt;=</code> | <code>*</code>  | <code>&lt;&lt;</code> | <code>==</code>  |<br>| <code>–</code>  | <code>%</code>  | <code>&gt;&gt;</code> |       |</p>
<p> <strong>备忘:</strong></p>
<p>必须要注意的是 <code>!=</code> 操作符并不是一个可被重写的操作符。表达式 <code>e1 != e2</code> 仅仅是 <code>!(e1 == e2)</code> 的一个语法糖。</p>
<p>下面是重写 <code>+</code> 和 <code>-</code> 操作符的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Vector &#123;</span><br><span class="line">  final int x, y;</span><br><span class="line"></span><br><span class="line">  Vector(this.x, this.y);</span><br><span class="line"></span><br><span class="line">  Vector operator +(Vector v) &#x3D;&gt; Vector(x + v.x, y + v.y);</span><br><span class="line">  Vector operator -(Vector v) &#x3D;&gt; Vector(x - v.x, y - v.y);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 运算符 &#x3D;&#x3D; 和 hashCode 的实现未在这里展示，详情请查看下方说明。</span><br><span class="line">  &#x2F;&#x2F; ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  final v &#x3D; Vector(2, 3);</span><br><span class="line">  final w &#x3D; Vector(2, 2);</span><br><span class="line"></span><br><span class="line">  assert(v + w &#x3D;&#x3D; Vector(4, 5));</span><br><span class="line">  assert(v - w &#x3D;&#x3D; Vector(0, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果重写 <code>==</code> 操作符，必须也同时重写对象 <code>hashCode</code> 的 Getter 方法。你可以查阅 <a href="https://dart.cn/guides/libraries/library-tour#implementing-map-keys" target="_blank" rel="noopener">实现映射键</a> 获取更多关于重写的 <code>==</code> 和 <code>hashCode</code> 的例子。</p>
<p>你也可以查阅 <a href="https://dart.cn/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">扩展一个类</a>获取更多关于重写的信息。</p>
<h4 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h4><p>如果调用了对象上不存在的方法或实例变量将会触发 <code>noSuchMethod</code> 方法，你可以重写 <code>noSuchMethod</code> 方法来追踪和记录这一行为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 除非你重写 noSuchMethod，否则调用一个不存在的成员会导致 NoSuchMethodError。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'你尝试使用一个不存在的成员：'</span> +</span><br><span class="line">  <span class="string">'<span class="subst">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你不能调用一个未实现的方法除非下面其中的一个条件成立：</p>
<ul>
<li>接收方是静态的 <code>dynamic</code> 类型。</li>
<li>接收方具有静态类型，定义了未实现的方法（抽象亦可），并且接收方的动态类型实现了 <code>noSuchMethod</code> 方法且具体的实现与 <code>Object</code> 中的不同。</li>
</ul>
<p>你可以查阅 <a href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/nosuchmethod-forwarding.md" target="_blank" rel="noopener">noSuchMethod 转发规范</a>获取更多相关信息。</p>
<h3 id="1-9-Extension-方法"><a href="#1-9-Extension-方法" class="headerlink" title="1.9 Extension 方法"></a>1.9 Extension 方法</h3><p>Dart 2.7 中引入的 Extension 方法是向现有库添加功能的一种方式。你可能甚至都不知道有 Extension 方法。例如，当您在 IDE 中使用代码完成功能时，它建议将 Extension 方法与常规方法一起使用。</p>
<p>这里是一个在 <code>String</code> 中使用 extension 方法的样例，我们取名为 <code>parseInt()</code>，它在 <code>string_apis.dart</code> 中定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;string_apis.dart&#39;;</span><br><span class="line">...</span><br><span class="line">print(&#39;42&#39;.padLeft(5)); &#x2F;&#x2F; Use a String method.</span><br><span class="line">print(&#39;42&#39;.parseInt()); &#x2F;&#x2F; Use an extension method.</span><br></pre></td></tr></table></figure>

<p>有关使用以及实现 extension 方法的详细信息，请参阅 <a href="https://dart.cn/guides/language/extension-methods" target="_blank" rel="noopener">extension methods 页面</a>.</p>
<h3 id="1-10-使用枚举"><a href="#1-10-使用枚举" class="headerlink" title="1.10 使用枚举"></a>1.10 使用枚举</h3><p>使用关键字 <code>enum</code> 来定义枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure>

<p>每一个枚举值都有一个名为 <code>index</code> 成员变量的 Getter 方法，该方法将会返回以 0 为基准索引的位置值。例如，第一个枚举值的索引是 0 ，第二个枚举值的索引是 1。以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(Color.red.index &#x3D;&#x3D; 0);</span><br><span class="line">assert(Color.green.index &#x3D;&#x3D; 1);</span><br><span class="line">assert(Color.blue.index &#x3D;&#x3D; 2);</span><br></pre></td></tr></table></figure>

<p>可以使用枚举类的 <code>values</code> 方法获取一个包含所有枚举值的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Color&gt; colors &#x3D; Color.values;</span><br><span class="line">assert(colors[2] &#x3D;&#x3D; Color.blue);</span><br></pre></td></tr></table></figure>

<p>你可以在 <a href="https://dart.cn/guides/language/language-tour#switch-和-case" target="_blank" rel="noopener">Switch 语句</a>中使用枚举，但是需要注意的是必须处理枚举值的每一种情况，即每一个枚举值都必须成为一个 case 子句，不然会出现警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var aColor &#x3D; Color.blue;</span><br><span class="line"></span><br><span class="line">switch (aColor) &#123;</span><br><span class="line">  case Color.red:</span><br><span class="line">    print(&#39;红如玫瑰！&#39;);</span><br><span class="line">    break;</span><br><span class="line">  case Color.green:</span><br><span class="line">    print(&#39;绿如草原！&#39;);</span><br><span class="line">    break;</span><br><span class="line">  default: &#x2F;&#x2F; 没有该语句会出现警告。</span><br><span class="line">    print(aColor); &#x2F;&#x2F; &#39;Color.blue&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型有如下两个限制：</p>
<ul>
<li>枚举不能成为子类，也不可以 mix in，你也不可以实现一个枚举。</li>
<li>不能显式地实例化一个枚举类。</li>
</ul>
<p>你可以查阅 [Dart 编程语言规范][]获取更多相关信息。</p>
<h3 id="1-11-使用-Mixin-为类添加功能"><a href="#1-11-使用-Mixin-为类添加功能" class="headerlink" title="1.11 使用 Mixin 为类添加功能"></a>1.11 使用 Mixin 为类添加功能</h3><p>Mixin 是一种在多重继承中复用某个类中代码的方法模式。</p>
<p>使用 <code>with</code> 关键字并在其后跟上 Mixin 类的名字来使用 Mixin 模式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类继承自 Object 并且不为该类定义构造函数，这个类就是 Mixin 类，除非你想让该类与普通的类一样可以被正常地使用，否则可以使用关键字 <code>mixin</code> 替代 <code>class</code> 让其成为一个单纯的 Mixin 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mixin Musical &#123;</span><br><span class="line">  bool canPlayPiano &#x3D; false;</span><br><span class="line">  bool canCompose &#x3D; false;</span><br><span class="line">  bool canConduct &#x3D; false;</span><br><span class="line"></span><br><span class="line">  void entertainMe() &#123;</span><br><span class="line">    if (canPlayPiano) &#123;</span><br><span class="line">      print(&#39;Playing piano&#39;);</span><br><span class="line">    &#125; else if (canConduct) &#123;</span><br><span class="line">      print(&#39;Waving hands&#39;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      print(&#39;Humming to self&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用关键字 <code>on</code> 来指定哪些类可以使用该 Mixin 类，比如有 Mixin 类 A，但是 A 只能被 B 类使用，则可以这样定义 A：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mixin MusicalPerformer on Musician &#123;</span><br><span class="line">  &#x2F;&#x2F; ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>版本提示:</strong></p>
<p><code>mixin</code> 关键字在 Dart 2.1 中才被引用支持。早期版本中的代码通常使用 <code>abstract class</code> 代替。你可以查阅 <a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md" target="_blank" rel="noopener">Dart SDK 变</a></p>
<h3 id="1-12-类变量和方法"><a href="#1-12-类变量和方法" class="headerlink" title="1.12 类变量和方法"></a>1.12 类变量和方法</h3><p>使用关键字 <code>static</code> 可以声明类变量或类方法。</p>
<h4 id="1-12-1静态变量"><a href="#1-12-1静态变量" class="headerlink" title="1.12.1静态变量"></a>1.12.1静态变量</h4><p>静态变量（即类变量）常用于声明类范围内所属的状态变量和常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">  static const initialCapacity &#x3D; 16;</span><br><span class="line">  &#x2F;&#x2F; ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  assert(Queue.initialCapacity &#x3D;&#x3D; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量在其首次被使用的时候才被初始化。</p>
<h4 id="1-12-2-静态方法"><a href="#1-12-2-静态方法" class="headerlink" title="1.12.2 静态方法"></a>1.12.2 静态方法</h4><p>静态方法（即类方法）不能被一个类的实例访问，同样地，静态方法内也不可以使用 <code>this</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39;;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line"></span><br><span class="line">  static double distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    var dx &#x3D; a.x - b.x;</span><br><span class="line">    var dy &#x3D; a.y - b.y;</span><br><span class="line">    return sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var a &#x3D; Point(2, 2);</span><br><span class="line">  var b &#x3D; Point(4, 4);</span><br><span class="line">  var distance &#x3D; Point.distanceBetween(a, b);</span><br><span class="line">  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);</span><br><span class="line">  print(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<p>对于一些通用或常用的静态方法，应该将其定义为顶级函数而非静态方法。</p>
<p>可以将静态方法作为编译时常量。例如，你可以将静态方法作为一个参数传递给一个常量构造函数。</p>
<h2 id="二、泛型"><a href="#二、泛型" class="headerlink" title="二、泛型"></a>二、泛型</h2><p>如果你查看数组的 API 文档，你会发现数组 <a href="https://api.dart.dev/stable/dart-core/List-class.html" target="_blank" rel="noopener">List</a> 的实际类型为 <code>List&lt;E&gt;</code>。 &lt;…&gt; 符号表示数组是一个 <em>泛型</em>（或 <em>参数化类型</em>） <a href="https://dart.cn/guides/language/effective-dart/design#do-follow-existing-mnemonic-conventions-when-naming-type-parameters" target="_blank" rel="noopener">通常</a> 使用一个字母来代表类型参数，比如E、T、S、K 和 V 等等。</p>
<h3 id="2-1-为什么使用泛型？"><a href="#2-1-为什么使用泛型？" class="headerlink" title="2.1 为什么使用泛型？"></a>2.1 为什么使用泛型？</h3><p>泛型常用于需要要求类型安全的情况，但是它也会对代码运行有好处：</p>
<ul>
<li>适当地指定泛型可以更好地帮助代码生成。</li>
<li>使用泛型可以减少代码重复。</li>
</ul>
<p>比如你想声明一个只能包含 String 类型的数组，你可以将该数组声明为 <code>List&lt;String&gt;</code>（读作“字符串类型的 list”），这样的话就可以很容易避免因为在该数组放入非 String 类变量而导致的诸多问题，同时编译器以及其他阅读代码的人都可以很容易地发现并定位问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var names &#x3D; List&lt;String&gt;();</span><br><span class="line">names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);</span><br><span class="line">names.add(42); &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>另一个使用泛型的原因是可以减少重复代码。泛型可以让你在多个不同类型实现之间共享同一个接口声明，比如下面的例子中声明了一个类用于缓存对象的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class ObjectCache &#123;</span><br><span class="line">  Object getByKey(String key);</span><br><span class="line">  void setByKey(String key, Object value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不久后你可能又会想专门为 String 类对象做一个缓存，于是又有了专门为 String 做缓存的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class StringCache &#123;</span><br><span class="line">  String getByKey(String key);</span><br><span class="line">  void setByKey(String key, String value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果过段时间你又想为数字类型也创建一个类，那么就会有很多诸如此类的代码……</p>
<p>这时候可以考虑使用泛型来声明一个类，让不同类型的缓存实现该类做出不同的具体实现即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Cache&lt;T&gt; &#123;</span><br><span class="line">  T getByKey(String key);</span><br><span class="line">  void setByKey(String key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，T 是一个替代类型。其相当于类型占位符，在开发者调用该接口的时候会指定具体类型。</p>
<h3 id="2-2-使用集合字面量"><a href="#2-2-使用集合字面量" class="headerlink" title="2.2 使用集合字面量"></a>2.2 使用集合字面量</h3><p>List、Set 以及 Map 字面量也可以是参数化的。定义参数化的 List 只需在中括号前添加 <code>&lt;*type*&gt;</code>；定义参数化的 Map 只需要在大括号前添加 <code>&lt;*keyType*, *valueType*&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var names &#x3D; &lt;String&gt;[&#39;小芸&#39;, &#39;小芳&#39;, &#39;小民&#39;];</span><br><span class="line">var uniqueNames &#x3D; &lt;String&gt;&#123;&#39;小芸&#39;, &#39;小芳&#39;, &#39;小民&#39;&#125;;</span><br><span class="line">var pages &#x3D; &lt;String, String&gt;&#123;</span><br><span class="line">  &#39;index.html&#39;: &#39;主页&#39;,</span><br><span class="line">  &#39;robots.txt&#39;: &#39;网页机器人提示&#39;,</span><br><span class="line">  &#39;humans.txt&#39;: &#39;我们是人类，不是机器&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用类型参数化的构造函数"><a href="#2-3-使用类型参数化的构造函数" class="headerlink" title="2.3 使用类型参数化的构造函数"></a>2.3 使用类型参数化的构造函数</h3><p>在调用构造方法时也可以使用泛型，只需在类名后用尖括号（<code>&lt;...&gt;</code>）将一个或多个类型包裹即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var nameSet &#x3D; Set&lt;String&gt;.from(names);</span><br></pre></td></tr></table></figure>

<p>下面代码创建了一个键为 Int 类型，值为 View 类型的 Map 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var views &#x3D; Map&lt;int, View&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-泛型集合以及它们所包含的类型"><a href="#2-4-泛型集合以及它们所包含的类型" class="headerlink" title="2.4 泛型集合以及它们所包含的类型"></a>2.4 泛型集合以及它们所包含的类型</h3><p>Dart的泛型类型是 <em>固化的</em>，这意味着即便在运行时也会保持类型信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var names &#x3D; List&lt;String&gt;();</span><br><span class="line">names.addAll([&#39;小芸&#39;, &#39;小芳&#39;, &#39;小民&#39;]);</span><br><span class="line">print(names is List&lt;String&gt;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<blockquote>
<p>与 Java 不同的是，Java 中的泛型是类型 <em>擦除</em> 的，这意味着泛型类型会在运行时被移除。在 Java 中你可以判断对象是否为 List 但不可以判断对象是否为 <code>List&lt;String&gt;</code>。</p>
</blockquote>
<h3 id="2-5-限制参数化类型"><a href="#2-5-限制参数化类型" class="headerlink" title="2.5 限制参数化类型"></a>2.5 限制参数化类型</h3><p>有时使用泛型的时候可能会想限制泛型的类型范围，这时候可以使用 <code>extends</code> 关键字：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 具体实现……</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">"'Foo&lt;<span class="subst">$T</span>&gt;' 的实例"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这时候就可以使用 <code>SomeBaseClass</code> 或者它的子类来作为泛型参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class="line"><span class="keyword">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure>

<p>这时候也可以指定无参数的泛型，这时无参数泛型的类型则为 <code>Foo&lt;SomeBaseClass&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; Foo();</span><br><span class="line">print(foo); &#x2F;&#x2F; &#39;Foo&lt;SomeBaseClass&gt;&#39; 的实例 (Instance of &#39;Foo&lt;SomeBaseClass&gt;&#39;)</span><br></pre></td></tr></table></figure>

<p>将非 <code>SomeBaseClass</code> 的类型作为泛型参数则会导致编译错误：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Foo&lt;<span class="built_in">Object</span>&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="2-6-使用泛型方法"><a href="#2-6-使用泛型方法" class="headerlink" title="2.6 使用泛型方法"></a>2.6 使用泛型方法</h3><p>起初 Dart 只支持在类的声明时指定泛型，现在同样也可以在方法上使用泛型，称之为 <em>泛型方法</em>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// 处理一些初始化工作或错误检测……</span></span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 处理一些额外的检查……</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>first&lt;T&gt;</code> 的泛型 <code>T</code> 可以在如下地方使用：</p>
<ul>
<li>函数的返回值类型 (<code>T</code>)。</li>
<li>参数的类型 (<code>List&lt;T&gt;</code>)。</li>
<li>局部变量的类型 (<code>T tmp</code>)。</li>
</ul>
<p>你可以查阅<a href="https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md" target="_blank" rel="noopener">使用泛型函数</a>获取更多关于泛型的信息。</p>
<h2 id="三、库和可见性"><a href="#三、库和可见性" class="headerlink" title="三、库和可见性"></a>三、库和可见性</h2><p><code>import</code> 和 <code>library</code> 关键字可以帮助你创建一个模块化和可共享的代码库。代码库不仅只是提供 API 而且还起到了封装的作用：以下划线（_）开头的成员仅在代码库中可见。<em>每个 Dart 程序都是一个库</em>，即便没有使用关键字 <code>library</code> 指定。</p>
<p>Dart 的库可以使用<a href="https://dart.cn/guides/packages" target="_blank" rel="noopener">包</a>工具来发布和部署。</p>
<h3 id="3-1-使用库"><a href="#3-1-使用库" class="headerlink" title="3.1 使用库"></a>3.1 使用库</h3><p>使用 <code>import</code> 来指定命名空间以便其它库可以访问。</p>
<p>比如你可以导入代码库 <a href="https://api.dart.dev/stable/dart-html" target="_blank" rel="noopener">dart:html</a> 来使用 Dart Web 中相关 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:html&#39;;</span><br></pre></td></tr></table></figure>

<p><code>import</code> 的唯一参数是用于指定代码库的 URI，对于 Dart 内置的库，使用 <code>dart:xxxxxx</code> 的形式。而对于其它的库，你可以使用一个文件系统路径或者以 <code>package:xxxxxx</code> 的形式。<code>package:xxxxxx</code> 指定的库通过包管理器（比如 pub 工具）来提供：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:test&#x2F;test.dart&#39;;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<p><em>URI</em> 代表统一资源标识符。</p>
<p><em>URL</em>（统一资源定位符）是一种常见的URI。</p>
<h4 id="3-1-1-指定库前缀"><a href="#3-1-1-指定库前缀" class="headerlink" title="3.1.1 指定库前缀"></a>3.1.1 指定库前缀</h4><p>如果你导入的两个代码库有冲突的标识符，你可以为其中一个指定前缀。比如如果 library1 和 library2 都有 Element 类，那么可以这么处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:lib1&#x2F;lib1.dart&#39;;</span><br><span class="line">import &#39;package:lib2&#x2F;lib2.dart&#39; as lib2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 lib1 的 Element 类。</span><br><span class="line">Element element1 &#x3D; Element();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 lib2 的 Element 类。</span><br><span class="line">lib2.Element element2 &#x3D; lib2.Element();</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-导入库的一部分"><a href="#3-1-2-导入库的一部分" class="headerlink" title="3.1.2 导入库的一部分"></a>3.1.2 导入库的一部分</h4><p>如果你只想使用代码库中的一部分，你可以有选择地导入代码库。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只导入 lib1 中的 foo。(Import only foo).</span><br><span class="line">import &#39;package:lib1&#x2F;lib1.dart&#39; show foo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 lib2 中除了 foo 外的所有。</span><br><span class="line">import &#39;package:lib2&#x2F;lib2.dart&#39; hide foo;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-延迟加载库"><a href="#3-1-3-延迟加载库" class="headerlink" title="3.1.3 延迟加载库"></a>3.1.3 延迟加载库</h4><p><em>延迟加载</em>（也常称为 <em>懒加载</em>）允许应用在需要时再去加载代码库，下面是可能使用到延迟加载的场景：</p>
<ul>
<li>为了减少应用的初始化时间。</li>
<li>处理 A/B 测试，比如测试各种算法的不同实现。</li>
<li>加载很少会使用到的功能，比如可选的屏幕和对话框。</li>
</ul>
<blockquote>
<p><strong>目前只有 dart2js 支持延迟加载</strong> Flutter、Dart VM以及 DartDevc 目前都不支持延迟加载。你可以查阅 <a href="https://github.com/dart-lang/sdk/issues/33118" target="_blank" rel="noopener">issue #33118</a> 和 <a href="https://github.com/dart-lang/sdk/issues/27776" target="_blank" rel="noopener">issue #27776</a> 获取更多的相关信息。</p>
</blockquote>
<p>使用 <code>deferred as</code> 关键字来标识需要延时加载的代码库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:greetings&#x2F;hello.dart&#39; deferred as hello;</span><br></pre></td></tr></table></figure>

<p>当实际需要使用到库中 API 时先调用 <code>loadLibrary</code> 函数加载库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future greet() async &#123;</span><br><span class="line">  await hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的代码，使用 <code>await</code> 关键字暂停代码执行直到库加载完成。更多关于 <code>async</code> 和 <code>await</code> 的信息请参考<a href="https://dart.cn/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a>。</p>
<p><code>loadLibrary</code> 函数可以调用多次也没关系，代码库只会被加载一次。</p>
<p>当你使用延迟加载的时候需要牢记以下几点：</p>
<ul>
<li>延迟加载的代码库中的常量需要在代码库被加载的时候才会导入，未加载时是不会导入的。</li>
<li>导入文件的时候无法使用延迟加载库中的类型。如果你需要使用类型，则考虑吧接口类型转移到另一个库中然后让两个库都分别导入这个接口库。</li>
<li>Dart会隐式地将 <code>loadLibrary</code> 方法导入到使用了 <code>deferred as *命名空间*</code> 的类中。<code>loadLibrary</code> 函数返回的是一个 <a href="https://dart.cn/guides/libraries/library-tour#future" target="_blank" rel="noopener">Future</a>。</li>
</ul>
<h3 id="3-2-实现库"><a href="#3-2-实现库" class="headerlink" title="3.2 实现库"></a>3.2 实现库</h3><p>查阅<a href="https://dart.cn/guides/libraries/create-library-packages" target="_blank" rel="noopener">创建依赖库包</a>可以获取有关如何实现库包的建议，包括：</p>
<ul>
<li>如何组织库的源文件。</li>
<li>如何使用 <code>export</code> 命令。</li>
<li>何时使用 <code>part</code> 命令。</li>
<li>何时使用 <code>library</code> 命令。</li>
<li>如何使用倒入和导出命令实现多平台的库支持。</li>
</ul>
<h2 id="四、异步支持"><a href="#四、异步支持" class="headerlink" title="四、异步支持"></a>四、异步支持</h2><p>Dart 代码库中有大量返回 <a href="https://api.dart.dev/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 或 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 对象的函数，这些函数都是 <em>异步</em> 的，它们会在耗时操作（比如I/O）执行完毕前直接返回而不会等待耗时操作执行完毕。</p>
<p><code>async</code> 和 <code>await</code> 关键字用于实现异步编程，并且让你的代码看起来就像是同步的一样。</p>
<h3 id="4-1-处理-Future"><a href="#4-1-处理-Future" class="headerlink" title="4.1 处理 Future"></a>4.1 处理 Future</h3><p>可以通过下面两种方式，获得 Future 执行完成的结果：</p>
<ul>
<li>使用 <code>async</code> 和 <code>await</code>；</li>
<li>使用 Future API，具体描述，参考<a href="https://dart.cn/guides/libraries/library-tour#future" target="_blank" rel="noopener">库概览</a>。</li>
</ul>
<p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的，但是看起来有点像同步代码。例如，下面的代码使用 <code>await</code> 等待异步函数的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await lookUpVersion();</span><br></pre></td></tr></table></figure>

<p>必须在带有 async 关键字的 <em>异步函数</em> 中使用 <code>await</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// 使用 version 继续处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<blockquote>
<p>尽管异步函数可以处理耗时操作，但是它并不会等待这些耗时操作完成，异步函数执行时会在其遇到第一个 <code>await</code> 表达式（<a href="https://github.com/dart-lang/sdk/blob/master/docs/newsletter/20170915.md#synchronous-async-start" target="_blank" rel="noopener">详情见</a>）的时候返回一个 Future 对象，然后等待 await 表达式执行完毕后继续执行。</p>
</blockquote>
<p>使用 <code>try</code>、<code>catch</code> 以及 <code>finally</code> 来处理使用 <code>await</code> 导致的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  version &#x3D; await lookUpVersion();</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 无法找到版本时做出的反应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在异步函数中多次使用 <code>await</code> 关键字。例如，下面代码中等待了三次函数结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var entrypoint &#x3D; await findEntrypoint();</span><br><span class="line">var exitCode &#x3D; await runExecutable(entrypoint, args);</span><br><span class="line">await flushThenExit(exitCode);</span><br><span class="line">await *表达式的返回值通常是一个 Future 对象；如果不是的话也会自动将其包裹在一个 Future 对象里。Future 对象代表一个“承诺”，&#96;await \*表达式\*&#96;会阻塞直到需要的对象返回。*</span><br></pre></td></tr></table></figure>

<p><strong>如果在使用 <code>await</code> 时导致编译错误，请确保 <code>await</code> 在一个异步函数中使用</strong>。例如，如果想在 main() 函数中使用 <code>await</code>，那么 <code>main()</code> 函数就必须使用 <code>async</code> 关键字标识。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'在 Main 函数中执行：版本是 <span class="subst">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-声明异步函数"><a href="#4-2-声明异步函数" class="headerlink" title="4.2 声明异步函数"></a>4.2 声明异步函数</h3><p>定义 <em>异步函数</em> 只需在普通方法上加上 <code>async</code> 关键字即可。</p>
<p>将关键字 <code>async</code> 添加到函数并让其返回一个 Future 对象。假设有如下返回 String 对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookUpVersion() &#x3D;&gt; &#39;1.0.0&#39;;</span><br></pre></td></tr></table></figure>

<p>将其改为异步函数，返回值是 Future：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; lookUpVersion() async &#x3D;&gt; &#39;1.0.0&#39;;</span><br></pre></td></tr></table></figure>

<p>注意，函数体不需要使用 Future API。如有必要，Dart 会创建 Future 对象。</p>
<p>如果函数没有返回有效值，需要设置其返回类型为 <code>Future&lt;void&gt;</code>。</p>
<p>关于 futures、<code>async</code> 和 <code>await</code> 的使用介绍，可以参见这个 codelab: <a href="https://dart.cn/codelabs/async-await" target="_blank" rel="noopener">asynchronous programming codelab</a>。</p>
<h3 id="4-3-处理-Stream"><a href="#4-3-处理-Stream" class="headerlink" title="4.3 处理 Stream"></a>4.3 处理 Stream</h3><p>如果想从 Stream 中获取值，可以有两种选择：</p>
<ul>
<li><p>使用 <code>async</code> 关键字和一个 <em>异步循环</em>（使用 <code>await for</code> 关键字标识）。</p>
</li>
<li><p>使用 Stream API。详情参考<a href="https://dart.cn/guides/libraries/library-tour#stream" target="_blank" rel="noopener">库概览</a>。</p>
<p><strong>备忘:</strong></p>
</li>
</ul>
<p>在使用 <code>await for</code> 关键字前，确保其可以令代码逻辑更加清晰并且是真的需要等待所有的结果执行完毕。例如，通常不应该在 UI 事件监听器上使用 <code>await for</code> 关键字，因为 UI 框架发出的事件流是无穷尽的。</p>
<p>使用 await for 定义异步循环看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">await for (varOrType identifier in expression) &#123;</span><br><span class="line">  &#x2F;&#x2F; 每当 Stream 发出一个值时会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>*表达式*</code> 的类型必须是 Stream。执行流程如下：</p>
<ol>
<li>等待直到 Stream 返回一个数据。</li>
<li>使用 1 中 Stream 返回的数据执行循环体。</li>
<li>重复 1、2 过程直到 Stream 数据返回完毕。</li>
</ol>
<p>使用 <code>break</code> 和 <code>return</code> 语句可以停止接收 Stream 数据，这样就跳出了循环并取消注册监听 Stream。</p>
<p><strong>如果在实现异步 for 循环时遇到编译时错误，请检查确保 <code>await for</code> 处于异步函数中。</strong> 例如，要在应用程序的 <code>main()</code> 函数中使用异步 for 循环，<code>main()</code> 函数体必须标记为 <code>async</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以查阅库概览中有关 <a href="https://dart.cn/guides/libraries/library-tour#dartasync---asynchronous-programming" target="_blank" rel="noopener">dart:async</a> 的部分获取更多有关异步编程的信息。</p>
<h2 id="五、生成器"><a href="#五、生成器" class="headerlink" title="五、生成器"></a>五、生成器</h2><p>当你需要延迟地生成一连串的值时，可以考虑使用 <em>生成器函数</em>。Dart 内置支持两种形式的生成器方法：</p>
<ul>
<li><strong>同步</strong> 生成器：返回一个 <strong><a href="https://api.dart.dev/stable/dart-core/Iterable-class.html" target="_blank" rel="noopener">Iterable</a></strong> 对象。</li>
<li><strong>异步</strong> 生成器：返回一个 <strong><a href="https://api.dart.dev/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a></strong> 对象。</li>
</ul>
<p>通过在函数上加 <code>sync*</code> 关键字并将返回值类型设置为 Iterable 来实现一个 <strong>同步</strong> 生成器函数，在函数中使用 <code>yield</code> 语句来传递值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterable&lt;int&gt; naturalsTo(int n) sync* &#123;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  while (k &lt; n) yield k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 <strong>异步</strong> 生成器函数与同步类似，只不过关键字为 <code>async*</code> 并且返回值为 Stream：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* &#123;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  while (k &lt; n) yield k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果生成器是递归调用的，可是使用 <code>yield*</code> 语句提升执行性能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterable&lt;int&gt; naturalsDownFrom(int n) sync* &#123;</span><br><span class="line">  if (n &gt; 0) &#123;</span><br><span class="line">    yield n;</span><br><span class="line">    yield* naturalsDownFrom(n - 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、可调用类"><a href="#六、可调用类" class="headerlink" title="六、可调用类"></a>六、可调用类</h2><p>通过实现类的 <code>call()</code> 方法，允许使用类似函数调用的方式来使用该类的实例。</p>
<p>在下面的示例中，<code>WannabeFunction</code> 类定义了一个 call() 函数，函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号。单击运行按钮执行代码。</p>
<iframe src="https://dartpad.cn/embed-inline.html?id=3723fcf3915ca935d13393b8a9f86fd5&amp;ga_id=callable_classes" width="100%" height="350px" style="box-sizing: border-box; color: rgb(33, 37, 41); font-family: &quot;Noto Sans SC&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; border: 1px solid rgb(204, 204, 204);"></iframe>



<h2 id="七、隔离区"><a href="#七、隔离区" class="headerlink" title="七、隔离区"></a>七、隔离区</h2><p>大多数计算机中，甚至在移动平台上，都在使用多核 CPU。为了有效利用多核性能，开发者一般使用共享内存的方式让线程并发地运行。然而，多线程共享数据通常会导致很多潜在的问题，并导致代码运行出错。</p>
<p>为了解决多线程带来的并发问题，Dart 使用 isolates 替代线程，所有的 Dart 代码均运行在一个 <em>isolates</em> 中。每一个 isolates 有它自己的堆内存以确保其状态不被其它 isolates 访问。</p>
<p>你可以查阅下面的文档获取更多相关信息：</p>
<ul>
<li><a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a" target="_blank" rel="noopener">Dart 异步编程：隔离区和事件循环</a></li>
<li><a href="https://api.dart.dev/stable/dart-isolate" target="_blank" rel="noopener">dart:isolate API 参考</a>介绍了 <a href="https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html" target="_blank" rel="noopener">Isolate.spawn()</a> 和 <a href="https://api.dart.dev/stable/dart-isolate/TransferableTypedData-class.html" target="_blank" rel="noopener">TransferableTypedData</a> 的用法</li>
<li><a href="https://flutter.cn/docs/cookbook/networking/background-parsing" target="_blank" rel="noopener">Background parsing</a> cookbook on the Flutter site</li>
<li>Flutter 网站上关于<a href="https://flutter.cn/docs/cookbook/networking/background-parsing" target="_blank" rel="noopener">后台解析</a>的 Cookbook</li>
</ul>
<h2 id="八、类型定义-重要"><a href="#八、类型定义-重要" class="headerlink" title="八、类型定义(重要)"></a>八、类型定义(重要)</h2><p>在 Dart 语言中，函数与 String 和 Number 一样都是对象，可以使用 <em>类型定义</em>（或者叫 <em>方法类型别名</em>）来为函数的类型命名。使用函数命名将该函数类型的函数赋值给一个变量时，类型定义将会保留相关的类型信息。</p>
<p>比如下面的代码没有使用类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class SortedCollection &#123;</span><br><span class="line">  Function compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(int f(Object a, Object b)) &#123;</span><br><span class="line">    compare &#x3D; f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简单的不完整实现。</span><br><span class="line">int sort(Object a, Object b) &#x3D;&gt; 0;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  SortedCollection coll &#x3D; SortedCollection(sort);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 我们知道 compare 是一个函数类型的变量，但是具体是什么样的函数却不得而知。</span><br><span class="line">  assert(coll.compare is Function);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，当将参数 <code>f</code> 赋值给 <code>compare</code> 时，函数的类型信息丢失了，这里 <code>f</code> 这个函数的类型为 <code>(Object, Object) → int</code>（→ 代表返回），当然该类型也是一个 Function 的子类，但是将 <code>f</code> 赋值给 <code>compare</code> 后，<code>f</code> 的类型 <code>(Object, Object) → int</code> 就会丢失。我们可以使用 <code>typedef</code> 显式地保留类型信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef Compare &#x3D; int Function(Object a, Object b);</span><br><span class="line"></span><br><span class="line">class SortedCollection &#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(this.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简单的不完整实现。</span><br><span class="line">int sort(Object a, Object b) &#x3D;&gt; 0;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  SortedCollection coll &#x3D; SortedCollection(sort);</span><br><span class="line">  assert(coll.compare is Function);</span><br><span class="line">  assert(coll.compare is Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<blockquote>
<p>目前类型定义只能用在函数类型上，但是将来可能会有变化。</p>
</blockquote>
<p>因为类型定义只是别名，因此我们可以使用它判断任意函数类型的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef Compare&lt;T&gt; &#x3D; int Function(T a, T b);</span><br><span class="line"></span><br><span class="line">int sort(int a, int b) &#x3D;&gt; a - b;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  assert(sort is Compare&lt;int&gt;); &#x2F;&#x2F; True!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、元数据"><a href="#九、元数据" class="headerlink" title="九、元数据"></a>九、元数据</h2><p>使用元数据可以为代码增加一些额外的信息。元数据注解以 <code>@</code> 开头，其后紧跟一个编译时常量（比如 <code>deprecated</code>）或者调用一个常量构造函数。</p>
<p>Dart 中有两个注解是所有代码都可以使用的：<code>@deprecated</code> 和 <code>@override</code>。你可以查阅<a href="https://dart.cn/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">扩展一个类</a>获取有关 <code>@override</code> 的使用示例。下面是使用 <code>@deprecated</code> 的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">_弃用: 使用 [turnOn] 替代_</span></span></span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">打开 TV 的电源。</span></span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以自定义元数据注解。下面的示例定义了一个带有两个参数的 @todo 注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library todo;</span><br><span class="line"></span><br><span class="line">class Todo &#123;</span><br><span class="line">  final String who;</span><br><span class="line">  final String what;</span><br><span class="line"></span><br><span class="line">  const Todo(this.who, this.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 @todo 注解的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#39;todo.dart&#39;;</span><br><span class="line"></span><br><span class="line">@Todo(&#39;seth&#39;, &#39;make this do something&#39;)</span><br><span class="line">void doSomething() &#123;</span><br><span class="line">  print(&#39;do something&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元数据可以在 library、class、typedef、type parameter、constructor、factory、function、field、parameter 或者 variable 声明之前使用，也可以在 import 或 export 之前使用。可使用反射在运行时获取元数据信息。</p>
<h2 id="十、注释"><a href="#十、注释" class="headerlink" title="十、注释"></a>十、注释</h2><p>Dart 支持单行注释、多行注释和文档注释。</p>
<h3 id="10-1-单行注释"><a href="#10-1-单行注释" class="headerlink" title="10.1 单行注释"></a>10.1 单行注释</h3><p>单行注释以 <code>//</code> 开始。所有在 <code>//</code> 和该行结尾之间的内容被编译器忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO: refactor into an AbstractLlamaGreetingFactory?</span><br><span class="line">  print(&#39;Welcome to my Llama farm!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-多行注释"><a href="#10-2-多行注释" class="headerlink" title="10.2 多行注释"></a>10.2 多行注释</h3><p>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾。所有在 <code>/*</code> 和 <code>*/</code> 之间的内容被编译器忽略（不会忽略文档注释）。多行注释可以嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  &#x2F;*</span><br><span class="line">   * This is a lot of work. Consider raising chickens.</span><br><span class="line"></span><br><span class="line">  Llama larry &#x3D; Llama();</span><br><span class="line">  larry.feed();</span><br><span class="line">  larry.exercise();</span><br><span class="line">  larry.clean();</span><br><span class="line">   *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-文档注释"><a href="#10-3-文档注释" class="headerlink" title="10.3 文档注释"></a>10.3 文档注释</h3><p>文档注释可以是多行注释，也可以是单行注释，文档注释以 <code>///</code> 或者 <code>/**</code> 开始。在连续行上使用 <code>///</code> 与多行文档注释具有相同的效果。</p>
<p>在文档注释中，除非用中括号括起来，否则 Dart 编译器会忽略所有文本。使用中括号可以引用类、方法、字段、顶级变量、函数、和参数。括号中的符号会在已记录的程序元素的词法域中进行解析。</p>
<p>下面是一个引用其他类和成员的文档注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A domesticated South American camelid (Lama glama).</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Andean cultures have used llamas as meat and pack</span><br><span class="line">&#x2F;&#x2F;&#x2F; animals since pre-Hispanic times.</span><br><span class="line">class Llama &#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; Feeds your llama [Food].</span><br><span class="line">  &#x2F;&#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; The typical llama eats one bale of hay per week.</span><br><span class="line">  void feed(Food food) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;&#x2F; Exercises your llama with an [activity] for</span><br><span class="line">  &#x2F;&#x2F;&#x2F; [timeLimit] minutes.</span><br><span class="line">  void exercise(Activity activity, int timeLimit) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生成的文档中，<code>[Food]</code> 会成为一个链接，指向 Food 类的 API 文档。</p>
<p>解析 Dart 代码并生成 HTML 文档，可以使用 SDK 中的<a href="https://github.com/dart-lang/dartdoc#dartdoc" target="_blank" rel="noopener">文档生成工具。</a>关于生成文档的实例，请参考 <a href="https://api.dart.dev/stable" target="_blank" rel="noopener">Dart API documentation.</a>关于文档结构的建议，请参考<a href="https://dart.cn/guides/language/effective-dart/documentation" target="_blank" rel="noopener">Guidelines for Dart Doc Comments.</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/flutter/dart/dart%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/11/flutter/dart/dart%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/" itemprop="url">dart开发语言基础（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-11T20:21:02+08:00">
                2020-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/dart/" itemprop="url" rel="index">
                    <span itemprop="name">dart</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/11/flutter/dart/dart%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/11/flutter/dart/dart%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、重要概念"><a href="#一、重要概念" class="headerlink" title="一、重要概念"></a>一、重要概念</h2><ul>
<li><p>所有变量引用的都是 <em>对象*，每个对象都是一个 *类</em> 的实例。数字、函数以及 <code>null</code> 都是对象。所有的类都继承于 <a href="https://api.dart.dev/stable/dart-core/Object-class.html" target="_blank" rel="noopener">Object</a> 类。</p>
</li>
<li><p>尽管 Dart 是强类型语言，但是在声明变量时指定类型是可选的，因为 Dart 可以进行类型推断。在上述代码中，变量 <code>number</code> 的类型被推断为 <code>int</code> 类型。如果想显式地声明一个不确定的类型，可以<a href="https://dart.cn/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" target="_blank" rel="noopener">使用特殊类型 <code>dynamic</code></a>。</p>
</li>
<li><p>Dart 支持泛型，比如 <code>List&lt;int&gt;</code>（表示一组由 int 对象组成的列表）或 <code>List&lt;dynamic&gt;</code>（表示一组由任何类型对象组成的列表）。</p>
</li>
<li><p>Dart 支持顶级函数（例如 <code>main</code> 方法），同时还支持定义属于类或对象的函数（即 <em>静态</em> 和 <em>实例方法<em>）。你还可以在函数中定义函数（</em>嵌套</em> 或 <em>局部函数</em>）。</p>
</li>
<li><p>Dart 支持顶级 <em>变量</em>，以及定义属于类或对象的变量（静态和实例变量）。实例变量有时称之为域或属性。</p>
</li>
<li><p>Dart 没有类似于 Java 那样的 <code>public</code>、<code>protected</code> 和 <code>private</code> 成员访问限定符。如果一个标识符以下划线 (_) 开头则表示该标识符在库内是私有的。可以查阅 <a href="https://dart.cn/guides/language/language-tour#libraries-and-visibility" target="_blank" rel="noopener">库和可见性</a> 获取更多相关信息。</p>
</li>
<li><p><em>标识符</em> 可以以字母或者下划线 (_) 开头，其后可跟字符和数字的组合。</p>
</li>
<li><p>Dart 中 <em>表达式</em> 和 <em>语句</em> 是有区别的，表达式有值而语句没有。比如<a href="https://dart.cn/guides/language/language-tour#conditional-expressions" target="_blank" rel="noopener">条件表达式</a> <code>expression condition ? expr1 : expr2</code> 中含有值 <code>expr1</code> 或 <code>expr2</code>。与 <a href="https://dart.cn/guides/language/language-tour#if-and-else" target="_blank" rel="noopener">if-else 分支语句</a>相比，<code>if-else</code> 分支语句则没有值。一个语句通常包含一个或多个表达式，但是一个表达式不能只包含一个语句。</p>
</li>
<li><p>Dart 工具可以显示 <em>警告</em> 和 <em>错误</em> 两种类型的问题。警告表明代码可能有问题但不会阻止其运行。错误分为编译时错误和运行时错误；编译时错误代码无法运行；运行时错误会在代码运行时导致<a href="https://dart.cn/guides/language/language-tour#exceptions" target="_blank" rel="noopener">异常</a>。</p>
</li>
</ul>
<h2 id="二、关键字"><a href="#二、关键字" class="headerlink" title="二、关键字"></a>二、关键字</h2><p>下面的表格中列出了 Dart 语言所使用的关键字。</p>
<table>
<thead>
<tr>
<th><a href="https://dart.cn/guides/language/language-tour#abstract-classes" target="_blank" rel="noopener">abstract</a> 2</th>
<th><a href="https://dart.cn/guides/language/language-tour#if-and-else" target="_blank" rel="noopener">else</a></th>
<th><a href="https://dart.cn/guides/language/language-tour#using-libraries" target="_blank" rel="noopener">import</a> 2</th>
<th><a href="https://dart.cn/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">super</a></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dart.cn/guides/language/language-tour#type-test-operators" target="_blank" rel="noopener">as</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#enumerated-types" target="_blank" rel="noopener">enum</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#for-loops" target="_blank" rel="noopener">in</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#switch-and-case" target="_blank" rel="noopener">switch</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#assert" target="_blank" rel="noopener">assert</a></td>
<td><a href="https://dart.cn/guides/libraries/create-library-packages" target="_blank" rel="noopener">export</a> 2</td>
<td><a href="https://stackoverflow.com/questions/28595501/was-the-interface-keyword-removed-from-dart" target="_blank" rel="noopener">interface</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#generators" target="_blank" rel="noopener">sync</a> 1</td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">async</a> 1</td>
<td><a href="https://dart.cn/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">extends</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#type-test-operators" target="_blank" rel="noopener">is</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#constructors" target="_blank" rel="noopener">this</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">await</a> 3</td>
<td><a href="https://dart.cn/guides/language/language-tour#extension-methods" target="_blank" rel="noopener">extension</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#libraries-and-visibility" target="_blank" rel="noopener">library</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#throw" target="_blank" rel="noopener">throw</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#break-and-continue" target="_blank" rel="noopener">break</a></td>
<td><a href="https://stackoverflow.com/questions/24929659/what-does-external-mean-in-dart" target="_blank" rel="noopener">external</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#adding-features-to-a-class-mixins" target="_blank" rel="noopener">mixin</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#booleans" target="_blank" rel="noopener">true</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#switch-and-case" target="_blank" rel="noopener">case</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#factory-constructors" target="_blank" rel="noopener">factory</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#using-constructors" target="_blank" rel="noopener">new</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#catch" target="_blank" rel="noopener">try</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#catch" target="_blank" rel="noopener">catch</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#booleans" target="_blank" rel="noopener">false</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#default-value" target="_blank" rel="noopener">null</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#typedefs" target="_blank" rel="noopener">typedef</a> 2</td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#instance-variables" target="_blank" rel="noopener">class</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#final-and-const" target="_blank" rel="noopener">final</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#catch" target="_blank" rel="noopener">on</a> 1</td>
<td><a href="https://dart.cn/guides/language/language-tour#variables" target="_blank" rel="noopener">var</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#final-and-const" target="_blank" rel="noopener">const</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#finally" target="_blank" rel="noopener">finally</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#overridable-operators" target="_blank" rel="noopener">operator</a> 2</td>
<td><a href="https://medium.com/dartlang/dart-2-legacy-of-the-void-e7afb5f44df0" target="_blank" rel="noopener">void</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#break-and-continue" target="_blank" rel="noopener">continue</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#for-loops" target="_blank" rel="noopener">for</a></td>
<td><a href="https://dart.cn/guides/libraries/create-library-packages#organizing-a-library-package" target="_blank" rel="noopener">part</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#while-and-do-while" target="_blank" rel="noopener">while</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/sound-problems#the-covariant-keyword" target="_blank" rel="noopener">covariant</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#functions" target="_blank" rel="noopener">Function</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#catch" target="_blank" rel="noopener">rethrow</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#adding-features-to-a-class-mixins" target="_blank" rel="noopener">with</a></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#switch-and-case" target="_blank" rel="noopener">default</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#getters-and-setters" target="_blank" rel="noopener">get</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#functions" target="_blank" rel="noopener">return</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#generators" target="_blank" rel="noopener">yield</a> 3</td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#lazily-loading-a-library" target="_blank" rel="noopener">deferred</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#importing-only-part-of-a-library" target="_blank" rel="noopener">hide</a> 1</td>
<td><a href="https://dart.cn/guides/language/language-tour#getters-and-setters" target="_blank" rel="noopener">set</a> 2</td>
<td></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#while-and-do-while" target="_blank" rel="noopener">do</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#if-and-else" target="_blank" rel="noopener">if</a></td>
<td><a href="https://dart.cn/guides/language/language-tour#importing-only-part-of-a-library" target="_blank" rel="noopener">show</a> 1</td>
<td></td>
</tr>
<tr>
<td><a href="https://dart.cn/guides/language/language-tour#important-concepts" target="_blank" rel="noopener">dynamic</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#implicit-interfaces" target="_blank" rel="noopener">implements</a> 2</td>
<td><a href="https://dart.cn/guides/language/language-tour#class-variables-and-methods" target="_blank" rel="noopener">static</a> 2</td>
<td></td>
</tr>
</tbody></table>
<p>应该避免使用这些单词作为标识符。但是，带有上标的单词可以在必要的情况下作为标识符：</p>
<ul>
<li>带有上标 <strong>1</strong> 的关键字为 <strong>上下文关键字</strong>，只有在特定的场景才有意义，它们可以在任何地方作为有效的标识符。</li>
<li>带有上标 <strong>2</strong> 的关键字为 <strong>内置标识符</strong>，其作用只是在JavaScript代码转为Dart代码时更简单，这些关键字在大多数时候都可以作为有效的标识符，但是它们不能用作类名或者类型名或者作为导入前缀使用。</li>
<li>带有上标 <strong>3</strong> 的关键字为 Dart1.0 发布后用于<a href="https://dart.cn/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">支持异步</a>相关的特性新加的。不能在由关键字 <code>async</code>、<code>async*</code> 或 <code>sync*</code> 标识的方法体中使用 <code>await</code> 或 <code>yield</code> 作为标识符。</li>
</ul>
<p>其它没有上标的关键字为 <strong>保留字</strong>，均不能用作标识符。</p>
<h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><h3 id="3-1-gt"><a href="#3-1-gt" class="headerlink" title="3.1 =&gt;"></a>3.1 =&gt;</h3><p>语法 <code>=&gt; *表达式*</code> 是 <code>{ return *表达式*; }</code> 的简写， <code>=&gt;</code> 有时也称之为胖箭头语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isNoble(int atomicNumber) &#x3D;&gt; _nobleGases[atomicNumber] !&#x3D; null;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-可选参数"><a href="#3-2-可选参数" class="headerlink" title="3.2 可选参数"></a>3.2 可选参数</h3><p>可选参数分为命名参数和位置参数，可在参数列表中任选其一使用，但两者不能同时出现在参数列表中。</p>
<h4 id="3-2-1-命名参数"><a href="#3-2-1-命名参数" class="headerlink" title="3.2.1 命名参数"></a>3.2.1 命名参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: true, hidden: false);</span><br></pre></td></tr></table></figure>

<p>虽然命名参数是可选参数的一种类型，但是你仍然可以使用 <a href="https://pub.flutter-io.cn/documentation/meta/latest/meta/required-constant.html" target="_blank" rel="noopener">@required</a> 注解来标识一个命名参数是必须的参数，此时调用者则必须为该参数提供一个值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Scrollbar(&#123;Key key, @required Widget child&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-位置参数"><a href="#3-2-2-位置参数" class="headerlink" title="3.2.2 位置参数"></a>3.2.2 位置参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String say(String from, String msg, [String device]) &#123;</span><br><span class="line">  var result &#x3D; &#39;$from says $msg&#39;;</span><br><span class="line">  if (device !&#x3D; null) &#123;</span><br><span class="line">    result &#x3D; &#39;$result with a $device&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-默认参数值"><a href="#3-2-3-默认参数值" class="headerlink" title="3.2.3 默认参数值"></a>3.2.3 默认参数值</h4><p>可以用 <code>=</code> 为函数的命名和位置参数定义默认值，默认值必须为编译时常量，没有指定默认值的情况下默认值为 <code>null</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 设置 [bold] 和 [hidden] 标识……</span><br><span class="line">&#x2F;&#x2F;&#x2F; Sets the [bold] and [hidden] flags ...</span><br><span class="line">void enableFlags(&#123;bool bold &#x3D; false, bool hidden &#x3D; false&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bold 的值将为 true；而 hidden 将为 false。</span><br><span class="line">enableFlags(bold: true);</span><br></pre></td></tr></table></figure>

<p>下一个示例将向你展示如何为位置参数设置默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String say(String from, String msg,</span><br><span class="line">    [String device &#x3D; &#39;carrier pigeon&#39;, String mood]) &#123;</span><br><span class="line">  var result &#x3D; &#39;$from says $msg&#39;;</span><br><span class="line">  if (device !&#x3D; null) &#123;</span><br><span class="line">    result &#x3D; &#39;$result with a $device&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (mood !&#x3D; null) &#123;</span><br><span class="line">    result &#x3D; &#39;$result (in a $mood mood)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) &#x3D;&#x3D;</span><br><span class="line">    &#39;Bob says Howdy with a carrier pigeon&#39;);</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-1默认参数是List"><a href="#3-2-3-1默认参数是List" class="headerlink" title="3.2.3.1默认参数是List"></a>3.2.3.1默认参数是List</h5><p>需要加入const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final List&lt;double&gt; data;</span><br><span class="line">final List&lt;String&gt; legends;</span><br><span class="line">const PieChart(&#123;Key key, this.data &#x3D; const [4.3,5.2,1.6,3.0], this.legends&#x3D;const [&#39;第一季度&#39;,&#39;第二季度&#39;,&#39;第三季度&#39;,&#39;第四季度&#39;,]&#125;) : super(key: key);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数作为一级对象"><a href="#3-3-函数作为一级对象" class="headerlink" title="3.3 函数作为一级对象"></a>3.3 函数作为一级对象</h3><p>可以将函数作为参数传递给另一个函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void printElement(int element) &#123;</span><br><span class="line">  print(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var list &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将 printElement 函数作为参数传递。</span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure>

<p>你也可以将函数赋值给一个变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var loudify &#x3D; (msg) &#x3D;&gt; &#39;!!! $&#123;msg.toUpperCase()&#125; !!!&#39;;</span><br><span class="line">assert(loudify(&#39;hello&#39;) &#x3D;&#x3D; &#39;!!! HELLO !!!&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-匿名函数"><a href="#3-4-匿名函数" class="headerlink" title="3.4 匿名函数"></a>3.4 匿名函数</h3><p>大多数方法都是有名字的，比如 <code>main()</code> 或 <code>printElement()</code>。你可以创建一个没有名字的方法，称之为 <em>匿名函数*，或 *Lambda表达式</em> 或 <em>Closure闭包</em>。你可以将匿名方法赋值给一个变量然后使用它，比如将该变量添加到集合或从中删除。</p>
<p>匿名方法看起来与命名方法类似，在括号之间可以定义参数，参数之间用逗号分割。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">后面大括号中的内容则为函数体：</span><br><span class="line"></span><br><span class="line">([[类型] 参数[, …]]) &#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面代码定义了只有一个参数 <code>item</code> 且没有参数类型的匿名方法。List 中的每个元素都会调用这个函数，打印元素位置和值的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var list &#x3D; [&#39;apples&#39;, &#39;bananas&#39;, &#39;oranges&#39;];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  print(&#39;$&#123;list.indexOf(item)&#125;: $item&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-5-词法作用域"><a href="#3-5-词法作用域" class="headerlink" title="3.5 词法作用域"></a>3.5 词法作用域</h3><p>Dart 是词法有作用域语言，变量的作用域在写代码的时候就确定了，大括号内定义的变量只能在大括号内访问，与 Java 类似。</p>
<p>下面是一个嵌套函数中变量在多个作用域中的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool topLevel &#x3D; true;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var insideMain &#x3D; true;</span><br><span class="line"></span><br><span class="line">  void myFunction() &#123;</span><br><span class="line">    var insideFunction &#x3D; true;</span><br><span class="line"></span><br><span class="line">    void nestedFunction() &#123;</span><br><span class="line">      var insideNestedFunction &#x3D; true;</span><br><span class="line"></span><br><span class="line">      assert(topLevel);</span><br><span class="line">      assert(insideMain);</span><br><span class="line">      assert(insideFunction);</span><br><span class="line">      assert(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>nestedFunction()</code> 函数可以访问包括顶层变量在内的所有的变量。</p>
<h3 id="3-5-词法闭包"><a href="#3-5-词法闭包" class="headerlink" title="3.5 词法闭包"></a>3.5 词法闭包</h3><p><em>闭包</em> 即一个函数对象，即使函数对象的调用在它原始作用域之外，依然能够访问在它词法作用域内的变量。</p>
<p>函数可以封闭定义到它作用域内的变量。接下来的示例中，函数 <code>makeAdder()</code> 捕获了变量 <code>addBy</code>。无论函数在什么时候返回，它都可以使用捕获的 <code>addBy</code> 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 返回一个将 [addBy] 添加到该函数参数的函数。</span><br><span class="line">&#x2F;&#x2F;&#x2F; Returns a function that adds [addBy] to the</span><br><span class="line">&#x2F;&#x2F;&#x2F; function&#39;s argument.</span><br><span class="line">Function makeAdder(int addBy) &#123;</span><br><span class="line">  return (int i) &#x3D;&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  &#x2F;&#x2F; 生成加 2 的函数。</span><br><span class="line">  var add2 &#x3D; makeAdder(2);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 生成加 4 的函数。</span><br><span class="line">  var add4 &#x3D; makeAdder(4);</span><br><span class="line"></span><br><span class="line">  assert(add2(3) &#x3D;&#x3D; 5);</span><br><span class="line">  assert(add4(3) &#x3D;&#x3D; 7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-测试函数是否相等"><a href="#3-6-测试函数是否相等" class="headerlink" title="3.6 测试函数是否相等"></a>3.6 测试函数是否相等</h3><p>下面是顶级函数，静态方法和示例方法相等性的测试示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;&#125; &#x2F;&#x2F; 定义顶层函数 (A top-level function)</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  static void bar() &#123;&#125; &#x2F;&#x2F; 定义静态方法</span><br><span class="line">  void baz() &#123;&#125; &#x2F;&#x2F; 定义实例方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var x;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 比较顶层函数是否相等。</span><br><span class="line">  x &#x3D; foo;</span><br><span class="line">  assert(foo &#x3D;&#x3D; x);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 比较静态方法是否相等。</span><br><span class="line">  x &#x3D; A.bar;</span><br><span class="line">  assert(A.bar &#x3D;&#x3D; x);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 比较实例方法是否相等。</span><br><span class="line">  var v &#x3D; A(); &#x2F;&#x2F; A 的实例 #1</span><br><span class="line">  var w &#x3D; A(); &#x2F;&#x2F; A 的实例 #2</span><br><span class="line">  var y &#x3D; w;</span><br><span class="line">  x &#x3D; w.baz;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 这两个闭包引用了相同的实例对象，因此它们相等。</span><br><span class="line">  assert(y.baz &#x3D;&#x3D; x);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 这两个闭包引用了不同的实例对象，因此它们不相等。</span><br><span class="line">  assert(v.baz !&#x3D; w.baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-返回值"><a href="#3-7-返回值" class="headerlink" title="3.7 返回值"></a>3.7 返回值</h3><p>所有的函数都有返回值。没有显示返回语句的函数最后一行默认为执行 <code>return null;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">assert(foo() &#x3D;&#x3D; null);</span><br></pre></td></tr></table></figure>

<h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><p>Dart定义了下表中显示的运算符。您可以覆盖许多这些运算符，如可覆盖运算符中所述。</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>一元后缀</td>
<td><code>*表达式*++</code> <code>*表达式*--</code> <code>()</code> <code>[]</code> <code>.</code> <code>?.</code></td>
</tr>
<tr>
<td>一元前缀</td>
<td><code>-*表达式*</code> <code>!*表达式*</code> <code>~*表达式*</code> <code>++*表达式*</code> <code>--*表达式*</code></td>
</tr>
<tr>
<td>乘除法</td>
<td><code>*</code> <code>/</code> <code>%</code> <code>~/</code></td>
</tr>
<tr>
<td>加减法</td>
<td><code>+</code> <code>-</code></td>
</tr>
<tr>
<td>位运算</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></td>
</tr>
<tr>
<td>二进制与</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>二进制异或</td>
<td><code>^</code></td>
</tr>
<tr>
<td>二进制或</td>
<td>`</td>
</tr>
<tr>
<td>关系和类型测试</td>
<td><code>&gt;=</code> <code>&gt;</code> <code>&lt;=</code> <code>&lt;</code> <code>as</code> <code>is</code> <code>is!</code></td>
</tr>
<tr>
<td>相等判断</td>
<td><code>==</code> <code>!=</code></td>
</tr>
<tr>
<td>逻辑与</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>逻辑或</td>
<td>`</td>
</tr>
<tr>
<td>空判断</td>
<td><code>??</code></td>
</tr>
<tr>
<td>条件表达式</td>
<td><code>*表达式 1* ? *表达式 2* : *表达式 3*</code></td>
</tr>
<tr>
<td>级联</td>
<td><code>..</code></td>
</tr>
<tr>
<td>赋值</td>
<td><code>=</code> <code>*=</code> <code>/=</code> <code>+=</code> <code>-=</code> <code>&amp;=</code> <code>^=</code> <em>等等……</em></td>
</tr>
</tbody></table>
<p>一旦你使用了运算符，就创建了表达式。下面是一些运算符表达式的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a++</span><br><span class="line">a + b</span><br><span class="line">a &#x3D; b</span><br><span class="line">a &#x3D;&#x3D; b</span><br><span class="line">c ? a : b</span><br><span class="line">a is T</span><br></pre></td></tr></table></figure>

<p>在<a href="https://dart.cn/guides/language/language-tour#operators" target="_blank" rel="noopener">运算符表</a> 中，运算符的优先级按先后排列，即第一行优先级最高，最后一行优先级最低，而同一行中，最左边的优先级最高，最右边的优先级最低。例如：<code>%</code> 运算符优先级高于 <code>==</code> ，而 <code>==</code> 高于 <code>&amp;&amp;</code>。根据优先级规则，那么意味着以下两行代码执行的效果相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 括号提高了可读性。</span><br><span class="line">&#x2F;&#x2F; Parentheses improve readability.</span><br><span class="line">if ((n % i &#x3D;&#x3D; 0) &amp;&amp; (d % i &#x3D;&#x3D; 0)) ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 难以理解，但是与上面的代码效果一样。</span><br><span class="line">if (n % i &#x3D;&#x3D; 0 &amp;&amp; d % i &#x3D;&#x3D; 0) ...</span><br></pre></td></tr></table></figure>

<h3 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h3><p>Dart 支持常用的算术运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td><code>–</code></td>
<td>减</td>
</tr>
<tr>
<td><code>-*表达式*</code></td>
<td>一元负, 也可以作为反转（反转表达式的符号）</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>~/</code></td>
<td>除并取整</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert(2 + 3 &#x3D;&#x3D; 5);</span><br><span class="line">assert(2 - 3 &#x3D;&#x3D; -1);</span><br><span class="line">assert(2 * 3 &#x3D;&#x3D; 6);</span><br><span class="line">assert(5 &#x2F; 2 &#x3D;&#x3D; 2.5); &#x2F;&#x2F; 结果是一个浮点数</span><br><span class="line">assert(5 ~&#x2F; 2 &#x3D;&#x3D; 2); &#x2F;&#x2F; 结果是一个整数</span><br><span class="line">assert(5 % 2 &#x3D;&#x3D; 1); &#x2F;&#x2F; 取余</span><br><span class="line"></span><br><span class="line">assert(&#39;5&#x2F;2 &#x3D; $&#123;5 ~&#x2F; 2&#125; r $&#123;5 % 2&#125;&#39; &#x3D;&#x3D; &#39;5&#x2F;2 &#x3D; 2 r 1&#39;);</span><br></pre></td></tr></table></figure>

<p>Dart 还支持自增自减操作。</p>
<table>
<thead>
<tr>
<th>Operator<code>++*var*</code></th>
<th><code>*var* = *var* + 1</code> (表达式的值为 <code>*var* + 1</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><code>*var*++</code></td>
<td><code>*var* = *var* + 1</code> (表达式的值为 <code>*var*</code>)</td>
</tr>
<tr>
<td><code>--*var*</code></td>
<td><code>*var* = *var* – 1</code> (表达式的值为 <code>*var* – 1</code>)</td>
</tr>
<tr>
<td><code>*var*--</code></td>
<td><code>*var* = *var* – 1</code> (表达式的值为 <code>*var*</code>)</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a, b;</span><br><span class="line"></span><br><span class="line">a &#x3D; 0;</span><br><span class="line">b &#x3D; ++a; &#x2F;&#x2F; 在 b 赋值前将 a 增加 1。</span><br><span class="line">assert(a &#x3D;&#x3D; b); &#x2F;&#x2F; 1 &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">a &#x3D; 0;</span><br><span class="line">b &#x3D; a++; &#x2F;&#x2F; 在 b 赋值后将 a 增加 1。</span><br><span class="line">assert(a !&#x3D; b); &#x2F;&#x2F; 1 !&#x3D; 0</span><br><span class="line"></span><br><span class="line">a &#x3D; 0;</span><br><span class="line">b &#x3D; --a; &#x2F;&#x2F; 在 b 赋值前将 a 减少 1。</span><br><span class="line">assert(a &#x3D;&#x3D; b); &#x2F;&#x2F; -1 &#x3D;&#x3D; -1</span><br><span class="line"></span><br><span class="line">a &#x3D; 0;</span><br><span class="line">b &#x3D; a--; &#x2F;&#x2F; 在 b 赋值后将 a 减少 1。</span><br><span class="line">assert(a !&#x3D; b); &#x2F;&#x2F; -1 !&#x3D; 0</span><br></pre></td></tr></table></figure>

<h3 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 关系运算符</h3><p>下表列出了关系运算符及含义：</p>
<table>
<thead>
<tr>
<th>Operator<code>==</code></th>
<th>相等</th>
</tr>
</thead>
<tbody><tr>
<td><code>!=</code></td>
<td>不等</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<p>要判断两个对象 x 和 y 是否表示相同的事物使用 <code>==</code> 即可。（在极少数情况下，可能需要使用 <a href="https://api.dart.dev/stable/dart-core/identical.html" target="_blank" rel="noopener">identical()</a> 函数来确定两个对象是否完全相同。）。下面是 <code>==</code> 运算符的一些规则：</p>
<ol>
<li>假设有变量 <em>x</em> 和 <em>y</em>，且 x 和 y 至少有一个为 null，则当且仅当 x 和 y 均为 null 时 x == y 才会返回 true，否则只有一个为 null 则返回 false。</li>
<li><code>*x*.==(*y*)</code> 将会返回值，这里不管有没有 y，即 y 是可选的。也就是说 <code>==</code> 其实是 x 中的一个方法，并且可以被重写。详情请查阅<a href="https://dart.cn/guides/language/language-tour#overridable-operators" target="_blank" rel="noopener">重写运算符</a>。</li>
</ol>
<p>下面的代码给出了每一种关系运算符的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assert(2 &#x3D;&#x3D; 2);</span><br><span class="line">assert(2 !&#x3D; 3);</span><br><span class="line">assert(3 &gt; 2);</span><br><span class="line">assert(2 &lt; 3);</span><br><span class="line">assert(3 &gt;&#x3D; 3);</span><br><span class="line">assert(2 &lt;&#x3D; 3);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-类型判断运算符"><a href="#4-3-类型判断运算符" class="headerlink" title="4.3 类型判断运算符"></a>4.3 类型判断运算符</h3><p><code>as</code>、<code>is</code>、<code>is!</code> 运算符是在运行时判断对象类型的运算符。</p>
<table>
<thead>
<tr>
<th>Operator<code>as</code></th>
<th>类型转换（也用作指定<a href="https://dart.cn/guides/language/language-tour#specifying-a-library-prefix" target="_blank" rel="noopener">类前缀</a>)）</th>
</tr>
</thead>
<tbody><tr>
<td><code>is</code></td>
<td>如果对象是指定类型则返回 true</td>
</tr>
<tr>
<td><code>is!</code></td>
<td>如果对象是指定类型则返回 false</td>
</tr>
</tbody></table>
<p>当且仅当 <code>obj</code> 实现了 <code>T</code> 的接口，<code>obj is T</code> 才是 true。例如 <code>obj is Object</code> 总为 true，因为所有类都是 Object 的子类。</p>
<p>仅当你确定这个对象是该类型的时候，你才可以使用 <code>as</code> 操作符可以把对象转换为特定的类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp as Person).firstName &#x3D; &#39;Bob&#39;;</span><br></pre></td></tr></table></figure>

<p>如果你不确定这个对象类型是不是 <code>T</code>，请在转型前使用 <code>is T</code> 检查类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (emp is Person) &#123;</span><br><span class="line">  &#x2F;&#x2F; 类型检查</span><br><span class="line">  emp.firstName &#x3D; &#39;Bob&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>as</code> 运算符进行缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp as Person).firstName &#x3D; &#39;Bob&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述两种方式是有区别的：如果 <code>emp</code> 为 null 或者不为 Person 类型，则第一种方式将会抛出异常，而第二种不会。</p>
</blockquote>
<h3 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h3><p>可以使用 <code>=</code> 来赋值，同时也可以使用 <code>??=</code> 来为值为 null 的变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 value 赋值给 a (Assign value to a)</span><br><span class="line">a &#x3D; value;</span><br><span class="line">&#x2F;&#x2F; 当且仅当 b 为 null 时才赋值</span><br><span class="line">b ??&#x3D; value;</span><br></pre></td></tr></table></figure>

<p>像 <code>+=</code> 这样的赋值运算符将算数运算符和赋值运算符组合在了一起。</p>
<table>
<thead>
<tr>
<th><code>=</code></th>
<th><code>–=</code></th>
<th><code>/=</code></th>
<th><code>%=</code></th>
<th><code>&gt;&gt;=</code></th>
<th><code>^=</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>+=</code></td>
<td><code>*=</code></td>
<td><code>~/=</code></td>
<td><code>&lt;&lt;=</code></td>
<td><code>&amp;=</code></td>
<td>`</td>
</tr>
</tbody></table>
<p>下表解释了符合运算符的原理：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>复合运算</th>
<th>等效表达式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>假设有运算符 *op*：</strong></td>
<td><code>a *op*= b</code></td>
<td><code>a = a *op* b</code></td>
</tr>
<tr>
<td><strong>示例：</strong></td>
<td><code>a += b</code></td>
<td><code>a = a + b</code></td>
</tr>
</tbody></table>
<p>下面的例子展示了如何使用赋值以及复合赋值运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2; &#x2F;&#x2F; 使用 &#x3D; 赋值 (Assign using &#x3D;)</span><br><span class="line">a *&#x3D; 3; &#x2F;&#x2F; 赋值并做乘法运算 Assign and multiply: a &#x3D; a * 3</span><br><span class="line">assert(a &#x3D;&#x3D; 6);</span><br></pre></td></tr></table></figure>

<h3 id="4-5-逻辑运算符"><a href="#4-5-逻辑运算符" class="headerlink" title="4.5 逻辑运算符"></a>4.5 逻辑运算符</h3><p>使用逻辑运算符你可以反转或组合布尔表达式。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>!*表达式*</code></td>
<td>对表达式结果取反（即将 true 变为 false，false 变为 true）</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
</tbody></table>
<p>下面是使用逻辑表达式的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!done &amp;&amp; (col &#x3D;&#x3D; 0 || col &#x3D;&#x3D; 3)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...Do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-按位和移位运算符"><a href="#4-6-按位和移位运算符" class="headerlink" title="4.6 按位和移位运算符"></a>4.6 按位和移位运算符</h3><p>在 Dart 中，二进制位运算符可以操作二进制的某一位，但仅适用于整数。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
</tr>
<tr>
<td><code>~*表达式*</code></td>
<td>按位取反（即将 “0” 变为 “1”，“1” 变为 “0”）</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>位左移</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>位右移</td>
</tr>
</tbody></table>
<p>下面是使用按位和移位运算符的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final value &#x3D; 0x22;</span><br><span class="line">final bitmask &#x3D; 0x0f;</span><br><span class="line"></span><br><span class="line">assert((value &amp; bitmask) &#x3D;&#x3D; 0x02); &#x2F;&#x2F; 按位与 (AND)</span><br><span class="line">assert((value &amp; ~bitmask) &#x3D;&#x3D; 0x20); &#x2F;&#x2F; 取反后按位与 (AND NOT)</span><br><span class="line">assert((value | bitmask) &#x3D;&#x3D; 0x2f); &#x2F;&#x2F; 按位或 (OR)</span><br><span class="line">assert((value ^ bitmask) &#x3D;&#x3D; 0x2d); &#x2F;&#x2F; 按位异或 (XOR)</span><br><span class="line">assert((value &lt;&lt; 4) &#x3D;&#x3D; 0x220); &#x2F;&#x2F; 位左移 (Shift left)</span><br><span class="line">assert((value &gt;&gt; 4) &#x3D;&#x3D; 0x02); &#x2F;&#x2F; 位右移 (Shift right)</span><br></pre></td></tr></table></figure>

<h3 id="4-7-条件表达式"><a href="#4-7-条件表达式" class="headerlink" title="4.7 条件表达式"></a>4.7 条件表达式</h3><p>Dart 有两个特殊的运算符可以用来替代 <a href="https://dart.cn/guides/language/language-tour#if-和-else" target="_blank" rel="noopener">if-else</a> 语句：</p>
<ul>
<li><p><code>*condition* ? *expr1* : *expr2*</code></p>
<p><code>*条件* ? *表达式 1* : *表达式 2*</code> ：如果条件为 true，执行表达式 1并返回执行结果，否则执行表达式 2 并返回执行结果。</p>
</li>
<li><p><code>*expr1* ?? *expr2*</code></p>
<p><code>*表达式 1* ?? *表达式 2*</code>：如果表达式 1 为非 null 则返回其值，否则执行表达式 2 并返回其值。</p>
</li>
</ul>
<p><strong>如果赋值是根据布尔表达式则考虑使用 <code>?:</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var visibility &#x3D; isPublic ? &#39;public&#39; : &#39;private&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>如果赋值是根据判定是否为 null 则考虑使用 <code>??</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String playerName(String name) &#x3D;&gt; name ?? &#39;Guest&#39;;</span><br></pre></td></tr></table></figure>

<p>上述示例还可以写成至少下面两种不同的形式，只是不够简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 相对使用 ?: 运算符来说稍微长了点。(Slightly longer version uses ?: operator).</span><br><span class="line">String playerName(String name) &#x3D;&gt; name !&#x3D; null ? name : &#39;Guest&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果使用 if-else 则更长。</span><br><span class="line">String playerName(String name) &#123;</span><br><span class="line">  if (name !&#x3D; null) &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#39;Guest&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-级联运算符（-）"><a href="#4-8-级联运算符（-）" class="headerlink" title="4.8 级联运算符（..）"></a>4.8 级联运算符（..）</h3><p>级联运算符（<code>..</code>）可以让你在同一个对象上连续调用多个对象的变量或方法。</p>
<p>比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">querySelector(&#39;#confirm&#39;) &#x2F;&#x2F; 获取对象 (Get an object).</span><br><span class="line">  ..text &#x3D; &#39;Confirm&#39; &#x2F;&#x2F; 使用对象的成员 (Use its members).</span><br><span class="line">  ..classes.add(&#39;important&#39;)</span><br><span class="line">  ..onClick.listen((e) &#x3D;&gt; window.alert(&#39;Confirmed!&#39;));</span><br></pre></td></tr></table></figure>

<p>第一个方法 <code>querySelector</code> 返回了一个 Selector 对象，后面的级联操作符都是调用这个 Selector 对象的成员并忽略每个操作的返回值。</p>
<p>上面的代码相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var button &#x3D; querySelector(&#39;#confirm&#39;);</span><br><span class="line">button.text &#x3D; &#39;Confirm&#39;;</span><br><span class="line">button.classes.add(&#39;important&#39;);</span><br><span class="line">button.onClick.listen((e) &#x3D;&gt; window.alert(&#39;Confirmed!&#39;));</span><br></pre></td></tr></table></figure>

<p>级联运算符可以嵌套，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final addressBook &#x3D; (AddressBookBuilder()</span><br><span class="line">      ..name &#x3D; &#39;jenny&#39;</span><br><span class="line">      ..email &#x3D; &#39;jenny@example.com&#39;</span><br><span class="line">      ..phone &#x3D; (PhoneNumberBuilder()</span><br><span class="line">            ..number &#x3D; &#39;415-555-0100&#39;</span><br><span class="line">            ..label &#x3D; &#39;home&#39;)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>在返回对象的函数中谨慎使用级联操作符。例如，下面的代码是错误的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sb &#x3D; StringBuffer();</span><br><span class="line">sb.write(&#39;foo&#39;)</span><br><span class="line">  ..write(&#39;bar&#39;); &#x2F;&#x2F; 出错：void 对象中没有方法 write (Error: method &#39;write&#39; isn&#39;t defined for &#39;void&#39;).</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>sb.write()</code> 方法返回的是 void，返回值为 <code>void</code> 的方法则不能使用级联运算符。</p>
<blockquote>
<p>严格来说 <code>..</code> 级联操作并非一个运算符而是 Dart 的特殊语法。</p>
</blockquote>
<h3 id="4-9-其他运算符"><a href="#4-9-其他运算符" class="headerlink" title="4.9 其他运算符"></a>4.9 其他运算符</h3><p>大多数其它的运算符，已经在其它的示例中使用过：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>使用方法</td>
<td>代表调用一个方法</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>访问 List</td>
<td>访问 List 中特定位置的元素</td>
</tr>
<tr>
<td><code>.</code></td>
<td>访问成员</td>
<td>成员访问符</td>
</tr>
<tr>
<td><code>?.</code></td>
<td>条件访问成员</td>
<td>与上述成员访问符类似，但是左边的操作对象不能为 null，例如 foo?.bar，如果 foo 为 null 则返回 null ，否则返回 bar</td>
</tr>
</tbody></table>
<p>更多关于 <code>.</code>, <code>?.</code> 和 <code>..</code> 运算符介绍，请参考<a href="https://dart.cn/guides/language/language-tour#classes" target="_blank" rel="noopener">类</a>.</p>
<h2 id="五、流程控制语句"><a href="#五、流程控制语句" class="headerlink" title="五、流程控制语句"></a>五、流程控制语句</h2><p>你可以使用下面的语句来控制 Dart 代码的执行流程：</p>
<ul>
<li><code>if</code> 和 <code>else</code></li>
<li><code>for</code> 循环</li>
<li><code>while</code> 和 <code>do</code>-<code>while</code> 循环</li>
<li><code>break</code> 和 <code>continue</code></li>
<li><code>switch</code> 和 <code>case</code></li>
<li><code>assert</code></li>
</ul>
<p>使用 <code>try-catch</code> 和 <code>throw</code> 也能影响控制流，详情参考<a href="https://dart.cn/guides/language/language-tour#exceptions" target="_blank" rel="noopener">异常</a>部分。</p>
<h3 id="5-1-If-和-Else"><a href="#5-1-If-和-Else" class="headerlink" title="5.1 If 和 Else"></a>5.1 If 和 Else</h3><p>Dart 支持 <code>if - else</code> 语句，其中 <code>else</code> 是可选的，比如下面的例子。你也可以参考<a href="https://dart.cn/guides/language/language-tour#conditional-expressions" target="_blank" rel="noopener">条件表达式</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (isRaining()) &#123;</span><br><span class="line">  you.bringRainCoat();</span><br><span class="line">&#125; else if (isSnowing()) &#123;</span><br><span class="line">  you.wearJacket();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  car.putTopDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 JavaScript 不同的是，Dart 的 if 语句中的条件必须是一个布尔值，不能是其它类型。详情请查阅<a href="https://dart.cn/guides/language/language-tour#booleans" target="_blank" rel="noopener">布尔值</a>。</p>
<h3 id="5-2-For-循环"><a href="#5-2-For-循环" class="headerlink" title="5.2 For 循环"></a>5.2 For 循环</h3><p>你可以使用标准的 <code>for</code> 循环进行迭代。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var message &#x3D; StringBuffer(&#39;Dart is fun&#39;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">  message.write(&#39;!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Dart 语言中，<code>for</code> 循环中的闭包会自动捕获循环的 <strong>索引值</strong> 以避免 JavaScript 中一些常见的陷阱。假设有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var callbacks &#x3D; [];</span><br><span class="line">for (var i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">  callbacks.add(() &#x3D;&gt; print(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) &#x3D;&gt; c());</span><br></pre></td></tr></table></figure>

<p>上述代码执行后会输出 <code>0</code> 和 <code>1</code>，但是如果在 JavaScript 中执行同样的代码则会输出两个 <code>2</code>。</p>
<p>如果要遍历的对象实现了 Iterable 接口，则可以使用 <a href="https://api.dart.dev/stable/dart-core/Iterable/forEach.html" target="_blank" rel="noopener">forEach()</a> 方法，如果不需要使用到索引，则使用 <code>forEach</code> 方法是一个非常好的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidates.forEach((candidate) &#x3D;&gt; candidate.interview());</span><br></pre></td></tr></table></figure>

<p>像 List 和 Set 等实现了 Iterable 接口的类还支持 <code>for-in</code> 形式的 <a href="https://dart.cn/guides/libraries/library-tour#iteration" target="_blank" rel="noopener">迭代</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var collection &#x3D; [0, 1, 2];</span><br><span class="line">for (var x in collection) &#123;</span><br><span class="line">  print(x); &#x2F;&#x2F; 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-While-和-Do-While"><a href="#5-3-While-和-Do-While" class="headerlink" title="5.3 While 和 Do-While"></a>5.3 While 和 Do-While</h3><p><code>while</code> 循环会在执行循环体前先判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (!isDone()) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do-while</code> 循环则会先执行一遍循环体 <em>再</em> 判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  printLine();</span><br><span class="line">&#125; while (!atEndOfPage());</span><br></pre></td></tr></table></figure>

<h3 id="5-4-Break-和-Continue"><a href="#5-4-Break-和-Continue" class="headerlink" title="5.4 Break 和 Continue"></a>5.4 Break 和 Continue</h3><p>使用 <code>break</code> 可以中断循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  if (shutDownRequested()) break;</span><br><span class="line">  processIncomingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>continue</code> 可以跳过本次循环直接进入下一次循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; candidates.length; i++) &#123;</span><br><span class="line">  var candidate &#x3D; candidates[i];</span><br><span class="line">  if (candidate.yearsExperience &lt; 5) &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line">  candidate.interview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 candidates 如果像 List 或 Set 一样实现了 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html" target="_blank" rel="noopener">Iterable</a> 接口则可以简单地使用下述写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">candidates</span><br><span class="line">    .where((c) &#x3D;&gt; c.yearsExperience &gt;&#x3D; 5)</span><br><span class="line">    .forEach((c) &#x3D;&gt; c.interview());</span><br></pre></td></tr></table></figure>

<h3 id="5-5-Switch-和-Case"><a href="#5-5-Switch-和-Case" class="headerlink" title="5.5 Switch 和 Case"></a>5.5 Switch 和 Case</h3><p>Switch 语句在 Dart 中使用 <code>==</code> 来比较整数、字符串或编译时常量，比较的两个对象必须是同一个类型且不能是子类并且没有重写 <code>==</code> 操作符。 <a href="https://dart.cn/guides/language/language-tour#enumerated-types" target="_blank" rel="noopener">枚举类型</a>非常适合在 <code>Switch</code> 语句中使用。</p>
<p> <strong>备忘:</strong></p>
<blockquote>
<p>Dart 中的 Switch 语句仅适用于有限的情况，比如使用解释器和扫描器的场景。</p>
</blockquote>
<p>每一个非空的 <code>case</code> 子句都必须有一个 <code>break</code> 语句，也可以通过 <code>continue</code>、<code>throw</code> 或者 <code>return</code> 来结束非空 <code>case</code> 语句。</p>
<p>当没有 <code>case</code> 语句匹配时，可以使用 <code>default</code> 子句来匹配这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var command &#x3D; &#39;OPEN&#39;;</span><br><span class="line">switch (command) &#123;</span><br><span class="line">  case &#39;CLOSED&#39;:</span><br><span class="line">    executeClosed();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;PENDING&#39;:</span><br><span class="line">    executePending();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;APPROVED&#39;:</span><br><span class="line">    executeApproved();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;DENIED&#39;:</span><br><span class="line">    executeDenied();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;OPEN&#39;:</span><br><span class="line">    executeOpen();</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    executeUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子忽略了 <code>case</code> 子句的 <code>break</code> 语句，因此会产生错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var command &#x3D; &#39;OPEN&#39;;</span><br><span class="line">switch (command) &#123;</span><br><span class="line">  case &#39;OPEN&#39;:</span><br><span class="line">    executeOpen();</span><br><span class="line">    &#x2F;&#x2F; 错误: 没有 break</span><br><span class="line"></span><br><span class="line">  case &#39;CLOSED&#39;:</span><br><span class="line">    executeClosed();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，Dart 支持空的 <code>case</code> 语句，允许其以 fall-through 的形式执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var command &#x3D; &#39;CLOSED&#39;;</span><br><span class="line">switch (command) &#123;</span><br><span class="line">  case &#39;CLOSED&#39;: &#x2F;&#x2F; case 语句为空时的 fall-through 形式。</span><br><span class="line">  case &#39;NOW_CLOSED&#39;:</span><br><span class="line">    &#x2F;&#x2F; case 条件值为 CLOSED 和 NOW_CLOSED 时均会执行该语句。</span><br><span class="line">    executeNowClosed();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在非空 <code>case</code> 语句中想要实现 fall-through 的形式，可以使用 <code>continue</code> 语句配合 lable 的方式实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var command &#x3D; &#39;CLOSED&#39;;</span><br><span class="line">switch (command) &#123;</span><br><span class="line">  case &#39;CLOSED&#39;:</span><br><span class="line">    executeClosed();</span><br><span class="line">    continue nowClosed;</span><br><span class="line">  &#x2F;&#x2F; 继续执行标签为 nowClosed 的 case 子句。</span><br><span class="line"></span><br><span class="line">  nowClosed:</span><br><span class="line">  case &#39;NOW_CLOSED&#39;:</span><br><span class="line">    &#x2F;&#x2F; case 条件值为 CLOSED 和 NOW_CLOSED 时均会执行该语句。</span><br><span class="line">    executeNowClosed();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 <code>case</code> 子句都可以有局部变量且仅在该 case 语句内可见。</p>
<h3 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a>5.6 断言</h3><p>在开发过程中，可以在条件表达式为 false 时使用 - <code>assert(*条件*, *可选信息*)</code>; - 语句来打断代码的执行。你可以在本文中找到大量使用 assert 的例子。下面是相关示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 确保变量值不为 null (Make sure the variable has a non-null value)</span><br><span class="line">assert(text !&#x3D; null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 确保变量值小于 100。</span><br><span class="line">assert(number &lt; 100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 确保这是一个 https 地址。</span><br><span class="line">assert(urlString.startsWith(&#39;https&#39;));</span><br></pre></td></tr></table></figure>

<p><code>assert</code> 的第二个参数可以为其添加一个字符串消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(urlString.startsWith(&#39;https&#39;),</span><br><span class="line">    &#39;URL ($urlString) should start with &quot;https&quot;.&#39;);</span><br></pre></td></tr></table></figure>

<p><code>assert</code> 的第一个参数可以是值为布尔值的任何表达式。如果表达式的值为 true，则断言成功，继续执行。如果表达式的值为 false，则断言失败，抛出一个 <a href="https://api.dart.dev/stable/dart-core/AssertionError-class.html" target="_blank" rel="noopener">AssertionError</a> 异常。</p>
<p>如何判断 assert 是否生效？assert 是否生效依赖开发工具和使用的框架：</p>
<ul>
<li>Flutter 在<a href="https://flutter.cn/docs/testing/debugging#debug-mode-assertions" target="_blank" rel="noopener">调试模式</a>时生效。</li>
<li>一些开发工具比如 <a href="https://dart.cn/tools/dartdevc" target="_blank" rel="noopener">dartdevc</a> 通常情况下是默认生效的。</li>
<li>其他一些工具，比如 <a href="https://dart.cn/server/tools/dart-vm" target="_blank" rel="noopener">dart</a> 以及 <a href="https://dart.cn/tools/dart2js" target="_blank" rel="noopener">dart2js</a> 通过在运行 Dart 程序时添加命令行参数 <code>--enable-asserts</code> 使 assert 生效。</li>
</ul>
<p>在生产环境代码中，断言会被忽略，与此同时传入 <code>assert</code> 的参数不被判断。</p>
<h2 id="六、异常"><a href="#六、异常" class="headerlink" title="六、异常"></a>六、异常</h2><p>Dart 代码可以抛出和捕获异常。异常表示一些未知的错误情况，如果异常没有捕获则会被抛出从而导致抛出异常的代码终止执行。</p>
<p>与 Java 不同的是，Dart 的所有异常都是非必检异常，方法不一定会声明其所抛出的异常并且你也不会被要求捕获任何异常。</p>
<p>Dart 提供了 <a href="https://api.dart.dev/stable/dart-core/Exception-class.html" target="_blank" rel="noopener">Exception</a> 和 <a href="https://api.dart.dev/stable/dart-core/Error-class.html" target="_blank" rel="noopener">Error</a> 两种类型的异常以及它们一系列的子类，你也可以定义自己的异常类型。但是在 Dart 中可以将任何非 null 对象作为异常抛出而不局限于 Exception 或 Error 类型。</p>
<h3 id="6-1-抛出异常"><a href="#6-1-抛出异常" class="headerlink" title="6.1 抛出异常"></a>6.1 抛出异常</h3><p>下面是关于抛出或者 <em>引发</em> 异常的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw FormatException(&#39;Expected at least 1 section&#39;);</span><br></pre></td></tr></table></figure>

<p>你也可以抛出任意的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw &#39;Out of llamas!&#39;;</span><br></pre></td></tr></table></figure>

<p> <strong>备忘:</strong></p>
<p>优秀的代码通常会抛出 <a href="https://api.dart.dev/stable/dart-core/Error-class.html" target="_blank" rel="noopener">Error</a> 或 <a href="https://api.dart.dev/stable/dart-core/Exception-class.html" target="_blank" rel="noopener">Exception</a> 类型的异常。</p>
<p>因为抛出异常是一个表达式，所以可以在 =&gt; 语句中使用，也可以在其他使用表达式的地方抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void distanceTo(Point other) &#x3D;&gt; throw UnimplementedError();</span><br></pre></td></tr></table></figure>

<h3 id="6-2-捕获异常"><a href="#6-2-捕获异常" class="headerlink" title="6.2 捕获异常"></a>6.2 捕获异常</h3><p>捕获异常可以避免异常继续传递（重新抛出异常除外）。捕获一个异常可以给你处理它的机会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于可以抛出多种异常类型的代码，也可以指定多个 catch 语句，每个语句分别对应一个异常类型，如果 catch 语句没有指定异常类型则表示可以捕获任意异常类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  &#x2F;&#x2F; 指定异常</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 其它类型的异常</span><br><span class="line">  print(&#39;Unknown exception: $e&#39;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#x2F;&#x2F; 不指定类型，处理其它全部</span><br><span class="line">  print(&#39;Something really unknown: $e&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示可以使用 <code>on</code> 或 <code>catch</code> 来捕获异常，使用 <code>on</code> 来指定异常类型，使用 <code>catch</code> 来捕获异常对象，两者可同时使用。</p>
<p>你可以为 <code>catch</code> 方法指定两个参数，第一个参数为抛出的异常对象，第二个参数为栈信息 <a href="https://api.dart.dev/stable/dart-core/StackTrace-class.html" target="_blank" rel="noopener">StackTrace</a> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Exception details:\n <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Exception details:\n <span class="subst">$e</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Stack trace:\n <span class="subst">$s</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字 <code>rethrow</code> 可以将捕获的异常再次抛出：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">dynamic</span> foo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">print</span>(foo++); <span class="comment">// 运行时错误</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// 允许调用者查看异常。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'main() finished handling <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Finally"><a href="#6-3-Finally" class="headerlink" title="6.3 Finally"></a>6.3 Finally</h3><p>可以使用 <code>finally</code> 语句来包裹确保不管有没有异常都执行代码，如果没有指定 <code>catch</code> 语句来捕获异常，则在执行完 <code>finally</code> 语句后再抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  &#x2F;&#x2F; 总是清理，即便抛出了异常。</span><br><span class="line">  cleanLlamaStalls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finally</code> 语句会在任何匹配的 <code>catch</code> 语句后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  print(&#39;Error: $e&#39;); &#x2F;&#x2F; 先处理异常。</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  cleanLlamaStalls(); &#x2F;&#x2F; 然后清理。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多详情，请参考你可以阅读 Dart 核心库概览的 <a href="https://dart.cn/guides/libraries/library-tour#exceptions" target="_blank" rel="noopener">异常</a> 章节获取更多相关信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Android/%E5%BC%80%E5%8F%91/APP%E4%BC%98%E5%8C%96%E5%B0%8F%E5%BB%BA%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/09/Android/%E5%BC%80%E5%8F%91/APP%E4%BC%98%E5%8C%96%E5%B0%8F%E5%BB%BA%E8%AE%AE/" itemprop="url">APP优化小建议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-09T19:36:07+08:00">
                2020-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/09/Android/%E5%BC%80%E5%8F%91/APP%E4%BC%98%E5%8C%96%E5%B0%8F%E5%BB%BA%E8%AE%AE/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/09/Android/%E5%BC%80%E5%8F%91/APP%E4%BC%98%E5%8C%96%E5%B0%8F%E5%BB%BA%E8%AE%AE/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>从代码角度，列举一些针对Android的App开发的优化小建议</p>
</blockquote>
<h2 id="1-广播"><a href="#1-广播" class="headerlink" title="1. 广播"></a>1. 广播</h2><p>应用程序内部广播通信，优先采用LocalBroadcastManager，安全性更好，运行效率更高。 见文章<a href="http://www.gityuan.com/2017/4/23/local_broadcast_manager" target="_blank" rel="noopener">LocalBroadcastManager原理分析</a></p>
<h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><p>线程创建优先采用线程池<code>ThreadPoolExecutor</code>，而不是<code>new Thread()</code>； 另外设置线程优先级为后台运行优先级，能有效减少Runnable创建的线程和和UI线程之间的资源竞争。</p>
<p><strong>优势：</strong> 通过<code>new Thread()</code>来创建线程是比较常用的方式，而使用线程池的方式有不少优势如下</p>
<ul>
<li>线程可重复利用，节省线程的创建与销毁开销，性能有所提升；</li>
<li>方便控制并发线程数，提高资源的利用率，减少过多的资源竞争；</li>
</ul>
<p><strong>用法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建Runable对象</span><br><span class="line">Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            &#x2F;&#x2F;TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#x2F;&#x2F;创建线程池</span><br><span class="line">ExecutorService threadPoolExecutor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">    corePoolSize, maximumPoolSize,</span><br><span class="line">    keepAliveTime, unit, workQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行runnable</span><br><span class="line">threadPoolExecutor.execute(runnable);</span><br></pre></td></tr></table></figure>

<p>对于corePoolSize，一般往往可以设置为<code>Runtime.getRuntime().availableProcessors()</code>，代表当前系统活跃的CPU个数。</p>
<p>另外系统采用工厂模式，通过设置ThreadPoolExecutor的不同参数，提供四种默认线程池： <strong>(1) newCachedThreadPool</strong> 可缓存线程池，若线程空闲60s则回收，若无空闲线程可无限创建新线程，定义如下： <code>new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</code></p>
<p>调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">cachedThreadPool.execute(runnable);</span><br></pre></td></tr></table></figure>

<p><strong>(2) newFixedThreadPool</strong> 定长线程，固定线程池大小，定义如下： <code>new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></p>
<p>调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool &#x3D; Executors.newFixedThreadPool(nThreads);</span><br><span class="line">fixedThreadPool.execute(runnable);</span><br></pre></td></tr></table></figure>

<p><strong>(3) newSingleThreadExecutor</strong> 只有一个线程的线程池，定义如下： <code>new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));</code></p>
<p>调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">newSingleThreadExecutor.execute(runnable);</span><br></pre></td></tr></table></figure>

<p><strong>(4) newScheduledThreadPool</strong> 可定时周期执行的线程池，定义如下： <code>new ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());</code></p>
<p>调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService scheduledThreadPool &#x3D; Executors.newScheduledThreadPool(corePoolSize);</span><br><span class="line">scheduledThreadPool.schedule(runnable, delay, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h2 id="3-ArrayList-Vs-LinkedList"><a href="#3-ArrayList-Vs-LinkedList" class="headerlink" title="3. ArrayList Vs LinkedList"></a>3. ArrayList Vs LinkedList</h2><p>ArrayList基于动态数组的数据结构， 对于随机访问(get/set)，ArrayList效率比LinkedList高； LinkedList基于链表的数据结构，对于新增和删除(add/remove)，LinedList效率比ArrayList高；</p>
<p>（1）对于list, 优先选择ArrayList，除非少数需要大量的插入/删除操作才使用LinkedList。因为当数据量非常大时get操作，LinkedList时间复杂度为o(n), 而ArrayList时间复杂度为o(1)。</p>
<p>（2）循环遍历</p>
<p>LinkedList采用foreach方式， 效率最高。for循环方式效率大幅度降低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">for (Integer j : list) &#123;</span><br><span class="line">    ... &#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList采用for循环+临时变量保存size，效率最高。 foreach方式效率略微降低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">int len &#x3D; list.size();</span><br><span class="line">for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">    list.get(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)采用new ArrayList()方式，初始大小为0，首次增加数组时，扩充大小到12，以后到数组需要增长时，会将大小增加50%，并将原来的成员全部复制到新的数组内。所以尽可能将ArrayList提前设置成目标大小，或者接近目标大小，以减少数组不断创建与复制的过程，提高效率。</p>
<h2 id="4-HashMap-Vs-SparseArray"><a href="#4-HashMap-Vs-SparseArray" class="headerlink" title="4. HashMap Vs SparseArray"></a>4. HashMap Vs SparseArray</h2><p>(1)同时需要key和value，采用如下遍历方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        entry.getKey();</span><br><span class="line">        entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)只需要获取key，采用如下遍历方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    &#x2F;&#x2F; key process</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 当HashMap的key是整型时，采用SparseArray，效率更高。避免了对key与value的自动装箱与解箱操作。</p>
<h2 id="5-Bitmap"><a href="#5-Bitmap" class="headerlink" title="5. Bitmap"></a>5. Bitmap</h2><ul>
<li>使用BitmapFactory.Options对图片进行缩略读取；减小内存使用量；<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，先计算出一个合适的缩放比例，避免不必要的大图载入</li>
<li>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，能减小内存空间</li>
</ul>
</li>
<li>使用SoftReference:当内存不足时，虚拟机会自动回收它；</li>
<li>使用Bitmap.recycle()释放图片，虚拟机gc时回收Bitmap;</li>
<li>根据手机尺寸大小，配置不同大小的图片，保证使用尽可能小的图片资源。</li>
</ul>
<h2 id="6-Object-Pool"><a href="#6-Object-Pool" class="headerlink" title="6. Object Pool"></a>6. Object Pool</h2><p>内存对象，通过对象池技术来达到重复利用，减少对象重复创建。，从而减少内存分配和回收。</p>
<ul>
<li>复用系统自带的资源，framework-res.apk中包含很多内置资源，比如字符串/颜色/图片/样式/布局等。可减少APK大小、内存开销。</li>
<li>缓存算法LRU</li>
</ul>
<h2 id="7-Job-Scheduler"><a href="#7-Job-Scheduler" class="headerlink" title="7. Job Scheduler"></a>7. Job Scheduler</h2><p>使用Job Scheduler，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。</p>
<h2 id="8-Android避免使用Enum"><a href="#8-Android避免使用Enum" class="headerlink" title="8. Android避免使用Enum"></a>8. Android避免使用Enum</h2><p>Enum比静态常量，至少需要多过于2倍以上的内存空间，应该在Android中避免使用枚举。</p>
<h2 id="9-onDraw"><a href="#9-onDraw" class="headerlink" title="9. onDraw()"></a>9. onDraw()</h2><p>由于onDraw方法调用比较频繁，需避免对象创建操作，因为迅速增加内存，同样引起频繁的gc，甚至内存抖动。</p>
<h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h2><ul>
<li>内部类引用导致Activity的泄漏，尤其是Handler</li>
<li>监听器即使注销</li>
<li>考虑使用Application Context而不是Activity Context</li>
<li>onLowMemory()与onTrimMemory()</li>
<li>使用nano protobufs序列化数据</li>
<li>使用IntentService</li>
<li>Adapter 利用convertView.getTag()与 ViewHolder</li>
<li>窗口默认有一个不透明的背景，可以去掉的： getWindow().setBackground(null),或者修改xml</li>
<li>UI局部刷新</li>
<li>在性能敏感的代码，避免创建Java对象。比如onMeasure(), onLayout(), onDraw()， getView()等</li>
<li>使用弱引用</li>
</ul>
<p>其他资料:</p>
<ul>
<li><a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="noopener">http://developer.android.com/training/displaying-bitmaps/index.html</a></li>
<li><a href="http://www.trinea.cn/android/hashmap-loop-performance/" target="_blank" rel="noopener">http://www.trinea.cn/android/hashmap-loop-performance/</a></li>
<li><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="noopener">http://hukai.me/android-performance-oom/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Android/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/09/Android/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2/" itemprop="url">进程状态的切换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-09T18:12:51+08:00">
                2020-06-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/09/Android/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/09/Android/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、进程状态"><a href="#一、进程状态" class="headerlink" title="一、进程状态"></a>一、进程状态</h2><p>进程的生命周期内，有5种状态，分别为new, runnable, running, blocked, dead共5种状态，进程所处的状态，会随着系统负载以及运行环境的变化而不断发生改变(由一个状态切换到另一个状态)。</p>
<p><img src="http://gityuan.com/images/android-process/process_manage1.jpg" alt="process_status"></p>
<ul>
<li>创建状态(new)：进程正在被创建，仅仅在堆上分配内存，尚未进入就绪状态；</li>
<li>就绪状态(Runnable)：进程已处于准备运行的状态，即进程已获得除了CPU之外的所需资源，一旦分配到CPU时间片即可进入运行状态。</li>
<li>运行状态(Running)：进程正在运行，占用CPU资源，执行代码。任意时刻点，处于运行状态的进程(线程)的总数，不会超过是CPU的总核数；</li>
<li>阻塞状态(Blocked): 进程处于等待某一事件而放弃CPU，暂停运行。阻塞状态分3类：<ul>
<li>阻塞在对象等待池：当进程在运行时执行Object.wait()方法，虚拟机会把线程放入等待池；</li>
<li>阻塞在对象锁池 ：当进程在运行时企图获取已经被其他进程占用的同步锁时，虚拟机会把线程放入锁池；</li>
<li>其他阻塞状态 ：当进程在运行时执行Sleep()方法，或调用其他进程的join()方法，或者发出I/O请求时，进入该阻塞状态。</li>
</ul>
</li>
<li>死亡状态(dead)：进程正在被结束，这可能是进程正常结束或其他原因中断退出运行。<ul>
<li>进程结束运行前，系统必须置进程为dead态，再处理资源释放和回收等工作。</li>
</ul>
</li>
</ul>
<h2 id="二、状态转移"><a href="#二、状态转移" class="headerlink" title="二、状态转移"></a>二、状态转移</h2><p><img src="http://gityuan.com/images/android-process/process_manage2.jpg" alt="process_status"></p>
<ol>
<li>Runnable -&gt; Running： 就绪态的进程获得了CPU的时间片，进入运行态；</li>
<li>Running -&gt; Runnable: 运行态的进程在时间片用完后，必须出让CPU，进入就绪态；</li>
<li>Running -&gt; Blocked： 当进程请求资源的使用权(如外设)或等待事件发生(如I/O完成)时，由运行态转换为阻塞态；</li>
<li>Blocked -&gt; Runnable： 当进程已经获取所需资源的使用权或者等待事件已完成时，中断处理程序必须把相应进程的状态由阻塞态转为就绪态；</li>
</ol>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>进程的状态转移，主要围绕Runnable、Running、Blocked三个状态。Runnable与Running之间的转换，更多的是与调度器Scheduler相关，而Blocked状态主要涉及资源的使用权问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E3%80%81notify%E3%80%81sleep%E3%80%81interrupt%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E3%80%81notify%E3%80%81sleep%E3%80%81interrupt%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/" itemprop="url">wait、notify、sleep、interrupt对比分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-09T18:00:16+08:00">
                2020-06-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E3%80%81notify%E3%80%81sleep%E3%80%81interrupt%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E3%80%81notify%E3%80%81sleep%E3%80%81interrupt%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法简述"><a href="#方法简述" class="headerlink" title="方法简述"></a>方法简述</h2><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul>
<li>sleep：暂停当前正在执行的线程；（<strong>类方法</strong>）</li>
<li>yield：暂停当前正在执行的线程，并执行其他线程；（<strong>类方法</strong>）</li>
<li>join：等待该线程终止；</li>
<li>interrupt：中断该线程，当线程调用wait(),sleep(),join()或I/O操作时，将收到InterruptedException或 ClosedByInterruptException；</li>
</ul>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li>wait：暂停当前正在执行的线程，直到调用notify()或notifyAll()方法或超时，退出等待状态；</li>
<li>notify：唤醒在该对象上等待的一个线程；</li>
<li>notifyAll：唤醒在该对象上等待的所有线程；</li>
</ul>
<h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><h3 id="sleep-VS-wait"><a href="#sleep-VS-wait" class="headerlink" title="sleep VS wait"></a>sleep VS wait</h3><p>sleep()和wait()方法都是暂停当前正在执行的线程，出让CPU资源。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">所属类</th>
<th align="left">方法类型</th>
<th align="left">锁</th>
<th align="left">解除方法</th>
<th align="left">场景</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sleep</td>
<td align="left">Thread</td>
<td align="left">静态方法</td>
<td align="left">不释放锁</td>
<td align="left">timeout,interrupt</td>
<td align="left">无限制</td>
<td align="left">线程内的控制</td>
</tr>
<tr>
<td align="left">wait</td>
<td align="left">Object</td>
<td align="left">非静态方法</td>
<td align="left">释放锁</td>
<td align="left">timeout,notify,interrupt</td>
<td align="left">同步语句块</td>
<td align="left">线程间的通信</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void sleep(long millis) throws InterruptedException public static void sleep(long millis, int nanos) throws InterruptedException public final void wait() throws InterruptedException public final void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException</span><br></pre></td></tr></table></figure>

<h3 id="wait-amp-amp-notify"><a href="#wait-amp-amp-notify" class="headerlink" title="wait &amp;&amp; notify"></a>wait &amp;&amp; notify</h3><p>调用对象的wait()、notify()、notifyAll()方法的线程，必须是作为此对象监视器的所有者。常见的场景便是就是synchronized关键字的语句块内部使用这3个方法，如果直接在线程中使用wait()、notify()、notifyAll()方法，那么会抛出异常IllegalMonitorStateException，抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。。</p>
<p>调用wait()方法的线程，在调用该线程的interrupt()方法，则会重新尝试获取对象锁。只有当获取到对象锁，才开始抛出相应的异常，则执行该线程之后的程序。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>interrupt()方法的工作仅仅是改变中断状态，并不是直接中断正在运行的线程。中断的真正原理是当线程被Object.wait(),Thread.join()或sleep()方法阻塞时，调用interrupt()方法后改变中断状态，而wait/join/sleep这些方法内部会不断地检查线程的中断状态值，当发现中断状态值改变时则抛出InterruptedException异常；对于没有阻塞的线程，调用interrupt()方法是没有任何作用。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield()方法使当前线程出让CPU执行时间，当并不会释放当前线程所持有的锁。执行完yield()方法后，线程从Running状态转变为Runnable状态，既然是Runnable状态，那么也很可能马上会被CPU调度再次进入Running状态。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" itemprop="url">Java线程池最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-09T17:50:48+08:00">
                2020-06-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/09/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在日常的开发工作当中，线程池往往承载着一个应用中最重要的业务逻辑，因此我们有必要更多地去关注线程池的执行情况，包括异常的处理和分析等等。本文主要聚焦在如何正确使用线程池上，以及提供一些实用的建议。文中会稍微涉及到一些线程池实现原理方面的知识，但是不会做过多展开。网络上关于线程池的原理以及源码解析的文章有很多，感兴趣的同学可以自行查阅。</p>
<h2 id="线程池的异常处理"><a href="#线程池的异常处理" class="headerlink" title="线程池的异常处理"></a>线程池的异常处理</h2><h3 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h3><p>我们都知道Runnable接口中的run方法是不允许抛出异常的，因此派生出这个线程的主线程可能无法直接获得该线程在执行过程中的异常信息。如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(1 &#x2F; 0); &#x2F;&#x2F; 这行会导致报错！</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">        e.printStackTrace(); &#x2F;&#x2F;如果你把这一行注释掉，这个程序将不会抛出任何异常.</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？其实我们看一下Thread中的源码就会发现，Thread在执行过程中如果遇到了异常，会先判断当前线程是否有设置UncaughtExceptionHandler，如果没有，则会从线程所在的ThreadGroup中获取。（<strong>注意：</strong>每个线程都有自己的ThreadGroup，即使你没有指定，并且它实现了UncaughtExceptionHandler接口）我们看下ThreadGroup中默认的对UncaughtExceptionHandler接口的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh &#x3D;</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        if (ueh !&#x3D; null) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; else if (!(e instanceof ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(&quot;Exception in thread \&quot;&quot;</span><br><span class="line">                             + t.getName() + &quot;\&quot; &quot;);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个ThreadGroup如果有父ThreadGroup，则调用父ThreadGroup的uncaughtException，否则调用全局默认的<code>Thread.DefaultUncaughtExceptionHandler</code>，如果全局的handler也没有设置，则只是简单地将异常信息定位到System.err中，这就是为什么我们应当在创建线程的时候，去实现它的UncaughtExceptionHandler接口的原因，这么做可以让你更方便地去排查问题。</p>
<h3 id="通过execute提交任务给线程池"><a href="#通过execute提交任务给线程池" class="headerlink" title="通过execute提交任务给线程池"></a>通过execute提交任务给线程池</h3><p>回到线程池这个话题，如果我们向线程池提交的任务中，没有对异常进行try…catch处理，并且运行的时候出现了异常，那会对线程池造成什么影响呢？答案是没有影响，线程池依旧可以正常工作，但是异常却被吞掉了。这通常来说不是一个好事情，因为我们需要拿到原始的异常对象去分析问题。</p>
<p>那么怎样才能拿到原始的异常对象呢？我们从线程池的源码着手开始研究这个问题。当然网上关于线程池的源码解析文章有很多，这里限于篇幅，直接给出最相关的部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">    Runnable task &#x3D; w.firstTask;</span><br><span class="line">    w.firstTask &#x3D; null;</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            &#x2F;&#x2F; If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            &#x2F;&#x2F; if not, ensure thread is not interrupted.  This</span><br><span class="line">            &#x2F;&#x2F; requires a recheck in second case to deal with</span><br><span class="line">            &#x2F;&#x2F; shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个方法就是真正去执行提交给线程池的任务的代码。这里我们略去其中不相关的逻辑，重点关注第19行到第32行的逻辑，其中第23行是真正开始执行提交给线程池的任务，那么第20行是干什么的呢？其实就是在执行提交给线程池的任务之前可以做一些前置工作，同样的，我们看到第31行，这个是在执行完提交的任务之后，可以做一些后置工作。beforeExecute这个我们暂且不管，重点关注下afterExecute这个方法。我们可以看到，在执行任务过程中，一旦抛出任何类型的异常，都会提交给afterExecute这个方法，然而查看线程池的源代码我们可以发现，默认的afterExecute是个空实现，因此，我们有必要继承ThreadPoolExecutor去实现这个afterExecute方法。（看源码我们可以发现这个afterExecute方法是protected类型的，从官方注释上也可以看到，这个方法就是推荐子类去实现的）当然，这个方法不能随意去实现，需要遵循一定的步骤，具体的官方注释也有讲，这里摘抄如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> *  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class ExtendedExecutor extends ThreadPoolExecutor &#123;</span><br><span class="line"> *   &#x2F;&#x2F; ...</span><br><span class="line"> *   protected void afterExecute(Runnable r, Throwable t) &#123;</span><br><span class="line"> *     super.afterExecute(r, t);</span><br><span class="line"> *     if (t &#x3D;&#x3D; null &amp;&amp; r instanceof Future&lt;?&gt;) &#123;</span><br><span class="line"> *       try &#123;</span><br><span class="line"> *         Object result &#x3D; ((Future&lt;?&gt;) r).get();</span><br><span class="line"> *       &#125; catch (CancellationException ce) &#123;</span><br><span class="line"> *           t &#x3D; ce;</span><br><span class="line"> *       &#125; catch (ExecutionException ee) &#123;</span><br><span class="line"> *           t &#x3D; ee.getCause();</span><br><span class="line"> *       &#125; catch (InterruptedException ie) &#123;</span><br><span class="line"> *           Thread.currentThread().interrupt(); &#x2F;&#x2F; ignore&#x2F;reset</span><br><span class="line"> *       &#125;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *     if (t !&#x3D; null)</span><br><span class="line"> *       System.out.println(t);</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;&#x2F;pre&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>那么通过这种方式，就可以将原先可能被线程池吞掉的异常成功捕获到，从而便于排查问题。</p>
<p>但是这里还有个小问题，我们注意到在runWorker方法中，执行<code>task.run();</code>语句之后，各种类型的异常都被抛出了，那这些被抛出的异常去了哪里？事实上这里的异常对象最终会被传入到Thread的dispatchUncaughtException方法中，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchUncaughtException(Throwable e) &#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(this, e);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到它会去获取UncaughtExceptionHandler的实现类，然后调用其中的uncaughtException方法，这也就回到了我们上一小节所分析的UncaughtExceptionHandler实现的具体逻辑。那么为了拿到最原始的异常对象，除了实现UncaughtExceptionHandler接口之外，也可以考虑实现afterExecute方法。</p>
<h3 id="通过submit提交任务到线程池"><a href="#通过submit提交任务到线程池" class="headerlink" title="通过submit提交任务到线程池"></a>通过submit提交任务到线程池</h3><p>这个同样很简单，我们还是先回到submit方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里的execute方法调用的是ThreadPoolExecutor中的execute方法，执行逻辑跟通过execute提交任务到线程池是一样的。我们先重点关注这里的newTaskFor方法，其源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到提交的Callable对象用FutureTask封装起来了。那么我们知道最终会执行到上述runWorker这个方法中，并且最核心的执行逻辑就是<code>task.run();</code>这行代码。我们知道这里的task其实是FutureTask类型，因此我们有必要看一下FutureTask中的run方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (state !&#x3D; NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c &#x3D; callable;</span><br><span class="line">        if (c !&#x3D; null &amp;&amp; state &#x3D;&#x3D; NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result &#x3D; c.call();</span><br><span class="line">                ran &#x3D; true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result &#x3D; null;</span><br><span class="line">                ran &#x3D; false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; runner must be non-null until state is settled to</span><br><span class="line">        &#x2F;&#x2F; prevent concurrent calls to run()</span><br><span class="line">        runner &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; state must be re-read after nulling runner to prevent</span><br><span class="line">        &#x2F;&#x2F; leaked interrupts</span><br><span class="line">        int s &#x3D; state;</span><br><span class="line">        if (s &gt;&#x3D; INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到这其中跟异常相关的最关键的代码就在第17行，也就是<code>setException(ex);</code>这个地方。我们看一下这个地方的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void setException(Throwable t) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome &#x3D; t;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); &#x2F;&#x2F; final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里最关键的地方就是将异常对象赋值给了outcome，outcome是FutureTask中的成员变量，我们通过调用submit方法，拿到一个Future对象之后，再调用它的get方法，其中最核心的方法就是report方法，下面给出每个方法的源码：</p>
<p>首先是get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s &#x3D; state;</span><br><span class="line">    if (s &lt;&#x3D; COMPLETING)</span><br><span class="line">        s &#x3D; awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到最终调用了report方法，其源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x &#x3D; outcome;</span><br><span class="line">    if (s &#x3D;&#x3D; NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;&#x3D; CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面是一些状态判断，如果当前任务不是正常执行完毕，或者被取消的话，那么这里的x其实就是原始的异常对象，可以看到会被ExecutionException包装。因此在你调用get方法时，可能会抛出ExecutionException异常，那么调用它的getCause方法就可以拿到最原始的异常对象了。</p>
<p>综上所述，针对提交给线程池的任务可能会抛出异常这一问题，主要有以下两种处理思路：</p>
<ol>
<li>在提交的任务当中自行try…catch，但这里有个不好的地方就是如果你会提交多种类型的任务到线程池中，每种类型的任务都需要自行将异常try…catch住，比较繁琐。而且如果你只是<code>catch(Exception e)</code>，可能依然会漏掉一些包括Error类型的异常，那为了保险起见，你可以考虑<code>catch(Throwable t)</code>.</li>
<li>自行实现线程池的afterExecute方法，或者实现Thread的UncaughtExceptionHandler接口。</li>
</ol>
<p>下面给出我个人创建线程池的一个示例，供大家参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Runnable&gt; queue &#x3D; new ArrayBlockingQueue&lt;&gt;(DEFAULT_QUEUE_SIZE);</span><br><span class="line">statisticsThreadPool &#x3D; new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAX_POOL_SIZE,</span><br><span class="line">        60, TimeUnit.SECONDS, queue, new ThreadFactoryBuilder()</span><br><span class="line">        .setThreadFactory(new ThreadFactory() &#123;</span><br><span class="line">            private int count &#x3D; 0;</span><br><span class="line">            private String prefix &#x3D; &quot;StatisticsTask&quot;;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(Runnable r) &#123;</span><br><span class="line">                return new Thread(r, prefix + &quot;-&quot; + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">            String threadName &#x3D; t.getName();</span><br><span class="line">            logger.error(&quot;statisticsThreadPool error occurred! threadName: &#123;&#125;, error msg: &#123;&#125;&quot;, threadName, e.getMessage(), e);</span><br><span class="line">        &#125;).build(), (r, executor) -&gt; &#123;</span><br><span class="line">    if (!executor.isShutdown()) &#123;</span><br><span class="line">        logger.warn(&quot;statisticsThreadPool is too busy! waiting to insert task to queue! &quot;);</span><br><span class="line">        Uninterruptibles.putUninterruptibly(executor.getQueue(), r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void afterExecute(Runnable r, Throwable t) &#123;</span><br><span class="line">        super.afterExecute(r, t);</span><br><span class="line">        if (t &#x3D;&#x3D; null &amp;&amp; r instanceof Future&lt;?&gt;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Future&lt;?&gt; future &#x3D; (Future&lt;?&gt;) r;</span><br><span class="line">                future.get();</span><br><span class="line">            &#125; catch (CancellationException ce) &#123;</span><br><span class="line">                t &#x3D; ce;</span><br><span class="line">            &#125; catch (ExecutionException ee) &#123;</span><br><span class="line">                t &#x3D; ee.getCause();</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); &#x2F;&#x2F; ignore&#x2F;reset</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;statisticsThreadPool error msg: &#123;&#125;&quot;, t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">statisticsThreadPool.prestartAllCoreThreads();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="线程数的设置"><a href="#线程数的设置" class="headerlink" title="线程数的设置"></a>线程数的设置</h2><p>我们知道任务一般有两种：CPU密集型和IO密集型。那么面对CPU密集型的任务，线程数不宜过多，一般选择CPU核心数+1或者核心数的2倍是比较合理的一个值。因此我们可以考虑将corePoolSize设置为CPU核心数+1，maxPoolSize设置为核心数的2倍。那么同样的，面对IO密集型任务时，我们可以考虑以核心数乘以4倍作为核心线程数，然后核心数乘以5倍作为最大线程数的方式去设置线程数，这样的设置会比直接拍脑袋设置一个值会更合理一些。</p>
<p>当然总的线程数不宜过多，控制在100个线程以内比较合理，否则线程数过多可能会导致频繁地上下文切换，导致系统性能反不如前。</p>
<h2 id="如何正确关闭一个线程池"><a href="#如何正确关闭一个线程池" class="headerlink" title="如何正确关闭一个线程池"></a>如何正确关闭一个线程池</h2><p>说到如何正确去关闭一个线程池，这里面也有点讲究。为了实现优雅停机的目标，我们应当先调用shutdown方法，调用这个方法也就意味着，这个线程池不会再接收任何新的任务，但是已经提交的任务还会继续执行，包括队列中的。所以，之后你还应当调用awaitTermination方法，这个方法可以设定线程池在关闭之前的最大超时时间，如果在超时时间结束之前线程池能够正常关闭，这个方法会返回true，否则，一旦超时，就会返回false。通常来说我们不可能无限制地等待下去，因此需要我们事先预估一个合理的超时时间，然后去使用这个方法。</p>
<p>如果awaitTermination方法返回false，你又希望尽可能在线程池关闭之后再做其他资源回收工作，你可以考虑再调用一下shutdownNow方法，此时队列中所有尚未被处理的任务都会被丢弃，同时会设置线程池中每个线程的中断标志位。shutdownNow并不保证一定可以让正在运行的线程停止工作，除非提交给线程的任务能够正确响应中断。到了这一步，你可以考虑继续调用awaitTermination方法，或者你直接放弃，去做接下来要做的事情。</p>
<h2 id="线程池中的其他有用方法"><a href="#线程池中的其他有用方法" class="headerlink" title="线程池中的其他有用方法"></a>线程池中的其他有用方法</h2><p>大家可能有留意到，我在创建线程池的时候，还调用了这个方法：<strong>prestartAllCoreThreads</strong>。这个方法有什么作用呢？我们知道一个线程池创建出来之后，在没有给它提交任何任务之前，这个线程池中的线程数为0。有时候我们事先知道会有很多任务会提交给这个线程池，但是等它一个个去创建新线程开销太大，影响系统性能，因此可以考虑在创建线程池的时候就将所有的核心线程全部一次性创建完毕，这样系统起来之后就可以直接使用了。</p>
<p>其实线程池中还提供了其他一些比较有意思的方法。比如我们现在设想一个场景，当一个线程池负载很高，快要撑爆导致触发拒绝策略时，有没有什么办法可以缓解这一问题？其实是有的，因为线程池提供了设置核心线程数和最大线程数的方法，它们分别是<strong>setCorePoolSize方法</strong>和<strong>setMaximumPoolSize方法</strong>。是的，<strong>线程池创建完毕之后也是可以更改其线程数的！</strong>因此，面对线程池高负荷运行的情况，我们可以这么处理：</p>
<ol>
<li>起一个定时轮询线程（守护类型），定时检测线程池中的线程数，具体来说就是调用getActiveCount方法</li>
<li>当发现线程数超过了核心线程数大小时，可以考虑将CorePoolSize和MaximumPoolSize的数值同时乘以2，当然这里不建议设置很大的线程数，因为并不是线程越多越好的，可以考虑设置一个上限值，比如50, 100之类的。</li>
<li>同时，去获取队列中的任务数，具体来说是调用getQueue方法再调用size方法。当队列中的任务数少于队列大小的二分之一时，我们可以认为现在线程池的负载没有那么高了，因此可以考虑在线程池先前有扩容过的情况下，将CorePoolSize和MaximumPoolSize还原回去，也就是除以2</li>
</ol>
<p>具体来说如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-d67af9d310145de7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>以上是我个人建议的一种使用线程池的方式。</p>
<h2 id="线程池一定是最佳方案吗？"><a href="#线程池一定是最佳方案吗？" class="headerlink" title="线程池一定是最佳方案吗？"></a>线程池一定是最佳方案吗？</h2><p>线程池并非在任何情况下都是性能最优的方案。如果是一个追求极致性能的场景，可以考虑使用<a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">Disruptor</a>，这是一个高性能队列。排除Disruptor不谈，单纯基于JDK的话会不会有更好地方案？答案是有的。</p>
<p>我们知道在一个线程池中，多个线程是共用一个队列的，因此在任务很多的情况下，需要对这个队列进行频繁读写，为了防止冲突因此需要加锁。事实上在阅读线程池源代码的时候就可以发现，里面充斥着各种加锁的代码，那有没有更好的实现方式呢？其实我们可以考虑创建一个由单线程线程池构成的列表，每个线程池都使用有界队列这种方式去实现多线程。这么做的好处是，每个线程池中的队列都只会被一个线程去操作，这样就没有竞争的问题。</p>
<p>其实这种用空间换时间的思路借鉴了Netty中的EventLoop的实现机制。试想，如果线程池的性能真的有那么好，为什么Netty不用呢？</p>
<h2 id="其他需要注意的地方"><a href="#其他需要注意的地方" class="headerlink" title="其他需要注意的地方"></a>其他需要注意的地方</h2><ol>
<li>任何情况下都不应该使用可伸缩线程池（线程的创建和销毁开销是很大的）</li>
<li>任何情况下都不应该使用无界队列，单测除外（有界队列常用的有ArrayBlockingQueue和LinkedBlockingQueue，前者基于数组实现，后者基于链表。从性能表现上来看，LinkedBlockingQueue的吞吐量更高但是性能并不稳定，实际情况下应当使用哪一种建议自行测试之后决定。顺便说一句，Executors的newFixedThreadPool采用的是LinkedBlockingQueue）</li>
<li>推荐自行实现RejectedExecutionHandler，JDK自带的都不是很好用，你可以在里面实现自己的逻辑。如果需要一些特定的上下文信息，你可以在Runnable实现类中添加一些自己的东西，这样在RejectedExecutionHandler中就可以直接使用了。</li>
</ol>
<h2 id="怎样做到不丢任务"><a href="#怎样做到不丢任务" class="headerlink" title="怎样做到不丢任务"></a>怎样做到不丢任务</h2><p>这里其实指的是一种特殊情况，就是比如突然遇到了一股流量尖峰，导致线程池负载已经非常高了，即快要触发拒绝策略的时候，我们可以怎么做来尽量防止提交的任务不会丢失。一般来说当遇到这种情况的时候，应当尽快触发报警通知研发人员来处理。之后不管是限流也好，还是增加机器也好，甚至是上kafka，redis甚至是数据库用来暂存任务数据也是可以的，但毕竟远水救不了近火，如果我们希望在正式解决这个问题之前，先尽可能地缓解，可以考虑怎么做呢？</p>
<p>首先可以考虑的就是我前面有提过的动态增大线程池中的线程数，但是假如说已经扩容过了，此时不应继续扩容，否则可能导致系统的吞吐量更低。在这种情况下，应当自行实现RejectedExecutionHandler，具体来说就是在实现类中，单独开一个单线程的线程池，然后调用原线程池的getQueue方法的put方法，将塞不进去的任务再次尝试塞进去。当然在队列满的时候是塞不进去的，但那至少也只是阻塞了这个单独的线程而已，并不影响主流程。</p>
<p>当然，这种方案是治标不治本的，面对流量激增这种场景其实业界有很多成熟的做法，只是单纯从线程池的角度来看的话，这种方式不失为一种临时的解决方案。</p>
<p>作者：非典型普通码农<br>链接：<a href="https://juejin.im/post/5d4e5c9de51d453c11684c25" target="_blank" rel="noopener">https://juejin.im/post/5d4e5c9de51d453c11684c25</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/07/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">源码分析-线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-07T21:37:40+08:00">
                2020-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">多线程开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/07/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/07/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>下图是 java 线程池几个相关类的继承结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-2a9e168c44e5a8be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">先简</p>
<h4 id="Exector"><a href="#Exector" class="headerlink" title="Exector"></a><code>Exector</code></h4><p>单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 <code>execute(Runnable runnable)</code> 接口方法定义。</p>
<h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h4><p><code>ExecutorService</code> 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以<strong>一般来说我们会使用这个接口</strong>。</p>
<h4 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a><code>AbstractExecutorService</code></h4><p>然后再下来一层是 <code>AbstractExecutorService</code>，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><code>ThreadPoolExecutor</code></h4><p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p>
<p>另外，我们还涉及到下图中的这些类：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8139133e1b0acddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a><code>Future</code></h4><p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 <code>Future</code> 接口，<code>RunnableFuture</code> 继承自此接口，然后我们最需要关心的就是它的实现类 <code>FutureTask</code>。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了<code>Runnable</code>接口的，其实就是先将 <code>Runnable</code>的任务包装成 <code>FutureTask</code>，然后再提交到线程池。这样，读者才能比较容易记住<code>FutureTask</code>这个类名：<strong>它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</strong></p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><code>BlockingQueue</code></h4><p>当然，线程池中的 <code>BlockingQueue</code> 也是非常重要的概念，<strong>如果线程数达到 <code>corePoolSize</code>，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行</strong>。这里的 BlockingQueue 通常我们使用其实现类 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue，每个实现类都有不同的特征，使用场景之后会慢慢分析。</p>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><code>ScheduledThreadPoolExecutor</code></h4><p>除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 <code>ThreadPoolExecutor</code>，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p>
<h2 id="二、Excutor接口"><a href="#二、Excutor接口" class="headerlink" title="二、Excutor接口"></a>二、Excutor接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line"> * @since 1.5</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p>
<p>我们经常这样启动一个线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable()&#123;</span><br><span class="line">  &#x2F;&#x2F; do something</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>用了线程池 Executor 后就可以像下面这么使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor &#x3D; anExecutor;</span><br><span class="line">executor.execute(new RunnableTask1());</span><br><span class="line">executor.execute(new RunnableTask2());</span><br></pre></td></tr></table></figure>

<p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DirectExecutor implements Executor &#123;</span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        r.run();&#x2F;&#x2F; 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ThreadPerTaskExecutor implements Executor &#123;</span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        new Thread(r).start();  &#x2F;&#x2F; 每个任务都用一个新的线程来执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class SerialExecutor implements Executor &#123;</span><br><span class="line">    &#x2F;&#x2F; 任务队列</span><br><span class="line">    final Queue&lt;Runnable&gt; tasks &#x3D; new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    &#x2F;&#x2F; 这个才是真正的执行器</span><br><span class="line">    final Executor executor;</span><br><span class="line">    &#x2F;&#x2F; 当前正在执行的任务</span><br><span class="line">    Runnable active;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 初始化的时候，指定执行器</span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        this.executor &#x3D; executor;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span><br><span class="line">    public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">        tasks.offer(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (active &#x3D;&#x3D; null) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    protected synchronized void scheduleNext() &#123;</span><br><span class="line">        if ((active &#x3D; tasks.poll()) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 具体的执行转给真正的执行器 executor</span><br><span class="line">            executor.execute(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p>
<h2 id="三、ExecutorService"><a href="#三、ExecutorService" class="headerlink" title="三、ExecutorService"></a>三、ExecutorService</h2><p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor &#x3D; Executors.newFixOrCachedThreadPool(args...);</span><br></pre></td></tr></table></figure>

<p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p>
<p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">    &#x2F;&#x2F; 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span><br><span class="line">    void shutdown();</span><br><span class="line">    &#x2F;&#x2F; 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span><br><span class="line">    &#x2F;&#x2F; 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line">    &#x2F;&#x2F; 线程池是否已关闭</span><br><span class="line">    boolean isShutdown();</span><br><span class="line">    &#x2F;&#x2F; 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span><br><span class="line">    &#x2F;&#x2F; 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span><br><span class="line">    boolean isTerminated();</span><br><span class="line">    &#x2F;&#x2F; 等待所有任务完成，并设置超时时间</span><br><span class="line">    &#x2F;&#x2F; 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span><br><span class="line">    &#x2F;&#x2F; 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span><br><span class="line">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException;</span><br><span class="line">    &#x2F;&#x2F; 提交一个 Callable 任务</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">    &#x2F;&#x2F; 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span><br><span class="line">    &#x2F;&#x2F; 因为 Runnable 的 run 方法本身并不返回任何东西</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">    &#x2F;&#x2F; 提交一个 Runnable 任务</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &#x2F;&#x2F; 执行所有任务，返回 Future 类型的一个 list</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            throws InterruptedException;</span><br><span class="line">    &#x2F;&#x2F; 也是执行所有任务，但是这里设置了超时时间</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException;</span><br><span class="line">    &#x2F;&#x2F; 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">            throws InterruptedException, ExecutionException;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span><br><span class="line">    &#x2F;&#x2F; 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                    long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p>
<h2 id="四、FutureTask"><a href="#四、FutureTask" class="headerlink" title="四、FutureTask"></a>四、FutureTask</h2><p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future   -&gt; RunnableFuture -&gt; FutureTask</span><br><span class="line">Runnable -&gt; RunnableFuture</span><br><span class="line">FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，</span><br><span class="line">所以每个 Runnable 通常都先包装成 FutureTask，</span><br><span class="line">然后调用 executor.execute(Runnable command) 将其提交给线程池</span><br></pre></td></tr></table></figure>

<p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常，如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></pre></td></tr></table></figure>

<p>其实到时候会通过这两个参数，将其包装成 Callable。</p>
<p>Callable 也是因为线程池的需要，所以才有了这个接口。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，就不展开说 FutureTask 类了，因为本文篇幅本来就够大了，这里我们需要知道怎么用就行了。</p>
<p>下面，我们来看看 <code>ExecutorService</code> 的抽象实现 <code>AbstractExecutorService</code> 。</p>
<h2 id="五、AbstractExecutorService"><a href="#五、AbstractExecutorService" class="headerlink" title="五、AbstractExecutorService"></a>五、AbstractExecutorService</h2><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。</p>
<p>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 <code>void execute(Runnable command)</code> 由于不需要获取结果，不会进行 FutureTask 的包装。</p>
<blockquote>
<p>需要获取结果（FutureTask），用 submit 方法，不需要获取结果，可以用 execute 方法。</p>
</blockquote>
<p>下面，我将一行一行源码地来分析这个类，跟着源码来看看其实现吧：</p>
<blockquote>
<p>Tips: invokeAny 和 invokeAll 方法占了这整个类的绝大多数篇幅，读者可以选择适当跳过，因为它们可能在你的实践中使用的频次比较低，而且它们不带有承前启后的作用，不用担心会漏掉什么导致看不懂后面的代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span><br><span class="line">    &#x2F;&#x2F; 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span><br><span class="line">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">        return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">        return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 提交任务</span><br><span class="line">    public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 1. 将任务包装成 FutureTask</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">        &#x2F;&#x2F; 2. 交给执行器执行，execute 方法由具体的子类来实现</span><br><span class="line">        &#x2F;&#x2F; 前面也说了，FutureTask 间接实现了Runnable 接口。</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 1. 将任务包装成 FutureTask</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);</span><br><span class="line">        &#x2F;&#x2F; 2. 交给执行器执行</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 1. 将任务包装成 FutureTask</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">        &#x2F;&#x2F; 2. 交给执行器执行</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span><br><span class="line">    &#x2F;&#x2F; 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span><br><span class="line">    &#x2F;&#x2F; 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span><br><span class="line">    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                            boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 任务数</span><br><span class="line">        int ntasks &#x3D; tasks.size();</span><br><span class="line">        if (ntasks &#x3D;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures&#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span><br><span class="line">        &#x2F;&#x2F; 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span><br><span class="line">        &#x2F;&#x2F; 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs &#x3D;</span><br><span class="line">            new ExecutorCompletionService&lt;T&gt;(this);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span><br><span class="line">            ExecutionException ee &#x3D; null;</span><br><span class="line">            long lastTime &#x3D; timed ? System.nanoTime() : 0;</span><br><span class="line">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it &#x3D; tasks.iterator();</span><br><span class="line">            &#x2F;&#x2F; 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            &#x2F;&#x2F; 提交了一个任务，所以任务数量减 1</span><br><span class="line">            --ntasks;</span><br><span class="line">            &#x2F;&#x2F; 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span><br><span class="line">            int active &#x3D; 1;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                &#x2F;&#x2F; ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span><br><span class="line">                &#x2F;&#x2F; BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span><br><span class="line">                Future&lt;T&gt; f &#x3D; ecs.poll();</span><br><span class="line">                &#x2F;&#x2F; 为 null，说明刚刚提交的第一个线程还没有执行完成</span><br><span class="line">                &#x2F;&#x2F; 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span><br><span class="line">                if (f &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    if (ntasks &gt; 0) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span><br><span class="line">                    &#x2F;&#x2F; 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span><br><span class="line">                    &#x2F;&#x2F; 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了</span><br><span class="line">                    else if (active &#x3D;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    &#x2F;&#x2F; 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span><br><span class="line">                    else if (timed) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 带等待的 poll 方法</span><br><span class="line">                        f &#x3D; ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        &#x2F;&#x2F; 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span><br><span class="line">                        if (f &#x3D;&#x3D; null)</span><br><span class="line">                            throw new TimeoutException();</span><br><span class="line">                        long now &#x3D; System.nanoTime();</span><br><span class="line">                        nanos -&#x3D; now - lastTime;</span><br><span class="line">                        lastTime &#x3D; now;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span><br><span class="line">                    &#x2F;&#x2F; take() 方法会阻塞，直到有元素返回，说明有任务结束了</span><br><span class="line">                    else</span><br><span class="line">                        f &#x3D; ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * 我感觉上面这一段并不是很好理解，这里简单说下。</span><br><span class="line">                 * 1. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span><br><span class="line">                 *     那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span><br><span class="line">                 * 2. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”</span><br><span class="line">                       这件事情上</span><br><span class="line">                 * 3. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，</span><br><span class="line">                       等待获取第一个执行结果</span><br><span class="line">                 * ?. 这里我还没理解 active &#x3D;&#x3D; 0 这个分支的到底是干嘛的？</span><br><span class="line">                 *&#x2F;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">                &#x2F;&#x2F; 有任务结束了</span><br><span class="line">                if (f !&#x3D; null) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 返回执行结果，如果有异常，都包装成 ExecutionException</span><br><span class="line">                        return f.get();</span><br><span class="line">                    &#125; catch (ExecutionException eex) &#123;</span><br><span class="line">                        ee &#x3D; eex;</span><br><span class="line">                    &#125; catch (RuntimeException rex) &#123;</span><br><span class="line">                        ee &#x3D; new ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#x2F;&#x2F; 注意看 for 循环的范围，一直到这里</span><br><span class="line">          </span><br><span class="line">            if (ee &#x3D;&#x3D; null)</span><br><span class="line">                ee &#x3D; new ExecutionException();</span><br><span class="line">            throw ee;</span><br><span class="line">		</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 方法退出之前，取消其他的任务</span><br><span class="line">            for (Future&lt;T&gt; f : futures)</span><br><span class="line">                f.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return doInvokeAny(tasks, false, 0);</span><br><span class="line">        &#125; catch (TimeoutException cannotHappen) &#123;</span><br><span class="line">            assert false;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                           long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        return doInvokeAny(tasks, true, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 执行所有的任务，返回任务结果。</span><br><span class="line">    &#x2F;&#x2F; 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span><br><span class="line">    &#x2F;&#x2F; 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span><br><span class="line">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 这个很简单</span><br><span class="line">            for (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                &#x2F;&#x2F; 包装成 FutureTask</span><br><span class="line">                RunnableFuture&lt;T&gt; f &#x3D; newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                &#x2F;&#x2F; 提交任务</span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            for (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                if (!f.isDone()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 这是一个阻塞方法，直到获取到值，或抛出了异常</span><br><span class="line">                        &#x2F;&#x2F; 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span><br><span class="line">                        &#x2F;&#x2F; 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; catch (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; catch (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span><br><span class="line">            &#x2F;&#x2F; 这个方法返回是真正的返回，任务都结束了</span><br><span class="line">            return futures;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 为什么要这个？就是上面说的有异常的情况</span><br><span class="line">            if (!done)</span><br><span class="line">                for (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 带超时的 invokeAll，我们找不同吧</span><br><span class="line">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null || unit &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line">            long lastTime &#x3D; System.nanoTime();</span><br><span class="line">            Iterator&lt;Future&lt;T&gt;&gt; it &#x3D; futures.iterator();</span><br><span class="line">            &#x2F;&#x2F; 提交一个任务，检测一次是否超时</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                execute((Runnable)(it.next()));</span><br><span class="line">                long now &#x3D; System.nanoTime();</span><br><span class="line">                nanos -&#x3D; now - lastTime;</span><br><span class="line">                lastTime &#x3D; now;</span><br><span class="line">                &#x2F;&#x2F; 超时</span><br><span class="line">                if (nanos &lt;&#x3D; 0)</span><br><span class="line">                    return futures;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                if (!f.isDone()) &#123;</span><br><span class="line">                    if (nanos &lt;&#x3D; 0)</span><br><span class="line">                        return futures;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span><br><span class="line">                        &#x2F;&#x2F; 因为上面其实已经用掉了一些时间了</span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; catch (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; catch (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">                        return futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    long now &#x3D; System.nanoTime();</span><br><span class="line">                    nanos -&#x3D; now - lastTime;</span><br><span class="line">                    lastTime &#x3D; now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            return futures;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!done)</span><br><span class="line">                for (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p>
<h2 id="六、ThreadPoolExecutor"><a href="#六、ThreadPoolExecutor" class="headerlink" title="六、ThreadPoolExecutor"></a>六、ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p>
<p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。</p>
<p>首先，我们来看看线程池实现中的几个概念和处理流程。</p>
<p>我们先回顾下提交任务的几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new Thread(<strong>runnable</strong>).start() 中的，此处的这个参数不是用于启动线程的，这里指的是<strong>任务</strong>，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p>
<p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法（我想作者只是不想因为这个再定义一个完全可以用 Runnable 来代替的接口，Callable 的出现，完全是因为 Runnable 不能满足需要）。</p>
<p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-a5329c67b78c155e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当然，上图没有考虑队列是否有界，提交任务时队列满了怎么办？什么情况下会创建新的线程？提交任务时线程池满了怎么办？空闲线程怎么关掉？这些问题下面我们会一一解决。</p>
<p>我们经常会使用 <code>Executors</code> 这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先不说有什么区别，它们最终都会导向这个构造方法：</p>
<h4 id="ThreadPoolExecutor构造"><a href="#ThreadPoolExecutor构造" class="headerlink" title="ThreadPoolExecutor构造"></a><code>ThreadPoolExecutor</code>构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#x2F;&#x2F; 这几个参数都是必须要有的</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">  </span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p>
<ul>
<li>corePoolSize：核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</li>
<li>maximumPoolSize：最大线程数，线程池允许创建的最大线程数。</li>
<li>workQueue： 任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</li>
<li>keepAliveTime：线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 <code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</li>
<li>threadFactory：用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</li>
<li>handler：当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</li>
</ul>
<p>除了上面几个属性外，我们再看看其他重要的属性。</p>
<h4 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h4><p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 500 多万）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认是RUNNING状态</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">&#x2F;&#x2F; 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span><br><span class="line">&#x2F;&#x2F; 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line">&#x2F;&#x2F; 000 11111111111111111111111111111</span><br><span class="line">&#x2F;&#x2F; 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1&#x3D;536860911</span><br><span class="line">&#x2F;&#x2F; 以我们现在计算机的实际情况，这个数量还是够用的</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line">&#x2F;&#x2F; 我们说了，线程池的状态存放在高 3 位中</span><br><span class="line">&#x2F;&#x2F; 运算结果为 111跟29个0：111 00000000000000000000000000000</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 000 00000000000000000000000000000</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 001 00000000000000000000000000000</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 010 00000000000000000000000000000</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 011 00000000000000000000000000000</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line">&#x2F;&#x2F; 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">&#x2F;&#x2F; 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Bit field accessors that don&#39;t require unpacking ctl.</span><br><span class="line"> * These depend on the bit layout and on workerCount being never negative.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static boolean runStateLessThan(int c, int s) &#123;</span><br><span class="line">    return c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean runStateAtLeast(int c, int s) &#123;</span><br><span class="line">    return c &gt;&#x3D; s;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean isRunning(int c) &#123;</span><br><span class="line">    return c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p>
<p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p>
<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul>
<li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li>
<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>
</ul>
<blockquote>
<p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p>
</blockquote>
<p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li>
<li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li>
<li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li>
<li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li>
</ul>
<p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p>
<h4 id="内部类Worker"><a href="#内部类Worker" class="headerlink" title="内部类Worker"></a>内部类Worker</h4><p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道<strong>任务是 Runnable（内部叫 task 或 command），线程是 Worker</strong>。</p>
<p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式（对 AQS 源码感兴趣的读者请参看我之前写的几篇文章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">    extends AbstractQueuedSynchronizer</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6138294804551838833L;</span><br><span class="line">    &#x2F;&#x2F; 这个是真正的线程，任务靠你啦</span><br><span class="line">    final Thread thread;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span><br><span class="line">    &#x2F;&#x2F; 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span><br><span class="line">    &#x2F;&#x2F; 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 用于存放此线程完全的任务数，注意了，这里用了 volatile，保证可见性</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line">	&#x2F;&#x2F; Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">        this.firstTask &#x3D; firstTask;</span><br><span class="line">        &#x2F;&#x2F; 调用 ThreadFactory 来创建一个新的线程</span><br><span class="line">        this.thread &#x3D; getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 这里调用了外部类的 runWorker 方法</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line">	...&#x2F;&#x2F; 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">  		&#x2F;&#x2F;分3步进行：            </span><br><span class="line">             1.如果正在运行的线程少于corePoolSize，请尝试使用给定命令作为其第一个任务来启动新线程。 对addWorker的调用原子地检查runState和workerCount，从而通过返回false来防止在不应该添加线程的情况下发出虚假警报。            </span><br><span class="line">             2.如果一个任务可以成功地排队，那么我们仍然需要仔细检查是否应该添加一个线程（因为现有线程自上次检查以来就已死亡）或该池自进入此方法后就关闭了。 因此，我们重新检查状态，并在必要时回滚排队，如果已停止，或者在没有线程的情况下启动新线程。            </span><br><span class="line">             3.如果我们不能将任务排队，那么我们尝试添加一个新线程。 如果失败，则表明我们已关闭或已饱和，因此拒绝该任务。</span><br><span class="line">             </span><br><span class="line">    &#x2F;&#x2F; 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br><span class="line">    &#x2F;&#x2F;默认状态是RUNNING状态 取值：高3位状态</span><br><span class="line">    int c &#x3D; ctl.get();  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    &#x2F;&#x2F;第一次是0 取值：低29位</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        &#x2F;&#x2F; 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        &#x2F;&#x2F; 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        &#x2F;* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        &#x2F;&#x2F; 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        &#x2F;&#x2F; 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    &#x2F;&#x2F; 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    &#x2F;&#x2F; 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span><br><span class="line">&#x2F;&#x2F; 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，</span><br><span class="line">&#x2F;&#x2F; 		如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span><br><span class="line">&#x2F;&#x2F; 		如果是 false，代表使用最大线程数 maximumPoolSize 作为界线</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    		&#x2F;&#x2F;获取状态 高三位 第一次开启状态还没有变化</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line">        &#x2F;&#x2F; 这个非常不好理解</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span><br><span class="line">        &#x2F;&#x2F; 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span><br><span class="line">        &#x2F;&#x2F; 2. firstTask !&#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 3. workQueue.isEmpty()</span><br><span class="line">        &#x2F;&#x2F; 简单分析下：</span><br><span class="line">        &#x2F;&#x2F; 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span><br><span class="line">        &#x2F;&#x2F; 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span><br><span class="line">        &#x2F;&#x2F; 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前线程个数</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line">            &#x2F;&#x2F;满足下面条件的不添加</span><br><span class="line">            &#x2F;&#x2F;1. 线程个数大于2的29次方</span><br><span class="line">            &#x2F;&#x2F;2. 核心线程的个数大于设置的核心线程数</span><br><span class="line">            &#x2F;&#x2F;3. 当前线程个数大于设置的最大线程数</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span><br><span class="line">            &#x2F;&#x2F; 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            &#x2F;&#x2F; 由于有并发，重新再读取一下 ctl</span><br><span class="line">            c &#x3D; ctl.get();</span><br><span class="line">            &#x2F;&#x2F; 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span><br><span class="line">            &#x2F;&#x2F; 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span><br><span class="line">            &#x2F;&#x2F; 那么需要回到外层的for循环</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* </span><br><span class="line">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span><br><span class="line">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span><br><span class="line">     *&#x2F;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; worker 是否已经启动</span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 是否已将这个 worker 添加到 workers 这个 HashSet 中</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        &#x2F;&#x2F; 把 firstTask 传给 worker 的构造方法</span><br><span class="line">        w &#x3D; new Worker(firstTask);</span><br><span class="line">        &#x2F;&#x2F; 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这个是整个类的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span><br><span class="line">            &#x2F;&#x2F; 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int c &#x3D; ctl.get();</span><br><span class="line">                int rs &#x3D; runStateOf(c);</span><br><span class="line">                &#x2F;&#x2F; 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span><br><span class="line">                &#x2F;&#x2F; 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; worker 里面的 thread 可不能是已经启动的</span><br><span class="line">                    if (t.isAlive())</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    &#x2F;&#x2F; 加到 workers 这个 HashSet 中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    &#x2F;&#x2F; largestPoolSize 用于记录 workers 中的个数的最大值</span><br><span class="line">                    &#x2F;&#x2F; 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 添加成功的话，启动这个线程</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                &#x2F;&#x2F; 启动线程</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回线程是否启动成功</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addWorkFailed"><a href="#addWorkFailed" class="headerlink" title="addWorkFailed"></a>addWorkFailed</h4><p>简单看下 addWorkFailed 的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; workers 中删除掉相应的 worker</span><br><span class="line">&#x2F;&#x2F; workCount 减 1</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w !&#x3D; null)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        &#x2F;&#x2F; rechecks for termination, in case the existence of this worker was holding up termination</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p>回过头来，继续往下走。我们知道，worker 中的线程 start 后，其 run 方法会调用 runWorker 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Worker 类的 run() 方法</span><br><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看 runWorker 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span><br><span class="line">&#x2F;&#x2F; 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F; 该线程的第一个任务(如果有的话)</span><br><span class="line">    Runnable task &#x3D; w.firstTask;</span><br><span class="line">    w.firstTask &#x3D; null;</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环调用 getTask 获取任务</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();          </span><br><span class="line">            &#x2F;&#x2F; 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 这是一个钩子方法，留给需要的子类实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 到这里终于可以执行任务了</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 这里不允许抛出 Throwable，所以转换为 Error</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 置空 task，准备 getTask 获取下一个任务</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 累加完成的任务数</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                &#x2F;&#x2F; 释放掉 worker 的独占锁</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果到这里，需要执行线程关闭：</span><br><span class="line">        &#x2F;&#x2F; 1. 说明 getTask 返回 null，也就是说，这个 worker 的使命结束了，执行关闭</span><br><span class="line">        &#x2F;&#x2F; 2. 任务执行过程中发生了异常</span><br><span class="line">        &#x2F;&#x2F; 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span><br><span class="line">        &#x2F;&#x2F; 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span><br><span class="line">        &#x2F;&#x2F; 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><p>我们看看 getTask() 是怎么获取任务的，这个方法写得真的很好，每一行都很简单，组合起来却所有的情况都想好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此方法有三种可能：</span><br><span class="line">&#x2F;&#x2F; 1. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span><br><span class="line">&#x2F;&#x2F;      它们会一直等待任务</span><br><span class="line">&#x2F;&#x2F; 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span><br><span class="line">&#x2F;&#x2F; 3. 如果发生了以下条件，此方法必须返回 null:</span><br><span class="line">&#x2F;&#x2F;    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span><br><span class="line">&#x2F;&#x2F;    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span><br><span class="line">&#x2F;&#x2F;    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line">  </span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line">        &#x2F;&#x2F; 两种可能</span><br><span class="line">        &#x2F;&#x2F; 1. rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; workQueue.isEmpty()</span><br><span class="line">        &#x2F;&#x2F; 2. rs &gt;&#x3D; STOP</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            &#x2F;&#x2F; CAS 操作，减少工作线程数</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean timed;      &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line">            &#x2F;&#x2F; 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span><br><span class="line">            timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            &#x2F;&#x2F; 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span><br><span class="line">            &#x2F;&#x2F; 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span><br><span class="line">            &#x2F;&#x2F; 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span><br><span class="line">            &#x2F;&#x2F;    换句话说，返回 null 意味着关闭线程。</span><br><span class="line">            &#x2F;&#x2F; 那是因为有可能开发者调用了 setMaximumPoolSize 将线程池的 maximumPoolSize 调小了</span><br><span class="line">            if (wc &lt;&#x3D; maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                break;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">            &#x2F;&#x2F; compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; wc &lt;&#x3D; maximumPoolSize 同时没有超时</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 到 workQueue 中获取任务</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果此 worker 发生了中断，采取的方案是重试</span><br><span class="line">            &#x2F;&#x2F; 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，</span><br><span class="line">            &#x2F;&#x2F; 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span><br><span class="line">            &#x2F;&#x2F; 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span><br><span class="line">            timedOut &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execute-1"><a href="#execute-1" class="headerlink" title="execute"></a>execute</h4><p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        &#x2F;&#x2F; 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        &#x2F;&#x2F; 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        &#x2F;* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        &#x2F;&#x2F; 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        &#x2F;&#x2F; 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    &#x2F;&#x2F; 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    &#x2F;&#x2F; 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面各个分支中，有两种情况会调用 reject(command) 来处理任务，因为按照正常的流程，线程池此时不能接受这个任务，所以需要执行我们的拒绝策略。接下来，我们说一说 ThreadPoolExecutor 中的拒绝策略。</p>
<h4 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行拒绝策略</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的 handler 我们需要在构造线程池的时候就传入这个参数，它是 RejectedExecutionHandler 的实例。</p>
<p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public CallerRunsPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不管怎样，直接抛出 RejectedExecutionException 异常</span><br><span class="line">&#x2F;&#x2F; 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span><br><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public AbortPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                             &quot; rejected from &quot; +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不做任何处理，直接忽略掉这个任务</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public DiscardPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这个相对霸道一点，如果线程池没有被关闭的话，</span><br><span class="line">&#x2F;&#x2F; 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public DiscardOldestPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，ThreadPoolExecutor 的源码算是分析结束了。单纯从源码的难易程度来说，ThreadPoolExecutor 的源码还算是比较简单的，只是需要我们静下心来好好看看罢了。</p>
<h2 id="七、Executors"><a href="#七、Executors" class="headerlink" title="七、Executors"></a>七、Executors</h2><p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p>
<ul>
<li>生成一个固定大小的线程池：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0 也不会执行 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p>
<p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p>
<ul>
<li>生成只有<strong>一个线程</strong>的固定线程池，这个更简单，和上面的一样，只要设置线程数为 1 就可以了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</p>
<p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p>
<p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int c &#x3D; ctl.get();</span><br><span class="line">&#x2F;&#x2F; corePoolSize 为 0，所以不会进到这个 if 分支</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    if (addWorker(command, true))</span><br><span class="line">        return;</span><br><span class="line">    c &#x3D; ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    int recheck &#x3D; ctl.get();</span><br><span class="line">    if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SynchronousQueue 是一个比较特殊的 BlockingQueue，其本身不储存任何元素，它有一个虚拟队列（或虚拟栈），不管读操作还是写操作，如果当前队列中存储的是与当前操作相同模式的线程，那么当前操作也进入队列中等待；如果是相反模式，则配对成功，从当前队列中取队头节点。具体的信息，可以看我的另一篇关于 BlockingQueue 的文章。</p>
</blockquote>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><ol>
<li><p>java 线程池有哪些关键属性？</p>
<blockquote>
<p>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</p>
<p>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p>
<p>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。</p>
<p>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p>
<p>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有<strong>抛出 RejectedExecutionException 异常</strong>、<strong>忽略任务</strong>、<strong>使用提交任务的线程来执行此任务</strong>和<strong>将队列中等待最久的任务删除，然后提交此任务</strong>这四种策略，默认为抛出异常。</p>
</blockquote>
</li>
<li><p>说说线程池中的线程创建时机？</p>
<blockquote>
<ol>
<li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li>
<li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li>
<li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
</blockquote>
</li>
<li><p>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</p>
<blockquote>
<p>细说太长，往上滑一点点，在 Executors 的小节进行了详尽的描述。</p>
</blockquote>
</li>
<li><p>任务执行过程中发生异常怎么处理？</p>
<blockquote>
<p>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</p>
</blockquote>
</li>
<li><p>什么时候会执行拒绝策略？</p>
<blockquote>
<ol>
<li>workers 的数量达到了 corePoolSize，任务入队成功，以此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li>
<li>workers 的数量大于等于 corePoolSize，准备入队，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
</blockquote>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
