<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="url">Android四大组件与进程启动的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T10:53:32+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android四大组件与进程启动的关系"><a href="#Android四大组件与进程启动的关系" class="headerlink" title="Android四大组件与进程启动的关系"></a>Android四大组件与进程启动的关系</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><p>Android系统将进程做得很友好的封装,对于上层app开发者来说进程几乎是透明的. 了解Android的朋友,一定知道Android四大组件,但对于进程可能会相对较陌生. 一个进程里面可以跑多个app, 一个app也可以跑在多个进程里，通过配置Android:process属性来决定所运行在哪个进程。</p>
<p>再进一步进程是如何创建的, 可能很多人不知道fork的存在. 在我的文章<a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a> 集中一点详细介绍了<code>Process.start</code>的过程是如何一步步创建进程.</p>
<p>进程承载着整个系统,”进程之于Android犹如水之于鱼”, 进程对于Android系统非常重要, 对于android来说承载着Android四大组件,承载着系统的正常运转. 本文则跟大家聊一聊进程的,是从另个角度来全局性讲解android进程启动全过程所涉及的根脉, 先来看看AMS.startProcessLocked方法.</p>
<h2 id="二-四大组件与进程"><a href="#二-四大组件与进程" class="headerlink" title="二. 四大组件与进程"></a>二. 四大组件与进程</h2><h3 id="2-1-四大组件"><a href="#2-1-四大组件" class="headerlink" title="2.1 四大组件"></a>2.1 四大组件</h3><p>Activity, Service, ContentProvider, BroadcastReceiver这四大组件,在启动的过程,当其所承载的进程不存在时需要调用startProcessLocked先创建进程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-310021ed91c92dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="2-1-1-Activity"><a href="#2-1-1-Activity" class="headerlink" title="2.1.1 Activity"></a>2.1.1 Activity</h4><p>启动Activity过程: 调用startActivity,该方法经过层层调用,最终会调用ActivityStackSupervisor.java中的<code>startSpecificActivityLocked</code>,当activity所属进程还没启动的情况下,则需要创建相应的进程.更多关于Activity, 见<a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;         </span><br><span class="line">        &#x2F;&#x2F;开启Activity</span><br><span class="line">        realStartActivityLocked(r, app, andResume, checkConfig);                                  </span><br><span class="line">        &#125;</span><br><span class="line">				&#x2F;&#x2F;创建进程</span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-Service"><a href="#2-1-2-Service" class="headerlink" title="2.1.2 Service"></a>2.1.2 Service</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>启动服务过程: 调用startService,该方法经过层层调用,最终会调用ActiveServices.java中的<code>bringUpServiceLocked</code>,当Service进程没有启动的情况(app==null), 则需要创建相应的进程. 更多关于Service, 见<a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService启动过程分析</a></p>
<p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final String bringUpServiceLocked(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ProcessRecord app &#x3D; mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">    if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if ((app&#x3D;mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                &quot;service&quot;, r.name, false, isolated, false)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-ContentProvider"><a href="#2-1-3-ContentProvider" class="headerlink" title="2.1.3 ContentProvider"></a>2.1.3 ContentProvider</h4><p>ContentProvider处理过程: 调用ContentResolver.query该方法经过层层调用, 最终会调用到AMS.java中的<code>getContentProviderImpl</code>,当ContentProvider所对应进程不存在,则需要创建新进程. 更多关于ContentProvider,见<a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="noopener">理解ContentProvider原理(一)</a></p>
<p>[-&gt; AMS.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private final ContentProviderHolder getContentProviderImpl(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ProcessRecord proc &#x3D; getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false);</span><br><span class="line">    if (proc !&#x3D; null &amp;&amp; proc.thread !&#x3D; null) &#123;</span><br><span class="line">        ...  &#x2F;&#x2F;进程已创建的case</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        proc &#x3D; startProcessLocked(cpi.processName,</span><br><span class="line">                    cpr.appInfo, false, 0, &quot;content provider&quot;,</span><br><span class="line">                    new ComponentName(cpi.applicationInfo.packageName,cpi.name),</span><br><span class="line">                    false, false, false);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-Broadcast"><a href="#2-1-4-Broadcast" class="headerlink" title="2.1.4 Broadcast"></a>2.1.4 Broadcast</h4><p>广播处理过程: 调用sendBroadcast,该方法经过层层调用, 最终会调用到BroadcastQueue.java中的<code>processNextBroadcast</code>,当BroadcastReceiver所对应的进程尚未启动，则创建相应进程. 更多关于broadcast, 见<a href="http://gityuan.com/2016/06/04/broadcast-receiver/" target="_blank" rel="noopener">Android Broadcast广播机制分析</a>.</p>
<p>[-&gt; BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ProcessRecord app &#x3D; mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo.uid, false);</span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">        ...  &#x2F;&#x2F;进程已创建的case</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((r.curApp&#x3D;mService.startProcessLocked(targetProcess,</span><br><span class="line">            info.activityInfo.applicationInfo, true,</span><br><span class="line">            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">            &quot;broadcast&quot;, r.curComponent,</span><br><span class="line">            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) !&#x3D; 0, false, false))</span><br><span class="line">                    &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-进程启动"><a href="#2-2-进程启动" class="headerlink" title="2.2 进程启动"></a>2.2 进程启动</h3><p>在<code>ActivityManagerService.java</code>关于启动进程有4个同名不同参数的重载方法StartProcessLocked, 为了便于说明,以下4个方法依次记为<code>1(a)</code>,<code>1(b)</code>, <code>2(a)</code>, <code>2(b)</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法 1(a)</span><br><span class="line">final ProcessRecord startProcessLocked( String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#x2F;&#x2F;方法 1(b) final ProcessRecord startProcessLocked( String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#x2F;&#x2F;方法 2(a) private final void startProcessLocked( ProcessRecord app, String hostingType, String hostingNameStr) &#x2F;&#x2F;方法 2(b) private final void startProcessLocked( ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span><br></pre></td></tr></table></figure>

<p><strong>1(a) ==&gt; 1(b):</strong> 方法1(a)将isolatedUid=0,其他参数赋值为null,再调用给1(b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123;</span><br><span class="line">    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">            hostingName, allowWhileBooting, isolated, 0 &#x2F;* isolatedUid *&#x2F;, keepIfLarge,</span><br><span class="line">            null &#x2F;* ABI override *&#x2F;, null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;,</span><br><span class="line">            null &#x2F;* crashHandler *&#x2F;);进程名至少要有2个字符 **2(a) &#x3D;&#x3D;&gt; 2(b):** 方法2(a)将其他3个参数abiOverride,entryPoint, entryPointArgs赋值为null,再调用给2(b)</span><br><span class="line"></span><br><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123;</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, null &#x2F;* abiOverride *&#x2F;,</span><br><span class="line">            null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<ul>
<li>1(a),1(b)的第一个参数为String类型的进程名processName,</li>
<li>2(a), 2(b)的第一个参数为ProcessRecord类型进程记录信息ProcessRecord;</li>
<li>1系列的方法最终调用到2系列的方法;</li>
</ul>
<p>四大组件所在应用首次启动时, 调用startProcessLocked方法1(a)，之后再调用流程: 1(a) =&gt; 1(b) ==&gt; 2(b).</p>
<h3 id="2-3-启动时机"><a href="#2-3-启动时机" class="headerlink" title="2.3 启动时机"></a>2.3 启动时机</h3><p>刚解说了4大组件与进程创建的调用方法，那么接下来再来说说进程创建的触发时机有哪些？如下：</p>
<ul>
<li>单进程App：对于这种情况，那么app首次启动某个组件时，比如通过调用startActivity来启动某个app，则先会触发创建该app进程，然后再启动该Activity。此时该app进程已创建，那么后续再该app中内部启动同一个activity或者其他组件，则都不会再创建新进程（除非该app进程被系统所杀掉）。</li>
<li>多进程App: 对于这种情况，那么每个配置过<code>android:process</code>属性的组件的首次启动，则都分别需要创建进程。再次启动同一个activity，其则都不会再创建新进程（除非该app进程被系统所杀掉），但如果启动的是其他组件，则还需要再次判断其所对应的进程是否存在。</li>
</ul>
<p>大多数情况下，app都是单进程架构，对于多进程架构的app一般是通过在AndroidManifest.xml中<code>android:process</code>属性来实现的。</p>
<ul>
<li>当android:process属性值以”:”开头，则代表该进程是私有的，只有该app可以使用，其他应用无法访问；</li>
<li>当android:process属性值不以”:“开头，则代表的是全局型进程，但这种情况需要注意的是进程名必须至少包含“.”字符。</li>
</ul>
<p>接下来，看看PackageParser.java来解析AndroidManiefst.xml过程就明白进程名的命名要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class PackageParser &#123;</span><br><span class="line">    ...</span><br><span class="line">    private static String buildCompoundName(String pkg, CharSequence procSeq, String type, String[] outError) &#123;</span><br><span class="line">        String proc &#x3D; procSeq.toString();</span><br><span class="line">        char c &#x3D; proc.charAt(0);</span><br><span class="line">        if (pkg !&#x3D; null &amp;&amp; c &#x3D;&#x3D; &#39;:&#39;) &#123;</span><br><span class="line">           if (proc.length() &lt; 2) &#123;</span><br><span class="line">               &#x2F;&#x2F;进程名至少要有2个字符</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           String subName &#x3D; proc.substring(1);</span><br><span class="line">           &#x2F;&#x2F;此时并不要求强求 字符&#39;.&#39;作为分割符号</span><br><span class="line">           String nameError &#x3D; validateName(subName, false, false);</span><br><span class="line">           if (nameError !&#x3D; null) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           return (pkg + proc).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;此时必须字符&#39;.&#39;作为分割符号</span><br><span class="line">        String nameError &#x3D; validateName(proc, true, false);</span><br><span class="line">        if (nameError !&#x3D; null &amp;&amp; !&quot;system&quot;.equals(proc)) &#123;</span><br><span class="line">           return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return proc.intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String validateName(String name, boolean requireSeparator, boolean requireFilename) &#123;</span><br><span class="line">        final int N &#x3D; name.length();</span><br><span class="line">        boolean hasSep &#x3D; false;</span><br><span class="line">        boolean front &#x3D; true;</span><br><span class="line">        for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">            final char c &#x3D; name.charAt(i);</span><br><span class="line">            if ((c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) || (c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;)) &#123;</span><br><span class="line">                front &#x3D; false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!front) &#123;</span><br><span class="line">                if ((c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) || c &#x3D;&#x3D; &#39;_&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;字符&#39;.&#39;作为分割符号</span><br><span class="line">            if (c &#x3D;&#x3D; &#39;.&#39;) &#123;</span><br><span class="line">                hasSep &#x3D; true;</span><br><span class="line">                front &#x3D; true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;bad character &#39;&quot; + c + &quot;&#39;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (requireFilename &amp;&amp; !FileUtils.isValidExtFilename(name)) &#123;</span><br><span class="line">            return &quot;Invalid filename&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return hasSep || !requireSeparator</span><br><span class="line">                ? null : &quot;must have at least one &#39;.&#39; separator&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完上面的源码.很显然对于android:process属性值不以”:“开头的进程名必须至少包含“.”字符。</p>
<h3 id="2-4-小节"><a href="#2-4-小节" class="headerlink" title="2.4 小节"></a>2.4 小节</h3><p>Activity, Service, ContentProvider, BroadcastReceiver这四大组件在启动时,当所承载的进程不存在时，包括多进程的情况，则都需要创建。</p>
<p><strong>四大组件的进程创建方法:</strong></p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">创建方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Activity</td>
<td align="left">ASS.startSpecificActivityLocked()</td>
</tr>
<tr>
<td align="left">Service</td>
<td align="left">ActiveServices.bringUpServiceLocked()</td>
</tr>
<tr>
<td align="left">ContentProvider</td>
<td align="left">AMS.getContentProviderImpl()</td>
</tr>
<tr>
<td align="left">Broadcast</td>
<td align="left">BroadcastQueue.processNextBroadcast()</td>
</tr>
</tbody></table>
<p>进程的创建过程交由系统进程system_server来完成的.</p>
<p><img src="http://gityuan.com/images/process/app_process_ipc.jpg" alt="app_process_ipc"></p>
<p>简称:</p>
<ul>
<li>ATP: ApplicationThreadProxy</li>
<li>AT: ApplicationThread (继承于ApplicationThreadNative)</li>
<li>AMP: ActivityManagerProxy</li>
<li>AMS: ActivityManagerService (继承于ActivityManagerNative)</li>
</ul>
<p>图解:</p>
<ol>
<li>system_server进程中调用<code>startProcessLocked</code>方法,该方法最终通过socket方式,将需要创建新进程的消息告知Zygote进程,并阻塞等待Socket返回新创建进程的pid;</li>
<li>Zygote进程接收到system_server发送过来的消息, 则通过fork的方法，将zygote自身进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程app process,这个进程可能是用于承载activity等组件;</li>
<li>创建完新进程后fork返回两次, 在新进程app process向servicemanager查询system_server进程中binder服务端AMS,获取相对应的Client端,也就是AMP. 有了这一对binder c/s对, 那么app process便可以通过binder向跨进程system_server发送请求,即attachApplication()</li>
<li>system_server进程接收到相应binder操作后,经过多次调用,利用ATP向app process发送binder请求, 即bindApplication.</li>
</ol>
<p>system_server拥有ATP/AMS, 每一个新创建的进程都会有一个相应的AT/AMS,从而可以跨进程 进行相互通信. 这便是进程创建过程的完整生态链.</p>
<h2 id="三-进程启动全过程"><a href="#三-进程启动全过程" class="headerlink" title="三. 进程启动全过程"></a>三. 进程启动全过程</h2><p>前面刚已介绍四大组件的创建进程的过程是调用1(a) <code>startProcessLocked</code>方法,该方法会再调用1(b)方法. 接下来从该方法开始往下讲述.</p>
<h3 id="3-1-AMS-startProcessLocked"><a href="#3-1-AMS-startProcessLocked" class="headerlink" title="3.1 AMS.startProcessLocked"></a>3.1 AMS.startProcessLocked</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    long startTime &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (!isolated) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据进程名和uid检查相应的ProcessRecord</span><br><span class="line">        app &#x3D; getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line"></span><br><span class="line">        if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果当前处于后台进程，检查当前进程是否处于bad进程列表</span><br><span class="line">            if (mBadProcesses.get(info.processName, info.uid) !&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;当用户明确地启动进程，则清空crash次数，以保证其不处于bad进程直到下次再弹出crash对话框。</span><br><span class="line">            mProcessCrashTimes.remove(info.processName, info.uid);</span><br><span class="line">            if (mBadProcesses.get(info.processName, info.uid) !&#x3D; null) &#123;</span><br><span class="line">                mBadProcesses.remove(info.processName, info.uid);</span><br><span class="line">                if (app !&#x3D; null) &#123;</span><br><span class="line">                    app.bad &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;对于孤立进程，无法再利用已存在的进程</span><br><span class="line">        app &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当存在ProcessRecord,且已分配pid(正在启动或者已经启动),</span><br><span class="line">    &#x2F;&#x2F; 且caller并不认为该进程已死亡或者没有thread对象attached到该进程.则不应该清理该进程</span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">        if (!knownToBeDead || app.thread &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果这是进程中新package，则添加到列表</span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当ProcessRecord已经被attached到先前的一个进程，则杀死并清理该进程</span><br><span class="line">        killProcessGroup(app.info.uid, app.pid);</span><br><span class="line">        handleAppDiedLocked(app, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostingNameStr &#x3D; hostingName !&#x3D; null? hostingName.flattenToShortString() : null;</span><br><span class="line">    if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建新的Process Record对象</span><br><span class="line">        app &#x3D; newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">        if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler &#x3D; crashHandler;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果这是进程中新package，则添加到列表</span><br><span class="line">        app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当系统未准备完毕，则将当前进程加入到mProcessesOnHold</span><br><span class="line">    if (!mProcessesReady &amp;&amp; !isAllowedWhileBooting(info) &amp;&amp; !allowWhileBooting) &#123;</span><br><span class="line">        if (!mProcessesOnHold.contains(app)) &#123;</span><br><span class="line">            mProcessesOnHold.add(app);</span><br><span class="line">        &#125;</span><br><span class="line">        return app;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 启动进程【见小节3.2】</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">    return (app.pid !&#x3D; 0) ? app : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能:</p>
<ul>
<li>对于非isolated进程,则根据进程名和uid来查询相应的ProcessRecord结构体. 如果当前进程处于后台且当前进程处于mBadProcesses列表,则直接返回;否则清空crash次数，以保证其不处于bad进程直到下次再弹出crash对话框。</li>
<li>当存在ProcessRecord,且已分配pid(正在启动或者已经启动)的情况下<ul>
<li>当caller并不认为该进程已死亡或者没有thread对象attached到该进程.则不应该清理该进程,则直接返回;</li>
<li>否则杀死并清理该进程;</li>
</ul>
</li>
<li>当ProcessRecord为空则新建一个,当创建失败则直接返回;</li>
<li>当以下3个值都为false,则将当前进程加入到mProcessesOnHold, 并直接返回; 当进程真正创建则从mProcessesOnHold中移除.<ul>
<li>当AMS.systemReady()执行完成,则<code>mProcessesReady</code>=true;</li>
<li>当进程为persistent, 则<code>isAllowedWhileBooting</code> =true;</li>
<li>一般地创建进程时参数<code>allowWhileBooting</code> = false, 只有AMS.startIsolatedProcess该值才为true;</li>
</ul>
</li>
<li>最后启动新进程,其中参数含义:<ul>
<li>hostingType可取值为”activity”,”service”,”broadcast”,”content provider”;</li>
<li>hostingNameStr数据类型为ComponentName,代表的是具体相对应的组件名.</li>
</ul>
</li>
</ul>
<p>另外, 进程uid是在进程真正创建之前调用<code>newProcessRecordLocked</code>方法来获取的uid, 这里会考虑是否为isolated的情况.</p>
<h3 id="3-2-AMS-startProcessLocked"><a href="#3-2-AMS-startProcessLocked" class="headerlink" title="3.2 AMS.startProcessLocked"></a>3.2 AMS.startProcessLocked</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">    long startTime &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">    &#x2F;&#x2F;当app的pid大于0且不是当前进程的pid，则从mPidsSelfLocked中移除该app.pid</span><br><span class="line">    if (app.pid &gt; 0 &amp;&amp; app.pid !&#x3D; MY_PID) &#123;</span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            mPidsSelfLocked.remove(app.pid);</span><br><span class="line">            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">        &#125;</span><br><span class="line">        app.setPid(0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从mProcessesOnHold移除该app</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line">    updateCpuStats(); &#x2F;&#x2F;更新cpu统计信息</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (AppGlobals.getPackageManager().isPackageFrozen(app.info.packageName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;当前package已被冻结,则抛出异常</span><br><span class="line">                throw new RuntimeException(&quot;Package &quot; + app.info.packageName + &quot; is frozen!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        int uid &#x3D; app.uid;</span><br><span class="line">        int[] gids &#x3D; null;</span><br><span class="line">        int mountExternal &#x3D; Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">        if (!app.isolated) &#123;</span><br><span class="line">            int[] permGids &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;通过Package Manager获取gids</span><br><span class="line">                final IPackageManager pm &#x3D; AppGlobals.getPackageManager();</span><br><span class="line">                permGids &#x3D; pm.getPackageGids(app.info.packageName, app.userId);</span><br><span class="line">                MountServiceInternal mountServiceInternal &#x3D; LocalServices.getService(</span><br><span class="line">                        MountServiceInternal.class);</span><br><span class="line">                mountExternal &#x3D; mountServiceInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                        app.info.packageName);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;添加共享app和gids，用于app直接共享资源</span><br><span class="line">            if (ArrayUtils.isEmpty(permGids)) &#123;</span><br><span class="line">                gids &#x3D; new int[2];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                gids &#x3D; new int[permGids.length + 2];</span><br><span class="line">                System.arraycopy(permGids, 0, gids, 2, permGids.length);</span><br><span class="line">            &#125;</span><br><span class="line">            gids[0] &#x3D; UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</span><br><span class="line">            gids[1] &#x3D; UserHandle.getUserGid(UserHandle.getUserId(uid));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据不同参数,设置相应的debugFlags</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        app.gids &#x3D; gids;</span><br><span class="line">        app.requiredAbi &#x3D; requiredAbi;</span><br><span class="line">        app.instructionSet &#x3D; instructionSet;</span><br><span class="line"></span><br><span class="line">        boolean isActivityProcess &#x3D; (entryPoint &#x3D;&#x3D; null);</span><br><span class="line">        if (entryPoint &#x3D;&#x3D; null) entryPoint &#x3D; &quot;android.app.ActivityThread&quot;;</span><br><span class="line">        &#x2F;&#x2F;请求Zygote创建新进程[见3.3]</span><br><span class="line">        Process.ProcessStartResult startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                app.info.dataDir, entryPointArgs);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (app.persistent) &#123;</span><br><span class="line">            Watchdog.getInstance().processStarted(app.processName, startResult.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;重置ProcessRecord的成员变量</span><br><span class="line">        app.setPid(startResult.pid);</span><br><span class="line">        app.usingWrapper &#x3D; startResult.usingWrapper;</span><br><span class="line">        app.removed &#x3D; false;</span><br><span class="line">        app.killed &#x3D; false;</span><br><span class="line">        app.killedByAm &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将新创建的进程加入到mPidsSelfLocked</span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            this.mPidsSelfLocked.put(startResult.pid, app);</span><br><span class="line">            if (isActivityProcess) &#123;</span><br><span class="line">                Message msg &#x3D; mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">                msg.obj &#x3D; app;</span><br><span class="line">                &#x2F;&#x2F;延迟发送消息PROC_START_TIMEOUT_MSG</span><br><span class="line">                mHandler.sendMessageDelayed(msg, startResult.usingWrapper</span><br><span class="line">                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        app.setPid(0); &#x2F;&#x2F;进程创建失败,则重置pid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据不同参数,设置相应的debugFlags,比如在AndroidManifest.xml中设置androidd:debuggable为true，代表app运行在debug模式,则增加debugger标识以及开启JNI check功能</li>
<li>调用Process.start来创建新进程;</li>
<li>重置ProcessRecord的成员变量, 一般情况下超时10s后发送PROC_START_TIMEOUT_MSG的handler消息;</li>
</ul>
<p>关于Process.start()是通过socket通信告知Zygote创建fork子进程，创建新进程后将ActivityThread类加载到新进程，并调用ActivityThread.main()方法。详细过程见<a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a>,接下来进入AT.main方法.</p>
<h3 id="3-3-ActivityThread-main"><a href="#3-3-ActivityThread-main" class="headerlink" title="3.3 ActivityThread.main"></a>3.3 ActivityThread.main</h3><p>[-&gt; ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;性能统计默认是关闭的</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line">    &#x2F;&#x2F;将当前进程所在userId赋值给sCurrentUser</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line">    AndroidKeyStoreProvider.install();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确保可信任的CA证书存放在正确的位置</span><br><span class="line">    final File configDir &#x3D; Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建主线程的Looper对象, 该Looper是不运行退出</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建ActivityThread对象</span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;建立Binder通道 【见流程3.4】</span><br><span class="line">    thread.attach(false);</span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当设置为true时，可打开消息队列的debug log信息</span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.loop(); &#x2F;&#x2F;消息循环运行</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建主线程的Looper对象: 该Looper是不运行退出. 也就是说主线程的Looper是在进程创建完成时自动创建完成,如果子线程也需要创建handler通信过程,那么就需要手动创建Looper对象,并且每个线程只能创建一次.</p>
</li>
<li><p>创建ActivityThread对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread = new ActivityThread()</span><br></pre></td></tr></table></figure>

<p>: 该过程会初始化几个很重要的变量:</p>
<ul>
<li>mAppThread = new ApplicationThread()</li>
<li>mLooper = Looper.myLooper()</li>
<li>mH = new H(), <code>H</code>继承于<code>Handler</code>;用于处理组件的生命周期.</li>
</ul>
</li>
<li><p>attach过程是当前主线程向system_server进程通信的过程, 将thread信息告知AMS.接下来还会进一步说明该过程.</p>
</li>
<li><p>sMainThreadHandler通过getHandler(),获取的对象便是<code>mH</code>,这就是主线程的handler对象.</p>
</li>
</ul>
<p>之后主线程调用Looper.loop(),进入消息循环状态, 当没有消息时主线程进入休眠状态, 一旦有消息到来则唤醒主线程并执行相关操作.</p>
<h3 id="3-4-ActivityThread-attach"><a href="#3-4-ActivityThread-attach" class="headerlink" title="3.4. ActivityThread.attach"></a>3.4. ActivityThread.attach</h3><p>[-&gt; ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    sCurrentActivityThread &#x3D; this;</span><br><span class="line">    mSystemThread &#x3D; system;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">         &#x2F;&#x2F;开启虚拟机的jit即时编译功能</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        &#x2F;&#x2F;创建ActivityManagerProxy对象</span><br><span class="line">        final IActivityManager mgr &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;调用基于IActivityManager接口的Binder通道【见流程3.5】</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;观察是否快接近heap的上限</span><br><span class="line">        BinderInternal.addGcWatcher(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">                if (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime &#x3D; Runtime.getRuntime();</span><br><span class="line">                long dalvikMax &#x3D; runtime.maxMemory();</span><br><span class="line">                long dalvikUsed &#x3D; runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                if (dalvikUsed &gt; ((3*dalvikMax)&#x2F;4)) &#123;</span><br><span class="line">                    mSomeActivitiesChanged &#x3D; false;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F;当已用内存超过最大内存的3&#x2F;4,则请求释放内存空间</span><br><span class="line">                        mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加dropbox日志到libcore</span><br><span class="line">    DropBox.setReporter(new DropBoxReporter());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加Config回调接口</span><br><span class="line">    ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class="line">            synchronized (mResourcesManager) &#123;</span><br><span class="line">                if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) &#123;</span><br><span class="line">                    if (mPendingConfiguration &#x3D;&#x3D; null ||</span><br><span class="line">                            mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123;</span><br><span class="line">                        mPendingConfiguration &#x3D; newConfig;</span><br><span class="line">                        sendMessage(H.CONFIGURATION_CHANGED, newConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLowMemory() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onTrimMemory(int level) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非系统attach的处理流程:</p>
<ul>
<li>创建线程来开启虚拟机的jit即时编译;</li>
<li>通过binder, 调用到AMS.attachApplication, 其参数mAppThread的数据类型为<code>ApplicationThread</code></li>
<li>观察是否快接近heap的上限,当已用内存超过最大内存的3/4,则请求释放内存空间</li>
<li>添加dropbox日志到libcore</li>
<li>添加Config回调接口</li>
</ul>
<h3 id="3-5-AMP-attachApplication"><a href="#3-5-AMP-attachApplication" class="headerlink" title="3.5 AMP.attachApplication"></a>3.5 AMP.attachApplication</h3><p>[-&gt; ActivityManagerProxy.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void attachApplication(IApplicationThread app) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(app.asBinder());</span><br><span class="line">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); &#x2F;&#x2F;【见流程3.6】</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处 descriptor = “android.app.IActivityManager”</p>
<h3 id="3-6-AMN-onTransact"><a href="#3-6-AMN-onTransact" class="headerlink" title="3.6 AMN.onTransact"></a>3.6 AMN.onTransact</h3><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    ...</span><br><span class="line">     case ATTACH_APPLICATION_TRANSACTION: &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        &#x2F;&#x2F;获取ApplicationThread的binder代理类 ApplicationThreadProxy</span><br><span class="line">        IApplicationThread app &#x3D; ApplicationThreadNative.asInterface(</span><br><span class="line">                data.readStrongBinder());</span><br><span class="line">        if (app !&#x3D; null) &#123;</span><br><span class="line">            attachApplication(app); &#x2F;&#x2F;此处是ActivityManagerService类中的方法 【见流程3.7】</span><br><span class="line">        &#125;</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-AMS-attachApplication"><a href="#3-7-AMS-attachApplication" class="headerlink" title="3.7 AMS.attachApplication"></a>3.7 AMS.attachApplication</h3><p>[-&gt; ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid); &#x2F;&#x2F; 【见流程3.8】</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的<code>thread</code>便是ApplicationThreadProxy对象,用于跟前面通过Process.start()所创建的进程中ApplicationThread对象进行通信.</p>
<h3 id="3-8-AMS-attachApplicationLocked"><a href="#3-8-AMS-attachApplicationLocked" class="headerlink" title="3.8 AMS.attachApplicationLocked"></a>3.8 AMS.attachApplicationLocked</h3><p>[-&gt; ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (pid !&#x3D; MY_PID &amp;&amp; pid &gt;&#x3D; 0) &#123;</span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            app &#x3D; mPidsSelfLocked.get(pid); &#x2F;&#x2F; 根据pid获取ProcessRecord</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        app &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (pid &gt; 0 &amp;&amp; pid !&#x3D; MY_PID) &#123;</span><br><span class="line">            &#x2F;&#x2F;ProcessRecord为空，则杀掉该进程</span><br><span class="line">            Process.killProcessQuiet(pid);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;退出新建进程的Looper</span><br><span class="line">            thread.scheduleExit();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;还刚进入attach过程,此时thread应该为null,若不为null则表示该app附到上一个进程，则立刻清空</span><br><span class="line">    if (app.thread !&#x3D; null) &#123;</span><br><span class="line">        handleAppDiedLocked(app, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String processName &#x3D; app.processName;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;绑定死亡通知</span><br><span class="line">        AppDeathRecipient adr &#x3D; new AppDeathRecipient(app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, 0);</span><br><span class="line">        app.deathRecipient &#x3D; adr;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        startProcessLocked(app, &quot;link fail&quot;, processName); &#x2F;&#x2F;重新启动进程</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置进程信息</span><br><span class="line">    app.makeActive(thread, mProcessStats); &#x2F;&#x2F;执行完该语句,则app.thread便不再为空</span><br><span class="line">    app.curAdj &#x3D; app.setAdj &#x3D; -100;</span><br><span class="line">    app.curSchedGroup &#x3D; app.setSchedGroup &#x3D; Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">    app.forcingToForeground &#x3D; null;</span><br><span class="line">    updateProcessForegroundLocked(app, false, false);</span><br><span class="line">    app.hasShownUi &#x3D; false;</span><br><span class="line">    app.debugging &#x3D; false;</span><br><span class="line">    app.cached &#x3D; false;</span><br><span class="line">    app.killedByAm &#x3D; false;</span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); &#x2F;&#x2F;移除进程启动超时的消息</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;系统处于ready状态或者该app为FLAG_PERSISTENT进程,则为true</span><br><span class="line">    boolean normalMode &#x3D; mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    List&lt;ProviderInfo&gt; providers &#x3D; normalMode ? generateApplicationProvidersLocked(app) : null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;app进程存在正在启动中的provider,则超时10s后发送CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG消息</span><br><span class="line">    if (providers !&#x3D; null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        Message msg &#x3D; mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj &#x3D; app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        ensurePackageDexOpt(app.instrumentationInfo !&#x3D; null</span><br><span class="line">                ? app.instrumentationInfo.packageName</span><br><span class="line">                : app.info.packageName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取应用appInfo</span><br><span class="line">        ApplicationInfo appInfo &#x3D; app.instrumentationInfo !&#x3D; null</span><br><span class="line">                ? app.instrumentationInfo : app.info;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 绑定应用 [见流程3.9]</span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                new Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        &#x2F;&#x2F;更新进程LRU队列</span><br><span class="line">        updateLruProcessLocked(app, false, null);</span><br><span class="line">        app.lastRequestedGc &#x3D; app.lastLowMemory &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line">        &#x2F;&#x2F;每当bind操作失败,则重启启动进程, 此处有可能会导致进程无限重启</span><br><span class="line">        startProcessLocked(app, &quot;bind fail&quot;, processName);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line">    boolean badApp &#x3D; false;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Activity: 检查最顶层可见的Activity是否等待在该进程中运行</span><br><span class="line">    if (normalMode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Service: 寻找所有需要在该进程中运行的服务</span><br><span class="line">    if (!badApp) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            didSomething |&#x3D; mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Broadcast: 检查是否在这个进程中有下一个广播接收者</span><br><span class="line">    if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            didSomething |&#x3D; sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;检查是否在这个进程中有下一个backup代理</span><br><span class="line">    if (!badApp &amp;&amp; mBackupTarget !&#x3D; null &amp;&amp; mBackupTarget.appInfo.uid &#x3D;&#x3D; app.uid) &#123;</span><br><span class="line">        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);</span><br><span class="line">        try &#123;</span><br><span class="line">            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class="line">                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class="line">                    mBackupTarget.backupMode);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (badApp) &#123; &#x2F;&#x2F;杀掉bad应用</span><br><span class="line">        app.kill(&quot;error during init&quot;, true);</span><br><span class="line">        handleAppDiedLocked(app, false, true);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!didSomething) &#123;</span><br><span class="line">        updateOomAdjLocked(); &#x2F;&#x2F;更新adj的值</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据pid从mPidsSelfLocked中查询到相应的ProcessRecord对象app;</li>
<li>当app==null,意味着本次创建的进程不存在, 则直接返回.</li>
<li>还刚进入attach过程,此时thread应该为null,若不为null则表示该app附到上一个进程，则调用handleAppDiedLocked清理.</li>
<li>绑定死亡通知,当进程pid死亡时会通过binder死亡回调,来通知system_server进程死亡的消息;</li>
<li>重置ProcessRecord进程信息, 此时app.thread也赋予了新值,便不再为空.</li>
<li>app进程存在正在启动中的provider,则超时10s后发送CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG消息</li>
<li>调用thread.bindApplication绑定应用进程, 后面再进一步说明</li>
<li>处理Provider, Activity, Service, Broadcast相应流程</li>
</ol>
<p>下面,再来说说thread.bindApplication的过程.</p>
<h3 id="3-9-ATP-bindApplication"><a href="#3-9-ATP-bindApplication" class="headerlink" title="3.9 ATP.bindApplication"></a>3.9 ATP.bindApplication</h3><p>[-&gt; ApplicationThreadNative.java ::ApplicationThreadProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationThreadProxy implements IApplicationThread &#123;</span><br><span class="line">    ...</span><br><span class="line">    public final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean openGlTrace, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeString(packageName);</span><br><span class="line">        info.writeToParcel(data, 0);</span><br><span class="line">        data.writeTypedList(providers);</span><br><span class="line">        if (testName &#x3D;&#x3D; null) &#123;</span><br><span class="line">            data.writeInt(0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data.writeInt(1);</span><br><span class="line">            testName.writeToParcel(data, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (profilerInfo !&#x3D; null) &#123;</span><br><span class="line">            data.writeInt(1);</span><br><span class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        data.writeBundle(testArgs);</span><br><span class="line">        data.writeStrongInterface(testWatcher);</span><br><span class="line">        data.writeStrongInterface(uiAutomationConnection);</span><br><span class="line">        data.writeInt(debugMode);</span><br><span class="line">        data.writeInt(openGlTrace ? 1 : 0);</span><br><span class="line">        data.writeInt(restrictedBackupMode ? 1 : 0);</span><br><span class="line">        data.writeInt(persistent ? 1 : 0);</span><br><span class="line">        config.writeToParcel(data, 0);</span><br><span class="line">        compatInfo.writeToParcel(data, 0);</span><br><span class="line">        data.writeMap(services);</span><br><span class="line">        data.writeBundle(coreSettings);</span><br><span class="line">        mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null,</span><br><span class="line">                IBinder.FLAG_ONEWAY);</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ATP经过binder ipc传递到ATN的onTransact过程.</p>
<h3 id="3-10-ATN-onTransact"><a href="#3-10-ATN-onTransact" class="headerlink" title="3.10 ATN.onTransact"></a>3.10 ATN.onTransact</h3><p>[-&gt; ApplicationThreadNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    ...</span><br><span class="line">    case BIND_APPLICATION_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">        String packageName &#x3D; data.readString();</span><br><span class="line">        ApplicationInfo info &#x3D;</span><br><span class="line">            ApplicationInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        List&lt;ProviderInfo&gt; providers &#x3D;</span><br><span class="line">            data.createTypedArrayList(ProviderInfo.CREATOR);</span><br><span class="line">        ComponentName testName &#x3D; (data.readInt() !&#x3D; 0)</span><br><span class="line">            ? new ComponentName(data) : null;</span><br><span class="line">        ProfilerInfo profilerInfo &#x3D; data.readInt() !&#x3D; 0</span><br><span class="line">                ? ProfilerInfo.CREATOR.createFromParcel(data) : null;</span><br><span class="line">        Bundle testArgs &#x3D; data.readBundle();</span><br><span class="line">        IBinder binder &#x3D; data.readStrongBinder();</span><br><span class="line">        IInstrumentationWatcher testWatcher &#x3D; IInstrumentationWatcher.Stub.asInterface(binder);</span><br><span class="line">        binder &#x3D; data.readStrongBinder();</span><br><span class="line">        IUiAutomationConnection uiAutomationConnection &#x3D;</span><br><span class="line">                IUiAutomationConnection.Stub.asInterface(binder);</span><br><span class="line">        int testMode &#x3D; data.readInt();</span><br><span class="line">        boolean openGlTrace &#x3D; data.readInt() !&#x3D; 0;</span><br><span class="line">        boolean restrictedBackupMode &#x3D; (data.readInt() !&#x3D; 0);</span><br><span class="line">        boolean persistent &#x3D; (data.readInt() !&#x3D; 0);</span><br><span class="line">        Configuration config &#x3D; Configuration.CREATOR.createFromParcel(data);</span><br><span class="line">        CompatibilityInfo compatInfo &#x3D; CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        HashMap&lt;String, IBinder&gt; services &#x3D; data.readHashMap(null);</span><br><span class="line">        Bundle coreSettings &#x3D; data.readBundle();</span><br><span class="line">        &#x2F;&#x2F;[见流程3.11]</span><br><span class="line">        bindApplication(packageName, info, providers, testName, profilerInfo, testArgs,</span><br><span class="line">                testWatcher, uiAutomationConnection, testMode, openGlTrace,</span><br><span class="line">                restrictedBackupMode, persistent, config, compatInfo, services, coreSettings);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-11-AT-bindApplication"><a href="#3-11-AT-bindApplication" class="headerlink" title="3.11 AT.bindApplication"></a>3.11 AT.bindApplication</h3><p>[-&gt; ActivityThread.java ::ApplicationThread]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">    if (services !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;将services缓存起来, 减少binder检索服务的次数</span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送消息H.SET_CORE_SETTINGS [见小节3.12]</span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    IPackageManager pm &#x3D; getPackageManager();</span><br><span class="line">    android.content.pm.PackageInfo pi &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        pi &#x3D; pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pi !&#x3D; null) &#123;</span><br><span class="line">        boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);</span><br><span class="line">        boolean processNameNotDefault &#x3D; (pi.applicationInfo !&#x3D; null &amp;&amp;</span><br><span class="line">         !appInfo.packageName.equals(pi.applicationInfo.processName));</span><br><span class="line">        boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);</span><br><span class="line"></span><br><span class="line">        if (!sharable) &#123;</span><br><span class="line">            VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir,</span><br><span class="line">                                    appInfo.processName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化AppBindData</span><br><span class="line">    AppBindData data &#x3D; new AppBindData();</span><br><span class="line">    data.processName &#x3D; processName;</span><br><span class="line">    data.appInfo &#x3D; appInfo;</span><br><span class="line">    data.providers &#x3D; providers;</span><br><span class="line">    data.instrumentationName &#x3D; instrumentationName;</span><br><span class="line">    data.instrumentationArgs &#x3D; instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher &#x3D; instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection &#x3D; instrumentationUiConnection;</span><br><span class="line">    data.debugMode &#x3D; debugMode;</span><br><span class="line">    data.enableOpenGlTrace &#x3D; enableOpenGlTrace;</span><br><span class="line">    data.restrictedBackupMode &#x3D; isRestrictedBackupMode;</span><br><span class="line">    data.persistent &#x3D; persistent;</span><br><span class="line">    data.config &#x3D; config;</span><br><span class="line">    data.compatInfo &#x3D; compatInfo;</span><br><span class="line">    data.initProfilerInfo &#x3D; profilerInfo;</span><br><span class="line">    &#x2F;&#x2F;发送消息H.BIND_APPLICATION [见小节3.13]</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中setCoreSettings()过程就是调用sendMessage(H.SET_CORE_SETTINGS, coreSettings) 来向主线程发送SET_CORE_SETTINGS消息.bindApplication方法的主要功能是依次向主线程发送消息<code>H.SET_CORE_SETTINGS</code>和<code>H.BIND_APPLICATION</code>. 接下来再来说说这两个消息的处理过程</p>
<h3 id="3-12-AT-handleSetCoreSettings"><a href="#3-12-AT-handleSetCoreSettings" class="headerlink" title="3.12 AT.handleSetCoreSettings"></a>3.12 AT.handleSetCoreSettings</h3><p>[-&gt; ActivityThread.java ::H]</p>
<p>当主线程收到H.SET_CORE_SETTINGS,则调用handleSetCoreSettings</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void handleSetCoreSettings(Bundle coreSettings) &#123;</span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        mCoreSettings &#x3D; coreSettings;</span><br><span class="line">    &#125;</span><br><span class="line">    onCoreSettingsChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void onCoreSettingsChange() &#123;</span><br><span class="line">    boolean debugViewAttributes &#x3D; mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) !&#x3D; 0;</span><br><span class="line">    if (debugViewAttributes !&#x3D; View.mDebugViewAttributes) &#123;</span><br><span class="line">        View.mDebugViewAttributes &#x3D; debugViewAttributes;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由于发生改变, 请求所有的activities重启启动</span><br><span class="line">        for (Map.Entry&lt;IBinder, ActivityClientRecord&gt; entry : mActivities.entrySet()) &#123;</span><br><span class="line">            requestRelaunchActivity(entry.getKey(), null, null, 0, false, null, null, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-13-AT-handleBindApplication"><a href="#3-13-AT-handleBindApplication" class="headerlink" title="3.13 AT.handleBindApplication"></a>3.13 AT.handleBindApplication</h3><p>[-&gt; ActivityThread.java ::H]</p>
<p>当主线程收到H.BIND_APPLICATION,则调用handleBindApplication</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">    mBoundApplication &#x3D; data;</span><br><span class="line">    mConfiguration &#x3D; new Configuration(data.config);</span><br><span class="line">    mCompatConfiguration &#x3D; new Configuration(data.config);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置进程名, 也就是说进程名是在进程真正创建以后的BIND_APPLICATION过程中才取名</span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">    if (data.persistent) &#123;</span><br><span class="line">        &#x2F;&#x2F;低内存设备, persistent进程不采用硬件加速绘制,以节省内存使用量</span><br><span class="line">        if (!ActivityManager.isHighEndGfx()) &#123;</span><br><span class="line">            HardwareRenderer.disable(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置时区</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line">    Locale.setDefault(data.config.locale);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新系统配置</span><br><span class="line">    mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);</span><br><span class="line">    mCurDefaultDisplayDpi &#x3D; data.config.densityDpi;</span><br><span class="line">    applyCompatConfiguration(mCurDefaultDisplayDpi);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取LoadedApk对象[见小节3.13.1]</span><br><span class="line">    data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建ContextImpl上下文</span><br><span class="line">    final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    if (!Process.isIsolated()) &#123;</span><br><span class="line">        final File cacheDir &#x3D; appContext.getCacheDir();</span><br><span class="line">        if (cacheDir !&#x3D; null) &#123;</span><br><span class="line">            System.setProperty(&quot;java.io.tmpdir&quot;, cacheDir.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用于存储产生&#x2F;编译的图形代码</span><br><span class="line">        final File codeCacheDir &#x3D; appContext.getCodeCacheDir();</span><br><span class="line">        if (codeCacheDir !&#x3D; null) &#123;</span><br><span class="line">            setupGraphicsSupport(data.info, codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当处于调试模式,则运行应用生成systrace信息</span><br><span class="line">    boolean appTracingAllowed &#x3D; (data.appInfo.flags&amp;ApplicationInfo.FLAG_DEBUGGABLE) !&#x3D; 0;</span><br><span class="line">    Trace.setAppTracingAllowed(appTracingAllowed);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化 默认的http代理</span><br><span class="line">    IBinder b &#x3D; ServiceManager.getService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    if (b !&#x3D; null) &#123;</span><br><span class="line">        IConnectivityManager service &#x3D; IConnectivityManager.Stub.asInterface(b);</span><br><span class="line">        final ProxyInfo proxyInfo &#x3D; service.getProxyForNetwork(null);</span><br><span class="line">        Proxy.setHttpProxySystemProperty(proxyInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (data.instrumentationName !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;FLAG_LARGE_HEAP则清除内存增长上限</span><br><span class="line">    if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) !&#x3D; 0) &#123;</span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 此处data.info是指LoadedApk, 通过反射创建目标应用Application对象[见小节3.14]</span><br><span class="line">        Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        mInitialApplication &#x3D; app;</span><br><span class="line"></span><br><span class="line">        if (!data.restrictedBackupMode) &#123;</span><br><span class="line">            List&lt;ProviderInfo&gt; providers &#x3D; data.providers;</span><br><span class="line">            if (providers !&#x3D; null) &#123;</span><br><span class="line">                installContentProviders(app, providers);</span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#x2F;&#x2F;调用Application.onCreate()回调方法.</span><br><span class="line">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在handleBindApplication()的过程中,会同时设置以下两个值:</p>
<ul>
<li>LoadedApk.mApplication</li>
<li>AT.mInitialApplication</li>
</ul>
<h4 id="3-13-1-getPackageInfoNoCheck"><a href="#3-13-1-getPackageInfoNoCheck" class="headerlink" title="3.13.1 getPackageInfoNoCheck"></a>3.13.1 getPackageInfoNoCheck</h4><p>[-&gt; ActivityThread.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">//不支持跨用户</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            <span class="comment">//创建LoadedApk对象</span></span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSystemThread &amp;&amp; <span class="string">"android"</span>.equals(aInfo.packageName)) &#123;</span><br><span class="line">                packageInfo.installSystemApplicationInfo(aInfo,</span><br><span class="line">                        getSystemContext().mPackageInfo.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">                <span class="comment">//不支持跨用户</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">                mPackages.put(aInfo.packageName,</span><br><span class="line">                        <span class="keyword">new</span> WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mResourcePackages.put(aInfo.packageName,</span><br><span class="line">                        <span class="keyword">new</span> WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建LoadedApk对象</p>
<h3 id="3-14-makeApplication"><a href="#3-14-makeApplication" class="headerlink" title="3.14 makeApplication"></a>3.14 makeApplication</h3><p>[-&gt; LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication !&#x3D; null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Application app &#x3D; null;</span><br><span class="line"></span><br><span class="line">    String appClass &#x3D; mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass &#x3D;&#x3D; null)) &#123;</span><br><span class="line">        appClass &#x3D; &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl &#x3D; getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;[见小节3.14.1]</span><br><span class="line">        ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        &#x2F;&#x2F;[见小节3.14.2]</span><br><span class="line">        app &#x3D; mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    &#x2F;&#x2F;设置mApplication对象值</span><br><span class="line">    mApplication &#x3D; app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;调用app.onCreate()</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers &#x3D; getAssets(mActivityThread)</span><br><span class="line">            .getAssignedPackageIdentifiers();</span><br><span class="line">    final int N &#x3D; packageIdentifiers.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id &#x3D; packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id &#x3D;&#x3D; 0x01 || id &#x3D;&#x3D; 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;重写所有apk库中的R常量[见小节3.14.3]</span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-14-1-createAppContext"><a href="#3-14-1-createAppContext" class="headerlink" title="3.14.1 createAppContext"></a>3.14.1 createAppContext</h4><p>[-&gt; ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123;</span><br><span class="line">    if (packageInfo &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;packageInfo&quot;);</span><br><span class="line">    return new ContextImpl(null, mainThread,</span><br><span class="line">            packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建ContextImpl对象</p>
<h4 id="3-14-2-newApplication"><a href="#3-14-2-newApplication" class="headerlink" title="3.14.2 newApplication"></a>3.14.2 newApplication</h4><p>[-&gt; Instrumentation.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">    return newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Application对象, 该对象名来自于mApplicationInfo.className.</p>
<h4 id="3-14-3-rewriteRValues"><a href="#3-14-3-rewriteRValues" class="headerlink" title="3.14.3 rewriteRValues"></a>3.14.3 rewriteRValues</h4><p>[-&gt; LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    try &#123;</span><br><span class="line">        rClazz &#x3D; cl.loadClass(packageName + &quot;.R&quot;);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Method callback;</span><br><span class="line">    try &#123;</span><br><span class="line">        callback &#x3D; rClazz.getMethod(&quot;onResourcesLoaded&quot;, int.class);</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Throwable cause;</span><br><span class="line">    try &#123;</span><br><span class="line">        callback.invoke(null, id);</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        cause &#x3D; e;</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        cause &#x3D; e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Failed to rewrite resource references for &quot; + packageName,</span><br><span class="line">            cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>本文首先介绍AMS的4个同名不同参数的方法startProcessLocked; 紧接着讲述了四大组件与进程的关系, Activity, Service, ContentProvider, BroadcastReceiver这四大组件,在启动的过程,当其所承载的进程不存在时需要先创建进程. 再然后进入重点以startProcessLocked以引线一路讲解整个过程所遇到的核心方法. 在整个过程中有新创建的进程与system_server进程之间的交互过程 是通过binder进行通信的, 这里有两条binder通道分别为AMP/AMN 和 ATP/ATN.</p>
<p><img src="http://gityuan.com/images/process/start_process.jpg" alt="start_process"></p>
<p>上图便是一次完整的进程创建过程,app的任何组件需要有一个承载其运行的容器,那就是进程, 那么进程的创建过程都是由系统进程system_server通过socket向zygote进程来请求fork()新进程, 当创建出来的app process与system_server进程之间的通信便是通过binder IPC机制.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/03/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" itemprop="url">git常见问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-03T11:22:41+08:00">
                2020-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/03/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/03/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git常见问题记录"><a href="#git常见问题记录" class="headerlink" title="git常见问题记录"></a>git常见问题记录</h1><h2 id="Empty-reply-from-server"><a href="#Empty-reply-from-server" class="headerlink" title="Empty reply from server"></a>Empty reply from server</h2><p>问题：fatal: unable to access ‘<a href="http://xxx.git/&#39;" target="_blank" rel="noopener">http://xxx.git/&#39;</a>: Empty reply from server</p>
<p>原因：因为设置了代理，所以找不到地址</p>
<p>解决：取消全局代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

<h2 id="error-src-refspec-xxx-matches-more-than-one"><a href="#error-src-refspec-xxx-matches-more-than-one" class="headerlink" title="error: src refspec xxx matches more than one."></a>error: src refspec xxx matches more than one.</h2><p>问题：error: src refspec v330 matches more than one.</p>
<p>原因：出现这个错误之前，是在远程服务器上创建了一个tag v330，同时本地分支也是 v330，</p>
<p>解决：删除tag，或者另起一名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v330</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/" itemprop="url">源码分析-Activity生命周期流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-02T20:41:53+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/" itemprop="url" rel="index">
                    <span itemprop="name">Activity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Activity 经典生命周期图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-9ceca5ca67e6e73f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-cc817b0ebc885e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>不要在<code>onCreate，onStart，onResume，onPause</code>几个方法进行耗时操作，否则会造成页面切换卡顿。</p>
<h2 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h2><p>Activity的生命周期中存在四种基本的状态：</p>
<ul>
<li>活动状态(Active/Runing)</li>
<li>暂停状态(Paused)</li>
<li>停止状态(Stopped)</li>
<li>销毁状态(Killed)。</li>
</ul>
<h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>一个新的Activity入栈后，当处于Activity栈顶时，此事它处于可见并且能与用户进行交互。</p>
<ul>
<li>期间触发的生命周期：<code>onCreate()-&gt; onStart()-&gt; onResume()</code></li>
</ul>
<h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p>当Activity失去焦点，一个新的非全屏Activity或者透明的Activity被放置栈顶，此时处于暂停状态。一个处于暂定状态的Activity只有在系统极度匮乏的时候才会被回收掉。</p>
<p>在Activity之上显示dialog对话框或者<code>PopupWindow</code>该Activity并不会变成暂停状态。<br>当下拉通知栏时，Activity会走什么生命周期?以及弹出Dialog时会走什么生命周期?关于这两知识点，今天特意写了一下，发现啥都没走，也就说任何生命周期都不会走，也简单查了一下原因，下拉通知栏因为是系统窗口，所以不影响activity的生命周期，Dialog或者Toast源码中也能看windowmanager.addView()，也就说都是和系统管理者有关系，不会影响到本应用。</p>
<ul>
<li>运行状态到暂停状态触发的生命周期：<code>onResume() --&gt; onPause()</code>。</li>
<li>从暂停状态恢复到运行状态触发的生命周期：<code>onPause() -&gt; onResume()</code>。</li>
</ul>
<h3 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h3><p>一个Activity完全被另一个Activity完全覆盖或者，用户不可见或者退到后台，叫做停止状态。它仍保存着所有状态和成员信息，不能和用户交互，当系统内存需要的时候Stopped状态的Activity会被强制回收掉。</p>
<ul>
<li>从暂停状态到停止状态经过的生命周期：<code>onPause()--&gt;onStop()</code></li>
<li>从停止状态到运行状态经过的生命周期：<code>onStop() --&gt; onRestart() --&gt; onStart() --&gt; onResume()</code>。不会走onCreate()方法。</li>
</ul>
<h3 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h3><p>如果一个Activity再Paused或者Stopped状态，系统可以将Activity从内存中删除，删除的方式有两种：一种是要求Activity结束，一种直接结束掉它的进程。当有需要的时候就得重新创建Activity了。</p>
<p>触发的生命周期：onDestroy()，直接结束进程的话是不会走onDestroy()的。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>在开启Activity流程分析时说过，开启Activity会经过<code>ActivityStackSupervisor#realStartActivityLocked()</code>方法，然后经过一些列流程最终调用<code>onCreate</code>方法，其实其它生命周期也是类似的。</p>
<h2 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><h3 id="realStartActivityLocked"><a href="#realStartActivityLocked" class="headerlink" title="realStartActivityLocked()"></a><code>realStartActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">            boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; Create activity launch transaction.</span><br><span class="line">                final ClientTransaction clientTransaction &#x3D; ClientTransaction.obtain(app.thread,</span><br><span class="line">                        r.appToken);</span><br><span class="line">                 &#x2F;&#x2F; 添加 LaunchActivityItem</span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                        System.identityHashCode(r), r.info,</span><br><span class="line">                        &#x2F;&#x2F; TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                        &#x2F;&#x2F; and override configs.</span><br><span class="line">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                        profilerInfo));</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Set desired final state.</span><br><span class="line">                final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">                if (andResume) &#123;</span><br><span class="line">                    lifecycleItem &#x3D; ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    lifecycleItem &#x3D; PauseActivityItem.obtain();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 2. 设置生命周期状态 这里是开启resume的关键，类型：ResumeActivityItem</span><br><span class="line">                clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Schedule transaction.</span><br><span class="line">                &#x2F;&#x2F;执行生命周期</span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">                ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是看<code>mService.getLifecycleManager()</code></p>
<h2 id="AMS中"><a href="#AMS中" class="headerlink" title="AMS中"></a>AMS中</h2><h3 id="getLifecycleManager"><a href="#getLifecycleManager" class="headerlink" title="getLifecycleManager()"></a><code>getLifecycleManager()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClientLifecycleManager getLifecycleManager() &#123;</span><br><span class="line">        return mLifecycleManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回ClientLifecycleManager对象，然后调用<code>scheduleTransaction()</code></p>
<h2 id="ClientLifecycleManager"><a href="#ClientLifecycleManager" class="headerlink" title="ClientLifecycleManager"></a><code>ClientLifecycleManager</code></h2><h3 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction()"></a><code>scheduleTransaction()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">        final IApplicationThread client &#x3D; transaction.getClient();</span><br><span class="line">        transaction.schedule();</span><br><span class="line">        if (!(client instanceof Binder)) &#123;</span><br><span class="line">            &#x2F;&#x2F; If client is not an instance of Binder - it&#39;s a remote call and at this point it is</span><br><span class="line">            &#x2F;&#x2F; safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">            &#x2F;&#x2F; the transaction is executed on client in ActivityThread.</span><br><span class="line">            transaction.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClientTransaction"><a href="#ClientTransaction" class="headerlink" title="ClientTransaction"></a><code>ClientTransaction</code></h2><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a><code>schedule()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">        mClient.scheduleTransaction(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>mClient</code>中<code>scheduleTransaction</code>方法，<code>mClient</code>是<code>IApplicationThread</code>,是<code>ActivityThread</code>内部类.</p>
<h2 id="ActivityThread-IApplicationThread"><a href="#ActivityThread-IApplicationThread" class="headerlink" title="ActivityThread#IApplicationThread"></a><code>ActivityThread#IApplicationThread</code></h2><p><code>IApplicationThread</code> 是极其重要的一个 Binder 接口，它维护了应用进程和 AMS 的之间的通讯。这个 <code>mClient</code> 就是应用进程在 AMS 进程中的代理对象，AMS 通过 <code>mClient</code> 来指挥应用进程。</p>
<h3 id="scheduleTransaction-1"><a href="#scheduleTransaction-1" class="headerlink" title="scheduleTransaction()"></a><code>scheduleTransaction()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">            ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>ActivityThread</code>中<code>scheduleTransaction</code>方法</p>
<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><h3 id="scheduleTransaction-2"><a href="#scheduleTransaction-2" class="headerlink" title="scheduleTransaction()"></a><code>scheduleTransaction()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">        transaction.preExecute(this);</span><br><span class="line">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程间通讯，我们找到EXECUTE_TRANSACTION对应的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case EXECUTE_TRANSACTION:</span><br><span class="line">                    final ClientTransaction transaction &#x3D; (ClientTransaction) msg.obj;</span><br><span class="line">                    mTransactionExecutor.execute(transaction);</span><br><span class="line">                    if (isSystem()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Client transactions inside system process are recycled on the client side</span><br><span class="line">                        &#x2F;&#x2F; instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">                        &#x2F;&#x2F; message is handled.</span><br><span class="line">                        transaction.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; TODO(lifecycler): Recycle locally scheduled transactions.</span><br></pre></td></tr></table></figure>

<h2 id="TransactionExecutor"><a href="#TransactionExecutor" class="headerlink" title="TransactionExecutor"></a><code>TransactionExecutor</code></h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a><code>execute()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">        final IBinder token &#x3D; transaction.getActivityToken();</span><br><span class="line">        log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line">				&#x2F;&#x2F;在这里执行onCreate()</span><br><span class="line">        executeCallbacks(transaction);</span><br><span class="line">				&#x2F;&#x2F;在这里执行onResume onStart()</span><br><span class="line">        executeLifecycleState(transaction);</span><br><span class="line">        mPendingActions.clear();</span><br><span class="line">        log(&quot;End resolving transaction&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实在之前的文章已经讲过onCreate是如何执行的了，这里就当预习了,<code>executeCallbacks</code>就不说了,最后执行<code>onCreate</code>,其实流程是差不多的</p>
<h3 id="executeLifecycleState"><a href="#executeLifecycleState" class="headerlink" title="executeLifecycleState()"></a><code>executeLifecycleState()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void executeLifecycleState(ClientTransaction transaction) &#123;</span><br><span class="line">        final ActivityLifecycleItem lifecycleItem &#x3D; transaction.getLifecycleStateRequest();</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;执行的是onStart</span><br><span class="line">        cycleToPath(r, lifecycleItem.getTargetState(), true &#x2F;* excludeLastState *&#x2F;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Execute the final transition with proper parameters.</span><br><span class="line">        &#x2F;&#x2F;onResume</span><br><span class="line">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>transaction.getLifecycleStateRequest()</code>是在前头传入的<code>ResumeActivityItem</code>，我们直接看<code>execute</code>方法，<code>cycleToPath</code>稍后在说</p>
<h2 id="ResumeActivityItem"><a href="#ResumeActivityItem" class="headerlink" title="ResumeActivityItem"></a><code>ResumeActivityItem</code></h2><h3 id="execute-1"><a href="#execute-1" class="headerlink" title="execute()"></a><code>execute()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">            PendingTransactionActions pendingActions) &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityResume&quot;);</span><br><span class="line">        client.handleResumeActivity(token, true &#x2F;* finalStateRequest *&#x2F;, mIsForward,</span><br><span class="line">                &quot;RESUME_ACTIVITY&quot;);</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ClientTransactionHandler</code>是一个抽象类，具体实现是<code>ActivityThread</code></p>
<h2 id="ActivityThread-1"><a href="#ActivityThread-1" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><p><code>handleResumeActivity</code>类似于这种方法还有很多，例如：<code>handlePauseActivity</code>,<code>handleStopActivity</code>等等。对应的Activity的生命周期.</p>
<h3 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity()"></a><code>handleResumeActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        final ActivityClientRecord r &#x3D; performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        ...</span><br><span class="line">       Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performResumeActivity"><a href="#performResumeActivity" class="headerlink" title="performResumeActivity()"></a><code>performResumeActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        final ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用的Activity中的<code>performResume</code></p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a><code>Activity</code></h2><h3 id="performResume"><a href="#performResume" class="headerlink" title="performResume()"></a><code>performResume()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final void performResume(boolean followedByPause, String reason) &#123;</span><br><span class="line">				&#x2F;&#x2F;执行onRestart生命周期</span><br><span class="line">        performRestart(true &#x2F;* start *&#x2F;, reason);</span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line">				&#x2F;&#x2F;执行onResume</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);        </span><br><span class="line">        ...</span><br><span class="line">        mFragments.dispatchResume();</span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">        onPostResume();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart"></a><code>onRestart</code></h1><h3 id="performRestart"><a href="#performRestart" class="headerlink" title="performRestart()"></a><code>performRestart()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final void performRestart(boolean start, String reason) &#123;</span><br><span class="line">			...</span><br><span class="line">			mInstrumentation.callActivityOnRestart(this);</span><br><span class="line">			...</span><br><span class="line">			if (start) &#123;</span><br><span class="line">			&#x2F;&#x2F;最后执行onStart</span><br><span class="line">                performStart(reason);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会通过<code>Instrumentation</code>执行<code>onRestart</code></p>
<p><code>performStart</code>执行<code>onStart</code>后面说</p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h2><h3 id="callActivityOnRestart"><a href="#callActivityOnRestart" class="headerlink" title="callActivityOnRestart()"></a><code>callActivityOnRestart()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.onRestart();</span><br></pre></td></tr></table></figure>

<p>就这一行代码但是已经足够了</p>
<h2 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a><code>Activity</code></h2><h3 id="onRestart-1"><a href="#onRestart-1" class="headerlink" title="onRestart"></a><code>onRestart</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void onRestart() &#123;</span><br><span class="line">        mCalled &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此onRestart便完成了。</p>
<h1 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a><code>onResume</code></h1><p>回到<code>performResume()</code>方法执行<code>mInstrumentation.callActivityOnResume(this);</code></p>
<p>道理是一样的使用<code>Instrumentation</code>执行<code>onResume</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnResume(Activity activity) &#123;</span><br><span class="line">        activity.mResumed &#x3D; true;</span><br><span class="line">        activity.onResume();</span><br><span class="line">        </span><br><span class="line">        if (mActivityMonitors !&#x3D; null) &#123;</span><br><span class="line">            synchronized (mSync) &#123;</span><br><span class="line">                final int N &#x3D; mActivityMonitors.size();</span><br><span class="line">                for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                    final ActivityMonitor am &#x3D; mActivityMonitors.get(i);</span><br><span class="line">                    am.match(activity, activity, activity.getIntent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void onResume() &#123;</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onResume &quot; + this);</span><br><span class="line">        getApplication().dispatchActivityResumed(this);</span><br><span class="line">        mActivityTransitionState.onResume(this, isTopOfTask());</span><br><span class="line">        if (mAutoFillResetNeeded) &#123;</span><br><span class="line">            if (!mAutoFillIgnoreFirstResumePause) &#123;</span><br><span class="line">                View focus &#x3D; getCurrentFocus();</span><br><span class="line">                if (focus !&#x3D; null &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO: in Activity killed&#x2F;recreated case, i.e. SessionLifecycleTest#</span><br><span class="line">                    &#x2F;&#x2F; testDatasetVisibleWhileAutofilledAppIsLifecycled: the View&#39;s initial</span><br><span class="line">                    &#x2F;&#x2F; window visibility after recreation is INVISIBLE in onResume() and next frame</span><br><span class="line">                    &#x2F;&#x2F; ViewRootImpl.performTraversals() changes window visibility to VISIBLE.</span><br><span class="line">                    &#x2F;&#x2F; So we cannot call View.notifyEnterOrExited() which will do nothing</span><br><span class="line">                    &#x2F;&#x2F; when View.isVisibleToUser() is false.</span><br><span class="line">                    getAutofillManager().notifyViewEntered(focus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mCalled &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在看看如何执行onStart方法的,我们在前面分析时说到<code>cycleToPath</code>最终执行onStart，来看看如何实现</p>
<h2 id="TransactionExecutor-1"><a href="#TransactionExecutor-1" class="headerlink" title="TransactionExecutor"></a><code>TransactionExecutor</code></h2><h3 id="cycleToPath"><a href="#cycleToPath" class="headerlink" title="cycleToPath()"></a><code>cycleToPath()</code></h3><p>这个方法是根据state计算生命周期的路径，简单说就是，当前处于 <code>onCreate()</code> 状态，<code>setLifecycleState()</code> 设置的 <strong>final state</strong> 是 <strong>onResume()</strong> ，就需要执行 onCreate 到 onResume 之间的状态，即 <code>onStart()</code> 。下面简单看下源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void cycleToPath(ActivityClientRecord r, int finish,</span><br><span class="line">            boolean excludeLastState) &#123;</span><br><span class="line">        final int start &#x3D; r.getLifecycleState();</span><br><span class="line">        log(&quot;Cycle from: &quot; + start + &quot; to: &quot; + finish + &quot; excludeLastState:&quot; + excludeLastState);</span><br><span class="line">        final IntArray path &#x3D; mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">        performLifecycleSequence(r, path);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="performLifecycleSequence"><a href="#performLifecycleSequence" class="headerlink" title="performLifecycleSequence()"></a><code>performLifecycleSequence()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void performLifecycleSequence(ActivityClientRecord r, IntArray path) &#123;</span><br><span class="line">       final int size &#x3D; path.size();</span><br><span class="line">       for (int i &#x3D; 0, state; i &lt; size; i++) &#123;</span><br><span class="line">           state &#x3D; path.get(i);</span><br><span class="line">           log(&quot;Transitioning to state: &quot; + state);</span><br><span class="line">           switch (state) &#123;</span><br><span class="line">               case ON_CREATE:</span><br><span class="line">                   mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                           null &#x2F;* customIntent *&#x2F;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_START:</span><br><span class="line">                   mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_RESUME:</span><br><span class="line">                   mTransactionHandler.handleResumeActivity(r.token, false &#x2F;* finalStateRequest *&#x2F;,</span><br><span class="line">                           r.isForward, &quot;LIFECYCLER_RESUME_ACTIVITY&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_PAUSE:</span><br><span class="line">                   mTransactionHandler.handlePauseActivity(r.token, false &#x2F;* finished *&#x2F;,</span><br><span class="line">                           false &#x2F;* userLeaving *&#x2F;, 0 &#x2F;* configChanges *&#x2F;, mPendingActions,</span><br><span class="line">                           &quot;LIFECYCLER_PAUSE_ACTIVITY&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_STOP:</span><br><span class="line">                   mTransactionHandler.handleStopActivity(r.token, false &#x2F;* show *&#x2F;,</span><br><span class="line">                           0 &#x2F;* configChanges *&#x2F;, mPendingActions, false &#x2F;* finalStateRequest *&#x2F;,</span><br><span class="line">                           &quot;LIFECYCLER_STOP_ACTIVITY&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case ON_DESTROY:</span><br><span class="line">                   mTransactionHandler.handleDestroyActivity(r.token, false &#x2F;* finishing *&#x2F;,</span><br><span class="line">                           0 &#x2F;* configChanges *&#x2F;, false &#x2F;* getNonConfigInstance *&#x2F;,</span><br><span class="line">                           &quot;performLifecycleSequence. cycling to:&quot; + path.get(size - 1));</span><br><span class="line">                   break;</span><br><span class="line">               case ON_RESTART:</span><br><span class="line">                   mTransactionHandler.performRestartActivity(r.token, false &#x2F;* start *&#x2F;);</span><br><span class="line">                   break;</span><br><span class="line">               default:</span><br><span class="line">                   throw new IllegalArgumentException(&quot;Unexpected lifecycle state: &quot; + state);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>getLifecyclePath()</code> 方法就是根据 <code>start</code> 和 <code>finish</code> 计算出中间的生命周期路径。这里计算出来就是 <code>ON_START</code> 。</p>
<p>找到 <code>ON_START</code> 分支，调用了 <code>ActivityThread.handleStartActivity()</code> 方法，又是一样的套路了，这里就不再赘述了。</p>
<p>依次类推，<code>ActivityThread</code> 中应该有如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleLaunchActivity()</span><br><span class="line">handleStartActivity()</span><br><span class="line">handleResumeActivity()</span><br><span class="line">handlePauseActivity()</span><br><span class="line">handleStopActivity()</span><br><span class="line">handleDestroyActivity()</span><br></pre></td></tr></table></figure>

<h1 id="onPause延续startActivity流程"><a href="#onPause延续startActivity流程" class="headerlink" title="onPause延续startActivity流程"></a>onPause延续startActivity流程</h1><p>在<code>startActivity</code>启动流程中会调用<code>ActivityStarter#startActivity()</code>然后调用<code>startActivityUnchecked</code></p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a><code>ActivityStarter</code></h2><h3 id="startActivityUnchecked"><a href="#startActivityUnchecked" class="headerlink" title="startActivityUnchecked()"></a><code>startActivityUnchecked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            ActivityRecord[] outActivity) &#123;</span><br><span class="line"></span><br><span class="line">        setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">                voiceInteractor);</span><br><span class="line">				&#x2F;&#x2F; 处理activity的启动模式.绑定activity的启动模式</span><br><span class="line">        computeLaunchingTaskFlags();</span><br><span class="line">        computeSourceStack();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;给相应activity的intent设置flag</span><br><span class="line">        mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line">            &#x2F;&#x2F;根据activity的启动模式设置相应的栈</span><br><span class="line">            if (mStartActivity.getTask() &#x3D;&#x3D; null &amp;&amp; !clearTopAndResetStandardLaunchMode) &#123;</span><br><span class="line">                mStartActivity.setTask(reusedActivity.getTask());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (reusedActivity.getTask().intent &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; This task was started because of movement of the activity based on affinity...</span><br><span class="line">                &#x2F;&#x2F; Now that we are actually launching it, we can assign the base intent.</span><br><span class="line">                &#x2F;&#x2F;设置ActivityRecord,之后会传入到app_service进行activity的周期控制</span><br><span class="line">                reusedActivity.getTask().setIntent(mStartActivity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">            &#x2F;&#x2F;当activity设置为FLAG_ACTIVITY_CLEAR_TOP是的逻辑,即判断栈顶是否有目标activty,没有就重新创建,并且加入栈顶</span><br><span class="line">            if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) !&#x3D; 0</span><br><span class="line">                    || isDocumentLaunchesIntoExisting(mLaunchFlags)</span><br><span class="line">                    || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">                final TaskRecord task &#x3D; reusedActivity.getTask();</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">                final ActivityRecord top &#x3D; task.performClearTaskForReuseLocked(mStartActivity,</span><br><span class="line">                        mLaunchFlags);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; The above code can remove &#123;@code reusedActivity&#125; from the task, leading to the</span><br><span class="line">             </span><br><span class="line">              ......</span><br><span class="line">            &#x2F;&#x2F;设置目标栈与现有的activity匹配.根据需要清除栈</span><br><span class="line">            reusedActivity &#x3D; setTargetStackAndMoveToFrontIfNeeded(reusedActivity);</span><br><span class="line"></span><br><span class="line">            .......</span><br><span class="line">        &#x2F;&#x2F;根据activity的启动模式来判断是直接插入已存在栈顶还是重新开始插入;</span><br><span class="line">        mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,</span><br><span class="line">                mOptions);</span><br><span class="line">        if (mDoResume) &#123;   &#x2F;&#x2F; mDoResume &#x3D; true</span><br><span class="line">            final ActivityRecord topTaskActivity &#x3D;</span><br><span class="line">                    mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">            if (!mTargetStack.isFocusable()</span><br><span class="line">                    || (topTaskActivity !&#x3D; null &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                    &amp;&amp; mStartActivity !&#x3D; topTaskActivity)) &#123;</span><br><span class="line">                </span><br><span class="line">                mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">              </span><br><span class="line">                mService.mWindowManager.executeAppTransition();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">             </span><br><span class="line">                if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                    mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;注释8</span><br><span class="line">                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                        mOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (mStartActivity !&#x3D; null) &#123;</span><br><span class="line">            mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        return START_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStackSupervisor-1"><a href="#ActivityStackSupervisor-1" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><h3 id="resumeFocusedStackTopActivityLocked"><a href="#resumeFocusedStackTopActivityLocked" class="headerlink" title="resumeFocusedStackTopActivityLocked()"></a><code>resumeFocusedStackTopActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (targetStack !&#x3D; null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line">				...</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>判断targetStack不为空 且isFocusedStack(targetStack) == true targetStack 就是activity的任务栈 用于管理即将启动的activity的任务栈,进而调用:<code>targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</code></p>
<h2 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a><code>ActivityStack</code></h2><h3 id="targetStack-resumeTopActivityUncheckedLocked"><a href="#targetStack-resumeTopActivityUncheckedLocked" class="headerlink" title="targetStack.resumeTopActivityUncheckedLocked()"></a><code>targetStack.resumeTopActivityUncheckedLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">       	...</span><br><span class="line">           result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">				...</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="resumeTopActivityInnerLocked"><a href="#resumeTopActivityInnerLocked" class="headerlink" title="resumeTopActivityInnerLocked()"></a><code>resumeTopActivityInnerLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理下一个 activity?</span><br><span class="line">        final ActivityRecord next &#x3D; topRunningActivityLocked(true &#x2F;* focusableOnly *&#x2F;);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">        boolean pausing &#x3D; mStackSupervisor.pauseBackStacks(userLeaving, next, false);</span><br><span class="line">        &#x2F;&#x2F; 注释1</span><br><span class="line">        if (mResumedActivity !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">            pausing |&#x3D; startPausingLocked(userLeaving, false, next, false);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">            if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Skip resume: need to start pausing&quot;);</span><br><span class="line">            </span><br><span class="line">            if (next.app !&#x3D; null &amp;&amp; next.app.thread !&#x3D; null) &#123;</span><br><span class="line">                mService.updateLruProcessLocked(next.app, true, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            if (lastResumed !&#x3D; null) &#123;</span><br><span class="line">                lastResumed.setWillCloseOrEnterPip(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (mResumedActivity &#x3D;&#x3D; next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">                &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">            executeAppTransition(options);</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Top activity resumed (dontWaitForPause) &quot; + next);</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">                    .......</span><br><span class="line">                    &#x2F;&#x2F;注释2</span><br><span class="line">                    mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br><span class="line">                    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       ......</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注释1:从这里的源码可以看到当启动新的activity的时候,上一个activity走完onPause,之后才可以走新activity:onCreate —&gt;onStart—&gt;onResume…</li>
<li>注释2:回调过程重新交给ActivityStackSupervisor的startSpecificActivityLocked;继续走startActivity的流程，也可以说是onCreate()流程。</li>
</ul>
<h1 id="开始onPause"><a href="#开始onPause" class="headerlink" title="开始onPause"></a>开始onPause</h1><h3 id="startPausingLocked"><a href="#startPausingLocked" class="headerlink" title="startPausingLocked()"></a><code>startPausingLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,</span><br><span class="line">            ActivityRecord resuming, boolean pauseImmediately) &#123;</span><br><span class="line">        if (mPausingActivity !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        ...</span><br><span class="line">        if (prev.app !&#x3D; null &amp;&amp; prev.app.thread !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">            try &#123;</span><br><span class="line">                EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class="line">                        prev.shortComponentName, &quot;userLeaving&#x3D;&quot; + userLeaving);</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">								&#x2F;&#x2F;还是原来的配方，还是原来的味道</span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class="line">                        PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                                prev.configChangeFlags, pauseImmediately));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore exception, if process died other code will cleanup.</span><br><span class="line">                Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">                mPausingActivity &#x3D; null;</span><br><span class="line">                mLastPausedActivity &#x3D; null;</span><br><span class="line">                mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mPausingActivity &#x3D; null;</span><br><span class="line">            mLastPausedActivity &#x3D; null;</span><br><span class="line">            mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,
                        PauseActivityItem.obtain(prev.finishing, userLeaving,
                                prev.configChangeFlags, pauseImmediately));</code></p>
<p>多么的相似直接<code>scheduleTransaction</code>,就是复制上面的流程,最终执行：</p>
<h2 id="ActivityThread-2"><a href="#ActivityThread-2" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><h3 id="handleStopActivity"><a href="#handleStopActivity" class="headerlink" title="handleStopActivity()"></a><code>handleStopActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">    public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving,</span><br><span class="line">            int configChanges, PendingTransactionActions pendingActions, String reason) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a><code>onStop</code></h1><p>onStop执行是在<code>onResume</code>执行方法中，具体在<code>ActivityThread</code>的<code>handleResumeActivity</code></p>
<h2 id="ActivityThread-3"><a href="#ActivityThread-3" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><h3 id="handleResumeActivity-1"><a href="#handleResumeActivity-1" class="headerlink" title="handleResumeActivity()"></a><code>handleResumeActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">            String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        final ActivityClientRecord r &#x3D; performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        ...</span><br><span class="line">       Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下Idler都做了什么。当MessageQueue空闲的时候就会回调Idler.queueIdle方法，经过层层调用跳转到ActivityStack.stopActivityLocked方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           		...</span><br><span class="line">              am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">              ...</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>am最终执行的是AMS中同名方法</p>
<h2 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a><code>AMS</code></h2><h3 id="activityIdle"><a href="#activityIdle" class="headerlink" title="activityIdle()"></a><code>activityIdle()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                ActivityRecord r &#x3D;</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, false &#x2F;* fromTimeout *&#x2F;,</span><br><span class="line">                                false &#x2F;* processPausingActivities *&#x2F;, config);</span><br><span class="line">                if (stopProfiling) &#123;</span><br><span class="line">                    if ((mProfileProc &#x3D;&#x3D; r.app) &amp;&amp; mProfilerInfo !&#x3D; null) &#123;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStackSupervisor-2"><a href="#ActivityStackSupervisor-2" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><h3 id="activityIdleInternalLocked"><a href="#activityIdleInternalLocked" class="headerlink" title="activityIdleInternalLocked()"></a><code>activityIdleInternalLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,</span><br><span class="line">            boolean processPausingActivities, Configuration config) &#123;</span><br><span class="line">            ...</span><br><span class="line">            for (int i &#x3D; 0; i &lt; NS; i++) &#123;</span><br><span class="line">            r &#x3D; stops.get(i);</span><br><span class="line">            final ActivityStack stack &#x3D; r.getStack();</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                if (r.finishing) &#123;</span><br><span class="line">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,</span><br><span class="line">                            &quot;activityIdleInternalLocked&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stack.stopActivityLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStack-1"><a href="#ActivityStack-1" class="headerlink" title="ActivityStack"></a><code>ActivityStack</code></h2><h3 id="stopActivityLocked"><a href="#stopActivityLocked" class="headerlink" title="stopActivityLocked()"></a><code>stopActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void stopActivityLocked(ActivityRecord r) &#123;</span><br><span class="line">				mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,</span><br><span class="line">                        StopActivityItem.obtain(r.visible, r.configChangeFlags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的逻辑,最终执行</p>
<h2 id="ActivityThread-4"><a href="#ActivityThread-4" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><h3 id="handleStopActivity-1"><a href="#handleStopActivity-1" class="headerlink" title="handleStopActivity()"></a><code>handleStopActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void handleStopActivity(IBinder token, boolean show, int configChanges,</span><br><span class="line">           PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) &#123;</span><br><span class="line">       final ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">       r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line"></span><br><span class="line">       final StopInfo stopInfo &#x3D; new StopInfo();</span><br><span class="line">       performStopActivityInner(r, stopInfo, show, true &#x2F;* saveState *&#x2F;, finalStateRequest,</span><br><span class="line">               reason);</span><br><span class="line"></span><br><span class="line">       if (localLOGV) Slog.v(</span><br><span class="line">           TAG, &quot;Finishing stop of &quot; + r + &quot;: show&#x3D;&quot; + show</span><br><span class="line">           + &quot; win&#x3D;&quot; + r.window);</span><br><span class="line"></span><br><span class="line">       updateVisibility(r, show);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">       if (!r.isPreHoneycomb()) &#123;</span><br><span class="line">           QueuedWork.waitToFinish();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       stopInfo.setActivity(r);</span><br><span class="line">       stopInfo.setState(r.state);</span><br><span class="line">       stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">       pendingActions.setStopInfo(stopInfo);</span><br><span class="line">       mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-ActivityManagerService/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-ActivityManagerService/" itemprop="url">Android系统服务-ActivityManagerService</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-02T14:03:56+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统服务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-ActivityManagerService/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/02/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-ActivityManagerService/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ActivityManagerService（以后简称AMS）是Framework层的核心服务之一，是Binder的子类,主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。</p>
<p><img src="https://doc.yonyoucloud.com/doc/wiki/project/deep-android-v2/images/chapter6/image001.png" alt="image"></p>
<ul>
<li>AMS继承自ActivityManagerNative(AMN)，并实现了Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口</li>
</ul>
<ol start="2">
<li>AMN继承Java的Binder类，同时实现了IActivityManager接口，即AMN将作为Binder通信的服务端为用户提供支持</li>
<li>在ActivityManagerNative类中定义了内部类ActivityManagerProxy，该类同样实现了IActivityManager接口，将作为客户端使用的服务端代理</li>
<li>其它进程将使用ActivityManager来使用AMS的服务。ActivityManager通过AMN提供的getDefault接口得到ActivityManagerProxy，然后再以Binder通信的方式调用AMS的接口</li>
</ol>
<ul>
<li>从这里我们可以看出应用进程通过binder的方式和systemserver进程进行通信</li>
</ul>
<p><strong>AMS启动整体流程图</strong></p>
<p><img src="https://img-blog.csdn.net/2018021317481510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF95dA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h1 id="AMS启动过程"><a href="#AMS启动过程" class="headerlink" title="AMS启动过程"></a>AMS启动过程</h1><h2 id="SystemServer-java"><a href="#SystemServer-java" class="headerlink" title="SystemServer.java"></a><code>SystemServer.java</code></h2><p><code>startBootstrapServices()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;启动AMS服务【见小节2.2】</span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置AMS的系统服务管理器</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    &#x2F;&#x2F;设置AMS的APP安装器</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    &#x2F;&#x2F;初始化AMS相关的PMS</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置SystemServer【见小节2.3】</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动AMS服务"><a href="#启动AMS服务" class="headerlink" title="启动AMS服务"></a>启动AMS服务</h1><p>SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要：</p>
<ol>
<li>创建ActivityManagerService.Lifecycle对象；</li>
<li>调用Lifecycle.onStart()方法。</li>
</ol>
<h2 id="ActivityManagerService-java"><a href="#ActivityManagerService-java" class="headerlink" title="ActivityManagerService.java"></a><code>ActivityManagerService.java</code></h2><h3 id="AMS-Lifecycle"><a href="#AMS-Lifecycle" class="headerlink" title="AMS.Lifecycle"></a><code>AMS.Lifecycle</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static final class Lifecycle extends SystemService &#123;</span><br><span class="line">    private final ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">    public Lifecycle(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        &#x2F;&#x2F;创建ActivityManagerService【见小节2.1.2】</span><br><span class="line">        mService &#x3D; new ActivityManagerService(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        mService.start();  &#x2F;&#x2F;【见小节2.1.3】</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ActivityManagerService getService() &#123;</span><br><span class="line">        return mService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程：创建AMS内部类的Lifecycle，已经创建AMS对象，并调用AMS.start();</p>
<h2 id="AMS创建"><a href="#AMS创建" class="headerlink" title="AMS创建"></a>AMS创建</h2><h3 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService()"></a><code>ActivityManagerService()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">    mContext &#x3D; systemContext;</span><br><span class="line">    mFactoryTest &#x3D; FactoryTest.getMode();&#x2F;&#x2F;默认为FACTORY_TEST_OFF</span><br><span class="line">    mSystemThread &#x3D; ActivityThread.currentActivityThread();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建名为&quot;ActivityManager&quot;的前台线程，并获取mHandler</span><br><span class="line">    mHandlerThread &#x3D; new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">    mHandler &#x3D; new MainHandler(mHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过UiThread类，创建名为&quot;android.ui&quot;的线程</span><br><span class="line">    mUiHandler &#x3D; new UiHandler();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前台广播接收器，在运行超过10s将放弃执行</span><br><span class="line">    mFgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">            &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</span><br><span class="line">    &#x2F;&#x2F;后台广播接收器，在运行超过60s将放弃执行</span><br><span class="line">    mBgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">            &quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</span><br><span class="line">    mBroadcastQueues[0] &#x3D; mFgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[1] &#x3D; mBgBroadcastQueue;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建ActiveServices，其中非低内存手机mMaxStartingBackground为8</span><br><span class="line">    mServices &#x3D; new ActiveServices(this);</span><br><span class="line">    mProviderMap &#x3D; new ProviderMap(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建目录&#x2F;data&#x2F;system</span><br><span class="line">    File dataDir &#x3D; Environment.getDataDirectory();</span><br><span class="line">    File systemDir &#x3D; new File(dataDir, &quot;system&quot;);</span><br><span class="line">    systemDir.mkdirs();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建服务BatteryStatsService</span><br><span class="line">    mBatteryStatsService &#x3D; new BatteryStatsService(systemDir, mHandler);</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建进程统计服务，信息保存在目录&#x2F;data&#x2F;system&#x2F;procstats，</span><br><span class="line">    mProcessStats &#x3D; new ProcessStatsService(this, new File(systemDir, &quot;procstats&quot;));</span><br><span class="line"></span><br><span class="line">    mAppOpsService &#x3D; new AppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler);</span><br><span class="line">    mGrantFile &#x3D; new AtomicFile(new File(systemDir, &quot;urigrants.xml&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; User 0是第一个，也是唯一的一个开机过程中运行的用户</span><br><span class="line">    mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true));</span><br><span class="line">    mUserLru.add(UserHandle.USER_OWNER);</span><br><span class="line">    updateStartedUserArrayLocked();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;CPU使用情况的追踪器执行初始化</span><br><span class="line">    mProcessCpuTracker.init();</span><br><span class="line">    ...</span><br><span class="line">    mRecentTasks &#x3D; new RecentTasks(this);</span><br><span class="line">    &#x2F;&#x2F; 创建ActivityStackSupervisor对象</span><br><span class="line">    mStackSupervisor &#x3D; new ActivityStackSupervisor(this, mRecentTasks);</span><br><span class="line">    mTaskPersister &#x3D; new TaskPersister(systemDir, mStackSupervisor, mRecentTasks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建名为&quot;CpuTracker&quot;的线程</span><br><span class="line">    mProcessCpuThread &#x3D; new Thread(&quot;CpuTracker&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              synchronized(this) &#123;</span><br><span class="line">                final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">                long nextCpuDelay &#x3D; (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">                long nextWriteDelay &#x3D; (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">                if (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                    nextCpuDelay &#x3D; nextWriteDelay;</span><br><span class="line">                &#125;</span><br><span class="line">                if (nextCpuDelay &gt; 0) &#123;</span><br><span class="line">                    mProcessCpuMutexFree.set(true);</span><br><span class="line">                    this.wait(nextCpuDelay);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              updateCpuStatsNow(); &#x2F;&#x2F;更新CPU状态</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程共创建了3个线程，分别为”ActivityManager”，”android.ui”，”CpuTracker”。</p>
<h3 id="AMS-start"><a href="#AMS-start" class="headerlink" title="AMS.start()"></a><code>AMS.start()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void start() &#123;</span><br><span class="line">    Process.removeAllProcessGroups(); &#x2F;&#x2F;移除所有的进程组</span><br><span class="line">    mProcessCpuThread.start(); &#x2F;&#x2F;启动CpuTracker线程</span><br><span class="line"></span><br><span class="line">    mBatteryStatsService.publish(mContext); &#x2F;&#x2F;启动电池统计服务</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    &#x2F;&#x2F;创建LocalService，并添加到LocalServices</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setSystemProcess"><a href="#setSystemProcess" class="headerlink" title="setSystemProcess()"></a><code>setSystemProcess()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">        if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">        ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line">        ApplicationInfo info &#x3D; mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;【见小节2.3.1】</span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建ProcessRecord对象</span><br><span class="line">            ProcessRecord app &#x3D; newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">            app.persistent &#x3D; true; &#x2F;&#x2F;设置为persistent进程</span><br><span class="line">            app.pid &#x3D; MY_PID;</span><br><span class="line">            app.maxAdj &#x3D; ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, false, null);&#x2F;&#x2F;维护进程lru</span><br><span class="line">            updateOomAdjLocked(); &#x2F;&#x2F;更新adj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要工作是注册各种服务。</p>
<h2 id="ActivityThread-java"><a href="#ActivityThread-java" class="headerlink" title="ActivityThread.java"></a><code>ActivityThread.java</code></h2><h3 id="installSystemApplicationInfo"><a href="#installSystemApplicationInfo" class="headerlink" title="installSystemApplicationInfo()"></a><code>installSystemApplicationInfo()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        getSystemContext().installSystemApplicationInfo(info, classLoader);</span><br><span class="line">        mProfiler &#x3D; new Profiler();    &#x2F;&#x2F;创建用于性能统计的Profiler对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用ContextImpl的nstallSystemApplicationInfo()方法，最终调用LoadedApk的installSystemApplicationInfo，加载名为“android”的package</p>
<h2 id="LoadedApk-java"><a href="#LoadedApk-java" class="headerlink" title="LoadedApk.java"></a><code>LoadedApk.java</code></h2><h3 id="installSystemApplicationInfo-1"><a href="#installSystemApplicationInfo-1" class="headerlink" title="installSystemApplicationInfo()"></a><code>installSystemApplicationInfo()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123;</span><br><span class="line">    assert info.packageName.equals(&quot;android&quot;);</span><br><span class="line">    mApplicationInfo &#x3D; info; &#x2F;&#x2F;将包名为&quot;android&quot;的应用信息保存到mApplicationInfo</span><br><span class="line">    mClassLoader &#x3D; classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SystemServer-java-1"><a href="#SystemServer-java-1" class="headerlink" title="SystemServer.java"></a><code>SystemServer.java</code></h2><h3 id="startOtherServices"><a href="#startOtherServices" class="headerlink" title="startOtherServices()"></a><code>startOtherServices()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;安装系统Provider 【见小节2.4.1】</span><br><span class="line">  mActivityManagerService.installSystemProviders();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;phase480 &amp;&amp; 500</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;【见小节3.1】</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F;phase550</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         &#x2F;&#x2F;phase600</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AMS-java"><a href="#AMS-java" class="headerlink" title="AMS.java"></a><code>AMS.java</code></h2><h3 id="installSystemProviders"><a href="#installSystemProviders" class="headerlink" title="installSystemProviders()"></a><code>installSystemProviders()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void installSystemProviders() &#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        ProcessRecord app &#x3D; mProcessNames.get(&quot;system&quot;, Process.SYSTEM_UID);</span><br><span class="line">        providers &#x3D; generateApplicationProvidersLocked(app);</span><br><span class="line">        if (providers !&#x3D; null) &#123;</span><br><span class="line">            for (int i&#x3D;providers.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">                ProviderInfo pi &#x3D; (ProviderInfo)providers.get(i);</span><br><span class="line">                &#x2F;&#x2F;移除非系统的provider</span><br><span class="line">                if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (providers !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;安装所有的系统provider</span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建核心Settings Observer，用于监控Settings的改变。</span><br><span class="line">    mCoreSettingsObserver &#x3D; new CoreSettingsObserver(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="systemReady"><a href="#systemReady" class="headerlink" title="systemReady()"></a><code>systemReady()</code></h3><p>AMS.systemReady()方法的参数为Runable类型的goingCallback， 该方法执行简单划分以下几部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    before goingCallback; &#x2F;&#x2F; 见小节[3.1]</span><br><span class="line">    goingCallback.run(); &#x2F;&#x2F; 见小节[3.2]</span><br><span class="line">    after goingCallback; &#x2F;&#x2F; 见小节[3.3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="before-goingCallback"><a href="#before-goingCallback" class="headerlink" title="before goingCallback"></a><code>before goingCallback</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this) &#123;</span><br><span class="line">    if (mSystemReady) &#123; &#x2F;&#x2F;首次为flase，则不进入该分支</span><br><span class="line">        if (goingCallback !&#x3D; null) &#123;</span><br><span class="line">                goingCallback.run();</span><br><span class="line">            &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRecentTasks.clear();</span><br><span class="line">    &#x2F;&#x2F;恢复最近任务栏的task</span><br><span class="line">    mRecentTasks.addAll(mTaskPersister.restoreTasksLocked());</span><br><span class="line">    mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">    mTaskPersister.startPersisting();</span><br><span class="line"></span><br><span class="line">    if (!mDidUpdate) &#123;</span><br><span class="line">        if (mWaitingUpdate) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final ArrayList&lt;ComponentName&gt; doneReceivers &#x3D; new ArrayList&lt;ComponentName&gt;();</span><br><span class="line">        &#x2F;&#x2F;处于升级过程【见小节3.1.1】</span><br><span class="line">        mWaitingUpdate &#x3D; deliverPreBootCompleted(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                    mDidUpdate &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                showBootMessage(mContext.getText(</span><br><span class="line">                        R.string.android_upgrading_complete),</span><br><span class="line">                        false);</span><br><span class="line">                writeLastDonePreBootReceivers(doneReceivers);</span><br><span class="line">                systemReady(goingCallback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, doneReceivers, UserHandle.USER_OWNER);</span><br><span class="line"></span><br><span class="line">        if (mWaitingUpdate) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mDidUpdate &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAppOpsService.systemReady();</span><br><span class="line">    mSystemReady &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;ProcessRecord&gt; procsToKill &#x3D; null;</span><br><span class="line">synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">    for (int i&#x3D;mPidsSelfLocked.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">        ProcessRecord proc &#x3D; mPidsSelfLocked.valueAt(i);</span><br><span class="line">        &#x2F;&#x2F;非persistent进程,加入procsToKill</span><br><span class="line">        if (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">            if (procsToKill &#x3D;&#x3D; null) &#123;</span><br><span class="line">                procsToKill &#x3D; new ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            procsToKill.add(proc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized(this) &#123;</span><br><span class="line">    if (procsToKill !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;杀掉procsToKill中的进程, 杀掉进程且不允许重启</span><br><span class="line">        for (int i&#x3D;procsToKill.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">            ProcessRecord proc &#x3D; procsToKill.get(i);</span><br><span class="line">            removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mProcessesReady &#x3D; true; &#x2F;&#x2F;process处于ready状态</span><br><span class="line">&#125;</span><br><span class="line">Slog.i(TAG, &quot;System now ready&quot;);</span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,</span><br><span class="line">     SystemClock.uptimeMillis());</span><br></pre></td></tr></table></figure>

<p>该阶段的主要功能：</p>
<ul>
<li>向PRE_BOOT_COMPLETED的接收者发送广播；</li>
<li>杀掉procsToKill中的进程, 杀掉进程且不允许重启；</li>
<li>此时，系统和进程都处于ready状态；</li>
</ul>
<h3 id="deliverPreBootCompleted"><a href="#deliverPreBootCompleted" class="headerlink" title="deliverPreBootCompleted()"></a><code>deliverPreBootCompleted()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private boolean deliverPreBootCompleted(final Runnable onFinishCallback, ArrayList&lt;ComponentName&gt; doneReceivers, int userId) &#123;</span><br><span class="line">    Intent intent &#x3D; new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);</span><br><span class="line">    List&lt;ResolveInfo&gt; ris &#x3D; AppGlobals.getPackageManager().queryIntentReceivers(</span><br><span class="line">                intent, null, 0, userId);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对于FLAG_SYSTEM&#x3D;false的app直接过滤掉</span><br><span class="line">    for (int i&#x3D;ris.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">        if ((ris.get(i).activityInfo.applicationInfo.flags</span><br><span class="line">                &amp;ApplicationInfo.FLAG_SYSTEM) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            ris.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);</span><br><span class="line"></span><br><span class="line">    if (userId &#x3D;&#x3D; UserHandle.USER_OWNER) &#123;</span><br><span class="line">        ArrayList&lt;ComponentName&gt; lastDoneReceivers &#x3D; readLastDonePreBootReceivers();</span><br><span class="line">        for (int i&#x3D;0; i&lt;ris.size(); i++) &#123;</span><br><span class="line">            ActivityInfo ai &#x3D; ris.get(i).activityInfo;</span><br><span class="line">            ComponentName comp &#x3D; new ComponentName(ai.packageName, ai.name);</span><br><span class="line">            if (lastDoneReceivers.contains(comp)) &#123;</span><br><span class="line">                ris.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                doneReceivers.add(comp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    PreBootContinuation cont &#x3D; new PreBootContinuation(intent, onFinishCallback,</span><br><span class="line">            doneReceivers, ris, users);  &#x2F;&#x2F;【见小节3.1.2】</span><br><span class="line">    cont.go(); &#x2F;&#x2F;【见小节3.1.3】</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreBootContinuation"><a href="#PreBootContinuation" class="headerlink" title="PreBootContinuation"></a><code>PreBootContinuation</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final class PreBootContinuation extends IIntentReceiver.Stub &#123;</span><br><span class="line"></span><br><span class="line">    PreBootContinuation(Intent _intent, Runnable _onFinishCallback,</span><br><span class="line">            ArrayList&lt;ComponentName&gt; _doneReceivers, List&lt;ResolveInfo&gt; _ris, int[] _users) &#123;</span><br><span class="line">        intent &#x3D; _intent;</span><br><span class="line">        onFinishCallback &#x3D; _onFinishCallback;</span><br><span class="line">        doneReceivers &#x3D; _doneReceivers;</span><br><span class="line">        ris &#x3D; _ris;</span><br><span class="line">        users &#x3D; _users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreBootContinuation-go"><a href="#PreBootContinuation-go" class="headerlink" title="PreBootContinuation.go"></a>PreBootContinuation.go</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRi != curRi) &#123;</span><br><span class="line">        ActivityInfo ai = ris.get(curRi).activityInfo;</span><br><span class="line">        ComponentName comp = <span class="keyword">new</span> ComponentName(ai.packageName, ai.name);</span><br><span class="line">        intent.setComponent(comp);</span><br><span class="line">        doneReceivers.add(comp);</span><br><span class="line">        lastRi = curRi;</span><br><span class="line">        CharSequence label = ai.loadLabel(mContext.getPackageManager());</span><br><span class="line">        showBootMessage(mContext.getString(R.string.android_preparing_apk, label), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送广播</span></span><br><span class="line">    broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent, <span class="keyword">null</span>, <span class="keyword">this</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, users[curUser]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="goingCallback-run"><a href="#goingCallback-run" class="headerlink" title="goingCallback.run()"></a>goingCallback.run()</h3><p>此处的goingCallback,便是在startOtherServices()过程中传递进来的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      &#x2F;&#x2F;phase550</span><br><span class="line">      mSystemServiceManager.startBootPhase(</span><br><span class="line">              SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line"></span><br><span class="line">      mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">      &#x2F;&#x2F;启动WebView</span><br><span class="line">      WebViewFactory.prepareWebViewInSystemServer();</span><br><span class="line">      &#x2F;&#x2F;启动系统UI【见小节3.2.1】</span><br><span class="line">      startSystemUi(context);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 执行一系列服务的systemReady方法</span><br><span class="line">      networkScoreF.systemReady();</span><br><span class="line">      networkManagementF.systemReady();</span><br><span class="line">      networkStatsF.systemReady();</span><br><span class="line">      networkPolicyF.systemReady();</span><br><span class="line">      connectivityF.systemReady();</span><br><span class="line">      audioServiceF.systemReady();</span><br><span class="line">      Watchdog.getInstance().start(); &#x2F;&#x2F;Watchdog开始工作</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;phase600</span><br><span class="line">      mSystemServiceManager.startBootPhase(</span><br><span class="line">              SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;执行一系列服务的systemRunning方法</span><br><span class="line">      wallpaper.systemRunning();</span><br><span class="line">      inputMethodManager.systemRunning(statusBarF);</span><br><span class="line">      location.systemRunning();</span><br><span class="line">      countryDetector.systemRunning();</span><br><span class="line">      networkTimeUpdater.systemRunning();</span><br><span class="line">      commonTimeMgmtService.systemRunning();</span><br><span class="line">      textServiceManagerService.systemRunning();</span><br><span class="line">      assetAtlasService.systemRunning();</span><br><span class="line">      inputManager.systemRunning();</span><br><span class="line">      telephonyRegistry.systemRunning();</span><br><span class="line">      mediaRouter.systemRunning();</span><br><span class="line">      mmsService.systemRunning();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程启动各种进程：</p>
<ul>
<li>启动阶段550，回调相应onBootPhase()方法；</li>
<li>启动WebView，并且会创建进程，这是zygote正式创建的第一个进程；</li>
<li>启动systemui服务；</li>
<li>…</li>
</ul>
<h3 id="startSystemUi"><a href="#startSystemUi" class="headerlink" title="startSystemUi()"></a><code>startSystemUi()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final void startSystemUi(Context context) &#123;</span><br><span class="line">    Intent intent &#x3D; new Intent();</span><br><span class="line">    intent.setComponent(new ComponentName(&quot;com.android.systemui&quot;,</span><br><span class="line">                &quot;com.android.systemui.SystemUIService&quot;));</span><br><span class="line">    context.startServiceAsUser(intent, UserHandle.OWNER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务”com.android.systemui/.SystemUIService”</p>
<h3 id="after-goingCallback"><a href="#after-goingCallback" class="headerlink" title="after goingCallback"></a>after goingCallback</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动【见小节3.3.1】</span><br><span class="line">mSystemServiceManager.startUser(mCurrentUserId);</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">    if (mFactoryTest !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过pms获取所有的persistent进程</span><br><span class="line">        List apps &#x3D; AppGlobals.getPackageManager().</span><br><span class="line">            getPersistentApplications(STOCK_PM_FLAGS);</span><br><span class="line">        if (apps !&#x3D; null) &#123;</span><br><span class="line">            int N &#x3D; apps.size();</span><br><span class="line">            int i;</span><br><span class="line">            for (i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                ApplicationInfo info &#x3D; (ApplicationInfo)apps.get(i);</span><br><span class="line">                if (info !&#x3D; null &amp;&amp; !info.packageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;启动persistent进程</span><br><span class="line">                    addAppLocked(info, false, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBooting &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F; 启动桌面Activity 【见小节3.3.2】</span><br><span class="line">    startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;system发送广播USER_STARTED</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_USER_STARTED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(...);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;system发送广播USER_STARTING</span><br><span class="line">        intent &#x3D; new Intent(Intent.ACTION_USER_STARTING);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(...);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该阶段主要功能：</p>
<ul>
<li>回调所有SystemService的onStartUser()方法；</li>
<li>启动persistent进程；</li>
<li>启动home Activity;</li>
<li>发送广播USER_STARTED和USER_STARTING；</li>
<li>恢复栈顶Activity;</li>
<li>发送广播USER_SWITCHED；</li>
</ul>
<h3 id="SSM-startUser"><a href="#SSM-startUser" class="headerlink" title="SSM.startUser"></a>SSM.startUser</h3><p>[-&gt; SystemServiceManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void startUser(final int userHandle) &#123;</span><br><span class="line">    final int serviceLen &#x3D; mServices.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; serviceLen; i++) &#123;</span><br><span class="line">        final SystemService service &#x3D; mServices.get(i);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;回调所有SystemService的onStartUser()方法</span><br><span class="line">            service.onStartUser(userHandle);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-AMS-startHomeActivityLocked"><a href="#3-3-2-AMS-startHomeActivityLocked" class="headerlink" title="3.3.2 AMS.startHomeActivityLocked"></a>3.3.2 AMS.startHomeActivityLocked</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boolean startHomeActivityLocked(int userId, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F;home intent有CATEGORY_HOME</span><br><span class="line">    Intent intent &#x3D; getHomeIntent();</span><br><span class="line">    ActivityInfo aInfo &#x3D; resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    if (aInfo !&#x3D; null) &#123;</span><br><span class="line">        intent.setComponent(new ComponentName(</span><br><span class="line">                aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        aInfo &#x3D; new ActivityInfo(aInfo);</span><br><span class="line">        aInfo.applicationInfo &#x3D; getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">        ProcessRecord app &#x3D; getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, true);</span><br><span class="line">        if (app &#x3D;&#x3D; null || app.instrumentationClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            &#x2F;&#x2F;启动桌面Activity</span><br><span class="line">            mStackSupervisor.startHomeActivity(intent, aInfo, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><ol>
<li>创建AMS实例对象，创建Andoid Runtime，ActivityThread和Context对象；</li>
<li>setSystemProcess：注册AMS、meminfo、cpuinfo等服务到ServiceManager；</li>
<li>installSystemProviderss，加载SettingsProvider；</li>
<li>启动SystemUIService，再调用一系列服务的systemReady()方法；</li>
</ol>
<h3 id="4-1-发布Binder服务"><a href="#4-1-发布Binder服务" class="headerlink" title="4.1 发布Binder服务"></a>4.1 发布Binder服务</h3><p>[小节2.3]的AMS.setSystemProcess()过程向servicemanager注册了如下这个binder服务</p>
<table>
<thead>
<tr>
<th align="left">服务名</th>
<th align="left">类名</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">activity</td>
<td align="left">ActivityManagerService</td>
<td align="left">AMS</td>
</tr>
<tr>
<td align="left">procstats</td>
<td align="left">ProcessStatsService</td>
<td align="left">进程统计</td>
</tr>
<tr>
<td align="left">meminfo</td>
<td align="left">MemBinder</td>
<td align="left">内存</td>
</tr>
<tr>
<td align="left">gfxinfo</td>
<td align="left">GraphicsBinder</td>
<td align="left">图像信息</td>
</tr>
<tr>
<td align="left">dbinfo</td>
<td align="left">DbBinder</td>
<td align="left">数据库</td>
</tr>
<tr>
<td align="left">cpuinfo</td>
<td align="left">CpuBinder</td>
<td align="left">CPU</td>
</tr>
<tr>
<td align="left">permission</td>
<td align="left">PermissionController</td>
<td align="left">权限</td>
</tr>
<tr>
<td align="left">processinfo</td>
<td align="left">ProcessInfoService</td>
<td align="left">进程服务</td>
</tr>
<tr>
<td align="left">usagestats</td>
<td align="left">UsageStatsService</td>
<td align="left">应用的使用情况</td>
</tr>
</tbody></table>
<p>想要查看这些服务的信息，可通过<code>dumpsys &lt;服务名&gt;</code>命令。比如查看CPU信息命令<code>dumpsys cpuinfo</code>。</p>
<h3 id="4-2-AMS-systemReady"><a href="#4-2-AMS-systemReady" class="headerlink" title="4.2 AMS.systemReady"></a>4.2 AMS.systemReady</h3><p>另外，AMS.systemReady()的大致过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService&#123;</span><br><span class="line"></span><br><span class="line">    public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ...&#x2F;&#x2F;更新操作</span><br><span class="line">        mSystemReady &#x3D; true; &#x2F;&#x2F;系统处于ready状态</span><br><span class="line">        removeProcessLocked(proc, true, false, &quot;system update done&quot;);&#x2F;&#x2F;杀掉所有非persistent进程</span><br><span class="line">        mProcessesReady &#x3D; true;  &#x2F;&#x2F;进程处于ready状态</span><br><span class="line"></span><br><span class="line">        goingCallback.run(); &#x2F;&#x2F;这里有可能启动进程</span><br><span class="line"></span><br><span class="line">        addAppLocked(info, false, null); &#x2F;&#x2F;启动所有的persistent进程</span><br><span class="line">        mBooting &#x3D; true;  &#x2F;&#x2F;正在启动中</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); &#x2F;&#x2F;启动桌面</span><br><span class="line">        mStackSupervisor.resumeTopActivitiesLocked(); &#x2F;&#x2F;恢复栈顶的Activity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再说一说<code>mProcessesReady</code>：</p>
<p>startProcessLocked()过程对于非persistent进程必须等待mProcessesReady = true才会真正创建进程，否则进程放入mProcessesOnHold队列。 当然以下情况不会判断mProcessesReady：</p>
<ul>
<li>addAppLocked()启动persistent进程; //但此时已经mProcessesReady；</li>
<li>finishBooting()启动on-hold进程; //但此时已经mProcessesReady；</li>
<li>cleanUpApplicationRecordLock() //启动需要restart进程，前提是进程已创建；</li>
<li>attachApplicationLocked() //绑定Bind死亡通告失败，前台同样是进程要已创建。</li>
</ul>
<p>还有一个特殊情况，可以创建进程：processNextBroadcast()过程对于flag为FLAG_RECEIVER_BOOT_UPGRADE的广播拉进程 ，只在小节3.1.1的升级过程会出现。</p>
<p>由此可见，mProcessesReady在没有ready前，则基本没有应用进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-init/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/31/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-init/" itemprop="url">Android系统启动-init</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-31T01:50:06+08:00">
                2020-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/31/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-init/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/31/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-init/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system&#x2F;core&#x2F;init&#x2F;</span><br><span class="line">  - init.cpp</span><br><span class="line">  - init_parser.cpp</span><br><span class="line">  - signal_handler.cpp</span><br></pre></td></tr></table></figure>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能分为4部分：</p>
<ul>
<li>解析并运行所有的init.rc相关文件</li>
<li>根据rc文件，生成相应的设备驱动节点</li>
<li>处理子进程的终止(signal方式)</li>
<li>提供属性服务的功能</li>
</ul>
<p>接下来从main()方法说起。</p>
<h2 id="main"><a href="#main" class="headerlink" title="main()"></a><code>main()</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">static int epoll_fd &#x3D; -1;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置文件属性0777</span><br><span class="line">    umask(0);</span><br><span class="line">    &#x2F;&#x2F;初始化内核log，位于节点&#x2F;dev&#x2F;kmsg【见小节1.2】</span><br><span class="line">    klog_init();</span><br><span class="line">    &#x2F;&#x2F;设置输出的log级别</span><br><span class="line">    klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一块共享的内存空间，用于属性服务【见小节5.1】</span><br><span class="line">    property_init();</span><br><span class="line">    &#x2F;&#x2F;初始化epoll功能</span><br><span class="line">    epoll_fd &#x3D; epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    &#x2F;&#x2F;初始化子进程退出的信号处理函数，并调用epoll_ctl设置signal fd可读的回调函数【见小节2.1】</span><br><span class="line">    signal_handler_init();  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;加载default.prop文件</span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line">    &#x2F;&#x2F;启动属性服务器，此处会调用epoll_ctl设置property fd可读的回调函数【见小节5.2】</span><br><span class="line">    start_property_service();   </span><br><span class="line">    &#x2F;&#x2F;解析init.rc文件</span><br><span class="line">    init_parse_config_file(&quot;&#x2F;init.rc&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为on early-init的语句</span><br><span class="line">    action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);</span><br><span class="line">    &#x2F;&#x2F;等冷插拔设备初始化完成</span><br><span class="line">    queue_builtin_action(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">    &#x2F;&#x2F;设备组合键的初始化操作，此处会调用epoll_ctl设置keychord fd可读的回调函数</span><br><span class="line">    queue_builtin_action(keychord_init_action, &quot;keychord_init&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 屏幕上显示Android静态Logo 【见小节1.3】</span><br><span class="line">    queue_builtin_action(console_init_action, &quot;console_init&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为on init的语句</span><br><span class="line">    action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);</span><br><span class="line">    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line"></span><br><span class="line">    char bootmode[PROP_VALUE_MAX];</span><br><span class="line">    &#x2F;&#x2F;当处于充电模式，则charger加入执行队列；否则late-init加入队列。</span><br><span class="line">    if (property_get(&quot;ro.bootmode&quot;, bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, &quot;charger&quot;) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">       action_for_each_trigger(&quot;charger&quot;, action_add_queue_tail);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       action_for_each_trigger(&quot;late-init&quot;, action_add_queue_tail);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;触发器为属性是否设置</span><br><span class="line">    queue_builtin_action(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (!waiting_for_exec) &#123;</span><br><span class="line">            execute_one_command();</span><br><span class="line">             &#x2F;&#x2F;根据需要重启服务【见小节1.4】</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        int timeout &#x3D; -1;</span><br><span class="line">        if (process_needs_restart) &#123;</span><br><span class="line">            timeout &#x3D; (process_needs_restart - gettime()) * 1000;</span><br><span class="line">            if (timeout &lt; 0)</span><br><span class="line">                timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!action_queue_empty() || cur_action) &#123;</span><br><span class="line">            timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        &#x2F;&#x2F;循环等待事件发生</span><br><span class="line">        int nr &#x3D; TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">        if (nr &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        &#125; else if (nr &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">init进程执行完成后进入循环等待epoll_wait的状态。</span><br></pre></td></tr></table></figure>

<h2 id="log系统"><a href="#log系统" class="headerlink" title="log系统"></a>log系统</h2><p>此时android的log系统还没有启动，采用kernel的log系统，打开的设备节点/dev/kmsg， 那么可通过<code>cat /dev/kmsg</code>来获取内核log。</p>
<p>接下来，设置log的输出级别为KLOG_NOTICE_LEVEL(5)，当log级别小于5时则会输出到kernel log， 默认值为3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define KLOG_ERROR_LEVEL 3</span><br><span class="line">#define KLOG_WARNING_LEVEL 4</span><br><span class="line">#define KLOG_NOTICE_LEVEL 5</span><br><span class="line">#define KLOG_INFO_LEVEL 6</span><br><span class="line">#define KLOG_DEBUG_LEVEL 7</span><br><span class="line">#define KLOG_DEFAULT_LEVEL 3 &#x2F;&#x2F;默认为3</span><br></pre></td></tr></table></figure>

<h2 id="console-init-action"><a href="#console-init-action" class="headerlink" title="console_init_action"></a>console_init_action</h2><p>[-&gt; init.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int console_init_action(int nargs, char **args) &#123;</span><br><span class="line">    char console[PROP_VALUE_MAX];</span><br><span class="line">    if (property_get(&quot;ro.boot.console&quot;, console) &gt; 0) &#123;</span><br><span class="line">        snprintf(console_name, sizeof(console_name), &quot;&#x2F;dev&#x2F;%s&quot;, console);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int fd &#x3D; open(console_name, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;&#x3D; 0)</span><br><span class="line">        have_console &#x3D; 1;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(&quot;&#x2F;dev&#x2F;tty0&quot;, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;&#x3D; 0) &#123;</span><br><span class="line">        const char *msg;</span><br><span class="line">            msg &#x3D; &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;  &#x2F;&#x2F; console is 40 cols x 30 lines</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot; A N D R O I D &quot;;</span><br><span class="line">        write(fd, msg, strlen(msg));</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这便是开机显示的底部带ANDROID字样的画面。</p>
<h2 id="restart-processes"><a href="#restart-processes" class="headerlink" title="restart_processes"></a>restart_processes</h2><p>[-&gt; init.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void restart_processes() &#123;</span><br><span class="line">    process_needs_restart &#x3D; 0;</span><br><span class="line">    service_for_each_flags(SVC_RESTARTING,</span><br><span class="line">                           restart_service_if_needed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查service_list中的所有服务，对于带有SVC_RESTARTING标志的服务，则都会调用其相应的restart_service_if_needed。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void restart_service_if_needed(struct service *svc) &#123;</span><br><span class="line">    time_t next_start_time &#x3D; svc-&gt;time_started + 5;</span><br><span class="line"></span><br><span class="line">    if (next_start_time &lt;&#x3D; gettime()) &#123;</span><br><span class="line">        svc-&gt;flags &amp;&#x3D; (~SVC_RESTARTING);</span><br><span class="line">        service_start(svc, NULL);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((next_start_time &lt; process_needs_restart) ||</span><br><span class="line">        (process_needs_restart &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">        process_needs_restart &#x3D; next_start_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后再调用service_start来启动服务。</p>
<p>接下来，解读init的main方法中的4大块核心知识点：信号处理、rc文件语法、启动服务以及属性服务。</p>
<h1 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h1><p>在小节[1.1]的init.cpp的main()方法中通过signal_handler_init()来初始化信号处理过程。</p>
<p>主要工作：</p>
<ul>
<li>初始化signal句柄；</li>
<li>循环处理子进程；</li>
<li>注册epoll句柄；</li>
<li>处理子进程的终止；</li>
</ul>
<h2 id="signal-handler-init"><a href="#signal-handler-init" class="headerlink" title="signal_handler_init"></a>signal_handler_init</h2><p>[-&gt; signal_handler.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void signal_handler_init() &#123;</span><br><span class="line">    int s[2];</span><br><span class="line">    &#x2F;&#x2F; 创建socket pair</span><br><span class="line">    if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, s) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    signal_write_fd &#x3D; s[0];</span><br><span class="line">    signal_read_fd &#x3D; s[1];</span><br><span class="line">    &#x2F;&#x2F;当捕获信号SIGCHLD，则写入signal_write_fd</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    memset(&amp;act, 0, sizeof(act));</span><br><span class="line">    act.sa_handler &#x3D; SIGCHLD_handler;</span><br><span class="line">    &#x2F;&#x2F;SA_NOCLDSTOP使init进程只有在其子进程终止时才会受到SIGCHLD信号</span><br><span class="line">    act.sa_flags &#x3D; SA_NOCLDSTOP;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;进入waitpid来处理子进程是否退出的情况【见小节2.2】</span><br><span class="line">    reap_any_outstanding_children();</span><br><span class="line">    &#x2F;&#x2F;调用epoll_ctl方法来注册epoll的回调函数【见小节2.3】</span><br><span class="line">    register_epoll_handler(signal_read_fd, handle_signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个进程在处理其他进程发送的signal信号时都需要先注册，当进程的运行状态改变或终止时会产生某种signal信号，init进程是所有用户空间进程的父进程，当其子进程终止时产生SIGCHLD信号，init进程调用信号安装函数sigaction()，传递参数给sigaction结构体，便完成信号处理的过程。</p>
<p>这里有两个重要的函数：SIGCHLD_handler和handle_signal，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;写入数据</span><br><span class="line">static void SIGCHLD_handler(int) &#123;</span><br><span class="line">    &#x2F;&#x2F;向signal_write_fd写入1，直到成功为止</span><br><span class="line">    if (TEMP_FAILURE_RETRY(write(signal_write_fd, &quot;1&quot;, 1)) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;write(signal_write_fd) failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取数据</span><br><span class="line">static void handle_signal() &#123;</span><br><span class="line">    char buf[32];</span><br><span class="line">    &#x2F;&#x2F;读取signal_read_fd中的数据，并放入buf</span><br><span class="line">    read(signal_read_fd, buf, sizeof(buf));</span><br><span class="line">    reap_any_outstanding_children(); 【见小节2.2】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reap-any-outstanding-children"><a href="#reap-any-outstanding-children" class="headerlink" title="reap_any_outstanding_children"></a>reap_any_outstanding_children</h2><p>[-&gt; signal_handler.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static void reap_any_outstanding_children() &#123;</span><br><span class="line">    while (wait_for_one_process()) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static bool wait_for_one_process() &#123;</span><br><span class="line">    int status;</span><br><span class="line">    &#x2F;&#x2F;等待任意子进程，如果子进程没有退出则返回0，否则则返回该子进程pid。</span><br><span class="line">    pid_t pid &#x3D; TEMP_FAILURE_RETRY(waitpid(-1, &amp;status, WNOHANG));</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (pid &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;根据pid查找到相应的service</span><br><span class="line">    service* svc &#x3D; service_find_by_pid(pid);</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    if (!svc) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当flags为RESTART，且不是ONESHOT时，先kill进程组内所有的子进程或子线程</span><br><span class="line">    if (!(svc-&gt;flags &amp; SVC_ONESHOT) || (svc-&gt;flags &amp; SVC_RESTART)) &#123;</span><br><span class="line">        kill(-pid, SIGKILL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除当前服务svc中的所有创建过的socket</span><br><span class="line">    for (socketinfo* si &#x3D; svc-&gt;sockets; si; si &#x3D; si-&gt;next) &#123;</span><br><span class="line">        char tmp[128];</span><br><span class="line">        snprintf(tmp, sizeof(tmp), ANDROID_SOCKET_DIR&quot;&#x2F;%s&quot;, si-&gt;name);</span><br><span class="line">        unlink(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当flags为EXEC时，释放相应的服务</span><br><span class="line">    if (svc-&gt;flags &amp; SVC_EXEC) &#123;</span><br><span class="line">        waiting_for_exec &#x3D; false;</span><br><span class="line">        list_remove(&amp;svc-&gt;slist);</span><br><span class="line">        free(svc-&gt;name);</span><br><span class="line">        free(svc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    svc-&gt;pid &#x3D; 0;</span><br><span class="line">    svc-&gt;flags &amp;&#x3D; (~SVC_RUNNING);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对于ONESHOT服务，使其进入disabled状态</span><br><span class="line">    if ((svc-&gt;flags &amp; SVC_ONESHOT) &amp;&amp; !(svc-&gt;flags &amp; SVC_RESTART)) &#123;</span><br><span class="line">        svc-&gt;flags |&#x3D; SVC_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;禁用和重置的服务，都不再自动重启</span><br><span class="line">    if (svc-&gt;flags &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">        svc-&gt;NotifyStateChange(&quot;stopped&quot;); &#x2F;&#x2F;设置相应的service状态为stopped</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;服务在4分钟内重启次数超过4次，则重启手机进入recovery模式</span><br><span class="line">    time_t now &#x3D; gettime();</span><br><span class="line">    if ((svc-&gt;flags &amp; SVC_CRITICAL) &amp;&amp; !(svc-&gt;flags &amp; SVC_RESTART)) &#123;</span><br><span class="line">        if (svc-&gt;time_crashed + CRITICAL_CRASH_WINDOW &gt;&#x3D; now) &#123;</span><br><span class="line">            if (++svc-&gt;nr_crashed &gt; CRITICAL_CRASH_THRESHOLD) &#123;</span><br><span class="line">                android_reboot(ANDROID_RB_RESTART2, 0, &quot;recovery&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            svc-&gt;time_crashed &#x3D; now;</span><br><span class="line">            svc-&gt;nr_crashed &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    svc-&gt;flags &amp;&#x3D; (~SVC_RESTART);</span><br><span class="line">    svc-&gt;flags |&#x3D; SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行当前service中所有onrestart命令</span><br><span class="line">    struct listnode* node;</span><br><span class="line">    list_for_each(node, &amp;svc-&gt;onrestart.commands) &#123;</span><br><span class="line">        command* cmd &#x3D; node_to_item(node, struct command, clist);</span><br><span class="line">        cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置相应的service状态为restarting</span><br><span class="line">    svc-&gt;NotifyStateChange(&quot;restarting&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外：通过<code>getprop | grep init.svc</code> 可查看所有的service运行状态。状态总共分为：running, stopped, restarting</p>
<h2 id="register-epoll-handler"><a href="#register-epoll-handler" class="headerlink" title="register_epoll_handler"></a>register_epoll_handler</h2><p>[-&gt; signal_handler.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void register_epoll_handler(int fd, void (*fn)()) &#123;</span><br><span class="line">    epoll_event ev;</span><br><span class="line">    ev.events &#x3D; EPOLLIN;</span><br><span class="line">    ev.data.ptr &#x3D; reinterpret_cast&lt;void*&gt;(fn);</span><br><span class="line">    &#x2F;&#x2F;将fd的可读事件加入到epoll_fd的监听队列中</span><br><span class="line">    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        ERROR(&quot;epoll_ctl failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当fd可读，则会触发调用(*fn)函数。</p>
<h1 id="rc文件语法"><a href="#rc文件语法" class="headerlink" title="rc文件语法"></a>rc文件语法</h1><p>rc文件语法是以行尾单位，以空格间隔的语法，以#开始代表注释行。rc文件主要包含Action、Service、Command、Options，其中对于Action和Service的名称都是唯一的，对于重复的命名视为无效。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action： 通过触发器trigger，即以on开头的语句来决定执行相应的service的时机，具体有如下时机：</p>
<ul>
<li>on early-init; 在初始化早期阶段触发；</li>
<li>on init; 在初始化阶段触发；</li>
<li>on late-init; 在初始化晚期阶段触发；</li>
<li>on boot/charger： 当系统启动/充电时触发，还包含其他情况，此处不一一列举；</li>
<li>on property:<key>=<value>: 当属性值满足条件时触发；</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>服务Service，以 service开头，由init进程启动，一般运行在init的一个子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service在启动时会通过fork方式生成子进程。</p>
<p>例如： <code>service servicemanager /system/bin/servicemanager</code>代表的是服务名为servicemanager，服务执行的路径为/system/bin/servicemanager。</p>
<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><p>下面列举常用的命令</p>
<ul>
<li>class_start <service_class_name>： 启动属于同一个class的所有服务；</li>
<li>start <service_name>： 启动指定的服务，若已启动则跳过；</li>
<li>stop <service_name>： 停止正在运行的服务</li>
<li>setprop <name> <value>：设置属性值</li>
<li>mkdir <path>：创建指定目录</li>
<li>symlink <target> <sym_link>： 创建连接到<target>的<sym_link>符号链接；</li>
<li>write <path> <string>： 向文件path中写入字符串；</li>
<li>exec： fork并执行，会阻塞init进程直到程序完毕；</li>
<li>exprot <name> <name>：设定环境变量；</li>
<li>loglevel <level>：设置log级别</li>
</ul>
<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>Options是Service的可选项，与service配合使用</p>
<ul>
<li>disabled: 不随class自动启动，只有根据service名才启动；</li>
<li>oneshot: service退出后不再重启；</li>
<li>user/group： 设置执行服务的用户/用户组，默认都是root；</li>
<li>class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default；</li>
<li>onrestart:当服务重启时执行相应命令；</li>
<li>socket: 创建名为<code>/dev/socket/&lt;name&gt;</code>的socket</li>
<li>critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式</li>
</ul>
<p><strong>default:</strong> 意味着disabled=false，oneshot=false，critical=false。</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><h2 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">on init</span><br><span class="line">on late-init</span><br><span class="line">    trigger post-fs      </span><br><span class="line">    trigger load_system_props_action</span><br><span class="line">    trigger post-fs-data  </span><br><span class="line">    trigger load_persist_props_action</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line">    trigger boot   </span><br><span class="line"></span><br><span class="line">on post-fs      &#x2F;&#x2F;挂载文件系统</span><br><span class="line">    start logd</span><br><span class="line">    mount rootfs rootfs &#x2F; ro remount</span><br><span class="line">    mount rootfs rootfs &#x2F; shared rec</span><br><span class="line">    mount none &#x2F;mnt&#x2F;runtime&#x2F;default &#x2F;storage slave bind rec</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on post-fs-data  &#x2F;&#x2F;挂载data</span><br><span class="line">    start logd</span><br><span class="line">    start vold   &#x2F;&#x2F;启动vold</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on boot      &#x2F;&#x2F;启动核心服务</span><br><span class="line">    ...</span><br><span class="line">    class_start core &#x2F;&#x2F;启动core class</span><br></pre></td></tr></table></figure>

<p>触发器的执行顺序为on early-init -&gt; init -&gt; late-init，从上面的代码可知，在late-init触发器中会触发文件系统挂载以及on boot。再on boot过程会触发启动core class。至于main class的启动是由vold.decrypt的以下4个值的设置所决定的， 该过程位于system/vold/cryptfs.c文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br><span class="line"></span><br><span class="line">on property:vold.decrypt&#x3D;trigger_restart_min_framework</span><br><span class="line">    class_start main</span><br><span class="line"></span><br><span class="line">on property:vold.decrypt&#x3D;trigger_restart_framework</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br><span class="line"></span><br><span class="line">on property:vold.decrypt&#x3D;trigger_reset_main</span><br><span class="line">    class_reset main</span><br><span class="line"></span><br><span class="line">on property:vold.decrypt&#x3D;trigger_shutdown_framework</span><br><span class="line">    class_reset late_start</span><br><span class="line">    class_reset main</span><br></pre></td></tr></table></figure>

<h2 id="服务启动-Zygote"><a href="#服务启动-Zygote" class="headerlink" title="服务启动(Zygote)"></a>服务启动(Zygote)</h2><p>在init.zygote.rc文件中，zygote服务定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br></pre></td></tr></table></figure>

<p>通过<code>init_parser.cpp</code>完成整个service解析工作，此处就不详细展开讲解析过程，该过程主要工作是：</p>
<ul>
<li>创建一个名叫”zygote”的service结构体；</li>
<li>创建一个用于socket通信的socketinfo结构体；</li>
<li>创建一个包含4个onrestart的action结构体。</li>
</ul>
<p>Zygote服务会随着main class的启动而启动，退出后会由init重启zygote，即使多次重启也不会进入recovery模式。zygote所对应的可执行文件是/system/bin/app_process，通过调用<code>pid =fork()</code>创建子进程，通过<code>execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV)</code>，进入App_main.cpp的main()函数。故zygote是通过fork和execv共同创建的。</p>
<p>流程如下：</p>
<p><img src="http://gityuan.com/images/boot/init/zygote_init.jpg" alt="zygote_init"></p>
<p>而关于Zygote重启在前面的信号处理过程中讲过，是处理SIGCHLD信号，init进程重启zygote进程，更多关于Zygote内容见<a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Zygote篇</a>。</p>
<h2 id="服务重启"><a href="#服务重启" class="headerlink" title="服务重启"></a>服务重启</h2><p><img src="http://gityuan.com/images/boot/init/init_oneshot.jpg" alt="init_oneshot"></p>
<p>当init子进程退出时，会产生SIGCHLD信号，并发送给init进程，通过socket套接字传递数据，调用到wait_for_one_process()方法，根据是否是oneshot，来决定是重启子进程，还是放弃启动。</p>
<p>所有的Service里面只有servicemanager ，zygote ，surfaceflinger这3个服务有<code>onrestart</code>关键字来触发其他service启动过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;zygote可触发media、netd重启</span><br><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;servicemanager可触发healthd、zygote、media、surfaceflinger、drm重启</span><br><span class="line">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;surfaceflinger可触发zygote重启</span><br><span class="line">service surfaceflinger &#x2F;system&#x2F;bin&#x2F;surfaceflinger</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    onrestart restart zygote</span><br></pre></td></tr></table></figure>

<p>由上可知：</p>
<ul>
<li>zygote：触发media、netd以及子进程(包括system_server进程)重启；</li>
<li>system_server: 触发zygote重启;</li>
<li>surfaceflinger：触发zygote重启;</li>
<li>servicemanager: 触发zygote、healthd、media、surfaceflinger、drm重启</li>
</ul>
<p>所以，surfaceflinger,servicemanager,zygote自身以及system_server进程被杀都会触发Zygote重启。</p>
<h1 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h1><p>当某个进程A，通过property_set()修改属性值后，init进程会检查访问权限，当权限满足要求后，则更改相应的属性值，属性值一旦改变则会触发相应的触发器（即rc文件中的on开头的语句)，在Android Shared Memmory（共享内存区域）中有一个_system_property_area_区域，里面记录着所有的属性值。对于进程A通过property_get（）方法，获取的也是该共享内存区域的属性值。</p>
<h2 id="property-init"><a href="#property-init" class="headerlink" title="property_init"></a>property_init</h2><p>[-&gt; property_service.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void property_init() &#123;</span><br><span class="line">    &#x2F;&#x2F;用于保证只初始化_system_property_area_区域一次</span><br><span class="line">    if (property_area_initialized) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    property_area_initialized &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;创建共享内存</span><br><span class="line">    if (__system_property_area_init()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pa_workspace.size &#x3D; 0;</span><br><span class="line">    pa_workspace.fd &#x3D; open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法核心功能在执行__system_property_area_init()方法，创建用于跨进程的共享内存。主要工作如下：</p>
<ul>
<li>执行open()，打开名为”/dev/<strong>properties</strong>“的共享内存文件，并设置大小为128KB；</li>
<li>执行mmap()，将该内存映射到init进程；</li>
<li>将该内存的首地址保存在全局变量<strong>system_property_area</strong>，后续的增加或者修改属性都基于该变量来计算位置。</li>
</ul>
<p><strong>关于加载的prop文件</strong></p>
<p>通过<code>load_all_load_all_propsprops()</code>方法，加载以下：</p>
<ol>
<li>/system/build.prop；</li>
<li>/vendor/build.prop；</li>
<li>/factory/factory.prop；</li>
<li>/data/local.prop；</li>
<li>/data/property路径下的persist属性</li>
</ol>
<h2 id="start-property-service"><a href="#start-property-service" class="headerlink" title="start_property_service"></a>start_property_service</h2><p>[-&gt; property_service.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    property_set(<span class="string">"ro.property_service.version"</span>, <span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                   <span class="keyword">false</span>, <span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, nullptr, sehandle);</span><br><span class="line">    listen(property_set_fd, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//设置property文件描述符可读的回调函数【见小节2.3】</span></span><br><span class="line">    register_epoll_handler(property_set_fd, handle_property_set_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建并监听名叫“property_service”的socket，再利用epoll_ctl设置property文件描述符触发可读时的回调函数为handle_property_set_fd，接下来看看该函数的实现。</p>
<h2 id="handle-property-set-fd"><a href="#handle-property-set-fd" class="headerlink" title="handle_property_set_fd"></a>handle_property_set_fd</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_property_set_fd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> constexpr uint32_t kDefaultSocketTimeout = <span class="number">2000</span>; <span class="comment">/* ms */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = accept4(property_set_fd, nullptr, nullptr, SOCK_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    struct ucred cr;</span><br><span class="line">    socklen_t cr_size = sizeof(cr);</span><br><span class="line">    getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; <span class="number">0</span>)；</span><br><span class="line"></span><br><span class="line">    <span class="function">SocketConnection <span class="title">socket</span><span class="params">(s, cr)</span></span>;</span><br><span class="line">    uint32_t timeout_ms = kDefaultSocketTimeout; <span class="comment">//设置2秒超时</span></span><br><span class="line"></span><br><span class="line">    uint32_t cmd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!socket.RecvUint32(&amp;cmd, &amp;timeout_ms)) &#123;</span><br><span class="line">        socket.SendUint32(PROP_ERROR_READ_CMD);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROP_MSG_SETPROP: &#123;</span><br><span class="line">        <span class="keyword">char</span> prop_name[PROP_NAME_MAX];</span><br><span class="line">        <span class="keyword">char</span> prop_value[PROP_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!socket.RecvChars(prop_name, PROP_NAME_MAX, &amp;timeout_ms) ||</span><br><span class="line">            !socket.RecvChars(prop_value, PROP_VALUE_MAX, &amp;timeout_ms)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prop_name[PROP_NAME_MAX-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        prop_value[PROP_VALUE_MAX-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置property【见小节5.4】</span></span><br><span class="line">        handle_property_set(socket, prop_value, prop_value, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PROP_MSG_SETPROP2: &#123;</span><br><span class="line">        std::string name;</span><br><span class="line">        std::string value;</span><br><span class="line">        <span class="keyword">if</span> (!socket.RecvString(&amp;name, &amp;timeout_ms) ||</span><br><span class="line">            !socket.RecvString(&amp;value, &amp;timeout_ms)) &#123;</span><br><span class="line">          socket.SendUint32(PROP_ERROR_READ_DATA);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置property【见小节5.4】</span></span><br><span class="line">        handle_property_set(socket, name, value, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        socket.SendUint32(PROP_ERROR_INVALID_CMD);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里针对socket接收事件设置2秒超时，也就是说property的设置过程有可能耗时。</p>
<h2 id="handle-property-set"><a href="#handle-property-set" class="headerlink" title="handle_property_set"></a>handle_property_set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_property_set</span><span class="params">(SocketConnection&amp; socket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> std::string&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                bool legacy_protocol)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cmd_name = legacy_protocol ? <span class="string">"PROP_MSG_SETPROP"</span> : <span class="string">"PROP_MSG_SETPROP2"</span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_legal_property_name(name)) &#123; <span class="comment">//检查属性名是否合规</span></span><br><span class="line">    socket.SendUint32(PROP_ERROR_INVALID_NAME);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  struct ucred cr = socket.cred();</span><br><span class="line">  <span class="keyword">char</span>* source_ctx = nullptr;</span><br><span class="line">  getpeercon(socket.socket(), &amp;source_ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (android::base::StartsWith(name, <span class="string">"ctl."</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (check_control_mac_perms(value.c_str(), source_ctx, &amp;cr)) &#123;</span><br><span class="line">      <span class="comment">//处理以ctl.开头的属性</span></span><br><span class="line">      handle_control_message(name.c_str() + <span class="number">4</span>, value.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (check_perms(name, source_ctx, &amp;cr)) &#123;</span><br><span class="line">      <span class="comment">//设置属性名和属性值</span></span><br><span class="line">      uint32_t result = property_set(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  freecon(source_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会检测属性名是否合规，具体检查规范如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">is_legal_property_name</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    size_t namelen = name.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (namelen &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (name[namelen - <span class="number">1</span>] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow alphanumeric, plus '.', '-', '@', ':', or '_' */</span></span><br><span class="line">    <span class="comment">/* Don't allow ".." to appear in a property name */</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; namelen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// i=0 is guaranteed to never have a dot. See above.</span></span><br><span class="line">            <span class="keyword">if</span> (name[i-<span class="number">1</span>] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name[i] == <span class="string">'_'</span> || name[i] == <span class="string">'-'</span> || name[i] == <span class="string">'@'</span> || name[i] == <span class="string">':'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (name[i] &gt;= <span class="string">'a'</span> &amp;&amp; name[i] &lt;= <span class="string">'z'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (name[i] &gt;= <span class="string">'A'</span> &amp;&amp; name[i] &lt;= <span class="string">'Z'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (name[i] &gt;= <span class="string">'0'</span> &amp;&amp; name[i] &lt;= <span class="string">'9'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint32_t <span class="title">property_set</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertySetImpl(name, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">PropertySetImpl</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    size_t valuelen = value.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_legal_property_name(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> PROP_ERROR_INVALID_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valuelen &gt;= PROP_VALUE_MAX) &#123; <span class="comment">//属性名不可过长</span></span><br><span class="line">        <span class="keyword">return</span> PROP_ERROR_INVALID_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop_info* pi = (prop_info*) __system_property_find(name.c_str());</span><br><span class="line">    <span class="keyword">if</span> (pi != nullptr) &#123;</span><br><span class="line">        <span class="comment">// 以ro.开头的属性不可更改</span></span><br><span class="line">        <span class="keyword">if</span> (android::base::StartsWith(name, <span class="string">"ro."</span>)</span><br><span class="line">            &amp;&amp; strcmp(name.c_str(),<span class="string">"ro.build.software.version"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PROP_ERROR_READ_ONLY_PROPERTY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新属性</span></span><br><span class="line">        __system_property_update(pi, value.c_str(), valuelen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//添加属性</span></span><br><span class="line">        <span class="keyword">int</span> rc = __system_property_add(name.c_str(), name.size(), value.c_str(), valuelen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以persist.开头的属性需要持久化</span></span><br><span class="line">    <span class="keyword">if</span> (persistent_properties_loaded &amp;&amp; android::base::StartsWith(name, <span class="string">"persist."</span>)) &#123;</span><br><span class="line">        write_persistent_property(name.c_str(), value.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//属性值改变的通知过程</span></span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    <span class="keyword">return</span> PROP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同属性执行逻辑有所不同，主要区分如下：</p>
<ul>
<li><p>属性名以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctl.</span><br></pre></td></tr></table></figure>

<p>开头，则表示是控制消息，控制消息用来执行一些命令。例如：</p>
<ul>
<li>setprop ctl.start bootanim 查看开机动画；</li>
<li>setprop ctl.stop bootanim 关闭开机动画；</li>
<li>setprop ctl.start pre-recovey 进入recovery模式；</li>
</ul>
</li>
<li><p>属性名以<code>ro.</code>开头，则表示是只读的，不能设置，所以直接返回；</p>
</li>
<li><p>属性名以<code>persist.</code>开头，则需要把这些值写到对应文件；需要注意的是，persist用于持久化保存某些属性值，当同时也带来了额外的IO操作。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>init进程(pid=1)是Linux系统中用户空间的第一个进程，主要工作如下：</p>
<ul>
<li>创建一块共享的内存空间，用于属性服务器;</li>
<li>解析各个rc文件，并启动相应属性服务进程;</li>
<li>初始化epoll，依次设置signal、property、keychord这3个fd可读时相对应的回调函数;</li>
<li>进入无限循环状态，执行如下流程：<ul>
<li>检查action_queue列表是否为空，若不为空则执行相应的action;</li>
<li>检查是否需要重启的进程，若有则将其重新启动;</li>
<li>进入epoll_wait等待状态，直到系统属性变化事件(property_set改变属性值)，或者收到子进程的信号SIGCHLD，再或者keychord 键盘输入事件，则会退出等待状态，执行相应的回调函数。</li>
</ul>
</li>
</ul>
<p>可见init进程在开机之后的核心工作就是响应property变化事件和回收僵尸进程。当某个进程调用property_set来改变一个系统属性值时，系统会通过socket向init进程发送一个property变化的事件通知，那么property fd会变成可读，init进程采用epoll机制监听该fd则会 触发回调handle_property_set_fd()方法。回收僵尸进程，在Linux内核中，如父进程不等待子进程的结束直接退出，会导致子进程在结束后变成僵尸进程，占用系统资源。为此，init进程专门安装了SIGCHLD信号接收器，当某些子进程退出时发现其父进程已经退出，则会向init进程发送SIGCHLD信号，init进程调用回调方法handle_signal()来回收僵尸子进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E7%AF%87/" itemprop="url">Android系统总结篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T13:38:37+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E7%AF%87/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E7%AF%87/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h2><p>Android大致可以分为四层架构：<strong>Linux内核层、系统运行库层、应用框架层和应用层</strong>。</p>
<p>本文作为Android系统架构的开篇，起到提纲挈领的作用，从系统整体架构角度概要讲解Android系统的核心技术点，带领大家初探Android系统全貌以及内部运作机制。虽然Android系统非常庞大且错综复杂，需要具备全面的技术栈，但整体架构设计清晰。Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-a8c2d9d3a1a3a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>Linux内核层</p>
<p>Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。</p>
</li>
<li><p>系统运行库层</p>
<p>这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGl|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。</p>
<p>同样这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用。另外，Android运行库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机示例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。</p>
</li>
<li><p>应用框架层</p>
<p>这一层主要提供了构建应用程序时可能用到的各种API,Andorid自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。</p>
</li>
<li><p>应用层</p>
<p>所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play上下载的小游戏，当然还包括你自己开发的程序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2c322e9e0eea1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="脑图"></p>
</li>
</ul>
<h2 id="系统启动架构"><a href="#系统启动架构" class="headerlink" title="系统启动架构"></a>系统启动架构</h2><p>Google提供的5层架构图很经典，但为了更进一步透视Android系统架构，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌，阐述Android内部的环环相扣的内在联系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-68a5968ed562a20e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-f03913fd803c3125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h2><p>init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程。对于init进程的功能分为4部分：</p>
<ul>
<li><p>创建一块共享的内存空间，用于属性服务器;</p>
</li>
<li><p>解析各个rc文件，并启动相应属性服务进程;</p>
</li>
<li><p>初始化epoll，依次设置signal、property、keychord这3个fd可读时相对应的回调函数;</p>
</li>
<li><p>进入无限循环状态，执行如下流程：</p>
<ul>
<li>检查action_queue列表是否为空，若不为空则执行相应的action;</li>
<li>检查是否需要重启的进程，若有则将其重新启动;</li>
<li>进入epoll_wait等待状态，直到系统属性变化事件(property_set改变属性值)，或者收到子进程的信号SIGCHLD，再或者keychord 键盘输入事件，则会退出等待状态，执行相应的回调函数。</li>
</ul>
</li>
</ul>
<p>可见init进程在开机之后的核心工作就是响应property变化事件和回收僵尸进程。当某个进程调用property_set来改变一个系统属性值时，系统会通过socket向init进程发送一个property变化的事件通知，那么property fd会变成可读，init进程采用epoll机制监听该fd则会 触发回调handle_property_set_fd()方法。回收僵尸进程，在Linux内核中，如父进程不等待子进程的结束直接退出，会导致子进程在结束后变成僵尸进程，占用系统资源。为此，init进程专门安装了SIGCHLD信号接收器，当某些子进程退出时发现其父进程已经退出，则会向init进程发送SIGCHLD信号，init进程调用回调方法handle_signal()来回收僵尸子进程。</p>
<h3 id="启动zygone服务"><a href="#启动zygone服务" class="headerlink" title="启动zygone服务"></a>启动zygone服务</h3><ul>
<li>创建一个名叫”zygote”的service结构体；</li>
<li>创建一个用于socket通信的socketinfo结构体；</li>
<li>创建一个包含4个onrestart的action结构体。</li>
</ul>
<p><img src="http://gityuan.com/images/boot/init/zygote_init.jpg" alt="zygote_init"></p>
<h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p>Zygote启动过程的函数调用类大致流程如下：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_process.jpg" alt="zygote_process"></p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_start.jpg" alt="zygote_start"></p>
<ol>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；</li>
<li>zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li>
</ol>
<p><strong>Zygote做了哪些事：</strong></p>
<ul>
<li>创建vm虚拟机</li>
<li>注册JNI函数</li>
<li>建立socket通道，响应客户端请求</li>
<li>预加载通用类、资源、openGL、共享库、WebView</li>
<li>创建system_server进程</li>
<li>调用runSelectLoop()，当接收到请求创建新进程请求时立即唤醒并执行相应工作，没有请求则休眠。</li>
</ul>
<h3 id="Zygote创建进程"><a href="#Zygote创建进程" class="headerlink" title="Zygote创建进程"></a>Zygote创建进程</h3><p>进程创建过程的简要图：</p>
<p><img src="http://gityuan.com/images/android-process/start_app_process.jpg" alt="start_app_process"></p>
<p>Process.start()方法是阻塞操作，等待直到进程创建完成并返回相应的新进程pid，才完成该方法。</p>
<p>当App第一次启动时或者启动远程Service，即AndroidManifest.xml文件中定义了process:remote属性时，都需要创建进程。比如当用户点击桌面的某个App图标，桌面本身是一个app（即Launcher App），那么Launcher所在进程便是这次创建新进程的发起进程，该通过binder发送消息给system_server进程，该进程承载着整个java framework的核心服务。system_server进程从Process.start开始，执行创建进程，流程图（以进程的视角）如下：</p>
<p><img src="http://gityuan.com/images/android-process/process-create.jpg" alt="process-create"></p>
<p>上图中，<code>system_server</code>进程通过socket IPC通道向<code>zygote</code>进程通信，<code>zygote</code>在fork出新进程后由于fork<strong>调用一次，返回两次</strong>，即在zygote进程中调用一次，在zygote进程和子进程中各返回一次，从而能进入子进程来执行代码。该调用流程图的过程：</p>
<ol>
<li><strong>system_server进程</strong>（<code>即流程1~3</code>）：通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；</li>
<li><strong>zygote进程：</strong>接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节其具体工作是依次执行下面的3个方法：<ul>
<li>preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；</li>
<li>nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；</li>
<li>postForkCommon()：在启动之前被暂停的4个Daemon子线程。</li>
</ul>
</li>
<li><strong>新进程</strong>：进入handleChildProc()方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即Activity.main()方法。</li>
</ol>
<h2 id="system-server进程启动"><a href="#system-server进程启动" class="headerlink" title="system_server进程启动"></a>system_server进程启动</h2><p>SystemServer由Zygote fork生成的，进程名为<code>system_server</code>，该进程承载着framework的核心服务。 <a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Android系统启动-zygote篇</a>中讲到Zygote启动过程中会调用startSystemServer()，可知<code>startSystemServer()</code>函数是system_server启动流程的起点， 启动流程图如下：<img src="http://gityuan.com/images/boot/systemServer/system_server.jpg" alt="system_server_boot_process"></p>
<p>上图前4步骤（即颜色为紫色的流程）运行在是<code>Zygote</code>进程，从第5步（即颜色为蓝色的流程）ZygoteInit.handleSystemServerProcess开始是运行在新创建的<code>system_server</code>，这是fork机制实现的（fork会返回2次）。下面从startSystemServer()开始讲解详细启动流程。</p>
<p>在<code>SystemServer#main</code>方法中进入<code>Looper.loop()</code>状态,等待其他线程通过<code>handler</code>发送消息到主线再处理.</p>
<p>system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。</p>
<ul>
<li>引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService；</li>
<li>核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService；</li>
<li>其他服务(70个+)：AlarmManagerService、VibratorService等。</li>
</ul>
<p>合计总大约80个系统服务：</p>
<table>
<thead>
<tr>
<th><code>ActivityManagerService</code></th>
<th><code>PackageManagerService</code></th>
<th><code>WindowManagerService</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>PowerManagerService</code></td>
<td><code>BatteryService</code></td>
<td><code>BatteryStatsService</code></td>
</tr>
<tr>
<td><code>DreamManagerService</code></td>
<td><code>DropBoxManagerService</code></td>
<td><code>SamplingProfilerService</code></td>
</tr>
<tr>
<td><code>UsageStatsService</code></td>
<td><code>DiskStatsService</code></td>
<td><code>DeviceStorageMonitorService</code></td>
</tr>
<tr>
<td>SchedulingPolicyService</td>
<td><code>AlarmManagerService</code></td>
<td>DeviceIdleController</td>
</tr>
<tr>
<td>ThermalObserver</td>
<td>JobSchedulerService</td>
<td><code>AccessibilityManagerService</code></td>
</tr>
<tr>
<td>DisplayManagerService</td>
<td>LightsService</td>
<td><code>GraphicsStatsService</code></td>
</tr>
<tr>
<td>StatusBarManagerService</td>
<td>NotificationManagerService</td>
<td>WallpaperManagerService</td>
</tr>
<tr>
<td>UiModeManagerService</td>
<td>AppWidgetService</td>
<td>LauncherAppsService</td>
</tr>
<tr>
<td>TextServicesManagerService</td>
<td>ContentService</td>
<td>LockSettingsService</td>
</tr>
<tr>
<td>InputMethodManagerService</td>
<td>InputManagerService</td>
<td><code>MountService</code></td>
</tr>
<tr>
<td>FingerprintService</td>
<td>TvInputManagerService</td>
<td>DockObserver</td>
</tr>
<tr>
<td>NetworkManagementService</td>
<td>NetworkScoreService</td>
<td><code>NetworkStatsService</code></td>
</tr>
<tr>
<td>NetworkPolicyManagerService</td>
<td>ConnectivityService</td>
<td>BluetoothService</td>
</tr>
<tr>
<td>WifiP2pService</td>
<td>WifiService</td>
<td>WifiScanningService</td>
</tr>
<tr>
<td>AudioService</td>
<td>MediaRouterService</td>
<td>VoiceInteractionManagerService</td>
</tr>
<tr>
<td>MediaProjectionManagerService</td>
<td>MediaSessionService</td>
<td></td>
</tr>
<tr>
<td>DevicePolicyManagerService</td>
<td>PrintManagerService</td>
<td><code>BackupManagerService</code></td>
</tr>
<tr>
<td><code>UserManagerService</code></td>
<td>AccountManagerService</td>
<td><code>TrustManagerService</code></td>
</tr>
<tr>
<td><code>SensorService</code></td>
<td>LocationManagerService</td>
<td>VibratorService</td>
</tr>
<tr>
<td>CountryDetectorService</td>
<td>GestureLauncherService</td>
<td>PersistentDataBlockService</td>
</tr>
<tr>
<td>EthernetService</td>
<td>WebViewUpdateService</td>
<td>ClipboardService</td>
</tr>
<tr>
<td>TelephonyRegistry</td>
<td>TelecomLoaderService</td>
<td>NsdService</td>
</tr>
<tr>
<td>UpdateLockService</td>
<td>SerialService</td>
<td>SearchManagerService</td>
</tr>
<tr>
<td>CommonTimeManagementService</td>
<td>AssetAtlasService</td>
<td>ConsumerIrService</td>
</tr>
<tr>
<td>MidiServiceCameraService</td>
<td>TwilightService</td>
<td>RestrictionsManagerService</td>
</tr>
<tr>
<td>MmsServiceBroker</td>
<td>RttService</td>
<td>UsbService</td>
</tr>
</tbody></table>
<p>Service类别众多，其中表中加粗项是指博主挑选的较重要或者较常见的Service。</p>
<h3 id="服务启动阶段"><a href="#服务启动阶段" class="headerlink" title="服务启动阶段"></a>服务启动阶段</h3><p>SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程：</p>
<p><img src="http://gityuan.com/images/boot/systemServer/system_server_boot_process.jpg" alt="system_server服务启动流程"></p>
<h3 id="注册（添加）服务"><a href="#注册（添加）服务" class="headerlink" title="注册（添加）服务"></a>注册（添加）服务</h3><p><strong>方式1. ServiceManager.addService():</strong></p>
<ul>
<li>功能：向ServiceManager注册该服务.</li>
<li>特点：服务往往直接或间接继承于Binder服务；</li>
<li>举例：input, window, package；</li>
</ul>
<p><strong>方式2. SystemServiceManager.startService:</strong></p>
<ul>
<li>功能：<ul>
<li>创建服务对象；</li>
<li>执行该服务的onStart()方法；该方法会执行上面的SM.addService()；</li>
<li>根据启动到不同的阶段会回调onBootPhase()方法；</li>
<li>另外，还有多用户模式下用户状态的改变也会有回调方法；例如onStartUser();</li>
</ul>
</li>
<li>特点：服务往往自身或内部类继承于SystemService；</li>
<li>举例：power, activity；</li>
</ul>
<p>两种方式真正注册服务的过程都会调用到ServiceManager.addService()方法. 对于方式2多了一个服务对象创建以及 根据不同启动阶段采用不同的动作的过程。可以理解为方式2比方式1的功能更丰富。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer%20(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer%20(2)/" itemprop="url">Android系统启动-SystemServer(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T11:05:49+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer%20(2)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer%20(2)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是SystemService"><a href="#什么是SystemService" class="headerlink" title="什么是SystemService"></a>什么是SystemService</h1><p>我们在Android开发过程中经常会用到各种各样的系统管理服务，如进行窗口相关的操作会用到窗口管理服务WindowManager，进行电源相关的操作会用到电源管理服务PowerManager，还有很多其他的系统管理服务，如通知管理服务NotifacationManager、振动管理服务Vibrator、电池管理服务BatteryManager…… 这些Manager提供了很多对系统层的控制接口。对于App开发者，只需要了解这些接口的使用方式就可以方便的进行系统控制，获得系统各个服务的信息，而不需要了解这些接口的具体实现方式。而对于Framework开发者，则需要了解这些Manager服务的常用实现模式，维护这些Manager的接口，扩展这些接口，或者实现新的Manager。</p>
<p><img src="https://img-blog.csdn.net/20171220111218423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2V5dW5mZWlf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="一个简单的SystemService"><a href="#一个简单的SystemService" class="headerlink" title="一个简单的SystemService"></a>一个简单的SystemService</h2><p>我们从一个简单的系统服务Vibrator服务来看一下一个系统服务是怎样建立的。<br>Vibrator服务提供的控制手机振动的接口，应用可以调用Vibrator的接口来让手机产生振动，达到提醒用户的目的。<br>从Android的官方文档中可以看到Vibrator只是一个抽象类，只有4个抽象接口：</p>
<ul>
<li>abstract void cancel() 取消振动</li>
<li>abstract boolean hasVibrator() 是否有振动功能</li>
<li>abstract void vibrate(long[] pattern, int repeat) 按节奏重复振动</li>
<li>abstract void vibrate(long milliseconds) 持续振动</li>
</ul>
<p>应用中使用振动服务的方法也很简单，如让手机持续振动500毫秒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vibrator mVibrator &#x3D; (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">mVibrator.vibrate(500);</span><br></pre></td></tr></table></figure>

<p><code>Vibrator</code>使用起来很简单，我们再来看一下实现起来是不是也简单。从文档中可以看到Vibrator只是定义在android.os 包里的一个抽象类，在源码里的位置即<code>frameworks/base/core/java/android/os/Vibrator.java</code>，那么应用中实际使用的是哪个实例呢？应用中使用的Vibrator实例是通过Context的一个方法<code>getSystemService(Context.VIBRATOR_SERVICE)</code>获得的，而Context的实现一般都在<code>ContextImpl</code>中，那我们就看一下ContextImpl是怎么实现getSystemService的：<br><code>frameworks/base/core/java/android/app/ContextImpl.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>frameworks/base/core/java/android/app/SystemServiceRegistry.java</code></p>
<p>(<code>SystemServiceRegistry</code>是 Android 6.0之后才有的，Android 6.0 之前的代码没有该类，下面的代码是直接写在<code>ContextImpl</code>里的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher &#x3D; SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    return fetcher !&#x3D; null ? fetcher.getService(ctx) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SYSTEM_SERVICE_MA</code>P是一个HashMap，通过我们服务的名字name字符串，从这个HashMap里取出一个ServiceFetcher，再return这个ServiceFetcher的getService()。ServiceFetcher是什么？它的getService()又是什么？既然他是从SYSTEM_SERVICE_MAP这个HashMap里get出来的，那就找一找这个HashMap都put了什么。<br>通过搜索SystemServiceRegistry可以找到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,</span><br><span class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</span><br><span class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里往<code>SYSTEM_SERVICE_MAP</code>里<code>put</code>了一对<code>String</code>与<code>ServiceFetcher</code>组成的key/value对，<code>registerService()</code>又是从哪里调用的？继续搜索可以发现很多类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    registerService(Context.ACCESSIBILITY_SERVICE, AccessibilityManager.class,</span><br><span class="line">            new CachedServiceFetcher&lt;AccessibilityManager&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public AccessibilityManager createService(ContextImpl ctx) &#123;</span><br><span class="line">            return AccessibilityManager.getInstance(ctx);</span><br><span class="line">        &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    registerService(Context.VIBRATOR_SERVICE, Vibrator.class,</span><br><span class="line">            new CachedServiceFetcher&lt;Vibrator&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Vibrator createService(ContextImpl ctx) &#123;</span><br><span class="line">            return new SystemVibrator(ctx);</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SystemServiceRegistry</code>的static代码块里通过<code>registerService</code>注册了很多的系统服务，其中就包括我们正在调查的<code>VIBRATOR_SERVICE</code>，通过结合上面的分析代码可以可以知道<code>getSystemService(Context.VIBRATOR_SERVICE)</code>得到的是一个<code>SystemVibrator</code>的实例，通过查看<code>SystemVibrator</code>的代码也可以发现<code>SystemVibrator</code>确实是继承自Vibrator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class SystemVibrator extends Vibrator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再从<code>SystemVibrator</code>看一下系统的振动控制是怎么实现的。以<code>hasVibrator()</code>为例，这个是查询当前系统是否能够振动，在<code>SystemVibrator</code>中它的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasVibrator() &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        return mService.hasVibrator();</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接调用了一个<code>mService.hasVibrator()</code>。<code>mService</code>是什么？哪来的？搜索一下可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final IVibratorService mService;</span><br><span class="line">public SystemVibrator() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mService &#x3D; IVibratorService.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(&quot;vibrator&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mService</code> 是一个<code>IVibratorService</code>，我们先不去管<code>IVibratorService.Stub.asInterface</code>是怎么回事，先看一下<code>IVibratorService</code>是什么。搜索一下代码发现这并不是一个java文件，而是一个aidl文件：<code>frameworks/base/core/java/android/os/IVibratorService.aidl</code><br>AIDL (Android Interface Definition Language) 是Android中的接口定义文件，为系统提供了一种简单跨进程通信方法。<br>IVibratorService 中定义了几个接口，SystemVibrator中使用的也是这几个接口，包括我们刚才使用的hasVibrator()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IVibratorService</span><br><span class="line">&#123;</span><br><span class="line">    boolean hasVibrator();</span><br><span class="line">    void vibrate(...);</span><br><span class="line">    void vibratePattern(...);</span><br><span class="line">    void cancelVibrate(IBinder token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又只是接口定义，接口实现在哪呢？通过在<code>frameworks/base</code>目录下进行grep搜索，或者在AndroidXRef搜索，可以发现IVibratorService接口的实现在<code>frameworks/base/services/java/com/android/server/VibratorService.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class VibratorService extends IVibratorService.Stub</span><br></pre></td></tr></table></figure>

<p>可以看到 VibratorService实现了IVibratorService定义的所有接口，并通过JNI调用到native层，进行更底层的实现。更底层的实现不是这篇文档讨论的内容，我们需要分析的是VibratorService怎么成为系统服务的。那么VibratorService是怎么注册为系统服务的呢？在SystemServer里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VibratorService vibrator &#x3D; null;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;实例化VibratorService并添加到ServiceManager</span><br><span class="line">traceBeginAndSlog(&quot;StartVibratorService&quot;);</span><br><span class="line">vibrator &#x3D; new VibratorService(context);</span><br><span class="line">ServiceManager.addService(&quot;vibrator&quot;, vibrator);</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;通知服务系统启动完成</span><br><span class="line">Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;MakeVibratorServiceReady&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    vibrator.systemReady();</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    reportWtf(&quot;making Vibrator Service ready&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br></pre></td></tr></table></figure>

<p>这样在<code>SystemVibrator</code>里就可以通过下面的代码连接到<code>VibratorService</code>，与底层的系统服务进行通信了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IVibratorService.Stub.asInterface(ServiceManager.getService(&quot;vibrator&quot;));</span><br></pre></td></tr></table></figure>

<p><code>mService</code>相当于<code>IVibratorService</code>在应用层的一个代理，所有的实现还是在<code>SystemServer</code>的<code>VibratorService</code>里。</p>
<p>看代码时可以发现<code>registerService</code>是在static代码块里静态调用的，所以<code>getSystemServcr</code>获得的各个Manager也都是单例的。</p>
<h1 id="System-Service实现流程"><a href="#System-Service实现流程" class="headerlink" title="System Service实现流程"></a>System Service实现流程</h1><p><strong>从上面的分析，我们可以总结出Vibrator服务的整个实现流程：</strong></p>
<ol>
<li><p>定义一个抽象类<code>Vibrator</code>，定义了应用中可以访问的一些抽象方法(抽象)<br><code>frameworks/base/core/java/android/os/Vibrator.java</code></p>
</li>
<li><p>定义具体的类<code>SystemVibrator</code>继承<code>Vibrator</code>，实现抽象方法（客户端调用）</p>
<p><code>frameworks/base/core/java/android/os/SystemVibrator.java</code></p>
</li>
<li><p>定义一个AIDL接口文件<code>IVibratorService</code>，定义系统服务接口（服务端接口）<br>frameworks/base/core/java/android/os/IVibratorService.aidl</p>
</li>
<li><p>定义服务VibratorService，实现IVibratorService定义的接口(服务端实现)<br><code>frameworks/base/services/java/com/android/server/VibratorService.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class VibratorService extends IVibratorService.Stub</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>VibratorServicey</code>添加到系统服务<br><code>frameworks/base/services/java/com/android/server/SystemServer.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VibratorService vibrator &#x3D; null;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;实例化VibratorService并添加到ServiceManager</span><br><span class="line">Slog.i(TAG, &quot;Vibrator Service&quot;);</span><br><span class="line">vibrator &#x3D; new VibratorService(context);</span><br><span class="line">ServiceManager.addService(&quot;vibrator&quot;, vibrator);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;通知服务系统启动完成</span><br><span class="line">try &#123;</span><br><span class="line">    vibrator.systemReady();</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    reportWtf(&quot;making Vibrator Service ready&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>SystemVibrator</code>中通过<code>IVibratorService</code>的代理连接到<code>VibratorService</code>，这样<code>SystemVibrator</code>的接口实现里就可以调用<code>IVibratorService</code>的接口：</p>
<p><code>frameworks/base/core/java/android/os/SystemVibrator.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final IVibratorService mService;</span><br><span class="line">...</span><br><span class="line">public SystemVibrator() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mService &#x3D; IVibratorService.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(&quot;vibrator&quot;));</span><br><span class="line">    ...</span><br><span class="line">    public boolean hasVibrator() &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            return mService.hasVibrator();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>Context</code>里定义一个代表<code>Vibrator</code>服务的字符串</p>
<p><code>frameworks/base/core/java/android/content/Context.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String VIBRATOR_SERVICE &#x3D; &quot;vibrator&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ContextImpl里添加SystemVibrator的实例化过程<br><code>frameworks/base/core/java/android/app/ContextImpl.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registerService(VIBRATOR_SERVICE, new ServiceFetcher() &#123;</span><br><span class="line">public Object createService(ContextImpl ctx) &#123;</span><br><span class="line">    return new SystemVibrator(ctx);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用中使用<code>Vibrator</code>的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vibrator mVibrator &#x3D; (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">mVibrator.vibrate(500);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为保证编译正常，还需要将AIDL文件添加到编译配置里<br><code>frameworks/base/Android.mk</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES +&#x3D; \</span><br><span class="line">...</span><br><span class="line">core&#x2F;java&#x2F;android&#x2F;os&#x2F;IVibratorService.aidl \</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="System-Service-新加接口"><a href="#System-Service-新加接口" class="headerlink" title="System Service 新加接口"></a>System Service 新加接口</h1><p>如果我们需要实现一个新的系统服务，就可以按照上面的步骤在系统中扩展出一个新的服务，并给应用层提供出使用接口。如果想在Vibrator里添加一个新的接口，需要下面3步：</p>
<ol>
<li>在<code>IVibratorService</code>添加接口；</li>
<li>在<code>VibratorService</code>添加接口的实现；</li>
<li>在<code>Vibrator</code>及<code>SystemVibrator</code>里扩展新的接口；</li>
</ol>
<p>这样应用中就可以使用<code>Vibrator</code>的新接口了。</p>
<h1 id="应用层与-System-Service-通信"><a href="#应用层与-System-Service-通信" class="headerlink" title="应用层与 System Service 通信"></a>应用层与 System Service 通信</h1><p>上面的实现我们看到的只是从应用层通过服务代理，调用系统服务的接口，如果我们想反过来，将系统服务的状态通知给应用层，该怎么做呢？</p>
<ul>
<li>方法一：使用Broadcast</li>
</ul>
<p>我们知道使用Broadcast广播可以实现跨进程的消息传递，一些系统服务也使用了这种方法。如电池管理服务BatteryManagerService，收到底层上报的电池状态变化信息时，就将当前的电池状态封装在一个Intent里，action为android.intent.action.BATTERY_CHANGED。应用只要注册一个对应的BroadcastReceiver就可以收到BatterManagerService发送的电池状态信息。</p>
<ul>
<li>方法二：使用AIDL</li>
</ul>
<p>从上面我们可以知道，通过AIDL定义一套接口，由系统服务端实现这些接口，应用端使用一个相应的代理就可以访问系统服务的接口，那反过来让应用端实现AIDL接口，系统服务端使用代理调用应用端的接口可不可以呢？答案是YES。那么接下来的问题是怎么让系统服务得到这个代理。我们再来看一个LocationManager的例子。</p>
<p><code>LocationManager</code>是系统的定位服务，应用通过<code>LocationManager</code>可以获得设备当前的地理位置信息。下面是<code>LocationManager</code>的使用代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获得定位服务</span><br><span class="line">LocationManager locationManager &#x3D; </span><br><span class="line">        (LocationManager) getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义定位监听器</span><br><span class="line">LocationListener locationListener &#x3D; new LocationListener() &#123;</span><br><span class="line">    public void onLocationChanged(Location location) &#123;</span><br><span class="line">        &#x2F;&#x2F;监听到位置信息</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册监听器</span><br><span class="line">locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, </span><br><span class="line">        0, 0, locationListener);</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，我们创建了一个位置监听器LocationListener，并将这个监听器在LocationManager里进行了注册。当系统定位到系统的位置后，就会回调监听器的onLocationChanged()，将位置信息通知给监听器。LocationListener就是一个系统服务调用应用层接口的例子，我们就研究一下LocationListener的实现方式。</p>
<p>我们先从<code>LocationManager</code>怎么注册<code>LocationListener</code>开始研究：<br><code>frameworks/base/location/java/android/location/LocationManager.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private final ILocationManager mService;</span><br><span class="line">...</span><br><span class="line">private void requestLocationUpdates(LocationRequest request, </span><br><span class="line">        LocationListener listener, Looper looper, PendingIntent intent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; wrap the listener class</span><br><span class="line">    ListenerTransport transport &#x3D; wrapListener(listener, looper);</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.requestLocationUpdates(request, transport, </span><br><span class="line">                intent, packageName);</span><br><span class="line">   &#125; catch (RemoteException e) &#123;</span><br><span class="line">       Log.e(TAG, &quot;RemoteException&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到LocationListener被重新封装成了一个ListenerTransport，然后传递给了ILocationManager ，从前面的分析可以猜测到这个ILocationManager应该就是LocationManagerService的一个代理。那么ListenerTransport又是什么呢？搜索LocationManager.java可以找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private class ListenerTransport extends ILocationListener.Stub &#123;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void onLocationChanged(Location location) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是<code>ILocationListener.Stub</code>的一个继承实现，那么<code>ILocationListener</code>应该就是一个AIDL接口定义：</p>
<p><code>frameworks/base/location/java/android/location/ILocationListener.aidl</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oneway interface ILocationListener</span><br><span class="line">&#123;</span><br><span class="line">    void onLocationChanged(in Location location);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>LocationManagerService</code>里只要调用<code>ILocationListener</code>的方法就可以将消息传递给应用层的监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mListener.onLocationChanged(new Location(location));</span><br></pre></td></tr></table></figure>

<h1 id="实现-System-Service-的注意事项"><a href="#实现-System-Service-的注意事项" class="headerlink" title="实现 System Service 的注意事项"></a>实现 System Service 的注意事项</h1><ul>
<li><strong>注意防止阻塞</strong></li>
</ul>
<p>应用层访问系统服务提供的接口时会有两种情况：</p>
<ol>
<li>一种是应用调用端需要等待服务实现端处理完成，返回处理结果，这样如果服务端发生阻塞，那么应用端也会发生阻塞，因此在实现服务端的实现时要注意不要发生阻塞。</li>
<li>另一种是调用端不需要等待服务端返回结果，调用完成后直接返回<code>void</code>，这样服务端发生阻塞不会影响到应用端，这样的单向的接口在AIDL里定义时需要添加<code>oneway</code>关键字，如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneway void statusBarVisibilityChanged(int visibility);</span><br></pre></td></tr></table></figure>

<p>对于需要在服务端调用，在应用端实现的接口，考虑到系统的稳定性以及安全性，一般都会设计成上面的第二种，即AIDL里所有的接口都是单向的，如上面的<code>ILocationListener</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneway interface ILocationListener</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意多线程访问</strong></li>
</ul>
<p>每个系统服务在系统进程中只有一个实例，而且应用中系统服务的代理也是单例的，而且应用端的访问，在系统进程都是使用独立的线程进行响应，所以访问同一个系统服务的接口时必然会出现多个线程或者多个进程同时访问的情况。为保证系统服务的线程安全，需要对系统服务的进程进行多线程访问的保护，目前主要有两种实现线程安全的方法：</p>
<ol>
<li><p>一种是通过同步锁机制，锁住一个对象实例（一般是这个服务对象本身），这样这个服务同一时间只能响应一个访问请求，如<code>LocationManagerService</code>里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean callStatusChangedLocked(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种方法就是使用<code>Handler</code>机制，这种服务一般会创建一个单独的线程，当有应用端访问请求到来时会向服务线程的<code>Handler</code>里发送一个<code>Message</code>，利用单线程顺序执行的特性，保证所有的访问都按顺序进行处理，但这种方法只适合单向的访问，不适合需要返回的双向访问。</p>
</li>
</ol>
<h1 id="ServiceManager原理"><a href="#ServiceManager原理" class="headerlink" title="ServiceManager原理"></a>ServiceManager原理</h1><p>从上面流程的分析我们可以看到，所有的系统服务最终都是由<code>ServiceManager</code>来管理的，那么<code>ServiceManager</code>是怎么管理这些系统服务的呢？还是先看上面的<code>VibratorService</code>的实现：</p>
<p><img src="https://img-blog.csdn.net/20171220150919660?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2V5dW5mZWlf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>VibratorService通过addService()将自己注册到ServiceManager里，SystemVibrator通过getService()获得一个服务代理，并与服务进行通信交互，那么ServiceManager又是什么？它是怎么管理服务的注册与代理的呢？我们先从addService()与getService()开始，分析一下ServiceManager:</p>
<p><code>frameworks/base/core/java/android/os/ServiceManager.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        ...</span><br><span class="line">        getIServiceManager().addService(name, service, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return getIServiceManager().getService(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&#96;addService()&#96;和&#96;getService()&#96;都是直接调用了&#96;getIServiceManager()&#96;的方法，&#96;getIServiceManager()&#96;返回的又是什么呢？</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">    if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Find the service manager</span><br><span class="line">    sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">    return sServiceManager;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">这里是创建了一个&#96;IServiceManager&#96;类型的单实例，具体的实例又是通过&#96;ServiceManagerNative&#96;创建的:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">先来看&#96;BinderInternal.getContextObject()&#96;</span><br><span class="line">&#96;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;BinderInternal.java&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">public static final native IBinder getContextObject();</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&#96;getContextObject()&#96;是在native层实现的</span><br><span class="line">&#96;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, </span><br><span class="line">        jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b &#x3D; ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">后面的实现过程逻辑比较复杂，这里就不详细分析了，只是说明一下大致流程，感兴趣的可以自己详细研究一下binder的实现机制。</span><br><span class="line"></span><br><span class="line">ProcessState从名字可以看出这应该是一个保存进程状态的类，最好应该用单实例的对象保存，所以ProcessState::self()得到的也就是ProcessState的一个单实例对象，它的getContextObject()会继续调用getStrongProxyForHandle(int32_t handle)返回一个IBinder</span><br><span class="line"></span><br><span class="line">&#96;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller)</span><br><span class="line">&#123;</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">在getStrongProxyForHandle()中会根据传入的参数handle创建一个BpBinder，这个BpBinder会保存在一个数组mHandleToObject中，下次再用同样的handle请求时不会再重新创建。由于我们传入的handle&#x3D;0，这里创建的BpBinder也就相当于第0号BpBinder。</span><br><span class="line">之后的javaObjectForIBinder()会将C++的BpBinder对象封装成Java的BinderProxy对象并返回。所以BinderInternal.getContextObject()得到的是一个BinderProxy对象，并关联了native层的第0号BpBinder。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">ServiceManagerNative.asInterface(new BinderProxy());</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">ServiceManagerNative.asInterface()又做了些什么呢？</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&#96;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ServiceManagerNative.java&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    return new ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">这里会将&#96;BinderProxy&#96;再封装成一个&#96;ServiceManagerProxy()&#96;，所以&#96;getIServiceManager()&#96;得到的其实是一个&#96;ServiceManagerProxy&#96;，但是底层指向的是一个&#96;BpBinder(0)&#96;。</span><br><span class="line"></span><br><span class="line">&#96;ServiceManagerProxy&#96;、&#96;BinderProxy&#96;以及&#96;BpBinder&#96;都是代理模式中的proxy端，真正的实现应该在对应的native端。我们接着看。</span><br><span class="line"></span><br><span class="line">&#96;addService()&#96;和&#96;getService()&#96;在代理端的实现应该是在&#96;ServiceManagerProxy()&#96;里：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    return binder;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">        throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">从上面两个方法的实现可以看到，首先是创建了两个可序列化的Parcel data、reply，传入的参数被放到了data里，data、reply又一起传给了mRemote.transact()，之后又从reply里读取结果。addService()的实现里还通过data.writeStrongBinder(service)写入了一个IBinder的实例。同时注意到getService()和addService()里面调用mRemote.transact()传递的第一个参数分别为GET_SERVICE_TRANSACTION 和 ADD_SERVICE_TRANSACTION ，我们可以在IServiceManager里看到这是两个int值，分别为1和3</span><br><span class="line"></span><br><span class="line">&#96;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;IServiceManager.java&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">int GET_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION;  &#x2F;&#x2F;值为1</span><br><span class="line">int CHECK_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+1;</span><br><span class="line">int ADD_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+2;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&#96;mRemote&#96;就是&#96;BinderProxy&#96;，真正的实现是C++里的&#96;BpBinder&#96;</span><br><span class="line">&#96;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">status_t BpBinder::transact(</span><br><span class="line">        uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">IPCThreadState里的transact会将proxy端的请求通过binder机制写入到一块共享内存里，然后会有一个native端从共享内存里读出请求，并执行相应的操作。那么这个native端在哪里呢？是不是ServiceManagerNative呢？但是ServiceManagerNative只是一个抽象类，我们并没有找到继承自它的子类。实际上ServiceManagerNative只是架构方面的一个抽象定义，并没有真正的一个实现，真正实现ServiceManager 的native端功能的是在native层的service_manager.c中。</span><br><span class="line"></span><br><span class="line">service_manager是底层的一个独立进程，主要的实现代码就在&#96;service_manager.c&#96;中。</span><br><span class="line"></span><br><span class="line">&#96;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.h&#96;</span><br></pre></td></tr></table></figure>
<p>enum {<br>    /* Must match definitions in IBinder.h and IServiceManager.h */<br>    PING_TRANSACTION  = B_PACK_CHARS(‘_’,’P’,’N’,’G’),<br>    SVC_MGR_GET_SERVICE = 1,<br>    SVC_MGR_CHECK_SERVICE,<br>    SVC_MGR_ADD_SERVICE,<br>    SVC_MGR_LIST_SERVICES,<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c&#96;</span><br></pre></td></tr></table></figure>
<p>#include “binder.h”<br>…<br>int svcmgr_handler(struct binder_state *bs,<br>                   struct binder_transaction_data *txn,<br>                   struct binder_io *msg,<br>                   struct binder_io *reply)<br>{<br>    …<br>    switch(txn-&gt;code) {<br>    case SVC_MGR_GET_SERVICE:<br>    case SVC_MGR_CHECK_SERVICE:<br>        s = bio_get_string16(msg, &amp;len);<br>        if (s == NULL) {<br>            return -1;<br>        }<br>        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);<br>        if (!handle)<br>            break;<br>        bio_put_ref(reply, handle);<br>        return 0;</p>
<pre><code>case SVC_MGR_ADD_SERVICE:
    s = bio_get_string16(msg, &amp;len);
    if (s == NULL) {
        return -1;
    }
    handle = bio_get_ref(msg);
    allow_isolated = bio_get_uint32(msg) ? 1 : 0;
    if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,
        allow_isolated, txn-&gt;sender_pid))
        return -1;
    break;
    ...
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service_manager.c的svcmgr_handler函数就是监听代理端请求命令的txn-&gt;code就是mRemote.transact()里传过来的第一个参数。SVC_MGR_GET_SERVICE和SVC_MGR_ADD_SERVICE是在头文件binder.h里定义的，它们的值与IServiceManager.java里定义的一致，也是1和3。</span><br><span class="line">我们先看SVC_MGR_ADD_SERVICE的响应：</span><br><span class="line"></span><br><span class="line">首先通过s &#x3D; bio_get_string16(msg, &amp;len)获得了service的名称，</span><br><span class="line">然后通过handle &#x3D; bio_get_ref(msg)获得了一个handle，这个handle就是我们之前通过writeStrongBinder写入的IBinder，</span><br><span class="line">最后通过do_add_service()添加注册service&#96;do_add_service()&#96;的实现如下：</span><br></pre></td></tr></table></figure>
<p>int do_add_service(struct binder_state <em>bs,<br>                   const uint16_t <em>s, size_t len,<br>                   uint32_t handle, uid_t uid, int allow_isolated,<br>                   pid_t spid)<br>{<br>    struct svcinfo *si;<br>    si = find_svc(s, len);<br>    if (si) {<br>        if (si-&gt;handle) {<br>            ALOGE(“add_service(‘%s’,%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n”,<br>                 str8(s, len), handle, uid);<br>            svcinfo_death(bs, si);<br>        }<br>        si-&gt;handle = handle;<br>    } else {<br>        si = malloc(sizeof(</em>si) + (len + 1) * sizeof(uint16_t));<br>        si-&gt;handle = handle;<br>        si-&gt;len = len;<br>        memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t));<br>        si-&gt;name[len] = ‘\0’;<br>        si-&gt;death.func = (void</em>) svcinfo_death;<br>        si-&gt;death.ptr = si;<br>        si-&gt;allow_isolated = allow_isolated;<br>        si-&gt;next = svclist;<br>        svclist = si;<br>    }<br>    …<br>}</p>
<p>struct svcinfo *find_svc(const uint16_t *s16, size_t len)<br>{<br>    struct svcinfo *si;</p>
<pre><code>for (si = svclist; si; si = si-&gt;next) {
    if ((len == si-&gt;len) &amp;&amp;
        !memcmp(s16, si-&gt;name, len * sizeof(uint16_t))) {
        return si;
    }
}
return NULL;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 首先声明了一个struct svcinfo *si</span><br><span class="line">- 通过find_svc(s, len)查找一下同样名称的service之前是不是注册过，防止重复注册。find_svc()的实现里可以看到是通过遍历一个svclist链表来查重的，svclist链表就是用来保存所有注册过的service的</span><br><span class="line">- 如果确认没有重复注册service，就重新构造一个svcinfo添加到svclist链表的头部。</span><br><span class="line"></span><br><span class="line">我们再看SVC_MGR_GET_SERVICE的响应，主要是通过do_find_service()查找到对应的service，并通过bio_put_ref(reply, handle)将查找到的handle返回。do_find_service()的实现主要也是通过find_svc()去svclist链表中查找</span><br></pre></td></tr></table></figure>
<p>uint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)<br>{<br>    struct svcinfo *si = find_svc(s, len);<br>    …<br>    return si-&gt;handle;<br>}</p>
<pre><code>
通过上面的流程梳理我们最终了解到：

-  每个System Service通过调用ServiceManager.addService()将自己的名字以及IBinder引用保存到servicemanager进程的一个链表里

- 每个使用该System Service的进程通过调用ServiceManager.getService()从service_manager进程获得该System Service对应的IBinder，就可以与该System Service进行通信了。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer/" itemprop="url">Android系统启动-SystemServer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T11:05:49+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-SystemServer/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">  - ZygoteInit.java</span><br><span class="line">  - RuntimeInit.java</span><br><span class="line">  - Zygote.java</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;</span><br><span class="line">  - SystemServer.java</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;</span><br><span class="line">  - com_android_internal_os_Zygote.cpp</span><br><span class="line">  - AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;App_main.cpp</span><br></pre></td></tr></table></figure>

<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>SystemServer的在Android体系中所处的地位，SystemServer由Zygote fork生成的，进程名为<code>system_server</code>，该进程承载着framework的核心服务。 <a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Android系统启动-zygote篇</a>中讲到Zygote启动过程中会调用startSystemServer()，可知<code>startSystemServer()</code>函数是system_server启动流程的起点， 启动流程图如下：<img src="http://gityuan.com/images/boot/systemServer/system_server.jpg" alt="system_server_boot_process"></p>
<p>上图前4步骤（即颜色为紫色的流程）运行在是<code>Zygote</code>进程，从第5步（即颜色为蓝色的流程）ZygoteInit.handleSystemServerProcess开始是运行在新创建的<code>system_server</code>，这是fork机制实现的（fork会返回2次）。下面从startSystemServer()开始讲解详细启动流程。</p>
<h2 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a><code>ZygoteInit</code></h2><p>在Android9.0版本是在main方法中直接调用,开启system_server后直接运行。</p>
<h3 id="main"><a href="#main" class="headerlink" title="main()"></a><code>main()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">		...</span><br><span class="line">	if (startSystemServer) &#123;</span><br><span class="line">                Runnable r &#x3D; forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; &#123;@code r &#x3D;&#x3D; null&#125; in the parent (zygote) process, and &#123;@code r !&#x3D; null&#125; in the</span><br><span class="line">                &#x2F;&#x2F; child (system_server) process.</span><br><span class="line">                if (r !&#x3D; null) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer()"></a><code>forkSystemServer()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private static Runnable forkSystemServer(String abiList, String socketName,</span><br><span class="line">            ZygoteServer zygoteServer) &#123;</span><br><span class="line">        &#x2F;* Hardcoded command line to start the system server *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;参数准备</span><br><span class="line">        String args[] &#x3D; &#123;</span><br><span class="line">            &quot;--setuid&#x3D;1000&quot;,</span><br><span class="line">            &quot;--setgid&#x3D;1000&quot;,</span><br><span class="line">            &quot;--setgroups&#x3D;1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010&quot;,</span><br><span class="line">            &quot;--capabilities&#x3D;&quot; + capabilities + &quot;,&quot; + capabilities,</span><br><span class="line">            &quot;--nice-name&#x3D;system_server&quot;,</span><br><span class="line">            &quot;--runtime-args&quot;,</span><br><span class="line">            &quot;--target-sdk-version&#x3D;&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">            &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line">        ZygoteConnection.Arguments parsedArgs &#x3D; null;</span><br><span class="line"></span><br><span class="line">        int pid;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"> 		        &#x2F;&#x2F;用于解析参数，生成目标格式</span><br><span class="line">            parsedArgs &#x3D; new ZygoteConnection.Arguments(args);</span><br><span class="line">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">            boolean profileSystemServer &#x3D; SystemProperties.getBoolean(</span><br><span class="line">                    &quot;dalvik.vm.profilesystemserver&quot;, false);</span><br><span class="line">            if (profileSystemServer) &#123;</span><br><span class="line">                parsedArgs.runtimeFlags |&#x3D; Zygote.PROFILE_SYSTEM_SERVER;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* Request to fork the system server process *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F; fork子进程，该进程是system_server进程</span><br><span class="line">            pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    null,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">        &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* For child process *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 完成system_server进程剩余的工作</span><br><span class="line">        if (pid &#x3D;&#x3D; 0) &#123;				    </span><br><span class="line">            if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line">						&#x2F;&#x2F;关闭父进程zygote复制而来的Socket</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            &#x2F;&#x2F; 完成system_server进程剩余的工作</span><br><span class="line">            return handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>Zygote.forkSystemServer()</code>来创建<code>system_server</code>进程，返回进程pid，最后执行<code>handleSystemServerProcess</code>方法做后续处理。</p>
<h1 id="如何创建system-server进程"><a href="#如何创建system-server进程" class="headerlink" title="如何创建system_server进程"></a>如何创建<code>system_server</code>进程</h1><h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a><code>Zygote</code></h2><h3 id="forkSystemServer-1"><a href="#forkSystemServer-1" class="headerlink" title="forkSystemServer()"></a><code>forkSystemServer()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,</span><br><span class="line">            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</span><br><span class="line">        VM_HOOKS.preFork();</span><br><span class="line">        &#x2F;&#x2F; Resets nice priority for zygote process.</span><br><span class="line">        resetNicePriority();</span><br><span class="line">        int pid &#x3D; nativeForkSystemServer(</span><br><span class="line">                uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">        &#x2F;&#x2F; Enable tracing as soon as we enter the system_server.</span><br><span class="line">        if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            Trace.setTracingEnabled(true, runtimeFlags);</span><br><span class="line">        &#125;</span><br><span class="line">        VM_HOOKS.postForkCommon();</span><br><span class="line">        return pid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>nativeForkSystemServer()方法在AndroidRuntime.cpp中注册的，调用com_android_internal_os_Zygote.cpp中的register_com_android_internal_os_Zygote()方法建立native方法的映射关系，所以接下来进入如下方法。</p>
<h3 id="nativeForkSystemServer"><a href="#nativeForkSystemServer" class="headerlink" title="nativeForkSystemServer()"></a><code>nativeForkSystemServer()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,</span><br><span class="line">            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);</span><br></pre></td></tr></table></figure>

<h2 id="com-android-internal-os-Zygote"><a href="#com-android-internal-os-Zygote" class="headerlink" title="com_android_internal_os_Zygote"></a><code>com_android_internal_os_Zygote</code></h2><h3 id="com-android-internal-os-Zygote-nativeForkSystemServer"><a href="#com-android-internal-os-Zygote-nativeForkSystemServer" class="headerlink" title="com_android_internal_os_Zygote_nativeForkSystemServer()"></a><code>com_android_internal_os_Zygote_nativeForkSystemServer()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkSystemServer(</span><br><span class="line">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span><br><span class="line">        jlong effectiveCapabilities) &#123;</span><br><span class="line">  &#x2F;&#x2F;fork子进程，见【见小节4】</span><br><span class="line">  pid_t pid &#x3D; ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities, effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,</span><br><span class="line">                                      NULL, NULL);</span><br><span class="line">  if (pid &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; zygote进程，检测system_server进程是否创建</span><br><span class="line">      gSystemServerPid &#x3D; pid;</span><br><span class="line">      int status;</span><br><span class="line">      if (waitpid(pid, &amp;status, WNOHANG) &#x3D;&#x3D; pid) &#123;</span><br><span class="line">          &#x2F;&#x2F;当system_server进程死亡后，重启zygote进程</span><br><span class="line">          RuntimeAbort(env);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当system_server进程创建失败时，将会重启zygote进程。这里需要注意，对于Android 5.0以上系统，有两个zygote进程，分别是zygote、zygote64两个进程，system_server的父进程，一般来说64位系统其父进程是zygote64进程</p>
<ul>
<li>当kill system_server进程后，只重启zygote64和system_server，不重启zygote;</li>
<li>当kill zygote64进程后，只重启zygote64和system_server，也不重启zygote；</li>
<li>当kill zygote进程，则重启zygote、zygote64以及system_server。</li>
</ul>
<h3 id="ForkAndSpecializeCommon"><a href="#ForkAndSpecializeCommon" class="headerlink" title="ForkAndSpecializeCommon()"></a><code>ForkAndSpecializeCommon()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  SetSigChldHandler(); &#x2F;&#x2F;设置子进程的signal信号处理函数</span><br><span class="line">  pid_t pid &#x3D; fork(); &#x2F;&#x2F;fork子进程</span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入子进程</span><br><span class="line">    DetachDescriptors(env, fdsToClose); &#x2F;&#x2F;关闭并清除文件描述符</span><br><span class="line"></span><br><span class="line">    if (!is_system_server) &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非system_server子进程，则创建进程组</span><br><span class="line">        int rc &#x3D; createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); &#x2F;&#x2F;设置设置group</span><br><span class="line">    SetRLimits(env, javaRlimits); &#x2F;&#x2F;设置资源limit</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; setresgid(gid, gid, gid);</span><br><span class="line">    rc &#x3D; setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); &#x2F;&#x2F;设置调度策略</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;selinux上下文</span><br><span class="line">    rc &#x3D; selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    if (se_info_c_str &#x3D;&#x3D; NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str &#x3D; &quot;system_server&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (se_info_c_str !&#x3D; NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); &#x2F;&#x2F;设置线程名为system_server，方便调试</span><br><span class="line">    &#125;</span><br><span class="line">    UnsetSigChldHandler(); &#x2F;&#x2F;设置子进程的signal信号处理函数为默认函数</span><br><span class="line">    &#x2F;&#x2F;等价于调用zygote.callPostForkChildHooks()</span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入父进程，即zygote进程</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork()创建新进程，采用copy on write方式，这是linux创建进程的标准方法，会有两次return,对于pid==0为子进程的返回，对于pid&gt;0为父进程的返回。 到此system_server进程已完成了创建的所有工作，接下来开始了system_server进程的真正工作。在前面startSystemServer()方法中，zygote进程执行完forkSystemServer()后，新创建出来的system_server进程便进入handleSystemServerProcess()方法。关于fork()，可查看另一个文章<a href="http://gityuan.com/2016/03/26/app-process-create/#nativeforkandspecialize" target="_blank" rel="noopener">理解Android进程创建流程</a>。</p>
<h1 id="system-server进程已创建看看如何做后续处理"><a href="#system-server进程已创建看看如何做后续处理" class="headerlink" title="system_server进程已创建看看如何做后续处理"></a>system_server进程已创建看看如何做后续处理</h1><h2 id="ZygoteInit-1"><a href="#ZygoteInit-1" class="headerlink" title="ZygoteInit"></a><code>ZygoteInit</code></h2><h3 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess()"></a><code>handleSystemServerProcess()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) &#123;</span><br><span class="line">        &#x2F;&#x2F; set umask to 0077 so new files and directories will default to owner-only permissions.</span><br><span class="line">        Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line">				&#x2F;&#x2F;设置当前进程名为&quot;system_server&quot;</span><br><span class="line">        if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">            Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String systemServerClasspath &#x3D; Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">        if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行dex优化操作</span><br><span class="line">            performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">            &#x2F;&#x2F; Capturing profiles is only supported for debug or eng builds since selinux normally</span><br><span class="line">            &#x2F;&#x2F; prevents it.</span><br><span class="line">            boolean profileSystemServer &#x3D; SystemProperties.getBoolean(</span><br><span class="line">                    &quot;dalvik.vm.profilesystemserver&quot;, false);</span><br><span class="line">            if (profileSystemServer &amp;&amp; (Build.IS_USERDEBUG || Build.IS_ENG)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    prepareSystemServerProfile(systemServerClasspath);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;Failed to set up system server profile&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">						&#x2F;&#x2F;启动应用进程</span><br><span class="line">            WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    VMRuntime.getCurrentInstructionSet(), null, args);</span><br><span class="line"></span><br><span class="line">            throw new IllegalStateException(&quot;Unexpected return from WrapperInit.execApplication&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建类加载器，并赋予当前线程</span><br><span class="line">            ClassLoader cl &#x3D; null;</span><br><span class="line">            if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">                cl &#x3D; createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">                Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">					  &#x2F;&#x2F;system_server故进入此分支</span><br><span class="line">            return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="zygoteInit"><a href="#zygoteInit" class="headerlink" title="zygoteInit()"></a><code>zygoteInit()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">        if (RuntimeInit.DEBUG) &#123;</span><br><span class="line">            Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);</span><br><span class="line">        &#x2F;&#x2F;重定向log输出</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line">				&#x2F;&#x2F; 通用的一些初始化</span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        &#x2F;&#x2F; zygote初始化</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        &#x2F;&#x2F; 应用初始化</span><br><span class="line">        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativeZygoteInit"><a href="#nativeZygoteInit" class="headerlink" title="nativeZygoteInit()"></a><code>nativeZygoteInit()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final native void nativeZygoteInit();</span><br></pre></td></tr></table></figure>

<h2 id="AndroidRuntime-cpp"><a href="#AndroidRuntime-cpp" class="headerlink" title="AndroidRuntime.cpp"></a><code>AndroidRuntime.cpp</code></h2><h3 id="com-android-internal-os-RuntimeInit-nativeZygoteInit"><a href="#com-android-internal-os-RuntimeInit-nativeZygoteInit" class="headerlink" title="com_android_internal_os_RuntimeInit_nativeZygoteInit()"></a><code>com_android_internal_os_RuntimeInit_nativeZygoteInit()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()，在binder系列文章中的<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a>详细这两个方法的执行原理。</p>
<h2 id="RuntimeInit"><a href="#RuntimeInit" class="headerlink" title="RuntimeInit"></a><code>RuntimeInit</code></h2><h3 id="applicationInit"><a href="#applicationInit" class="headerlink" title="applicationInit()"></a><code>applicationInit()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv,</span><br><span class="line">            ClassLoader classLoader) &#123;</span><br><span class="line">        &#x2F;&#x2F;true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span><br><span class="line">        nativeSetExitWithoutCleanup(true);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75</span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">				&#x2F;&#x2F;解析参数</span><br><span class="line">        final Arguments args &#x3D; new Arguments(argv);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The end of of the RuntimeInit event (see #zygoteInit).</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用startClass的static方法 main() </span><br><span class="line">        return findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在startSystemServer()方法中通过硬编码初始化参数，可知此处args.startClass为”com.android.server.SystemServer”。</p>
<h3 id="findStaticMain"><a href="#findStaticMain" class="headerlink" title="findStaticMain()"></a><code>findStaticMain()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable findStaticMain(String className, String[] argv,</span><br><span class="line">           ClassLoader classLoader) &#123;</span><br><span class="line">       Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">       &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Missing class when invoking static main &quot; + className,</span><br><span class="line">                   ex);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Method m;</span><br><span class="line">       try &#123;</span><br><span class="line">           m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">       &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">       &#125; catch (SecurityException ex) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Problem getting static main on &quot; + className, ex);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       int modifiers &#x3D; m.getModifiers();</span><br><span class="line">       if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Main method is not public and static on &quot; + className);</span><br><span class="line">       &#125;</span><br><span class="line">       return new MethodAndArgsCaller(m, argv);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a><code>MethodAndArgsCaller</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static class MethodAndArgsCaller implements Runnable &#123;</span><br><span class="line">        &#x2F;** method to call *&#x2F;</span><br><span class="line">        private final Method mMethod;</span><br><span class="line"></span><br><span class="line">        &#x2F;** argument array *&#x2F;</span><br><span class="line">        private final String[] mArgs;</span><br><span class="line"></span><br><span class="line">        public MethodAndArgsCaller(Method method, String[] args) &#123;</span><br><span class="line">            mMethod &#x3D; method;</span><br><span class="line">            mArgs &#x3D; args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause &#x3D; ex.getCause();</span><br><span class="line">                if (cause instanceof RuntimeException) &#123;</span><br><span class="line">                    throw (RuntimeException) cause;</span><br><span class="line">                &#125; else if (cause instanceof Error) &#123;</span><br><span class="line">                    throw (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口，通过反射执行SystemServer中manin方法。</p>
<h1 id="进入SystemServer中"><a href="#进入SystemServer中" class="headerlink" title="进入SystemServer中"></a>进入<code>SystemServer</code>中</h1><p>至此已经进入SystemServer中的main方法中，</p>
<h2 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a><code>SystemServer</code></h2><h3 id="main-1"><a href="#main-1" class="headerlink" title="main()"></a><code>main()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        new SystemServer().run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先初始化，在调用run方法</p>
<h3 id="run"><a href="#run" class="headerlink" title="run()"></a><code>run()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private void run() &#123;</span><br><span class="line">		&#x2F;&#x2F;当系统时间比1970年更早，就设置当前系统时间为1970年</span><br><span class="line">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;变更虚拟机的库文件，对于Android 6.0默认采用的是libart.so</span><br><span class="line">    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">    if (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;清除vm内存增长上限，由于启动过程需要较多的虚拟机内存空间</span><br><span class="line">    VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置内存的可能有效使用率为0.8</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</span><br><span class="line">    &#x2F;&#x2F; 针对部分设备依赖于运行时就产生指纹信息，因此需要在开机完成前已经定义</span><br><span class="line">    Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;访问环境变量前，需要明确地指定用户</span><br><span class="line">    Environment.setUserRequired(true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确保当前系统进程的binder调用，总是运行在前台优先级(foreground priority)</span><br><span class="line">    BinderInternal.disableBackgroundScheduling(true);</span><br><span class="line">    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 主线程looper就在当前线程运行</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;加载android_servers.so库，该库包含的源码在frameworks&#x2F;base&#x2F;services&#x2F;目录下</span><br><span class="line">    System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测上次关机过程是否失败，该方法可能不会返回[见小节1.2.1]</span><br><span class="line">    performPendingShutdown();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化系统上下文 【见小节1.3】</span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建系统服务管理</span><br><span class="line">    mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">    &#x2F;&#x2F;将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动各种系统服务</span><br><span class="line">    try &#123;</span><br><span class="line">        startBootstrapServices(); &#x2F;&#x2F; 启动引导服务【见小节1.4】</span><br><span class="line">        startCoreServices();      &#x2F;&#x2F; 启动核心服务【见小节1.5】</span><br><span class="line">        startOtherServices();     &#x2F;&#x2F; 启动其他服务【见小节1.6】</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于debug版本，将log事件不断循环地输出到dropbox（用于分析）</span><br><span class="line">    if (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;一直循环执行</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。</p>
<h3 id="performPendingShutdown"><a href="#performPendingShutdown" class="headerlink" title="performPendingShutdown()"></a><code>performPendingShutdown()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void performPendingShutdown() &#123;</span><br><span class="line">    final String shutdownAction &#x3D; SystemProperties.get(</span><br><span class="line">            ShutdownThread.SHUTDOWN_ACTION_PROPERTY, &quot;&quot;);</span><br><span class="line">    if (shutdownAction !&#x3D; null &amp;&amp; shutdownAction.length() &gt; 0) &#123;</span><br><span class="line">        boolean reboot &#x3D; (shutdownAction.charAt(0) &#x3D;&#x3D; &#39;1&#39;);</span><br><span class="line"></span><br><span class="line">        final String reason;</span><br><span class="line">        if (shutdownAction.length() &gt; 1) &#123;</span><br><span class="line">            reason &#x3D; shutdownAction.substring(1, shutdownAction.length());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reason &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当&quot;sys.shutdown.requested&quot;值不为空,则会重启或者关机</span><br><span class="line">        ShutdownThread.rebootOrShutdown(null, reboot, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createSystemContext"><a href="#createSystemContext" class="headerlink" title="createSystemContext()"></a><code>createSystemContext()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void createSystemContext() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建system_server进程的上下文信息</span><br><span class="line">    ActivityThread activityThread &#x3D; ActivityThread.systemMain();</span><br><span class="line">    mSystemContext &#x3D; activityThread.getSystemContext();</span><br><span class="line">    &#x2F;&#x2F;设置主题</span><br><span class="line">    mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://gityuan.com/2017/04/02/android-application/" target="_blank" rel="noopener">理解Application创建过程</a>已介绍过createSystemContext()过程， 该过程会创建对象有ActivityThread，Instrumentation, ContextImpl，LoadedApk，Application。</p>
<h3 id="startBootstrapServices"><a href="#startBootstrapServices" class="headerlink" title="startBootstrapServices()"></a><code>startBootstrapServices()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    &#x2F;&#x2F;阻塞等待与installd建立socket通道 Installer的onStart()</span><br><span class="line">    Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务ActivityManagerService</span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务PowerManagerService</span><br><span class="line">    mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化power management</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务LightsService</span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务DisplayManagerService</span><br><span class="line">    mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Phase100: 在初始化package manager之前，需要默认的显示.</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当设备正在加密时，仅运行核心</span><br><span class="line">    String cryptState &#x3D; SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore &#x3D; true;</span><br><span class="line">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务PackageManagerService</span><br><span class="line">    mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务UserManagerService，新建目录&#x2F;data&#x2F;user&#x2F;</span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置AMS</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动传感器服务</span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务.</p>
<h3 id="startCoreServices"><a href="#startCoreServices" class="headerlink" title="startCoreServices()"></a><code>startCoreServices()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">		    &#x2F;&#x2F;启动服务BatteryService，用于统计电池电量，需要LightService.</span><br><span class="line">        mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line">		    &#x2F;&#x2F;启动服务UsageStatsService，用于统计应用使用情况</span><br><span class="line">        mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">        mActivityManagerService.setUsageStatsManager(</span><br><span class="line">                LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) &#123;</span><br><span class="line">            traceBeginAndSlog(&quot;StartWebViewUpdateService&quot;);</span><br><span class="line">            &#x2F;&#x2F;启动服务WebViewUpdateService</span><br><span class="line">            mWebViewUpdateService &#x3D; mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">        &#125;</span><br><span class="line">        BinderCallsStatsService.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>启动服务BatteryService，UsageStatsService，WebViewUpdateService。</p>
<h3 id="startOtherServices"><a href="#startOtherServices" class="headerlink" title="startOtherServices()"></a><code>startOtherServices()</code></h3><p>该方法比较长，有近千行代码，逻辑很简单，主要是启动一系列的服务，这里就不具体列举源码了，在第四节直接对其中的服务进行一个简单分类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">       ...</span><br><span class="line">       SystemConfig.getInstance();</span><br><span class="line">       mContentResolver &#x3D; context.getContentResolver(); &#x2F;&#x2F; resolver</span><br><span class="line">       ...</span><br><span class="line">       mActivityManagerService.installSystemProviders(); &#x2F;&#x2F;provider</span><br><span class="line">       mSystemServiceManager.startService(AlarmManagerService.class); &#x2F;&#x2F; alarm</span><br><span class="line">       &#x2F;&#x2F; watchdog</span><br><span class="line">       watchdog.init(context, mActivityManagerService); </span><br><span class="line">       inputManager &#x3D; new InputManagerService(context); &#x2F;&#x2F; input</span><br><span class="line">       wm &#x3D; WindowManagerService.main(...); &#x2F;&#x2F; window</span><br><span class="line">       inputManager.start();  &#x2F;&#x2F;启动input</span><br><span class="line">       mDisplayManagerService.windowManagerAndInputReady();</span><br><span class="line">       ...</span><br><span class="line">       mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); &#x2F;&#x2F; mount</span><br><span class="line">       mPackageManagerService.performBootDexOpt();  &#x2F;&#x2F; dexopt操作</span><br><span class="line">       ActivityManagerNative.getDefault().showBootMessage(...); &#x2F;&#x2F;显示启动界面</span><br><span class="line">       ...</span><br><span class="line">       statusBar &#x3D; new StatusBarManagerService(context, wm); &#x2F;&#x2F;statusBar</span><br><span class="line">       &#x2F;&#x2F;dropbox</span><br><span class="line">       ServiceManager.addService(Context.DROPBOX_SERVICE,</span><br><span class="line">                   new DropBoxManagerService(context, new File(&quot;&#x2F;data&#x2F;system&#x2F;dropbox&quot;)));</span><br><span class="line">        mSystemServiceManager.startService(JobSchedulerService.class); &#x2F;&#x2F;JobScheduler</span><br><span class="line">        lockSettings.systemReady(); &#x2F;&#x2F;lockSettings</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;phase480 和phase500</span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 准备好window, power, package, display服务</span><br><span class="line">       wm.systemReady();</span><br><span class="line">       mPowerManagerService.systemReady(...);</span><br><span class="line">       mPackageManagerService.systemReady();</span><br><span class="line">       mDisplayManagerService.systemReady(...);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F;重头戏[见小节2.1]</span><br><span class="line">       mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">           public void run() &#123;</span><br><span class="line">             ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>SystemServer启动各种服务中最后的一个环节便是AMS.systemReady()，详见<a href="http://gityuan.com/2016/02/21/activity-manager-service/" target="_blank" rel="noopener">ActivityManagerService启动过程</a>.</p>
<p>到此, System_server主线程的启动工作总算完成, 进入Looper.loop()状态,等待其他线程通过handler发送消息到主线再处理.</p>
<h1 id="至此System-Server启动完成"><a href="#至此System-Server启动完成" class="headerlink" title="至此System_Server启动完成"></a>至此System_Server启动完成</h1><h1 id="服务启动阶段"><a href="#服务启动阶段" class="headerlink" title="服务启动阶段"></a>服务启动阶段</h1><p>SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程：</p>
<p><img src="http://gityuan.com/images/boot/systemServer/system_server_boot_process.jpg" alt="system_server服务启动流程"></p>
<p><strong>各个启动阶段所在源码的大致位置：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class SystemServer &#123;</span><br><span class="line"></span><br><span class="line">    private void startBootstrapServices() &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#x2F;&#x2F;phase100</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void startCoreServices() &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void startOtherServices() &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#x2F;&#x2F;phase480 &amp;&amp; 500</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             &#x2F;&#x2F;phase550</span><br><span class="line">             mSystemServiceManager.startBootPhase(</span><br><span class="line">                     SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">             ...</span><br><span class="line">             &#x2F;&#x2F;phase600</span><br><span class="line">             mSystemServiceManager.startBootPhase(</span><br><span class="line">                     SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再说说简单每个阶段的大概完成的工作：</p>
<h2 id="Phase0"><a href="#Phase0" class="headerlink" title="Phase0"></a>Phase0</h2><p>创建四大引导服务:</p>
<ul>
<li>ActivityManagerService</li>
<li>PowerManagerService</li>
<li>LightsService</li>
<li>DisplayManagerService</li>
</ul>
<h2 id="Phase100"><a href="#Phase100" class="headerlink" title="Phase100"></a>Phase100</h2><p>进入阶段<code>PHASE_WAIT_FOR_DEFAULT_DISPLAY</code>=100回调服务</p>
<p>onBootPhase(100)</p>
<ul>
<li>DisplayManagerService</li>
</ul>
<p>然后创建大量服务下面列举部分:</p>
<ul>
<li>PackageManagerService</li>
<li>WindowManagerService</li>
<li>InputManagerService</li>
<li>NetworkManagerService</li>
<li>DropBoxManagerService</li>
<li>FingerprintService</li>
<li>LauncherAppsService</li>
<li>…</li>
</ul>
<h2 id="Phase480"><a href="#Phase480" class="headerlink" title="Phase480"></a>Phase480</h2><p>进入阶段<code>PHASE_LOCK_SETTINGS_READY</code>=480回调服务</p>
<p>onBootPhase(480)</p>
<ul>
<li>DevicePolicyManagerService</li>
</ul>
<p>阶段480后马上就进入阶段500.</p>
<h2 id="Phase500"><a href="#Phase500" class="headerlink" title="Phase500"></a>Phase500</h2><p><code>PHASE_SYSTEM_SERVICES_READY</code>=500，进入该阶段服务能安全地调用核心系统服务.</p>
<p>onBootPhase(500)</p>
<ul>
<li>AlarmManagerService</li>
<li>JobSchedulerService</li>
<li>NotificationManagerService</li>
<li>BackupManagerService</li>
<li>UsageStatsService</li>
<li>DeviceIdleController</li>
<li>TrustManagerService</li>
<li>UiModeManagerService</li>
<li>BluetoothService</li>
<li>BluetoothManagerService</li>
<li>EthernetService</li>
<li>WifiP2pService</li>
<li>WifiScanningService</li>
<li>WifiService</li>
<li>RttService</li>
</ul>
<p>各大服务执行systemReady():</p>
<ul>
<li>WindowManagerService.systemReady():</li>
<li>PowerManagerService.systemReady():</li>
<li>PackageManagerService.systemReady():</li>
<li>DisplayManagerService.systemReady():</li>
</ul>
<p>接下来就绪AMS.systemReady方法.</p>
<h2 id="Phase550"><a href="#Phase550" class="headerlink" title="Phase550"></a>Phase550</h2><p><code>PHASE_ACTIVITY_MANAGER_READY</code>=550， AMS.mSystemReady=true, 已准备就绪,进入该阶段服务能广播Intent;但是system_server主线程并没有就绪.</p>
<p>onBootPhase(550)</p>
<ul>
<li>MountService</li>
<li>TelecomLoaderService</li>
<li>UsbService</li>
<li>WebViewUpdateService</li>
<li>DockObserver</li>
<li>BatteryService</li>
</ul>
<p>接下来执行: (AMS启动native crash监控, 加载WebView，启动SystemUi等),如下</p>
<ul>
<li>mActivityManagerService.startObservingNativeCrashes();</li>
<li>WebViewFactory.prepareWebViewInSystemServer();</li>
<li>startSystemUi(context);</li>
<li>networkScoreF.systemReady();</li>
<li>networkManagementF.systemReady();</li>
<li>networkStatsF.systemReady();</li>
<li>networkPolicyF.systemReady();</li>
<li>connectivityF.systemReady();</li>
<li>audioServiceF.systemReady();</li>
<li>Watchdog.getInstance().start();</li>
</ul>
<h2 id="Phase600"><a href="#Phase600" class="headerlink" title="Phase600"></a>Phase600</h2><p><code>PHASE_THIRD_PARTY_APPS_CAN_START</code>=600</p>
<p>onBootPhase(600)</p>
<ul>
<li>JobSchedulerService</li>
<li>NotificationManagerService</li>
<li>BackupManagerService</li>
<li>AppWidgetService</li>
<li>GestureLauncherService</li>
<li>DreamManagerService</li>
<li>TrustManagerService</li>
<li>VoiceInteractionManagerService</li>
</ul>
<p>接下来,各种服务的systemRunning过程:</p>
<p>WallpaperManagerService、InputMethodManagerService、LocationManagerService、CountryDetectorService、NetworkTimeUpdateService、CommonTimeManagementService、TextServicesManagerService、AssetAtlasService、InputManagerService、TelephonyRegistry、MediaRouterService、MmsServiceBroker这些服务依次执行其<code>systemRunning()</code>方法。</p>
<h2 id="Phase1000"><a href="#Phase1000" class="headerlink" title="Phase1000"></a>Phase1000</h2><p>在经过一系列流程，再调用<code>AMS.finishBooting()</code>时，则进入阶段<code>Phase1000</code>。</p>
<p>到此，系统服务启动阶段完成就绪，system_server进程启动完成则进入<code>Looper.loop()</code>状态，随时待命，等待消息队列MessageQueue中的消息到来，则马上进入执行状态。</p>
<h1 id="服务类别"><a href="#服务类别" class="headerlink" title="服务类别"></a>服务类别</h1><p>system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。 以下这些系统服务的注册过程, 见<a href="http://gityuan.com/2016/10/01/system_service_common/" target="_blank" rel="noopener">Android系统服务的注册方式</a></p>
<ul>
<li>引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService；</li>
<li>核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService；</li>
<li>其他服务(70个+)：AlarmManagerService、VibratorService等。</li>
</ul>
<p>合计总大约80个系统服务：</p>
<table>
<thead>
<tr>
<th><code>ActivityManagerService</code></th>
<th><code>PackageManagerService</code></th>
<th><code>WindowManagerService</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>PowerManagerService</code></td>
<td><code>BatteryService</code></td>
<td><code>BatteryStatsService</code></td>
</tr>
<tr>
<td><code>DreamManagerService</code></td>
<td><code>DropBoxManagerService</code></td>
<td><code>SamplingProfilerService</code></td>
</tr>
<tr>
<td><code>UsageStatsService</code></td>
<td><code>DiskStatsService</code></td>
<td><code>DeviceStorageMonitorService</code></td>
</tr>
<tr>
<td>SchedulingPolicyService</td>
<td><code>AlarmManagerService</code></td>
<td>DeviceIdleController</td>
</tr>
<tr>
<td>ThermalObserver</td>
<td>JobSchedulerService</td>
<td><code>AccessibilityManagerService</code></td>
</tr>
<tr>
<td>DisplayManagerService</td>
<td>LightsService</td>
<td><code>GraphicsStatsService</code></td>
</tr>
<tr>
<td>StatusBarManagerService</td>
<td>NotificationManagerService</td>
<td>WallpaperManagerService</td>
</tr>
<tr>
<td>UiModeManagerService</td>
<td>AppWidgetService</td>
<td>LauncherAppsService</td>
</tr>
<tr>
<td>TextServicesManagerService</td>
<td>ContentService</td>
<td>LockSettingsService</td>
</tr>
<tr>
<td>InputMethodManagerService</td>
<td>InputManagerService</td>
<td><code>MountService</code></td>
</tr>
<tr>
<td>FingerprintService</td>
<td>TvInputManagerService</td>
<td>DockObserver</td>
</tr>
<tr>
<td>NetworkManagementService</td>
<td>NetworkScoreService</td>
<td><code>NetworkStatsService</code></td>
</tr>
<tr>
<td>NetworkPolicyManagerService</td>
<td>ConnectivityService</td>
<td>BluetoothService</td>
</tr>
<tr>
<td>WifiP2pService</td>
<td>WifiService</td>
<td>WifiScanningService</td>
</tr>
<tr>
<td>AudioService</td>
<td>MediaRouterService</td>
<td>VoiceInteractionManagerService</td>
</tr>
<tr>
<td>MediaProjectionManagerService</td>
<td>MediaSessionService</td>
<td></td>
</tr>
<tr>
<td>DevicePolicyManagerService</td>
<td>PrintManagerService</td>
<td><code>BackupManagerService</code></td>
</tr>
<tr>
<td><code>UserManagerService</code></td>
<td>AccountManagerService</td>
<td><code>TrustManagerService</code></td>
</tr>
<tr>
<td><code>SensorService</code></td>
<td>LocationManagerService</td>
<td>VibratorService</td>
</tr>
<tr>
<td>CountryDetectorService</td>
<td>GestureLauncherService</td>
<td>PersistentDataBlockService</td>
</tr>
<tr>
<td>EthernetService</td>
<td>WebViewUpdateService</td>
<td>ClipboardService</td>
</tr>
<tr>
<td>TelephonyRegistry</td>
<td>TelecomLoaderService</td>
<td>NsdService</td>
</tr>
<tr>
<td>UpdateLockService</td>
<td>SerialService</td>
<td>SearchManagerService</td>
</tr>
<tr>
<td>CommonTimeManagementService</td>
<td>AssetAtlasService</td>
<td>ConsumerIrService</td>
</tr>
<tr>
<td>MidiServiceCameraService</td>
<td>TwilightService</td>
<td>RestrictionsManagerService</td>
</tr>
<tr>
<td>MmsServiceBroker</td>
<td>RttService</td>
<td>UsbService</td>
</tr>
</tbody></table>
<p>Service类别众多，其中表中加粗项是指博主挑选的较重要或者较常见的Service，并且在本博客中已经展开或者计划展开讲解的Service，当然如果有精力会讲解更多service，后续再更新。</p>
<h1 id="客户端使用服务"><a href="#客户端使用服务" class="headerlink" title="客户端使用服务"></a>客户端使用服务</h1><h2 id="一个简单的SystemService"><a href="#一个简单的SystemService" class="headerlink" title="一个简单的SystemService"></a>一个简单的SystemService</h2><p>我们从一个简单的系统服务Vibrator服务来看一下一个系统服务是怎样建立的。<br>Vibrator服务提供的控制手机振动的接口，应用可以调用Vibrator的接口来让手机产生振动，达到提醒用户的目的。<br>从Android的官方文档中可以看到Vibrator只是一个抽象类，只有4个抽象接口：</p>
<ul>
<li>abstract void cancel() 取消振动</li>
<li>abstract boolean hasVibrator() 是否有振动功能</li>
<li>abstract void vibrate(long[] pattern, int repeat) 按节奏重复振动</li>
<li>abstract void vibrate(long milliseconds) 持续振动</li>
</ul>
<p>应用中使用振动服务的方法也很简单，如让手机持续振动500毫秒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vibrator mVibrator &#x3D; (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">mVibrator.vibrate(500);</span><br></pre></td></tr></table></figure>

<p><code>Vibrator</code>使用起来很简单，我们再来看一下实现起来是不是也简单。从文档中可以看到Vibrator只是定义在android.os 包里的一个抽象类，在源码里的位置即<code>frameworks/base/core/java/android/os/Vibrator.java</code>，那么应用中实际使用的是哪个实例呢？应用中使用的Vibrator实例是通过Context的一个方法<code>getSystemService(Context.VIBRATOR_SERVICE)</code>获得的，而Context的实现一般都在<code>ContextImpl</code>中，那我们就看一下ContextImpl是怎么实现getSystemService的：<br><code>frameworks/base/core/java/android/app/ContextImpl.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>frameworks/base/core/java/android/app/SystemServiceRegistry.java</code></p>
<p>(<code>SystemServiceRegistry</code>是 Android 6.0之后才有的，Android 6.0 之前的代码没有该类，下面的代码是直接写在<code>ContextImpl</code>里的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher &#x3D; SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    return fetcher !&#x3D; null ? fetcher.getService(ctx) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SYSTEM_SERVICE_MA</code>P是一个HashMap，通过我们服务的名字name字符串，从这个HashMap里取出一个ServiceFetcher，再return这个ServiceFetcher的getService()。ServiceFetcher是什么？它的getService()又是什么？既然他是从SYSTEM_SERVICE_MAP这个HashMap里get出来的，那就找一找这个HashMap都put了什么。<br>通过搜索SystemServiceRegistry可以找到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,</span><br><span class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</span><br><span class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里往<code>SYSTEM_SERVICE_MAP</code>里<code>put</code>了一对<code>String</code>与<code>ServiceFetcher</code>组成的key/value对，<code>registerService()</code>又是从哪里调用的？继续搜索可以发现很多类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    registerService(Context.ACCESSIBILITY_SERVICE, AccessibilityManager.class,</span><br><span class="line">            new CachedServiceFetcher&lt;AccessibilityManager&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public AccessibilityManager createService(ContextImpl ctx) &#123;</span><br><span class="line">            return AccessibilityManager.getInstance(ctx);</span><br><span class="line">        &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    registerService(Context.VIBRATOR_SERVICE, Vibrator.class,</span><br><span class="line">            new CachedServiceFetcher&lt;Vibrator&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Vibrator createService(ContextImpl ctx) &#123;</span><br><span class="line">            return new SystemVibrator(ctx);</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SystemServiceRegistry</code>的static代码块里通过<code>registerService</code>注册了很多的系统服务，其中就包括我们正在调查的<code>VIBRATOR_SERVICE</code>，通过结合上面的分析代码可以可以知道<code>getSystemService(Context.VIBRATOR_SERVICE)</code>得到的是一个<code>SystemVibrator</code>的实例，通过查看<code>SystemVibrator</code>的代码也可以发现<code>SystemVibrator</code>确实是继承自Vibrator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class SystemVibrator extends Vibrator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再从<code>SystemVibrator</code>看一下系统的振动控制是怎么实现的。以<code>hasVibrator()</code>为例，这个是查询当前系统是否能够振动，在<code>SystemVibrator</code>中它的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasVibrator() &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        return mService.hasVibrator();</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接调用了一个<code>mService.hasVibrator()</code>。<code>mService</code>是什么？哪来的？搜索一下可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final IVibratorService mService;</span><br><span class="line">public SystemVibrator() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mService &#x3D; IVibratorService.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(&quot;vibrator&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mService</code> 是一个<code>IVibratorService</code>，我们先不去管<code>IVibratorService.Stub.asInterface</code>是怎么回事，先看一下<code>IVibratorService</code>是什么。搜索一下代码发现这并不是一个java文件，而是一个aidl文件：<code>frameworks/base/core/java/android/os/IVibratorService.aidl</code><br>AIDL (Android Interface Definition Language) 是Android中的接口定义文件，为系统提供了一种简单跨进程通信方法。<br>IVibratorService 中定义了几个接口，SystemVibrator中使用的也是这几个接口，包括我们刚才使用的hasVibrator()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IVibratorService</span><br><span class="line">&#123;</span><br><span class="line">    boolean hasVibrator();</span><br><span class="line">    void vibrate(...);</span><br><span class="line">    void vibratePattern(...);</span><br><span class="line">    void cancelVibrate(IBinder token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又只是接口定义，接口实现在哪呢？通过在<code>frameworks/base</code>目录下进行grep搜索，或者在AndroidXRef搜索，可以发现IVibratorService接口的实现在<code>frameworks/base/services/java/com/android/server/VibratorService.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class VibratorService extends IVibratorService.Stub</span><br></pre></td></tr></table></figure>

<p>可以看到 VibratorService实现了IVibratorService定义的所有接口，并通过JNI调用到native层，进行更底层的实现。更底层的实现不是这篇文档讨论的内容，我们需要分析的是VibratorService怎么成为系统服务的。那么VibratorService是怎么注册为系统服务的呢？在SystemServer里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VibratorService vibrator &#x3D; null;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;实例化VibratorService并添加到ServiceManager</span><br><span class="line">traceBeginAndSlog(&quot;StartVibratorService&quot;);</span><br><span class="line">vibrator &#x3D; new VibratorService(context);</span><br><span class="line">ServiceManager.addService(&quot;vibrator&quot;, vibrator);</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;通知服务系统启动完成</span><br><span class="line">Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;MakeVibratorServiceReady&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    vibrator.systemReady();</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    reportWtf(&quot;making Vibrator Service ready&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br></pre></td></tr></table></figure>

<p>这样在<code>SystemVibrator</code>里就可以通过下面的代码连接到<code>VibratorService</code>，与底层的系统服务进行通信了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IVibratorService.Stub.asInterface(ServiceManager.getService(&quot;vibrator&quot;));</span><br></pre></td></tr></table></figure>

<p><code>mService</code>相当于<code>IVibratorService</code>在应用层的一个代理，所有的实现还是在<code>SystemServer</code>的<code>VibratorService</code>里。</p>
<p>看代码时可以发现<code>registerService</code>是在static代码块里静态调用的，所以<code>getSystemServcr</code>获得的各个Manager也都是单例的。</p>
<p><strong>从上面的分析，我们可以总结出Vibrator服务的整个实现流程：</strong></p>
<ol>
<li><p>定义一个抽象类<code>Vibrator</code>，定义了应用中可以访问的一些抽象方法(抽象)<br><code>frameworks/base/core/java/android/os/Vibrator.java</code></p>
</li>
<li><p>定义具体的类<code>SystemVibrator</code>继承<code>Vibrator</code>，实现抽象方法（客户端调用）</p>
<p><code>frameworks/base/core/java/android/os/SystemVibrator.java</code></p>
</li>
<li><p>定义一个AIDL接口文件<code>IVibratorService</code>，定义系统服务接口（服务端接口）<br>frameworks/base/core/java/android/os/IVibratorService.aidl</p>
</li>
<li><p>定义服务VibratorService，实现IVibratorService定义的接口(服务端实现)<br><code>frameworks/base/services/java/com/android/server/VibratorService.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class VibratorService extends IVibratorService.Stub</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>VibratorServicey</code>添加到系统服务<br><code>frameworks/base/services/java/com/android/server/SystemServer.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VibratorService vibrator &#x3D; null;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;实例化VibratorService并添加到ServiceManager</span><br><span class="line">Slog.i(TAG, &quot;Vibrator Service&quot;);</span><br><span class="line">vibrator &#x3D; new VibratorService(context);</span><br><span class="line">ServiceManager.addService(&quot;vibrator&quot;, vibrator);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;通知服务系统启动完成</span><br><span class="line">try &#123;</span><br><span class="line">    vibrator.systemReady();</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    reportWtf(&quot;making Vibrator Service ready&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>SystemVibrator</code>中通过<code>IVibratorService</code>的代理连接到<code>VibratorService</code>，这样<code>SystemVibrator</code>的接口实现里就可以调用<code>IVibratorService</code>的接口：</p>
<p><code>frameworks/base/core/java/android/os/SystemVibrator.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final IVibratorService mService;</span><br><span class="line">...</span><br><span class="line">public SystemVibrator() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mService &#x3D; IVibratorService.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(&quot;vibrator&quot;));</span><br><span class="line">    ...</span><br><span class="line">    public boolean hasVibrator() &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            return mService.hasVibrator();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>Context</code>里定义一个代表<code>Vibrator</code>服务的字符串</p>
<p><code>frameworks/base/core/java/android/content/Context.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String VIBRATOR_SERVICE &#x3D; &quot;vibrator&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ContextImpl里添加SystemVibrator的实例化过程<br><code>frameworks/base/core/java/android/app/ContextImpl.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registerService(VIBRATOR_SERVICE, new ServiceFetcher() &#123;</span><br><span class="line">public Object createService(ContextImpl ctx) &#123;</span><br><span class="line">    return new SystemVibrator(ctx);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用中使用<code>Vibrator</code>的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vibrator mVibrator &#x3D; (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">mVibrator.vibrate(500);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为保证编译正常，还需要将AIDL文件添加到编译配置里<br><code>frameworks/base/Android.mk</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES +&#x3D; \</span><br><span class="line">...</span><br><span class="line">core&#x2F;java&#x2F;android&#x2F;os&#x2F;IVibratorService.aidl \</span><br></pre></td></tr></table></figure>

</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-Zygote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-Zygote/" itemprop="url">Android系统启动-Zygote</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T09:38:15+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-Zygote/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/29/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-Zygote/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;App_main.cpp</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">  - ZygoteInit.java</span><br><span class="line">  - Zygote.java</span><br><span class="line">  - ZygoteConnection.java</span><br><span class="line">  </span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;net&#x2F;LocalServerSocket.java</span><br><span class="line">&#x2F;system&#x2F;core&#x2F;libutils&#x2F;Threads.cpp</span><br></pre></td></tr></table></figure>

<p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-vts-9.0_r13/cmds/app_process/app_main.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-vts-9.0_r13/cmds/app_process/app_main.cpp</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Zygote是由<a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">init进程</a>通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是App_main.cpp，进程名为zygote。</p>
<p>Zygote进程能够重启的地方:</p>
<ul>
<li>servicemanager进程被杀; (onresart)</li>
<li>surfaceflinger进程被杀; (onresart)</li>
<li>Zygote进程自己被杀; (oneshot=false)</li>
<li>system_server进程被杀; (waitpid)</li>
</ul>
<p>从App_main()开始，Zygote启动过程的函数调用类大致流程如下：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_process.jpg" alt="zygote_process"></p>
<h1 id="Zygote启动过程"><a href="#Zygote启动过程" class="headerlink" title="Zygote启动过程"></a>Zygote启动过程</h1><h2 id="App-main-cpp"><a href="#App-main-cpp" class="headerlink" title="App_main.cpp"></a><code>App_main.cpp</code></h2><h3 id="main"><a href="#main" class="headerlink" title="main()"></a><code>main()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;传到的参数argv为“-Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server”</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    argc--; argv++; &#x2F;&#x2F;忽略第一个参数</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; argc; i++) &#123;</span><br><span class="line">        if (argv[i][0] !&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (argv[i][1] &#x3D;&#x3D; &#39;-&#39; &amp;&amp; argv[i][2] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;参数解析</span><br><span class="line">    bool zygote &#x3D; false;</span><br><span class="line">    bool startSystemServer &#x3D; false;</span><br><span class="line">    bool application &#x3D; false;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line">    ++i;</span><br><span class="line">    while (i &lt; argc) &#123;</span><br><span class="line">        const char* arg &#x3D; argv[i++];</span><br><span class="line">        if (strcmp(arg, &quot;--zygote&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            zygote &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F;对于64位系统nice_name为zygote64; 32位系统为zygote</span><br><span class="line">            niceName &#x3D; ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            startSystemServer &#x3D; true;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--application&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            application &#x3D; true;</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--nice-name&#x3D;&quot;, 12) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            niceName.setTo(arg + 12);</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--&quot;, 2) !&#x3D; 0) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    if (!className.isEmpty()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 运行application或tool程序</span><br><span class="line">        args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;进入zygote模式，创建 &#x2F;data&#x2F;dalvik-cache路径</span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(&quot;start-system-server&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        char prop[PROP_VALUE_MAX];</span><br><span class="line">        if (property_get(ABI_LIST_PROPERTY, prop, NULL) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 11;</span><br><span class="line">        &#125;</span><br><span class="line">        String8 abiFlag(&quot;--abi-list&#x3D;&quot;);</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        for (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置进程名</span><br><span class="line">    if (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        &#x2F;&#x2F; 启动AppRuntime 【见小节2.2】</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;没有指定类名或zygote，参数错误</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动AppRuntime</li>
</ul>
<h2 id="AndroidRuntime-cpp"><a href="#AndroidRuntime-cpp" class="headerlink" title="AndroidRuntime.cpp"></a><code>AndroidRuntime.cpp</code></h2><h3 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)</span><br><span class="line">&#123;</span><br><span class="line">    static const String8 startSystemServer(&quot;start-system-server&quot;);</span><br><span class="line"></span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        if (options[i] &#x3D;&#x3D; startSystemServer) &#123;</span><br><span class="line">           const int LOG_BOOT_PROGRESS_START &#x3D; 3000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const char* rootDir &#x3D; getenv(&quot;ANDROID_ROOT&quot;);</span><br><span class="line">    if (rootDir &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        rootDir &#x3D; &quot;&#x2F;system&quot;;</span><br><span class="line">        if (!hasDir(&quot;&#x2F;system&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(NULL);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    &#x2F;&#x2F; 虚拟机创建【见小节2.3】</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env, zygote) !&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    &#x2F;&#x2F; JNI方法注册【见小节2.4】</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;等价 strArray&#x3D; new String[options.size() + 1];</span><br><span class="line">    stringClass &#x3D; env-&gt;FindClass(&quot;java&#x2F;lang&#x2F;String&quot;);</span><br><span class="line">    strArray &#x3D; env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;等价 strArray[0] &#x3D; &quot;com.android.internal.os.ZygoteInit&quot;</span><br><span class="line">    classNameStr &#x3D; env-&gt;NewStringUTF(className);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;等价 strArray[1] &#x3D; &quot;start-system-server&quot;；</span><br><span class="line">    &#x2F;&#x2F; strArray[2] &#x3D; &quot;--abi-list&#x3D;xxx&quot;；</span><br><span class="line">    &#x2F;&#x2F;其中xxx为系统响应的cpu架构类型，比如arm64-v8a.</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr &#x3D; env-&gt;NewStringUTF(options.itemAt(i).string());</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将&quot;com.android.internal.os.ZygoteInit&quot;转换为&quot;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit&quot;</span><br><span class="line">    char* slashClassName &#x3D; toSlashClassName(className);</span><br><span class="line">    jclass startClass &#x3D; env-&gt;FindClass(slashClassName);</span><br><span class="line">    if (startClass &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        jmethodID startMeth &#x3D; env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">            &quot;([Ljava&#x2F;lang&#x2F;String;)V&quot;);</span><br><span class="line">        &#x2F;&#x2F; 调用ZygoteInit.main()方法【见小节3.1】</span><br><span class="line">        env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;释放相应对象的内存空间</span><br><span class="line">    free(slashClassName);</span><br><span class="line">    mJavaVM-&gt;DetachCurrentThread();</span><br><span class="line">    mJavaVM-&gt;DestroyJavaVM();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startVm"><a href="#startVm" class="headerlink" title="startVm()"></a><code>startVm()</code></h3><p><strong>创建Java虚拟机</strong>方法的主要篇幅是关于虚拟机参数的设置，下面只列举部分在调试优化过程中常用参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; JNI检测功能，用于native层调用jni函数时进行常规检测，比较弱字符串格式是否符合要求，资源是否正确释放。该功能一般用于早期系统调试或手机Eng版，对于User版往往不会开启，引用该功能比较消耗系统CPU资源，降低系统性能。</span><br><span class="line">    bool checkJni &#x3D; false;</span><br><span class="line">    property_get(&quot;dalvik.vm.checkjni&quot;, propBuf, &quot;&quot;);</span><br><span class="line">    if (strcmp(propBuf, &quot;true&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        checkJni &#x3D; true;</span><br><span class="line">    &#125; else if (strcmp(propBuf, &quot;false&quot;) !&#x3D; 0) &#123;</span><br><span class="line">        property_get(&quot;ro.kernel.android.checkjni&quot;, propBuf, &quot;&quot;);</span><br><span class="line">        if (propBuf[0] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">            checkJni &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (checkJni) &#123;</span><br><span class="line">        addOption(&quot;-Xcheck:jni&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;虚拟机产生的trace文件，主要用于分析系统问题，路径默认为&#x2F;data&#x2F;anr&#x2F;traces.txt</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.stack-trace-file&quot;, stackTraceFileBuf, &quot;-Xstacktracefile:&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对于不同的软硬件环境，这些参数往往需要调整、优化，从而使系统达到最佳性能</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.heapstartsize&quot;, heapstartsizeOptsBuf, &quot;-Xms&quot;, &quot;4m&quot;);</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.heapsize&quot;, heapsizeOptsBuf, &quot;-Xmx&quot;, &quot;16m&quot;);</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.heapgrowthlimit&quot;, heapgrowthlimitOptsBuf, &quot;-XX:HeapGrowthLimit&#x3D;&quot;);</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.heapminfree&quot;, heapminfreeOptsBuf, &quot;-XX:HeapMinFree&#x3D;&quot;);</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.heapmaxfree&quot;, heapmaxfreeOptsBuf, &quot;-XX:HeapMaxFree&#x3D;&quot;);</span><br><span class="line">    parseRuntimeOption(&quot;dalvik.vm.heaptargetutilization&quot;,</span><br><span class="line">                       heaptargetutilizationOptsBuf, &quot;-XX:HeapTargetUtilization&#x3D;&quot;);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;preloaded-classes文件内容是由WritePreloadedClassFile.java生成的，</span><br><span class="line">    &#x2F;&#x2F;在ZygoteInit类中会预加载工作将其中的classes提前加载到内存，以提高系统性能</span><br><span class="line">    if (!hasFile(&quot;&#x2F;system&#x2F;etc&#x2F;preloaded-classes&quot;)) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化虚拟机</span><br><span class="line">    if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;JNI_CreateJavaVM failed\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startReg"><a href="#startReg" class="headerlink" title="startReg()"></a><code>startReg()</code></h3><p><strong>JNI方法注册</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int AndroidRuntime::startReg(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;设置线程创建方法为javaCreateThreadEtc 【见小节2.4.1】</span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    env-&gt;PushLocalFrame(200);</span><br><span class="line">    &#x2F;&#x2F;进程NI方法的注册【见小节2.4.2】</span><br><span class="line">    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(NULL);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="register-jni-procs"><a href="#register-jni-procs" class="headerlink" title="register_jni_procs()"></a><code>register_jni_procs()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env) &#123;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;【见小节2.4.3】</span><br><span class="line">        if (array[i].mProc(env) &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gRegJNI-mProc"><a href="#gRegJNI-mProc" class="headerlink" title="gRegJNI.mProc"></a><code>gRegJNI.mProc</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static const RegJNIRec gRegJNI[] &#x3D; &#123;</span><br><span class="line">    REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">    REG_JNI(register_android_os_Binder)，</span><br><span class="line">    ...</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>array[i]是指gRegJNI数组, 该数组有100多个成员。其中每一项成员都是通过<strong>REG_JNI</strong>宏定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define REG_JNI(name) &#123; name &#125;</span><br><span class="line">struct RegJNIRec &#123;</span><br><span class="line">    int (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，调用<code>mProc</code>，就等价于调用其参数名所指向的函数。 例如<code>REG_JNI(register_com_android_internal_os_RuntimeInit).mProc</code>也就是指进入<code>register_com_android_internal_os_RuntimeInit方法</code>，接下来就继续以此为例来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int register_com_android_internal_os_RuntimeInit(JNIEnv* env) &#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, &quot;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;RuntimeInit&quot;,</span><br><span class="line">        gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;gMethods：java层方法名与jni层的方法的一一映射关系</span><br><span class="line">static JNINativeMethod gMethods[] &#x3D; &#123;</span><br><span class="line">    &#123; &quot;nativeFinishInit&quot;, &quot;()V&quot;,</span><br><span class="line">        (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; &quot;nativeZygoteInit&quot;, &quot;()V&quot;,</span><br><span class="line">        (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; &quot;nativeSetExitWithoutCleanup&quot;, &quot;(Z)V&quot;,</span><br><span class="line">        (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Threads-cpp"><a href="#Threads-cpp" class="headerlink" title="Threads.cpp"></a><code>Threads.cpp</code></h2><h3 id="androidSetCreateThreadFunc"><a href="#androidSetCreateThreadFunc" class="headerlink" title="androidSetCreateThreadFunc()"></a><code>androidSetCreateThreadFunc()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void androidSetCreateThreadFunc(android_create_thread_fn func) &#123;</span><br><span class="line">    gCreateThreadFn &#x3D; func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机启动后startReg()过程，会设置线程创建函数指针<code>gCreateThreadFn</code>指向<code>javaCreateThreadEtc</code>.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>c++代码Zygote进程启动流程：</p>
<ul>
<li>启动appRuntime<ul>
<li>创建虚拟机</li>
<li>jni方法注册</li>
<li>调用ZygoteInit.main()方法</li>
</ul>
</li>
</ul>
<h1 id="进入Java层"><a href="#进入Java层" class="headerlink" title="进入Java层"></a>进入Java层</h1><p>前面[小节2.2]AndroidRuntime.start()执行到最后通过反射调用到ZygoteInit.main(),见下文:</p>
<h2 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a><code>ZygoteInit</code></h2><h3 id="main-1"><a href="#main-1" class="headerlink" title="main()"></a><code>main()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        RuntimeInit.enableDdms(); &#x2F;&#x2F;开启DDMS功能</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line">        boolean startSystemServer &#x3D; false;</span><br><span class="line">        String socketName &#x3D; &quot;zygote&quot;;</span><br><span class="line">        String abiList &#x3D; null;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; argv.length; i++) &#123;</span><br><span class="line">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer &#x3D; true;</span><br><span class="line">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList &#x3D; argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName &#x3D; argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        registerZygoteSocket(socketName); &#x2F;&#x2F;为Zygote注册socket【见小节3.2】</span><br><span class="line">        preload(); &#x2F;&#x2F; 预加载类和资源【见小节3.3】</span><br><span class="line">        SamplingProfilerIntegration.writeZygoteSnapshot();</span><br><span class="line">        gcAndFinalize(); &#x2F;&#x2F;GC操作</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);&#x2F;&#x2F;启动system_server【见小节3.4】</span><br><span class="line">        &#125;</span><br><span class="line">        caller &#x3D; zygoteServer.runSelectLoop(abiList); &#x2F;&#x2F;进入循环模式【见小节3.5】</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125;catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; We&#39;re in the child process and have exited the select loop. Proceed to execute the</span><br><span class="line">     &#x2F;&#x2F; command.</span><br><span class="line">        if (caller !&#x3D; null) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后会调用<code>caller.run()</code>。</p>
<ul>
<li>为Zygote注册socket</li>
<li>预加载类和资源</li>
<li>启动system_server</li>
<li>开启循环</li>
</ul>
<h3 id="registerZygoteSocket"><a href="#registerZygoteSocket" class="headerlink" title="registerZygoteSocket()"></a><code>registerZygoteSocket()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void registerZygoteSocket(String socketName) &#123;</span><br><span class="line">    if (sServerSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">        int fileDesc;</span><br><span class="line">        final String fullSocketName &#x3D; ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">        try &#123;</span><br><span class="line">            String env &#x3D; System.getenv(fullSocketName);</span><br><span class="line">            fileDesc &#x3D; Integer.parseInt(env);</span><br><span class="line">        &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            FileDescriptor fd &#x3D; new FileDescriptor();</span><br><span class="line">            fd.setInt$(fileDesc); &#x2F;&#x2F;设置文件描述符</span><br><span class="line">            sServerSocket &#x3D; new LocalServerSocket(fd); &#x2F;&#x2F;创建Socket的本地服务端</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LocalServerSocket"><a href="#LocalServerSocket" class="headerlink" title="LocalServerSocket()"></a><code>LocalServerSocket()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">impl &#x3D; new LocalSocketImpl(fd);</span><br><span class="line">        impl.listen(LISTEN_BACKLOG);</span><br><span class="line">        localAddress &#x3D; impl.getSockAddress();</span><br></pre></td></tr></table></figure>

<h3 id="preload"><a href="#preload" class="headerlink" title="preload()"></a><code>preload()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void preload() &#123;</span><br><span class="line">    &#x2F;&#x2F;预加载位于&#x2F;system&#x2F;etc&#x2F;preloaded-classes文件中的类</span><br><span class="line">    preloadClasses();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;预加载资源，包含drawable和color资源</span><br><span class="line">    preloadResources();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;预加载OpenGL</span><br><span class="line">    preloadOpenGL();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过System.loadLibrary()方法，</span><br><span class="line">    &#x2F;&#x2F;预加载&quot;android&quot;,&quot;compiler_rt&quot;,&quot;jnigraphics&quot;这3个共享库</span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;预加载 文本连接符资源</span><br><span class="line">    preloadTextResources();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;仅用于zygote进程，用于内存共享的进程</span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行Zygote进程的初始化,对于类加载，采用反射机制Class.forName()方法来加载。对于资源加载，主要是 com.android.internal.R.array.preloaded_drawables和com.android.internal.R.array.preloaded_color_state_lists，在应用程序中以com.android.internal.R.xxx开头的资源，便是此时由Zygote加载到内存的。</p>
<p>zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_fork.jpg" alt="zygote_fork"></p>
<h3 id="startSystemServer"><a href="#startSystemServer" class="headerlink" title="startSystemServer()"></a><code>startSystemServer()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    long capabilities &#x3D; posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_BLOCK_SUSPEND,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_RESOURCE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F;参数准备</span><br><span class="line">    String args[] &#x3D; &#123;</span><br><span class="line">        &quot;--setuid&#x3D;1000&quot;,</span><br><span class="line">        &quot;--setgid&#x3D;1000&quot;,</span><br><span class="line">        &quot;--setgroups&#x3D;1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;,</span><br><span class="line">        &quot;--capabilities&#x3D;&quot; + capabilities + &quot;,&quot; + capabilities,</span><br><span class="line">        &quot;--nice-name&#x3D;system_server&quot;,</span><br><span class="line">        &quot;--runtime-args&quot;,</span><br><span class="line">        &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ZygoteConnection.Arguments parsedArgs &#x3D; null;</span><br><span class="line">    int pid;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;用于解析参数，生成目标格式</span><br><span class="line">        parsedArgs &#x3D; new ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fork子进程，用于运行system_server</span><br><span class="line">        pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                null,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;进入子进程system_server</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 完成system_server进程剩余的工作</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。更多详情见<a href="http://gityuan.com/2016/02/14/android-system-server/" target="_blank" rel="noopener">Android系统启动-systemServer上篇</a>。</p>
<h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a><code>Zygote</code></h2><h3 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer"></a><code>forkSystemServer</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,</span><br><span class="line">            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</span><br><span class="line">        VM_HOOKS.preFork();</span><br><span class="line">        &#x2F;&#x2F; Resets nice priority for zygote process.</span><br><span class="line">        resetNicePriority();</span><br><span class="line">        int pid &#x3D; nativeForkSystemServer(</span><br><span class="line">                uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">        &#x2F;&#x2F; Enable tracing as soon as we enter the system_server.</span><br><span class="line">        if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            Trace.setTracingEnabled(true, runtimeFlags);</span><br><span class="line">        &#125;</span><br><span class="line">        VM_HOOKS.postForkCommon();</span><br><span class="line">        return pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int runtimeFlags,</span><br><span class="line">            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);</span><br></pre></td></tr></table></figure>

<p>调用底层创建system_server进程。</p>
<h2 id="ZygoteInit-1"><a href="#ZygoteInit-1" class="headerlink" title="ZygoteInit"></a><code>ZygoteInit</code></h2><h3 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop()"></a><code>runSelectLoop()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    &#x2F;&#x2F;sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">            pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">            pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">             &#x2F;&#x2F;处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span><br><span class="line">            Os.poll(pollFds, -1);</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；</span><br><span class="line">            &#x2F;&#x2F; 否则进入continue，跳出本次循环。</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；</span><br><span class="line">                &#x2F;&#x2F; 则创建ZygoteConnection对象,并添加到fds。</span><br><span class="line">                ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor()); &#x2F;&#x2F;添加到fds.</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作【见小节3.6】</span><br><span class="line">                boolean done &#x3D; peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i); &#x2F;&#x2F;处理完则从fds中移除该文件描述符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求。</p>
<h3 id="ZygoteConnection"><a href="#ZygoteConnection" class="headerlink" title="ZygoteConnection"></a><code>ZygoteConnection</code></h3><h3 id="runOnce"><a href="#runOnce" class="headerlink" title="runOnce()"></a><code>runOnce()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs &#x3D; null;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;读取socket客户端发送过来的参数列表</span><br><span class="line">        args &#x3D; readArgumentList();</span><br><span class="line">        descriptors &#x3D; mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;将binder客户端传递过来的参数，解析成Arguments对象格式</span><br><span class="line">        parsedArgs &#x3D; new Arguments(args);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;【见小节7】</span><br><span class="line">        pid &#x3D; Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;子进程执行</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;进入子进程流程</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;父进程执行</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd &#x3D; null;</span><br><span class="line">            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Zygote启动过程的调用流程图：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_start.jpg" alt="zygote_start"></p>
<ol>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；</li>
<li>zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li>
</ol>
<p><strong>Zygote做了哪些事：</strong></p>
<ul>
<li>创建vm虚拟机</li>
<li>注册JNI函数</li>
<li>建立socket通道，响应客户端请求</li>
<li>预加载通用类、资源、openGL、共享库、WebView</li>
<li>创建system_server进程</li>
<li>调用runSelectLoop()，当接收到请求创建新进程请求时立即唤醒并执行相应工作，没有请求则休眠。</li>
</ul>
<h1 id="fork进程"><a href="#fork进程" class="headerlink" title="fork进程"></a>fork进程</h1><h2 id="Zygote-1"><a href="#Zygote-1" class="headerlink" title="Zygote"></a><code>Zygote</code></h2><h3 id="forkAndSpecialize"><a href="#forkAndSpecialize" class="headerlink" title="forkAndSpecialize"></a><code>forkAndSpecialize</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, String instructionSet, String appDataDir) &#123;</span><br><span class="line">    VM_HOOKS.preFork(); &#x2F;&#x2F;【见小节8】</span><br><span class="line">    int pid &#x3D; nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir); &#x2F;&#x2F;【见小节9】</span><br><span class="line">    ...</span><br><span class="line">    VM_HOOKS.postForkCommon(); &#x2F;&#x2F;【见小节11】</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS是Zygote对象的静态成员变量：VM_HOOKS = new ZygoteHooks();</p>
<h2 id="ZygoteHooks"><a href="#ZygoteHooks" class="headerlink" title="ZygoteHooks"></a><code>ZygoteHooks</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void preFork() &#123;</span><br><span class="line">    Daemons.stop(); &#x2F;&#x2F;停止4个Daemon子线程【见小节8.1】</span><br><span class="line">    waitUntilAllThreadsStopped(); &#x2F;&#x2F;等待所有子线程结束【见小节8.2】</span><br><span class="line">    token &#x3D; nativePreFork(); &#x2F;&#x2F;完成gc堆的初始化工作【见小节8.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Daemons"><a href="#Daemons" class="headerlink" title="Daemons"></a><code>Daemons</code></h2><h3 id="stop"><a href="#stop" class="headerlink" title="stop()"></a><code>stop()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void stop() &#123;</span><br><span class="line">    HeapTaskDaemon.INSTANCE.stop(); &#x2F;&#x2F;Java堆整理线程</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.stop(); &#x2F;&#x2F;引用队列线程</span><br><span class="line">    FinalizerDaemon.INSTANCE.stop(); &#x2F;&#x2F;析构线程</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.stop(); &#x2F;&#x2F;析构监控线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处守护线程Stop方式是先调用目标线程interrrupt()方法，然后再调用目标线程join()方法，等待线程执行完成。</p>
<h3 id="waitUntilAllThreadsStopped"><a href="#waitUntilAllThreadsStopped" class="headerlink" title="waitUntilAllThreadsStopped()"></a><code>waitUntilAllThreadsStopped()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void waitUntilAllThreadsStopped() &#123;</span><br><span class="line">    File tasks &#x3D; new File(&quot;&#x2F;proc&#x2F;self&#x2F;task&quot;);</span><br><span class="line">    &#x2F;&#x2F; 当&#x2F;proc中线程数大于1，就出让CPU直到只有一个线程，才退出循环</span><br><span class="line">    while (tasks.list().length &gt; 1) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativePreFork"><a href="#nativePreFork" class="headerlink" title="nativePreFork()"></a><code>nativePreFork()</code></h3><p>nativePreFork通过JNI最终调用如下方法：</p>
<h2 id="dalvik-system-ZygoteHooks"><a href="#dalvik-system-ZygoteHooks" class="headerlink" title="dalvik_system_ZygoteHooks"></a>dalvik_system_ZygoteHooks</h2><h3 id="ZygoteHooks-nativePreFork"><a href="#ZygoteHooks-nativePreFork" class="headerlink" title="ZygoteHooks_nativePreFork"></a><code>ZygoteHooks_nativePreFork</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</span><br><span class="line">    Runtime* runtime &#x3D; Runtime::Current();</span><br><span class="line">    runtime-&gt;PreZygoteFork(); &#x2F;&#x2F; 见下文</span><br><span class="line">    if (Trace::GetMethodTracingMode() !&#x3D; TracingMode::kTracingInactive) &#123;</span><br><span class="line">      Trace::Pause();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将线程转换为long型并保存到token，该过程是非安全的</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于runtime-&gt;PreZygoteFork的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::PreZygoteFork() &#123;</span><br><span class="line">    &#x2F;&#x2F; 堆的初始化工作。这里就不继续再往下追art虚拟机</span><br><span class="line">    heap_-&gt;PreZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS.preFork()的主要功能便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），并等待这些线程的停止，初始化gc堆的工作, 并将线程转换为long型并保存到token</p>
<h2 id="Zygote-2"><a href="#Zygote-2" class="headerlink" title="Zygote"></a><code>Zygote</code></h2><h3 id="nativeForkAndSpecialize"><a href="#nativeForkAndSpecialize" class="headerlink" title="nativeForkAndSpecialize()"></a><code>nativeForkAndSpecialize()</code></h3><h2 id="com-android-internal-os-Zygote"><a href="#com-android-internal-os-Zygote" class="headerlink" title="com_android_internal_os_Zygote"></a><code>com_android_internal_os_Zygote</code></h2><h3 id="com-android-internal-os-Zygote-nativeForkAndSpecialize"><a href="#com-android-internal-os-Zygote-nativeForkAndSpecialize" class="headerlink" title="com_android_internal_os_Zygote_nativeForkAndSpecialize()"></a><code>com_android_internal_os_Zygote_nativeForkAndSpecialize()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(</span><br><span class="line">    JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span><br><span class="line">    jint debug_flags, jobjectArray rlimits,</span><br><span class="line">    jint mount_external, jstring se_info, jstring se_name,</span><br><span class="line">    jintArray fdsToClose, jstring instructionSet, jstring appDataDir) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将CAP_WAKE_ALARM赋予蓝牙进程</span><br><span class="line">    jlong capabilities &#x3D; 0;</span><br><span class="line">    if (uid &#x3D;&#x3D; AID_BLUETOOTH) &#123;</span><br><span class="line">        capabilities |&#x3D; (1LL &lt;&lt; CAP_WAKE_ALARM);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见流程10】</span><br><span class="line">    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, false, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForkAndSpecializeCommon"><a href="#ForkAndSpecializeCommon" class="headerlink" title="ForkAndSpecializeCommon()"></a><code>ForkAndSpecializeCommon()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置子进程的signal信号处理函数</span><br><span class="line">  SetSigChldHandler();</span><br><span class="line">  &#x2F;&#x2F;fork子进程 【见流程10.1】</span><br><span class="line">  pid_t pid &#x3D; fork();</span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程</span><br><span class="line">    DetachDescriptors(env, fdsToClose); &#x2F;&#x2F;关闭并清除文件描述符</span><br><span class="line"></span><br><span class="line">    if (!is_system_server) &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非system_server子进程，则创建进程组</span><br><span class="line">        int rc &#x3D; createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); &#x2F;&#x2F;设置设置group</span><br><span class="line">    SetRLimits(env, javaRlimits); &#x2F;&#x2F;设置资源limit</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; setresgid(gid, gid, gid);</span><br><span class="line">    rc &#x3D; setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); &#x2F;&#x2F;设置调度策略</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;selinux上下文</span><br><span class="line">    rc &#x3D; selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    if (se_info_c_str &#x3D;&#x3D; NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str &#x3D; &quot;system_server&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (se_info_c_str !&#x3D; NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); &#x2F;&#x2F;设置线程名为system_server，方便调试</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为</span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line">    &#x2F;&#x2F;等价于调用zygote.callPostForkChildHooks() 【见流程10.2】</span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入父进程，即Zygote进程</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。</p>
<ul>
<li>父进程中，fork返回新创建的子进程的pid;</li>
<li>子进程中，fork返回0；</li>
<li>当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</li>
</ul>
<p>fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote进程是所有Android进程的母体，包括system_server和各个App进程。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。其中下图中Zygote进程的libc、vm、preloaded classes、preloaded resources是如何生成的，可查看另一个文章<a href="http://gityuan.com/2016/02/13/android-zygote/#preload" target="_blank" rel="noopener">Android系统启动-zygote篇</a>，见下图：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_fork.jpg" alt="zygote_fork"></p>
<p>copy-on-write过程：当父子进程任一方修改内存数据时（这是on-write时机），才发生缺页中断，从而分配新的物理内存（这是copy操作）。</p>
<p>copy-on-write原理：写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork过程只拷贝父进程的页表，并标记这些页表是只读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常(page fault)，Linux收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。</p>
<h5 id="10-1-1-fork-cpp"><a href="#10-1-1-fork-cpp" class="headerlink" title="10.1.1 fork.cpp"></a>10.1.1 fork.cpp</h5><p>[-&gt; bionic/fork.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define FORK_FLAGS (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD)</span><br><span class="line">int fork() &#123;</span><br><span class="line">  __bionic_atfork_run_prepare(); &#x2F;&#x2F;[见小节2.1.1]</span><br><span class="line"></span><br><span class="line">  pthread_internal_t* self &#x3D; __get_thread();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;fork期间，获取父进程pid，并使其缓存值无效</span><br><span class="line">  pid_t parent_pid &#x3D; self-&gt;invalidate_cached_pid();</span><br><span class="line">  &#x2F;&#x2F;系统调用【见小节2.2】</span><br><span class="line">  int result &#x3D; syscall(__NR_clone, FORK_FLAGS, NULL, NULL, NULL, &amp;(self-&gt;tid));</span><br><span class="line">  if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    self-&gt;set_cached_pid(gettid());</span><br><span class="line">    __bionic_atfork_run_child(); &#x2F;&#x2F;fork完成执行子进程回调方法[见小节2.1.1]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    self-&gt;set_cached_pid(parent_pid);</span><br><span class="line">    __bionic_atfork_run_parent(); &#x2F;&#x2F;fork完成执行父进程回调方法</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能说明：在执行syscall的前后都有相应的回调方法。</p>
<ul>
<li>__bionic_atfork_run_prepare： fork完成前，父进程回调方法</li>
<li>__bionic_atfork_run_child： fork完成后，子进程回调方法</li>
<li>__bionic_atfork_run_paren： fork完成后，父进程回调方法</li>
</ul>
<p>以上3个方法的实现都位于bionic/pthread_atfork.cpp。如果有需要，可以扩展该回调方法，添加相关的业务需求。</p>
<h4 id="10-2-Zygote-callPostForkChildHooks"><a href="#10-2-Zygote-callPostForkChildHooks" class="headerlink" title="10.2 Zygote.callPostForkChildHooks"></a>10.2 Zygote.callPostForkChildHooks</h4><p>[-&gt; Zygote.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用ZygoteHooks.postForkChild()</span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void postForkChild(int debugFlags, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;【见流程10.3】</span><br><span class="line">    nativePostForkChild(token, debugFlags, instructionSet);</span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。</p>
<h4 id="10-3-nativePostForkChild"><a href="#10-3-nativePostForkChild" class="headerlink" title="10.3 nativePostForkChild"></a>10.3 nativePostForkChild</h4><p>nativePostForkChild通过JNI最终调用调用如下方法：</p>
<p>[-&gt; dalvik_system_ZygoteHooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处token是由[小节8.3]创建的，记录着当前线程</span><br><span class="line">    Thread* thread &#x3D; reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">    &#x2F;&#x2F;设置新进程的主线程id</span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    ..</span><br><span class="line">    if (instruction_set !&#x3D; nullptr) &#123;</span><br><span class="line">      ScopedUtfChars isa_string(env, instruction_set);</span><br><span class="line">      InstructionSet isa &#x3D; GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">      Runtime::NativeBridgeAction action &#x3D; Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">      if (isa !&#x3D; kNone &amp;&amp; isa !&#x3D; kRuntimeISA) &#123;</span><br><span class="line">        action &#x3D; Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;【见流程10.4】</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-4-DidForkFromZygote"><a href="#10-4-DidForkFromZygote" class="headerlink" title="10.4 DidForkFromZygote"></a>10.4 DidForkFromZygote</h4><p>[-&gt; Runtime.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) &#123;</span><br><span class="line">  is_zygote_ &#x3D; false;</span><br><span class="line">  if (is_native_bridge_loaded_) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">      case NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge(); &#x2F;&#x2F;卸载用于跨平台的桥连库</span><br><span class="line">        is_native_bridge_loaded_ &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      case NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);&#x2F;&#x2F;初始化用于跨平台的桥连库</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建Java堆处理的线程池</span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  &#x2F;&#x2F;重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line">  if (jit_.get() &#x3D;&#x3D; nullptr &amp;&amp; jit_options_-&gt;UseJIT()) &#123;</span><br><span class="line">    &#x2F;&#x2F;当flag被设置，并且还没有创建JIT时，则创建JIT</span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;设置信号处理函数</span><br><span class="line">  StartSignalCatcher();</span><br><span class="line">  &#x2F;&#x2F;启动JDWP线程，当命令debuger的flags指定&quot;suspend&#x3D;y&quot;时，则暂停runtime</span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于信号处理过程，其代码位于signal_catcher.cc文件中，后续会单独讲解。</p>
<h3 id="11-postForkCommon"><a href="#11-postForkCommon" class="headerlink" title="11. postForkCommon"></a>11. postForkCommon</h3><p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void postForkCommon() &#123;</span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void start() &#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS.postForkCommon的主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。</p>
<h3 id="12-forkAndSpecialize小结"><a href="#12-forkAndSpecialize小结" class="headerlink" title="12. forkAndSpecialize小结"></a>12. forkAndSpecialize小结</h3><p>该方法主要功能：</p>
<ul>
<li>preFork： 停止Zygote的4个Daemon子线程的运行，初始化gc堆；</li>
<li>nativeForkAndSpecialize：调用<code>fork()</code>创建新进程，设置新进程的主线程id，重置gc性能数据，设置信号处理函数等功能。</li>
<li>postForkCommon：启动4个Deamon子线程。</li>
</ul>
<p>其调用关系链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Zygote.forkAndSpecialize</span><br><span class="line">    ZygoteHooks.preFork</span><br><span class="line">        Daemons.stop</span><br><span class="line">        ZygoteHooks.nativePreFork</span><br><span class="line">            dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork</span><br><span class="line">                Runtime::PreZygoteFork</span><br><span class="line">                    heap_-&gt;PreZygoteFork()</span><br><span class="line">    Zygote.nativeForkAndSpecialize</span><br><span class="line">        com_android_internal_os_Zygote.ForkAndSpecializeCommon</span><br><span class="line">            fork()</span><br><span class="line">            Zygote.callPostForkChildHooks</span><br><span class="line">                ZygoteHooks.postForkChild</span><br><span class="line">                    dalvik_system_ZygoteHooks.nativePostForkChild</span><br><span class="line">                        Runtime::DidForkFromZygote</span><br><span class="line">    ZygoteHooks.postForkCommon</span><br><span class="line">        Daemons.start</span><br></pre></td></tr></table></figure>

<p><strong>时序图：</strong> 点击查看<a href="http://gityuan.com/images/android-process/fork_and_specialize.jpg" target="_blank" rel="noopener">大图</a></p>
<p><img src="http://gityuan.com/images/android-process/fork_and_specialize.jpg" alt="fork_and_specialize"></p>
<p>到此App进程已完成了创建的所有工作，接下来开始新创建的App进程的工作。在前面ZygoteConnection.runOnce方法中，zygote进程执行完<code>forkAndSpecialize()</code>后，新创建的App进程便进入<code>handleChildProc()</code>方法，下面的操作运行在App进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/" itemprop="url">画图工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T00:11:59+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/29/%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/29/%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h1><p><a href="https://www.processon.com/popular" target="_blank" rel="noopener">Process on</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
