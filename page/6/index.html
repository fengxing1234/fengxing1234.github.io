<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/" itemprop="url">自定义binder架构的C/S组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T17:46:25+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Native层Binder"><a href="#Native层Binder" class="headerlink" title="Native层Binder"></a>Native层Binder</h1><p>源码结构：</p>
<ul>
<li>ClientDemo.cpp: 客户端程序</li>
<li>ServerDemo.cpp：服务端程序</li>
<li>IMyService.h：自定义的MyService服务的头文件</li>
<li>IMyService.cpp：自定义的MyService服务</li>
<li>Android.mk：源码build文件</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取service manager引用</span><br><span class="line">    sp &lt; IServiceManager &gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">    &#x2F;&#x2F;注册名为&quot;service.myservice&quot;的服务到service manager</span><br><span class="line">    sm-&gt;addService(String16(&quot;service.myservice&quot;), new BnMyService());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool(); &#x2F;&#x2F;启动线程池</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool(); &#x2F;&#x2F;把主线程加入线程池</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将名为”service.myservice”的BnMyService服务添加到ServiceManager，并启动服务</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取service manager引用</span><br><span class="line">    sp &lt; IServiceManager &gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">    &#x2F;&#x2F;获取名为&quot;service.myservice&quot;的binder接口</span><br><span class="line">    sp &lt; IBinder &gt; binder &#x3D; sm-&gt;getService(String16(&quot;service.myservice&quot;));</span><br><span class="line">    &#x2F;&#x2F;将biner对象转换为强引用类型的IMyService</span><br><span class="line">    sp&lt;IMyService&gt; cs &#x3D; interface_cast &lt; IMyService &gt; (binder);</span><br><span class="line">    &#x2F;&#x2F;利用binder引用调用远程sayHello()方法</span><br><span class="line">    cs-&gt;sayHello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取名为”service.myservice”的服务，再进行类型，最后调用远程方法<code>sayHello()</code></p>
<h2 id="创建MyService"><a href="#创建MyService" class="headerlink" title="创建MyService"></a>创建MyService</h2><p><strong>IMyService.h</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">namespace android</span><br><span class="line">&#123;</span><br><span class="line">    class IMyService : public IInterface</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        DECLARE_META_INTERFACE(MyService); &#x2F;&#x2F;使用宏，申明MyService</span><br><span class="line">        virtual void sayHello()&#x3D;0; &#x2F;&#x2F;定义方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义命令字段</span><br><span class="line">    enum</span><br><span class="line">    &#123;</span><br><span class="line">        HELLO &#x3D; 1,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;申明客户端BpMyService</span><br><span class="line">    class BpMyService: public BpInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        BpMyService(const sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">        virtual void sayHello();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;申明服务端BnMyService</span><br><span class="line">    class BnMyService: public BnInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags &#x3D; 0);</span><br><span class="line">        virtual void sayHello();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能：</p>
<ul>
<li>申明IMyService</li>
<li>申明BpMyService（Binder客户端）</li>
<li>申明BnMyService（Binder的服务端）</li>
</ul>
<p><strong>IMyService.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">namespace android</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;使用宏，完成MyService定义</span><br><span class="line">    IMPLEMENT_META_INTERFACE(MyService, &quot;android.demo.IMyService&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;客户端</span><br><span class="line">    BpMyService::BpMyService(const sp&lt;IBinder&gt;&amp; impl) :</span><br><span class="line">            BpInterface&lt;IMyService&gt;(impl) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现客户端sayHello方法</span><br><span class="line">    void BpMyService::sayHello() &#123;</span><br><span class="line">        printf(&quot;BpMyService::sayHello\n&quot;);</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMyService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(HELLO, data, &amp;reply);</span><br><span class="line">        printf(&quot;get num from BnMyService: %d\n&quot;, reply.readInt32());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;服务端，接收远程消息，处理onTransact方法</span><br><span class="line">    status_t BnMyService::onTransact(uint_t code, const Parcel&amp; data,</span><br><span class="line">            Parcel* reply, uint32_t flags) &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case HELLO: &#123;    &#x2F;&#x2F;收到HELLO命令的处理流程</span><br><span class="line">            printf(&quot;BnMyService:: got the client hello\n&quot;);</span><br><span class="line">            CHECK_INTERFACE(IMyService, data, reply);</span><br><span class="line">            sayHello();</span><br><span class="line">            reply-&gt;writeInt32(2015);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现服务端sayHello方法</span><br><span class="line">    void BnMyService::sayHello() &#123;</span><br><span class="line">        printf(&quot;BnMyService::sayHello\n&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://gityuan.com/images/binder/binderSimple/native_binder_demo.jpg" alt="native_binder"></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><strong>编译生成</strong> 利用Android.mk编译上述代码，在Android的源码中，通过mm编译后，可生成两个可执行文件ServerDemo，ClientDemo。</p>
<p><strong>执行</strong></p>
<p>首先将这两个ServerDemo，ClientDemo可执行文件push到手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push ServerDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ClientDemo &#x2F;system&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>如果push不成功，那么先执行<code>adb remount</code>，再执行上面的指令；如果还不成功，可能就是权限不够。</p>
<p>如果上述开启成功，通过开启两个窗口运行（一个运行client端，另一个运行server端）</p>
<p><strong>结果</strong></p>
<p>服务端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/native_server.png" alt="native_server"></p>
<p>客户端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/native_client.png" alt="native_client"></p>
<h1 id="Framework层Binder"><a href="#Framework层Binder" class="headerlink" title="Framework层Binder"></a>Framework层Binder</h1><p>源码结构：</p>
<p>Server端</p>
<ol>
<li>ServerDemo.java：可执行程序</li>
<li>IMyService.java: 定义IMyService接口</li>
<li>MyService.java：定义MyService</li>
</ol>
<p>Client端</p>
<ol>
<li>ClientDemo.java：可执行程序</li>
<li>IMyService.java: 与Server端完全一致</li>
<li>MyServiceProxy.java：定义MyServiceProxy</li>
</ol>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><p><strong>ServerDemo.java</strong></p>
<p>可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;MyService Start&quot;);</span><br><span class="line">        &#x2F;&#x2F;准备Looper循环执行</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        &#x2F;&#x2F;设置为前台优先级</span><br><span class="line">        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        &#x2F;&#x2F;注册服务</span><br><span class="line">        ServiceManager.addService(&quot;MyService&quot;, new MyService());</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMyService.java</strong></p>
<p>定义sayHello()方法，DESCRIPTOR属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyService extends IInterface &#123;</span><br><span class="line">    static final java.lang.String DESCRIPTOR &#x3D; &quot;com.gityuan.frameworkBinder.MyServer&quot;;</span><br><span class="line">    public void sayHello(String str) throws RemoteException ;</span><br><span class="line">    static final int TRANSACTION_say &#x3D; android.os.IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyService.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Binder implements IMyService&#123;</span><br><span class="line"></span><br><span class="line">    public MyService() &#123;</span><br><span class="line">        this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 将MyService转换为IMyService接口 **&#x2F;</span><br><span class="line">    public static com.gityuan.frameworkBinder.IMyService asInterface( android.os.IBinder obj) &#123;</span><br><span class="line">        if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iInterface &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (((iInterface !&#x3D; null)&amp;&amp;(iInterface instanceof com.gityuan.frameworkBinder.IMyService)))&#123;</span><br><span class="line">            return ((com.gityuan.frameworkBinder.IMyService) iInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 服务端，接收远程消息，处理onTransact方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_say: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            String str &#x3D; data.readString();</span><br><span class="line">            sayHello(str);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 自定义sayHello()方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        System.out.println(&quot;MyService:: Hello, &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><p><strong>ClientDemo.java</strong></p>
<p>可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Client start&quot;);</span><br><span class="line">        IBinder binder &#x3D; ServiceManager.getService(&quot;MyService&quot;); &#x2F;&#x2F;获取名为&quot;MyService&quot;的服务</span><br><span class="line">        IMyService myService &#x3D; new MyServiceProxy(binder); &#x2F;&#x2F;创建MyServiceProxy对象</span><br><span class="line">        myService.sayHello(&quot;binder&quot;); &#x2F;&#x2F;通过MyServiceProxy对象调用接口的方法</span><br><span class="line">        System.out.println(&quot;Client end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMyService.java</strong></p>
<p>与Server端的IMyService是一致，基本都是拷贝一份过来。</p>
<p><strong>MyServiceProxy.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyServiceProxy implements IMyService &#123;</span><br><span class="line">    private android.os.IBinder mRemote;  &#x2F;&#x2F;代表BpBinder</span><br><span class="line"></span><br><span class="line">    public MyServiceProxy(android.os.IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">        return DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 自定义的sayHello()方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) throws RemoteException &#123;</span><br><span class="line">        android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(str);</span><br><span class="line">            mRemote.transact(TRANSACTION_say, _data, _reply, 0);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://gityuan.com/images/binder/binderSimple/MyServer_framework_binder.jpg" alt="framework_binder"></p>
<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>首先将ServerDemo，ClientDemo可执行文件，以及ServerDemo.jar，ClientDemo.jar都push到手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push ServerDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ClientDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ServerDemo.jar &#x2F;system&#x2F;framework</span><br><span class="line">adb push ClientDemo.jar &#x2F;system&#x2F;framework</span><br></pre></td></tr></table></figure>

<p>如果push不成功，那么先执行<code>adb remount</code>，再执行上面的指令；如果还不成功，可能就是权限不够。</p>
<p>如果上述开启成功，通过开启两个窗口运行（一个运行client端，另一个运行server端）</p>
<p><strong>结果</strong></p>
<p>服务端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/framework_server.png" alt="framework_server"></p>
<p>客户端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/framework_client.png" alt="framework_client"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/" itemprop="url">Binder机制framework层分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T13:42:10+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><p>基于6.0.0_r1地址<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r1/core/java/android/os/" target="_blank" rel="noopener">源码地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">  - IInterface.java</span><br><span class="line">  - IServiceManager.java</span><br><span class="line">  - ServiceManager.java</span><br><span class="line">  - ServiceManagerNative.java(内含ServiceManagerProxy类)</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">  - IBinder.java</span><br><span class="line">  - Binder.java(内含BinderProxy类)</span><br><span class="line">  - Parcel.java</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">  - BinderInternal.java</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;jni&#x2F;</span><br><span class="line">  - AndroidRuntime.cpp</span><br><span class="line">  - android_os_Parcel.cpp</span><br><span class="line">  - android_util_Binder.cpp</span><br></pre></td></tr></table></figure>

<p><strong>IInterface</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Base class for Binder interfaces.  When defining a new interface,</span><br><span class="line"> * you must derive it from IInterface.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve the Binder object associated with this interface.</span><br><span class="line">     * You must use this instead of a plain cast, so that proxy objects</span><br><span class="line">     * can return the correct result.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IServiceManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Basic interface for finding and publishing system services.</span><br><span class="line"> * </span><br><span class="line"> * An implementation of this interface is usually published as the</span><br><span class="line"> * global context object, which can be retrieved via</span><br><span class="line"> * BinderNative.getContextObject().  An easy way to retrieve this</span><br><span class="line"> * is with the static method BnServiceManager.getDefault().</span><br><span class="line"> * </span><br><span class="line"> * @hide</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IServiceManager extends IInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Blocks for a few seconds waiting for it to be</span><br><span class="line">     * published if it does not already exist.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder getService(String name) throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Non-blocking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder checkService(String name) throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">                throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return a list of all currently running services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String[] listServices() throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Assign a permission controller to the service manager.  After set, this</span><br><span class="line">     * interface is checked before any services are added.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    static final String descriptor &#x3D; &quot;android.os.IServiceManager&quot;;</span><br><span class="line">    int GET_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">    int CHECK_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+1;</span><br><span class="line">    int ADD_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+2;</span><br><span class="line">    int LIST_SERVICES_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+3;</span><br><span class="line">    int CHECK_SERVICES_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+4;</span><br><span class="line">    int SET_PERMISSION_CONTROLLER_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ServiceManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** @hide *&#x2F;</span><br><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;ServiceManager&quot;;</span><br><span class="line">    private static IServiceManager sServiceManager;</span><br><span class="line">    private static HashMap&lt;String, IBinder&gt; sCache &#x3D; new HashMap&lt;String, IBinder&gt;();</span><br><span class="line">    private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a reference to a service with the given name.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the service to get</span><br><span class="line">     * @return a reference to the service, or &lt;code&gt;null&lt;&#x2F;code&gt; if the service doesn&#39;t exist</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the new service</span><br><span class="line">     * @param service the service object</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the new service</span><br><span class="line">     * @param service the service object</span><br><span class="line">     * @param allowIsolated set to true to allow isolated sandboxed processes</span><br><span class="line">     * to access this service</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void addService(String name, IBinder service, boolean allowIsolated) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Non-blocking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder checkService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().checkService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in checkService&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return a list of all currently running services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String[] listServices() throws RemoteException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return getIServiceManager().listServices();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in listServices&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This is only intended to be called when the process is first being brought</span><br><span class="line">     * up and bound by the activity manager. There is only one thread in the process</span><br><span class="line">     * at that time, so no locking is done.</span><br><span class="line">     * </span><br><span class="line">     * @param cache the cache of service references</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void initServiceCache(Map&lt;String, IBinder&gt; cache) &#123;</span><br><span class="line">        if (sCache.size() !&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;setServiceCache may only be called once&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sCache.putAll(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceManagerNative</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Native implementation of the service manager.  Most clients will only</span><br><span class="line"> * care about getDefault() and possibly asInterface().</span><br><span class="line"> * @hide</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class ServiceManagerNative extends Binder implements IServiceManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Cast a Binder object into a service manager interface, generating</span><br><span class="line">     * a proxy if needed.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ServiceManagerNative()</span><br><span class="line">    &#123;</span><br><span class="line">        attachInterface(this, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">            case IServiceManager.GET_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; getService(name);</span><br><span class="line">                reply.writeStrongBinder(service);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.CHECK_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; checkService(name);</span><br><span class="line">                reply.writeStrongBinder(service);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; data.readStrongBinder();</span><br><span class="line">                boolean allowIsolated &#x3D; data.readInt() !&#x3D; 0;</span><br><span class="line">                addService(name, service, allowIsolated);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.LIST_SERVICES_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String[] list &#x3D; listServices();</span><br><span class="line">                reply.writeStringArray(list);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            case IServiceManager.SET_PERMISSION_CONTROLLER_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                IPermissionController controller</span><br><span class="line">                        &#x3D; IPermissionController.Stub.asInterface(</span><br><span class="line">                                data.readStrongBinder());</span><br><span class="line">                setPermissionController(controller);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder asBinder()</span><br><span class="line">    &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder checkService(String name) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(CHECK_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String[] listServices() throws RemoteException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; services &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">            Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">            data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">            data.writeInt(n);</span><br><span class="line">            n++;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean res &#x3D; mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);</span><br><span class="line">                if (!res) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; The result code that is returned by the C++ code can</span><br><span class="line">                &#x2F;&#x2F; cause the call to throw an exception back instead of</span><br><span class="line">                &#x2F;&#x2F; returning a nice result...  so eat it here and go on.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            services.add(reply.readString());</span><br><span class="line">            reply.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        String[] array &#x3D; new String[services.size()];</span><br><span class="line">        services.toArray(array);</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(controller.asBinder());</span><br><span class="line">        mRemote.transact(SET_PERMISSION_CONTROLLER_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    private IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IBinder</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">public interface IBinder &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The first transaction code available for user commands.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int FIRST_CALL_TRANSACTION  &#x3D; 0x00000001;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The last transaction code available for user commands.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int LAST_CALL_TRANSACTION   &#x3D; 0x00ffffff;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: pingBinder().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int PING_TRANSACTION        &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;P&#39;&lt;&lt;16)|(&#39;N&#39;&lt;&lt;8)|&#39;G&#39;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: dump internal state.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int DUMP_TRANSACTION        &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;D&#39;&lt;&lt;16)|(&#39;M&#39;&lt;&lt;8)|&#39;P&#39;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: interrogate the recipient side</span><br><span class="line">     * of the transaction for its canonical interface descriptor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int INTERFACE_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;N&#39;&lt;&lt;16)|(&#39;T&#39;&lt;&lt;8)|&#39;F&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: send a tweet to the target</span><br><span class="line">     * object.  The data in the parcel is intended to be delivered to</span><br><span class="line">     * a shared messaging service associated with the object; it can be</span><br><span class="line">     * anything, as long as it is not more than 130 UTF-8 characters to</span><br><span class="line">     * conservatively fit within common messaging services.  As part of</span><br><span class="line">     * &#123;@link Build.VERSION_CODES#HONEYCOMB_MR2&#125;, all Binder objects are</span><br><span class="line">     * expected to support this protocol for fully integrated tweeting</span><br><span class="line">     * across the platform.  To support older code, the default implementation</span><br><span class="line">     * logs the tweet to the main log as a simple emulation of broadcasting</span><br><span class="line">     * it publicly over the Internet.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;Also, upon completing the dispatch, the object must make a cup</span><br><span class="line">     * of tea, return it to the caller, and exclaim &quot;jolly good message</span><br><span class="line">     * old boy!&quot;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int TWEET_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;T&#39;&lt;&lt;16)|(&#39;W&#39;&lt;&lt;8)|&#39;T&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: tell an app asynchronously that the</span><br><span class="line">     * caller likes it.  The app is responsible for incrementing and maintaining</span><br><span class="line">     * its own like counter, and may display this value to the user to indicate the</span><br><span class="line">     * quality of the app.  This is an optional command that applications do not</span><br><span class="line">     * need to handle, so the default implementation is to do nothing.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;There is no response returned and nothing about the</span><br><span class="line">     * system will be functionally affected by it, but it will improve the</span><br><span class="line">     * app&#39;s self-esteem.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int LIKE_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;L&#39;&lt;&lt;16)|(&#39;I&#39;&lt;&lt;8)|&#39;K&#39;;</span><br><span class="line">    &#x2F;** @hide *&#x2F;</span><br><span class="line">    int SYSPROPS_TRANSACTION &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;S&#39;&lt;&lt;16)|(&#39;P&#39;&lt;&lt;8)|&#39;R&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Flag to &#123;@link #transact&#125;: this is a one-way call, meaning that the</span><br><span class="line">     * caller returns immediately, without waiting for a result from the</span><br><span class="line">     * callee. Applies only if the caller and callee are in different</span><br><span class="line">     * processes.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int FLAG_ONEWAY             &#x3D; 0x00000001;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Limit that should be placed on IPC sizes to keep them safely under the</span><br><span class="line">     * transaction buffer limit.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final int MAX_IPC_SIZE &#x3D; 64 * 1024;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the canonical name of the interface supported by this binder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check to see if the object still exists.</span><br><span class="line">     * </span><br><span class="line">     * @return Returns false if the</span><br><span class="line">     * hosting process is gone, otherwise the result (always by default</span><br><span class="line">     * true) returned by the pingBinder() implementation on the other</span><br><span class="line">     * side.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean pingBinder();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check to see if the process that the binder is in is still alive.</span><br><span class="line">     *</span><br><span class="line">     * @return false if the process is not alive.  Note that if it returns</span><br><span class="line">     * true, the process may have died while the call is returning.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isBinderAlive();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempt to retrieve a local implementation of an interface</span><br><span class="line">     * for this Binder object.  If null is returned, you will need</span><br><span class="line">     * to instantiate a proxy class to marshall calls through</span><br><span class="line">     * the transact() method.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Print the object&#39;s state into the given stream.</span><br><span class="line">     * </span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Like &#123;@link #dump(FileDescriptor, String[])&#125; but always executes</span><br><span class="line">     * asynchronously.  If the object is local, a new thread is created</span><br><span class="line">     * to perform the dump.</span><br><span class="line">     *</span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Perform a generic operation with the object.</span><br><span class="line">     * </span><br><span class="line">     * @param code The action to perform.  This should</span><br><span class="line">     * be a number between &#123;@link #FIRST_CALL_TRANSACTION&#125; and</span><br><span class="line">     * &#123;@link #LAST_CALL_TRANSACTION&#125;.</span><br><span class="line">     * @param data Marshalled data to send to the target.  Must not be null.</span><br><span class="line">     * If you are not sending any data, you must create an empty Parcel</span><br><span class="line">     * that is given here.</span><br><span class="line">     * @param reply Marshalled data to be received from the target.  May be</span><br><span class="line">     * null if you are not interested in the return value.</span><br><span class="line">     * @param flags Additional operation flags.  Either 0 for a normal</span><br><span class="line">     * RPC, or &#123;@link #FLAG_ONEWAY&#125; for a one-way RPC.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">        throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Interface for receiving a callback when the process hosting an IBinder</span><br><span class="line">     * has gone away.</span><br><span class="line">     * </span><br><span class="line">     * @see #linkToDeath</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public interface DeathRecipient &#123;</span><br><span class="line">        public void binderDied();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Register the recipient for a notification if this binder</span><br><span class="line">     * goes away.  If this binder object unexpectedly goes away</span><br><span class="line">     * (typically because its hosting process has been killed),</span><br><span class="line">     * then the given &#123;@link DeathRecipient&#125;&#39;s</span><br><span class="line">     * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method</span><br><span class="line">     * will be called.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;You will only receive death notifications for remote binders,</span><br><span class="line">     * as local binders by definition can&#39;t die without you dying as well.</span><br><span class="line">     * </span><br><span class="line">     * @throws RemoteException if the target IBinder&#39;s</span><br><span class="line">     * process has already died.</span><br><span class="line">     * </span><br><span class="line">     * @see #unlinkToDeath</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void linkToDeath(DeathRecipient recipient, int flags)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove a previously registered death notification.</span><br><span class="line">     * The recipient will no longer be called if this object</span><br><span class="line">     * dies.</span><br><span class="line">     * </span><br><span class="line">     * @return &#123;@code true&#125; if the &lt;var&gt;recipient&lt;&#x2F;var&gt; is successfully</span><br><span class="line">     * unlinked, assuring you that its</span><br><span class="line">     * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method</span><br><span class="line">     * will not be called;  &#123;@code false&#125; if the target IBinder has already</span><br><span class="line">     * died, meaning the method has been (or soon will be) called.</span><br><span class="line">     * </span><br><span class="line">     * @throws java.util.NoSuchElementException if the given</span><br><span class="line">     * &lt;var&gt;recipient&lt;&#x2F;var&gt; has not been registered with the IBinder, and</span><br><span class="line">     * the IBinder is still alive.  Note that if the &lt;var&gt;recipient&lt;&#x2F;var&gt;</span><br><span class="line">     * was never registered, but the IBinder has already died, then this</span><br><span class="line">     * exception will &lt;em&gt;not&lt;&#x2F;em&gt; be thrown, and you will receive a false</span><br><span class="line">     * return value instead.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Binder</strong></p>
<p>BinderProxy是Binder的内部类实现IBinder接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Set this flag to true to detect anonymous, local or member classes</span><br><span class="line">     * that extend this Binder class and that are not static. These kind</span><br><span class="line">     * of classes can potentially create leaks.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final boolean FIND_POTENTIAL_LEAKS &#x3D; false;</span><br><span class="line">    private static final boolean CHECK_PARCEL_SIZE &#x3D; false;</span><br><span class="line">    static final String TAG &#x3D; &quot;Binder&quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Control whether dump() calls are allowed.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String sDumpDisabled &#x3D; null;</span><br><span class="line">    &#x2F;* mObject is used by native code, do not remove or rename *&#x2F;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private IInterface mOwner;</span><br><span class="line">    private String mDescriptor;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the ID of the process that sent you the current transaction</span><br><span class="line">     * that is being processed.  This pid can be used with higher-level</span><br><span class="line">     * system services to determine its identity and check permissions.</span><br><span class="line">     * If the current thread is not currently executing an incoming transaction,</span><br><span class="line">     * then its own pid is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getCallingPid();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the Linux uid assigned to the process that sent you the</span><br><span class="line">     * current transaction that is being processed.  This uid can be used with</span><br><span class="line">     * higher-level system services to determine its identity and check</span><br><span class="line">     * permissions.  If the current thread is not currently executing an</span><br><span class="line">     * incoming transaction, then its own uid is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getCallingUid();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the UserHandle assigned to the process that sent you the</span><br><span class="line">     * current transaction that is being processed.  This is the user</span><br><span class="line">     * of the caller.  It is distinct from &#123;@link #getCallingUid()&#125; in that a</span><br><span class="line">     * particular user will have multiple distinct apps running under it each</span><br><span class="line">     * with their own uid.  If the current thread is not currently executing an</span><br><span class="line">     * incoming transaction, then its own UserHandle is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final UserHandle getCallingUserHandle() &#123;</span><br><span class="line">        return new UserHandle(UserHandle.getUserId(getCallingUid()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reset the identity of the incoming IPC on the current thread.  This can</span><br><span class="line">     * be useful if, while handling an incoming call, you will be calling</span><br><span class="line">     * on interfaces of other objects that may be local to your process and</span><br><span class="line">     * need to do permission checks on the calls coming into them (so they</span><br><span class="line">     * will check the permission of your own local process, and not whatever</span><br><span class="line">     * process originally called you).</span><br><span class="line">     *</span><br><span class="line">     * @return Returns an opaque token that can be used to restore the</span><br><span class="line">     * original calling identity by passing it to</span><br><span class="line">     * &#123;@link #restoreCallingIdentity(long)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #getCallingPid()</span><br><span class="line">     * @see #getCallingUid()</span><br><span class="line">     * @see #restoreCallingIdentity(long)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native long clearCallingIdentity();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Restore the identity of the incoming IPC on the current thread</span><br><span class="line">     * back to a previously identity that was returned by &#123;@link</span><br><span class="line">     * #clearCallingIdentity&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param token The opaque token that was previously returned by</span><br><span class="line">     * &#123;@link #clearCallingIdentity&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #clearCallingIdentity</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void restoreCallingIdentity(long token);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets the native thread-local StrictMode policy mask.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The StrictMode settings are kept in two places: a Java-level</span><br><span class="line">     * threadlocal for libcore&#x2F;Dalvik, and a native threadlocal (set</span><br><span class="line">     * here) for propagation via Binder calls.  This is a little</span><br><span class="line">     * unfortunate, but necessary to break otherwise more unfortunate</span><br><span class="line">     * dependencies either of Dalvik on Android, or Android</span><br><span class="line">     * native-only code on Dalvik.</span><br><span class="line">     *</span><br><span class="line">     * @see StrictMode</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void setThreadStrictModePolicy(int policyMask);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets the current native thread-local StrictMode policy mask.</span><br><span class="line">     *</span><br><span class="line">     * @see #setThreadStrictModePolicy</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getThreadStrictModePolicy();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Flush any Binder commands pending in the current thread to the kernel</span><br><span class="line">     * driver.  This can be</span><br><span class="line">     * useful to call before performing an operation that may block for a long</span><br><span class="line">     * time, to ensure that any pending object references have been released</span><br><span class="line">     * in order to prevent the process from holding on to objects longer than</span><br><span class="line">     * it needs to.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void flushPendingCommands();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Add the calling thread to the IPC thread pool.  This function does</span><br><span class="line">     * not return until the current process is exiting.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void joinThreadPool();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns true if the specified interface is a proxy.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final boolean isProxy(IInterface iface) &#123;</span><br><span class="line">        return iface.asBinder() !&#x3D; iface;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Call blocks until the number of executing binder threads is less</span><br><span class="line">     * than the maximum number of binder threads allowed for this process.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void blockUntilThreadAvailable();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default constructor initializes the object.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Binder() &#123;</span><br><span class="line">        init();</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Binder&gt; klass &#x3D; getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Binder class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Convenience method for associating a specific interface with the Binder.</span><br><span class="line">     * After calling, queryLocalInterface() will be implemented for you</span><br><span class="line">     * to return the given owner IInterface when the corresponding</span><br><span class="line">     * descriptor is requested.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void attachInterface(IInterface owner, String descriptor) &#123;</span><br><span class="line">        mOwner &#x3D; owner;</span><br><span class="line">        mDescriptor &#x3D; descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation returns an empty interface name.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getInterfaceDescriptor() &#123;</span><br><span class="line">        return mDescriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation always returns true -- if you got here,</span><br><span class="line">     * the object is alive.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean pingBinder() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *</span><br><span class="line">     * Note that if you&#39;re calling on a local binder, this always returns true</span><br><span class="line">     * because your process is alive if you&#39;re calling it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isBinderAlive() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Use information supplied to attachInterface() to return the</span><br><span class="line">     * associated IInterface if it matches the requested</span><br><span class="line">     * descriptor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        if (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">            return mOwner;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Control disabling of dump calls in this process.  This is used by the system</span><br><span class="line">     * process watchdog to disable incoming dump calls while it has detecting the system</span><br><span class="line">     * is hung and is reporting that back to the activity controller.  This is to</span><br><span class="line">     * prevent the controller from getting hung up on bug reports at this point.</span><br><span class="line">     * @hide</span><br><span class="line">     *</span><br><span class="line">     * @param msg The message to show instead of the dump; if null, dumps are</span><br><span class="line">     * re-enabled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setDumpDisabled(String msg) &#123;</span><br><span class="line">        synchronized (Binder.class) &#123;</span><br><span class="line">            sDumpDisabled &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation is a stub that returns false.  You will want</span><br><span class="line">     * to override this to do the appropriate unmarshalling of transactions.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If you want to call this, call transact().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (code &#x3D;&#x3D; INTERFACE_TRANSACTION) &#123;</span><br><span class="line">            reply.writeString(getInterfaceDescriptor());</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (code &#x3D;&#x3D; DUMP_TRANSACTION) &#123;</span><br><span class="line">            ParcelFileDescriptor fd &#x3D; data.readFileDescriptor();</span><br><span class="line">            String[] args &#x3D; data.readStringArray();</span><br><span class="line">            if (fd !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd.getFileDescriptor(), args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        fd.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; swallowed, not propagated back to the caller</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Write the StrictMode header.</span><br><span class="line">            if (reply !&#x3D; null) &#123;</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StrictMode.clearGatheredViolations();</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Implemented to call the more convenient version</span><br><span class="line">     * &#123;@link #dump(FileDescriptor, PrintWriter, String[])&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) &#123;</span><br><span class="line">        FileOutputStream fout &#x3D; new FileOutputStream(fd);</span><br><span class="line">        PrintWriter pw &#x3D; new FastPrintWriter(fout);</span><br><span class="line">        try &#123;</span><br><span class="line">            final String disabled;</span><br><span class="line">            synchronized (Binder.class) &#123;</span><br><span class="line">                disabled &#x3D; sDumpDisabled;</span><br><span class="line">            &#125;</span><br><span class="line">            if (disabled &#x3D;&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd, pw, args);</span><br><span class="line">                &#125; catch (SecurityException e) &#123;</span><br><span class="line">                    pw.println(&quot;Security exception: &quot; + e.getMessage());</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Unlike usual calls, in this case if an exception gets thrown</span><br><span class="line">                    &#x2F;&#x2F; back to us we want to print it back in to the dump data, since</span><br><span class="line">                    &#x2F;&#x2F; that is where the caller expects all interesting information to</span><br><span class="line">                    &#x2F;&#x2F; go.</span><br><span class="line">                    pw.println();</span><br><span class="line">                    pw.println(&quot;Exception occurred while dumping:&quot;);</span><br><span class="line">                    e.printStackTrace(pw);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pw.println(sDumpDisabled);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            pw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Like &#123;@link #dump(FileDescriptor, String[])&#125;, but ensures the target</span><br><span class="line">     * executes asynchronously.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dumpAsync(final FileDescriptor fd, final String[] args) &#123;</span><br><span class="line">        final FileOutputStream fout &#x3D; new FileOutputStream(fd);</span><br><span class="line">        final PrintWriter pw &#x3D; new FastPrintWriter(fout);</span><br><span class="line">        Thread thr &#x3D; new Thread(&quot;Binder.dumpAsync&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd, pw, args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    pw.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thr.start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Print the object&#39;s state into the given stream.</span><br><span class="line">     * </span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param fout The file to which you should dump your state.  This will be</span><br><span class="line">     * closed for you after you return.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation rewinds the parcels and calls onTransact.  On</span><br><span class="line">     * the remote side, transact calls into the binder to do the IPC.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final boolean transact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);</span><br><span class="line">        if (data !&#x3D; null) &#123;</span><br><span class="line">            data.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean r &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        if (reply !&#x3D; null) &#123;</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local implementation is a no-op.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void linkToDeath(DeathRecipient recipient, int flags) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local implementation is a no-op.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void checkParcel(IBinder obj, int code, Parcel parcel, String msg) &#123;</span><br><span class="line">        if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;&#x3D; 800*1024) &#123;</span><br><span class="line">            &#x2F;&#x2F; Trying to send &gt; 800k, this is way too much</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            sb.append(msg);</span><br><span class="line">            sb.append(&quot;: on &quot;);</span><br><span class="line">            sb.append(obj);</span><br><span class="line">            sb.append(&quot; calling &quot;);</span><br><span class="line">            sb.append(code);</span><br><span class="line">            sb.append(&quot; size &quot;);</span><br><span class="line">            sb.append(parcel.dataSize());</span><br><span class="line">            sb.append(&quot; (data: &quot;);</span><br><span class="line">            parcel.setDataPosition(0);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;, &quot;);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;, &quot;);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;)&quot;);</span><br><span class="line">            Slog.wtfStack(TAG, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private native final void init();</span><br><span class="line">    private native final void destroy();</span><br><span class="line">    &#x2F;&#x2F; Entry point from android_util_Binder.cpp&#39;s onTransact</span><br><span class="line">    private boolean execTransact(int code, long dataObj, long replyObj,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain(replyObj);</span><br><span class="line">        &#x2F;&#x2F; theoretically, we should call transact, which will call onTransact,</span><br><span class="line">        &#x2F;&#x2F; but all that does is rewind it, and we just got these from an IPC,</span><br><span class="line">        &#x2F;&#x2F; so we&#39;ll just call it directly.</span><br><span class="line">        boolean res;</span><br><span class="line">        &#x2F;&#x2F; Log any exceptions as warnings, don&#39;t silently suppress them.</span><br><span class="line">        &#x2F;&#x2F; If the call was FLAG_ONEWAY then these exceptions disappear into the ether.</span><br><span class="line">        try &#123;</span><br><span class="line">            res &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Binder call failed.&quot;, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply.setDataPosition(0);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply.setDataPosition(0);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Unconditionally log this, since this is generally unrecoverable.</span><br><span class="line">            Log.e(TAG, &quot;Caught an OutOfMemoryError from the binder stub implementation.&quot;, e);</span><br><span class="line">            RuntimeException re &#x3D; new RuntimeException(&quot;Out of memory&quot;, e);</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(re);</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        checkParcel(this, code, reply, &quot;Unreasonably large binder reply buffer&quot;);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        &#x2F;&#x2F; Just in case -- we are done with the IPC, so there should be no more strict</span><br><span class="line">        &#x2F;&#x2F; mode violations that have gathered for this thread.  Either they have been</span><br><span class="line">        &#x2F;&#x2F; parceled and are now in transport off to the caller, or we are returning back</span><br><span class="line">        &#x2F;&#x2F; to the main transaction loop to wait for another incoming transaction.  Either</span><br><span class="line">        &#x2F;&#x2F; way, strict mode begone!</span><br><span class="line">        StrictMode.clearGatheredViolations();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    public native boolean pingBinder();</span><br><span class="line">    public native boolean isBinderAlive();</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">        return transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    public native String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line">    public native boolean transactNative(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException;</span><br><span class="line">    public native void linkToDeath(DeathRecipient recipient, int flags)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(DUMP_TRANSACTION, data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(DUMP_TRANSACTION, data, reply, FLAG_ONEWAY);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxy() &#123;</span><br><span class="line">        mSelf &#x3D; new WeakReference(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private native final void destroy();</span><br><span class="line">    </span><br><span class="line">    private static final void sendDeathNotice(DeathRecipient recipient) &#123;</span><br><span class="line">        if (false) Log.v(&quot;JavaBinder&quot;, &quot;sendDeathNotice to &quot; + recipient);</span><br><span class="line">        try &#123;</span><br><span class="line">            recipient.binderDied();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RuntimeException exc) &#123;</span><br><span class="line">            Log.w(&quot;BinderNative&quot;, &quot;Uncaught exception from death notification&quot;,</span><br><span class="line">                    exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final private WeakReference mSelf;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private long mOrgue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder概述"><a href="#Binder概述" class="headerlink" title="Binder概述"></a>Binder概述</h1><h2 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h2><p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p>
<p><img src="http://gityuan.com/images/binder/java_binder/java_binder.jpg" alt="java_binder"></p>
<ul>
<li>图中红色代表整个framework层 binder架构相关组件；<ul>
<li>Binder类代表Server端，BinderProxy类代码Client端；</li>
</ul>
</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的，后面会详细说明。</li>
</ul>
<h2 id="Binder类图"><a href="#Binder类图" class="headerlink" title="Binder类图"></a>Binder类图</h2><p><img src="http://gityuan.com/images/binder/java_binder/class_ServiceManager.jpg" alt="class_java_binder"></p>
<ul>
<li><strong>ServiceManager：</strong>通过getIServiceManager方法获取的是ServiceManagerProxy对象； ServiceManager的addService, getService实际工作都交由ServiceManagerProxy的相应方法来处理；</li>
<li><strong>ServiceManagerProxy：</strong>其成员变量mRemote指向BinderProxy对象，ServiceManagerProxy的addService, getService方法最终是交由mRemote来完成。</li>
<li><strong>ServiceManagerNative</strong>：其方法asInterface()返回的是ServiceManagerProxy对象，ServiceManager便是借助ServiceManagerNative类来找到ServiceManagerProxy；</li>
<li><strong>Binder：</strong>其成员变量mObject和方法execTransact()用于native方法</li>
<li><strong>BinderInternal：</strong>内部有一个GcWatcher类，用于处理和调试与Binder相关的垃圾回收。</li>
<li><strong>IBinder：</strong>接口中常量FLAG_ONEWAY：客户端利用binder跟服务端通信是阻塞式的，但如果设置了FLAG_ONEWAY，这成为非阻塞的调用方式，客户端能立即返回，服务端采用回调方式来通知客户端完成情况。另外IBinder接口有一个内部接口DeathDecipient(死亡通告)。</li>
</ul>
<h2 id="Binder类分层"><a href="#Binder类分层" class="headerlink" title="Binder类分层"></a>Binder类分层</h2><p>整个Binder从kernel至，native，JNI，Framework层所涉及的全部类</p>
<p><img src="http://gityuan.com/images/binder/java_binder_framework.jpg" alt="java_binder_framework"></p>
<h1 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h1><h2 id="SM-addService"><a href="#SM-addService" class="headerlink" title="SM.addService"></a>SM.addService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看getIServiceManager()过程，如下：</p>
<h2 id="getIServiceManager"><a href="#getIServiceManager" class="headerlink" title="getIServiceManager"></a>getIServiceManager</h2><p><strong>ServiceManager.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>采用了单例模式获取ServiceManager getIServiceManager()返回的是ServiceManagerProxy(简称SMP)对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceManagerProxy</code> 是<code>ServiceManagerNative</code>的内部类，实现IServiceManager接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder checkService(String name) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] listServices(int dumpPriority) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getContextObject"><a href="#getContextObject" class="headerlink" title="getContextObject()"></a>getContextObject()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Return the global &quot;context object&quot; of the system.  This is usually</span><br><span class="line">     * an implementation of IServiceManager, which you can use to find</span><br><span class="line">     * other services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native IBinder getContextObject();</span><br></pre></td></tr></table></figure>

<p>调用jni中方法<code>android_os_BinderInternal_getContextObject</code>返回IBinder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b &#x3D; ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ProcessState::self()-&gt;getContextObject()，在<a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">获取ServiceManager</a>的第3节已详细解决，即<code>ProcessState::self()-&gt;getContextObject()</code>等价于 <code>new BpBinder(0)</code>;</p>
<h4 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder"></a>javaObjectForIBinder</h4><p>[-&gt; android_util_binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val) &#123;</span><br><span class="line">    if (val &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; &#x2F;&#x2F;返回false</span><br><span class="line">        jobject object &#x3D; static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line"></span><br><span class="line">    jobject object &#x3D; (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    if (object !&#x3D; NULL) &#123; &#x2F;&#x2F;第一次object为null</span><br><span class="line">        jobject res &#x3D; jniGetReferent(env, object);</span><br><span class="line">        if (res !&#x3D; NULL) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建BinderProxy对象</span><br><span class="line">    object &#x3D; env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    if (object !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;BinderProxy.mObject成员变量记录BpBinder对象</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">        val-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line"></span><br><span class="line">        jobject refObject &#x3D; env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        &#x2F;&#x2F;将BinderProxy对象信息附加到BpBinder的成员变量mObjects中</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line"></span><br><span class="line">        sp&lt;DeathRecipientList&gt; drl &#x3D; new DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        &#x2F;&#x2F;BinderProxy.mOrgue成员变量记录死亡通知对象</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast&lt;jlong&gt;(drl.get()));</span><br><span class="line"></span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据BpBinder(C++)生成BinderProxy(Java)对象. 主要工作是创建BinderProxy对象,并把BpBinder对象地址保存到BinderProxy.mObject成员变量. 到此，可知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject()) </span><br><span class="line">等价于</span><br><span class="line">ServiceManagerNative.asInterface(new BinderProxy())</span><br></pre></td></tr></table></figure>

<h2 id="SMN-asInterface"><a href="#SMN-asInterface" class="headerlink" title="SMN.asInterface"></a>SMN.asInterface</h2><p>[-&gt; ServiceManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;obj为BpBinder</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由于obj为BpBinder，该方法默认返回null</span><br><span class="line">    IServiceManager in &#x3D; (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in !&#x3D; null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line">    return new ServiceManagerProxy(obj); &#x2F;&#x2F;【见小节3.3.1】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，可知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(new BinderProxy()) </span><br><span class="line">等价于</span><br><span class="line">new ServiceManagerProxy(new BinderProxy())</span><br></pre></td></tr></table></figure>

<p> 为了方便，ServiceManagerProxy简称为SMP。</p>
<h3 id="ServiceManagerProxy初始化"><a href="#ServiceManagerProxy初始化" class="headerlink" title="ServiceManagerProxy初始化"></a>ServiceManagerProxy初始化</h3><p>[-&gt; ServiceManagerNative.java ::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote为BinderProxy对象，该BinderProxy对象对应于BpBinder(0)，其作为binder代理端，指向native层大管家service Manager。</p>
<p><code>ServiceManager.getIServiceManager</code>最终等价于<code>new ServiceManagerProxy(new BinderProxy())</code>,意味着【3.1】中的getIServiceManager().addService()，等价于SMP.addService().</p>
<p>framework层的ServiceManager的调用实际的工作确实交给SMP的成员变量BinderProxy；而BinderProxy通过jni方式，最终会调用BpBinder对象；可见上层binder架构的核心功能依赖native架构的服务来完成的。</p>
<h2 id="ServiceManagerProxy-addService"><a href="#ServiceManagerProxy-addService" class="headerlink" title="ServiceManagerProxy.addService"></a>ServiceManagerProxy.addService</h2><p>[-&gt; ServiceManagerNative.java ::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    &#x2F;&#x2F;【见小节3.5】</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">    &#x2F;&#x2F;mRemote为BinderProxy【见小节3.7】</span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="data-writeStrongBinder-service-Java"><a href="#data-writeStrongBinder-service-Java" class="headerlink" title="data.writeStrongBinder(service)Java"></a>data.writeStrongBinder(service)Java</h2><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public writeStrongBinder(IBinder val)&#123;</span><br><span class="line">    &#x2F;&#x2F;此处为Native调用【见3.5.1】</span><br><span class="line">    nativewriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativeWriteStrongBinder-JNI"><a href="#nativeWriteStrongBinder-JNI" class="headerlink" title="nativeWriteStrongBinder()JNI"></a>nativeWriteStrongBinder()JNI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static native void nativeWriteStrongBinder(long nativePtr, IBinder val);</span><br></pre></td></tr></table></figure>

<p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object) &#123;</span><br><span class="line">    &#x2F;&#x2F;将java层Parcel转换为native层Parcel</span><br><span class="line">    Parcel* parcel &#x3D; reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;【见3.5.2】</span><br><span class="line">        const status_t err &#x3D; parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</span><br><span class="line">        if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ibinderForJavaObject"><a href="#ibinderForJavaObject" class="headerlink" title="ibinderForJavaObject"></a>ibinderForJavaObject</h4><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Java层的Binder对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh &#x3D; (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetLongField(obj, gBinderOffsets.mObject);</span><br><span class="line">        return jbh !&#x3D; NULL ? jbh-&gt;get(env, obj) : NULL; &#x2F;&#x2F;【见3.5.3】</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;Java层的BinderProxy对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        return (IBinder*)env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Binde(Java)生成JavaBBinderHolder(C++)对象. 主要工作是创建JavaBBinderHolder对象,并把JavaBBinderHolder对象地址保存到Binder.mObject成员变量.</p>
<h4 id="JavaBBinderHolder-get"><a href="#JavaBBinderHolder-get" class="headerlink" title="JavaBBinderHolder.get()"></a>JavaBBinderHolder.get()</h4><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    sp&lt;JavaBBinder&gt; b &#x3D; mBinder.promote();</span><br><span class="line">    if (b &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;首次进来，创建JavaBBinder对象【见3.5.4】</span><br><span class="line">        b &#x3D; new JavaBBinder(env, obj);</span><br><span class="line">        mBinder &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaBBinderHolder有一个成员变量mBinder，保存当前创建的JavaBBinder对象，这是一个wp类型的，可能会被垃圾回收器给回收，所以每次使用前，都需要先判断是否存在。</p>
<h4 id="JavaBBinder初始化"><a href="#JavaBBinder初始化" class="headerlink" title="JavaBBinder初始化"></a>JavaBBinder初始化</h4><p>==&gt; [-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaBBinder(JNIEnv* env, jobject object)</span><br><span class="line">    : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object))</span><br><span class="line">&#123;</span><br><span class="line">    android_atomic_inc(&amp;gNumLocalRefs);</span><br><span class="line">    incRefsCreated(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建JavaBBinder，该对象继承于BBinder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.writeStrongBinder(service)</span><br><span class="line">最终等价于&#96;parcel-&gt;</span><br><span class="line">writeStrongBinder(new JavaBBinder(env, obj))&#96;;</span><br></pre></td></tr></table></figure>

<h3 id="writeStrongBinder-C"><a href="#writeStrongBinder-C" class="headerlink" title="writeStrongBinder()C++"></a>writeStrongBinder()C++</h3><p>[-&gt; parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    return flatten_binder(ProcessState::self(), val, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flatten-binder"><a href="#flatten-binder" class="headerlink" title="flatten_binder"></a>flatten_binder</h4><p>[-&gt; parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; &#x2F;*proc*&#x2F;,</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags &#x3D; 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    if (binder !&#x3D; NULL) &#123;</span><br><span class="line">        IBinder *local &#x3D; binder-&gt;localBinder();</span><br><span class="line">        if (!local) &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; binder-&gt;remoteBinder();</span><br><span class="line">            const int32_t handle &#x3D; proxy ? proxy-&gt;handle() : 0;</span><br><span class="line">            obj.type &#x3D; BINDER_TYPE_HANDLE; &#x2F;&#x2F;远程Binder</span><br><span class="line">            obj.binder &#x3D; 0;</span><br><span class="line">            obj.handle &#x3D; handle;</span><br><span class="line">            obj.cookie &#x3D; 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj.type &#x3D; BINDER_TYPE_BINDER; &#x2F;&#x2F;本地Binder，进入该分支</span><br><span class="line">            obj.binder &#x3D; reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie &#x3D; reinterpret_cast&lt;uintptr_t&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj.type &#x3D; BINDER_TYPE_BINDER;  &#x2F;&#x2F;本地Binder</span><br><span class="line">        obj.binder &#x3D; 0;</span><br><span class="line">        obj.cookie &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见小节3.6.2】</span><br><span class="line">    return finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Binder对象扁平化，转换成flat_binder_object对象。</p>
<ul>
<li>对于Binder实体，则cookie记录Binder实体的指针；</li>
<li>对于Binder代理，则用handle记录Binder代理的句柄；</li>
</ul>
<p>关于localBinder，代码见Binder.cpp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BBinder* BBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BBinder* IBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finish-flatten-binder"><a href="#finish-flatten-binder" class="headerlink" title="finish_flatten_binder"></a>finish_flatten_binder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline static status_t finish_flatten_binder(</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; , const flat_binder_object&amp; flat, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    return out-&gt;writeObject(flat, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会带Java代码addService过程，则接下来进入transact</p>
<h2 id="BinderProxy-transact"><a href="#BinderProxy-transact" class="headerlink" title="BinderProxy.transact"></a>BinderProxy.transact</h2><p>[-&gt; Binder.java ::BinderProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F;用于检测Parcel大小是否大于800k</span><br><span class="line">    Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">    return transactNative(code, data, reply, flags); &#x2F;&#x2F;【见3.8】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到ServiceManagerProxy.addService，其成员变量mRemote是BinderProxy。transactNative经过jni调用，进入下面的方法</p>
<h3 id="android-os-BinderProxy-transact"><a href="#android-os-BinderProxy-transact" class="headerlink" title="android_os_BinderProxy_transact"></a>android_os_BinderProxy_transact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">    jint code, jobject dataObj, jobject replyObj, jint flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;java Parcel转为native Parcel</span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;gBinderProxyOffsets.mObject中保存的是new BpBinder(0)对象</span><br><span class="line">    IBinder* target &#x3D; (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此处便是BpBinder::transact(), 经过native层，进入Binder驱动程序</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的BinderProxy.transact()最终交由Native层的BpBinder::transact()完成。Native Binder的<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a>中有详细说明BpBinder执行过程。另外，该方法可抛出RemoteException。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>addService的核心过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain(); &#x2F;&#x2F;此处还需要将java层的Parcel转为Native层的Parcel</span><br><span class="line">    data-&gt;writeStrongBinder(new JavaBBinder(env, obj));</span><br><span class="line">    BpBinder::transact(ADD_SERVICE_TRANSACTION, *data, reply, 0); &#x2F;&#x2F;与Binder驱动交互</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册服务过程就是通过BpBinder来发送<code>ADD_SERVICE_TRANSACTION</code>命令，与实现与binder驱动进行数据交互。</p>
<h1 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h1><h2 id="SM-getService"><a href="#SM-getService" class="headerlink" title="SM.getService"></a>SM.getService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder service &#x3D; sCache.get(name); &#x2F;&#x2F;先从缓存中查看HashMap</span><br><span class="line">        if (service !&#x3D; null) &#123;</span><br><span class="line">            return service;</span><br><span class="line">        &#125; else &#123;</span><br></pre></td></tr></table></figure>
<pre><code>        return getIServiceManager().getService(name); 【见4.2】
    }
} catch (RemoteException e) {
    Log.e(TAG, &quot;error in getService&quot;, e);
}
return null;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关于getIServiceManager()，在前面已经讲述了，等价于new ServiceManagerProxy(new BinderProxy())。 其中sCache &#x3D; new HashMap&lt;String, IBinder&gt;()以hashmap格式缓存已组成的名称。请求获取服务过程中，先从缓存中查询是否存在，如果缓存中不存在的话，再通过binder交互来查询相应的服务。</span><br><span class="line"></span><br><span class="line">## ServiceManagerProxy.getService()</span><br></pre></td></tr></table></figure>
<p>class ServiceManagerProxy implements IServiceManager {<br>    public IBinder getService(String name) throws RemoteException {<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IServiceManager.descriptor);<br>        data.writeString(name);<br>        //mRemote为BinderProxy 【见4.3】<br>        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);<br>        //从reply里面解析出获取的IBinder对象【见4.8】<br>        IBinder binder = reply.readStrongBinder();<br>        reply.recycle();<br>        data.recycle();<br>        return binder;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BinderProxy.transact</span><br><span class="line"></span><br><span class="line">[-&gt; Binder.java]</span><br></pre></td></tr></table></figure>
<p>final class BinderProxy implements IBinder {<br>    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {<br>        Binder.checkParcel(this, code, data, “Unreasonably large binder buffer”);<br>        return transactNative(code, data, reply, flags);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## android_os_BinderProxy_transact</span><br><span class="line"></span><br><span class="line">[-&gt; android_util_Binder.cpp]</span><br></pre></td></tr></table></figure>
<p>static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,<br>    jint code, jobject dataObj, jobject replyObj, jint flags)<br>{<br>    …<br>    //java Parcel转为native Parcel<br>    Parcel* data = parcelForJavaObject(env, dataObj);<br>    Parcel* reply = parcelForJavaObject(env, replyObj);<br>    …</p>
<pre><code>//gBinderProxyOffsets.mObject中保存的是new BpBinder(0)对象
IBinder* target = (IBinder*)
    env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);
...

//此处便是BpBinder::transact(), 经过native层[见小节4.5]
status_t err = target-&gt;transact(code, *data, reply, flags);
...
return JNI_FALSE;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BpBinder.transact</span><br></pre></td></tr></table></figure>
<p>status_t BpBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    if (mAlive) {<br>        // [见小节4.6]<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);<br>        if (status == DEAD_OBJECT) mAlive = 0;<br>        return status;<br>    }</p>
<pre><code>return DEAD_OBJECT;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## IPC.transact</span><br><span class="line"></span><br><span class="line">[-&gt; IPCThreadState.cpp]</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck(); //数据错误检查<br>    flags |= TF_ACCEPT_FDS;<br>    ….<br>    if (err == NO_ERROR) {<br>         // 传输数据<br>        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);<br>    }<br>    …</p>
<pre><code>// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果
if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        //等待回应事件
        err = waitForResponse(reply);
    }else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}
return err;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  IPC.waitForResponse</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck(); //数据错误检查<br>    flags |= TF_ACCEPT_FDS;<br>    ….<br>    if (err == NO_ERROR) {<br>         // 传输数据<br>        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);<br>    }<br>    …</p>
<pre><code>// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果
if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        //等待回应事件
        err = waitForResponse(reply);
    }else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}
return err;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  IPC.waitForResponse</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::waitForResponse(Parcel <em>reply, status_t *acquireResult)<br>{<br>    int32_t cmd;<br>    int32_t err;<br>    while (1) {<br>        if ((err=talkWithDriver()) &lt; NO_ERROR) break;<br>        …<br>        cmd = mIn.readInt32();<br>        switch (cmd) {<br>          case BR_REPLY:<br>          {<br>            binder_transaction_data tr;<br>            err = mIn.read(&amp;tr, sizeof(tr));<br>            if (reply) {<br>                if ((tr.flags &amp; TF_STATUS_CODE) == 0) {<br>                    //当reply对象回收时，则会调用freeBuffer来回收内存<br>                    reply-&gt;ipcSetDataReference(<br>                        reinterpret_cast&lt;const uint8_t</em>&gt;(tr.data.ptr.buffer),<br>                        tr.data_size,<br>                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),<br>                        tr.offsets_size/sizeof(binder_size_t),<br>                        freeBuffer, this);<br>                } else {<br>                    …<br>                }<br>            }<br>          }<br>          case :…<br>        }<br>    }<br>    …<br>    return err;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么这个reply是哪来的呢，在文章[Binder系列3—启动ServiceManager](http:&#x2F;&#x2F;gityuan.com&#x2F;2015&#x2F;11&#x2F;07&#x2F;binder-start-sm&#x2F;)</span><br><span class="line"></span><br><span class="line">### binder_send_reply</span><br><span class="line"></span><br><span class="line">[-&gt; servicemanager&#x2F;binder.c]</span><br></pre></td></tr></table></figure>
<p>void binder_send_reply(struct binder_state *bs, struct binder_io *reply, binder_uintptr_t buffer_to_free, int status) {<br>    struct {<br>        uint32_t cmd_free;<br>        binder_uintptr_t buffer;<br>        uint32_t cmd_reply;<br>        struct binder_transaction_data txn;<br>    } <strong>attribute</strong>((packed)) data;</p>
<pre><code>data.cmd_free = BC_FREE_BUFFER; //free buffer命令
data.buffer = buffer_to_free;
data.cmd_reply = BC_REPLY; // reply命令
data.txn.target.ptr = 0;
data.txn.cookie = 0;
data.txn.code = 0;
if (status) {
    ...
} else {=

    data.txn.flags = 0;
    data.txn.data_size = reply-&gt;data - reply-&gt;data0;
    data.txn.offsets_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
    data.txn.data.ptr.buffer = (uintptr_t)reply-&gt;data0;
    data.txn.data.ptr.offsets = (uintptr_t)reply-&gt;offs0;
}
//向Binder驱动通信
binder_write(bs, &amp;data, sizeof(data));</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">binder_write将BC_FREE_BUFFER和BC_REPLY命令协议发送给驱动，进入驱动。binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write，由于是BC_REPLY命令协议，则进入binder_transaction， 该方法会向请求服务的线程Todo队列插入事务。</span><br><span class="line"></span><br><span class="line">接下来，请求服务的进程在执行talkWithDriver的过程执行到binder_thread_read()，处理Todo队列的事务。</span><br><span class="line"></span><br><span class="line">## readStrongBinder</span><br><span class="line"></span><br><span class="line">[-&gt; Parcel.java]</span><br><span class="line"></span><br><span class="line">readStrongBinder的过程基本是writeStrongBinder逆过程。</span><br></pre></td></tr></table></figure>
<p>static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) {<br>    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);<br>    if (parcel != NULL) {<br>        //【见小节4.8.1】<br>        return javaObjectForIBinder(env, parcel-&gt;readStrongBinder());<br>    }<br>    return NULL;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。</span><br><span class="line"></span><br><span class="line">### readStrongBinder(C++)</span><br><span class="line"></span><br><span class="line">[-&gt; Parcel.cpp]</span><br></pre></td></tr></table></figure>
<p>sp<IBinder> Parcel::readStrongBinder() const<br>{<br>    sp<IBinder> val;<br>    //【见小节4.8.2】<br>    unflatten_binder(ProcessState::self(), *this, &amp;val);<br>    return val;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### unflatten_binder</span><br></pre></td></tr></table></figure>
<p>status_t unflatten_binder(const sp<ProcessState>&amp; proc,<br>    const Parcel&amp; in, sp<IBinder>* out)<br>{<br>    const flat_binder_object* flat = in.readObject(false);<br>    if (flat) {<br>        switch (flat-&gt;type) {<br>            case BINDER_TYPE_BINDER:<br>                <em>out = reinterpret_cast&lt;IBinder</em>&gt;(flat-&gt;cookie);<br>                return finish_unflatten_binder(NULL, <em>flat, in);<br>            case BINDER_TYPE_HANDLE:<br>                //进入该分支【见4.8.3】<br>                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);<br>                //创建BpBinder对象<br>                return finish_unflatten_binder(<br>                    static_cast&lt;BpBinder</em>&gt;(out-&gt;get()), *flat, in);<br>        }<br>    }<br>    return BAD_TYPE;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### getStrongProxyForHandle</span><br></pre></td></tr></table></figure>
<p>sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)<br>{<br>    sp<IBinder> result;</p>
<pre><code>AutoMutex _l(mLock);
//查找handle对应的资源项
handle_entry* e = lookupHandleLocked(handle);

if (e != NULL) {
    IBinder* b = e-&gt;binder;
    if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
        ...
        //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象
        b = new BpBinder(handle);
        e-&gt;binder = b;
        if (b) e-&gt;refs = b-&gt;getWeakRefs();
        result = b;
    } else {
        result.force_set(b);
        e-&gt;refs-&gt;decWeak(this);
    }
}
return result;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。回到[小节4.8] 经过javaObjectForIBinder将native层BpBinder对象转换为Java层BinderProxy对象。 也就是说通过getService()最终获取了指向目标Binder服务端的代理对象BinderProxy。</span><br><span class="line"></span><br><span class="line">## 小结</span><br><span class="line"></span><br><span class="line">getService的核心过程：</span><br></pre></td></tr></table></figure>
<p>public static IBinder getService(String name) {<br>    …<br>    Parcel reply = Parcel.obtain(); //此处还需要将java层的Parcel转为Native层的Parcel<br>    BpBinder::transact(GET_SERVICE_TRANSACTION, *data, reply, 0);  //与Binder驱动交互<br>    IBinder binder = javaObjectForIBinder(env, new BpBinder(handle));<br>    …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javaObjectForIBinder作用是创建BinderProxy对象，并将BpBinder对象的地址保存到BinderProxy对象的mObjects中。 获取服务过程就是通过BpBinder来发送&#96;GET_SERVICE_TRANSACTION&#96;命令，与实现与binder驱动进行数据交互。</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line"></span><br><span class="line">以IWindowManager为例</span><br></pre></td></tr></table></figure>
<p>public interface IWindowManager extends android.os.IInterface {</p>
<pre><code>public static abstract class Stub extends android.os.Binder implements android.view.IWindowManager {
    private static final java.lang.String DESCRIPTOR = &quot;android.view.IWindowManager&quot;;

    public Stub() {
        this.attachInterface(this, DESCRIPTOR);
    }

    public static android.view.IWindowManager asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        if (((iin != null) &amp;&amp; (iin instanceof android.view.IWindowManager))) {
            return ((android.view.IWindowManager) iin);
        }
        return new android.view.IWindowManager.Stub.Proxy(obj);
    }

    public android.os.IBinder asBinder() {
        return this;
    }

    private static class Proxy implements android.view.IWindowManager {
        private android.os.IBinder mRemote;

        Proxy(android.os.IBinder remote) {
            mRemote = remote;
        }

        public android.os.IBinder asBinder() {
            return mRemote;
        }
    }
    ...
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Binder</span><br></pre></td></tr></table></figure>
<p>public class Binder implements IBinder {<br>    public void attachInterface(IInterface owner, String descriptor) {<br>        mOwner = owner;<br>        mDescriptor = descriptor;<br>    }</p>
<pre><code>public IInterface queryLocalInterface(String descriptor) {
    if (mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BinderProxy</span><br></pre></td></tr></table></figure>
<p>final class BinderProxy implements IBinder {<br>    public IInterface queryLocalInterface(String descriptor) {<br>        return null;<br>    }<br>}</p>
<pre><code>

</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/" itemprop="url">项目管理/临时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T22:22:01+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目团队成员之间的沟通原则：<br>1） 沟通目标<br>2） 正确的沟通渠道<br>3） 合适的时间和合适的地点<br>4） 尽量采用面对面的交流<br>5） 采用双向沟通方式，有反馈<br>6） 激发沟通对象的积极性和兴趣</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/" itemprop="url">startActivity源码分析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T15:17:42+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/" itemprop="url" rel="index">
                    <span itemprop="name">Activity</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/" itemprop="url" rel="index">
                    <span itemprop="name">startActivity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;</span><br><span class="line">  - ActivityManagerService.java</span><br><span class="line">  - ActivityStackSupervisor.java</span><br><span class="line">  - ActivityStack.java</span><br><span class="line">  - ActivityRecord.java</span><br><span class="line">  - ProcessRecord.java</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">  - IActivityManager.java</span><br><span class="line">  - ActivityManagerNative.java (内含AMP)</span><br><span class="line">  - ActivityManager.java</span><br><span class="line"></span><br><span class="line">  - IApplicationThread.java</span><br><span class="line">  - ApplicationThreadNative.java (内含ATP)</span><br><span class="line">  - ActivityThread.java (内含ApplicationThread)</span><br><span class="line"></span><br><span class="line">  - ContextImpl.java</span><br></pre></td></tr></table></figure>

<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-vts-9.0_r13/core/java/android/app/IApplicationThread.aidl" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-vts-9.0_r13/core/java/android/app/IApplicationThread.aidl</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Activity启动发起后，通过Binder最终交由system进程中的AMS来完成，则启动流程如下图：</p>
<p><img src="http://gityuan.com/images/activity/start_activity.jpg" alt="start_activity"></p>
<p><img src="http://gityuan.com/images/activity/start_activity_process.jpg" alt="start_activity_process"></p>
<p>启动流程：</p>
<ol>
<li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li>
<li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li>
<li>Zygote进程fork出新的子进程，即App进程；</li>
<li>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li>
<li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</li>
</ol>
<p>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续计划再进一步讲解生命周期过程与系统是如何交互，以及UI渲染过程，敬请期待。</p>
<h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a><code>MainActivity</code></h2><p>发起页面请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        findViewById(R.id.btn_pic).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                startActivity(new Intent(MainActivity.this, TestSamplePictureActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a><code>Activity</code></h2><h3 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity()"></a><code>startActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        this.startActivity(intent, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;           </span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult()"></a><code>startActivityForResult()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123;</span><br><span class="line">        startActivityForResult(intent, requestCode, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">            @Nullable Bundle options) &#123;</span><br><span class="line">            ...</span><br><span class="line">            Instrumentation.ActivityResult ar &#x3D;</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">          	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>context who:当前Activity</li>
<li>IBinder contextThread：<code>ActivityThread</code>中的<code>ApplicationThread</code></li>
<li>IBinder token：attach()中赋值的IBinder</li>
<li>Activity target:当前Activity</li>
<li>Intent intent：自己传递的intent</li>
<li>int requestCode：返回码</li>
<li>Bundle options：传null也会有一些附加信息<code>transferSpringboardActivityOptions</code>、</li>
</ul>
<p>在返回<code>ActivityResult ar</code>后就过<code>mMainThread.sendActivityResult</code>方法返回到<code>ActivityThread</code>中。<strong>（后续分析）</strong></p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h2><p>每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</p>
<h3 id="execStartActivity"><a href="#execStartActivity" class="headerlink" title="execStartActivity()"></a><code>execStartActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">执行应用程序发出的startActivity调用。 默认实现负责更新任何活动的&#123;@link ActivityMonitor&#125;对象，并将此调用分派给系统活动管理器。 您可以覆盖它以监视应用程序启动活动，并修改执行该操作时发生的情况。</span><br><span class="line"></span><br><span class="line">此方法返回一个&#123;@link ActivityResult&#125;对象，可以在拦截应用程序调用时使用该对象以避免执行start activity操作，但仍返回应用程序期望的结果。 为此，请重写此方法以捕获对启动活动的调用，以便它返回一个新的ActivityResult，其中包含您希望应用程序看到的结果，而不调用超级类。 请注意，如果requestCode 0，则应用程序仅期望结果</span><br><span class="line"></span><br><span class="line">如果未找到用于运行给定Intent的Activity，则此方法将引发&#123;@link android.content.ActivityNotFoundException&#125;。</span><br><span class="line">@param who从中开始活动的上下文。</span><br><span class="line">@param contextThread从其开始活动的Context的主线程。</span><br><span class="line">@param token 内部令牌，标识正在启动活动的系统； 可以为null。</span><br><span class="line">@param target哪个活动正在执行启动（并因此接收到任何结果）； 如果不是通过活动进行此调用，则可以为null。</span><br><span class="line">@param intent实际启动的Intent。</span><br><span class="line">@param requestCode该请求结果的标识符； 如果呼叫者不期望结果，则小于零。</span><br><span class="line">@param options附加选项。</span><br><span class="line">@return要强制返回特定结果，请返回包含所需数据的ActivityResult对象。 否则返回null。 默认实现始终返回null。</span><br><span class="line">*&#x2F;</span><br><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">            ...</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            &#x2F;&#x2F;通过am去执行startActivity</span><br><span class="line">            int result &#x3D; ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            &#x2F;&#x2F;根据result结果判断抛出异常</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a><code>ActivityManager</code></h2><h3 id="getService"><a href="#getService" class="headerlink" title="getService()"></a><code>getService()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">        return IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton &#x3D;</span><br><span class="line">            new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected IActivityManager create() &#123;</span><br><span class="line">                    &#x2F;&#x2F;1. 获取服务的Binder对象</span><br><span class="line">                    final IBinder b &#x3D; ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                     &#x2F;&#x2F;2. aidl 获取AMS</span><br><span class="line">                    final IActivityManager am &#x3D; IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    return am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<p>ServiceManager是安卓中一个重要的类，用于管理所有的系统服务，维护着系统服务和客户端的binder通信。返回的是Binder对象,用来进行应用与系统服务之间的通信的.</p>
<h2 id="IActivityManager"><a href="#IActivityManager" class="headerlink" title="IActivityManager"></a><code>IActivityManager</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Aidl接口</span><br><span class="line">public interface IActivityManager extends IInterface &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startActivity-1"><a href="#startActivity-1" class="headerlink" title="startActivity()"></a><code>startActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">                             String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags,</span><br><span class="line">                             ProfilerInfo profilerInfo, Bundle options) throws RemoteException;</span><br></pre></td></tr></table></figure>

<p>IActivityManager是Aidl的客户端，通过客户端去调用服务端的<code>startActivity</code>的实现方法。我们要找到<code>IActivityManager</code>的具体实现类，在找到他的代理就可以查看它的源码了。</p>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><p><strong>此时进入system_server进程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityManagerService extends IActivityManager.Stub</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>ActivityManagerService</code>就是<code>IActivityManager</code>的具体实现类（如果不懂的话自己先写aidl完成通讯，在查看系统生成的实现类就理解了）</p>
<h3 id="startActivity-2"><a href="#startActivity-2" class="headerlink" title="startActivity()"></a><code>startActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">                resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">                UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startActivityAsUser"><a href="#startActivityAsUser" class="headerlink" title="startActivityAsUser()"></a><code>startActivityAsUser()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">           Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">           int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,</span><br><span class="line">           boolean validateIncomingUser) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line"></span><br><span class="line">       userId &#x3D; mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">               Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; TODO: Switch to user app stacks here.</span><br><span class="line">       &#x2F;&#x2F;在此处切换到用户应用堆栈。</span><br><span class="line">       return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;)</span><br><span class="line">               .setCaller(caller)</span><br><span class="line">               .setCallingPackage(callingPackage)</span><br><span class="line">               .setResolvedType(resolvedType)</span><br><span class="line">               .setResultTo(resultTo)</span><br><span class="line">               .setResultWho(resultWho)</span><br><span class="line">               .setRequestCode(requestCode)</span><br><span class="line">               .setStartFlags(startFlags)</span><br><span class="line">               .setProfilerInfo(profilerInfo)</span><br><span class="line">               .setActivityOptions(bOptions)</span><br><span class="line">               .setMayWait(userId)</span><br><span class="line">               .execute();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>AMS的startActivity方法会调用AMS的startActivityAsUser方法,然后又调用另一个startActivityAsUser方法.最后来了一串链式调用设置信息,最后会来到ActivityStarter的execute方法.</p>
<p><strong>obtainStarter</strong>返回<code>ActivityStarter</code>对象。</p>
<h2 id="ActivityStartController"><a href="#ActivityStartController" class="headerlink" title="ActivityStartController"></a><code>ActivityStartController</code></h2><h3 id="obtainStarter"><a href="#obtainStarter" class="headerlink" title="obtainStarter()"></a><code>obtainStarter()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @return A starter to configure and execute starting an activity. It is valid until after</span><br><span class="line"> *         &#123;@link ActivityStarter#execute&#125; is invoked. At that point, the starter should be</span><br><span class="line"> *         considered invalid and no longer modified or used.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ActivityStarter obtainStarter(Intent intent, String reason) &#123;</span><br><span class="line">    return mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mFactory.obtain()从对象池中获取一个<code>ActivityStarter</code>对象。</p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a><code>ActivityStarter</code></h2><p>控制器，用于解释如何启动活动。<br>此类收集了用于确定将意图和标志如何转换为活动以及相关联的任务和堆栈的所有逻辑。</p>
<p>它是加载Activity的控制类，会收集所有的逻辑来决定如何将Intent和Flags转换为Activity，并将Activity和Task以及Stack相关联。</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Starts an activity based on the request parameters provided earlier.</span><br><span class="line">     * @return The starter result.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int execute() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO(b&#x2F;64750076): Look into passing request directly to these methods to allow</span><br><span class="line">            &#x2F;&#x2F; for transactional diffs and preprocessing.</span><br><span class="line">            &#x2F;&#x2F;TODO（b &#x2F; 64750076）：研究将请求直接传递给这些方法，以允许事务性差异和预处理。</span><br><span class="line">            if (mRequest.mayWait) &#123;</span><br><span class="line">                return startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                        mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                        mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                        mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                        mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                        mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                        mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                        mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                        mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                        mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            onExecutionComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据之前提供的请求参数启动活动。mayWait默认true表示我们应该等待启动请求的结果。</p>
<p>不管如何都不执行startActivity方法。</p>
<h3 id="startActivityMayWait"><a href="#startActivityMayWait" class="headerlink" title="startActivityMayWait"></a>startActivityMayWait</h3><p>这个方法很长很长,还看不懂，最后还是执行<code>startActivity()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">            String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">            ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">            Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,</span><br><span class="line">            int userId, TaskRecord inTask, String reason,</span><br><span class="line">            boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        &#x2F;&#x2F; Refuse possible leaked file descriptors</span><br><span class="line">        &#x2F;&#x2F;拒绝可能的泄漏文件描述符</span><br><span class="line">        if (intent !&#x3D; null &amp;&amp; intent.hasFileDescriptors()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当我们开始启动活动时，尽早通知跟踪器。应该是处理日志的。</span><br><span class="line">        mSupervisor.getActivityMetricsLogger().notifyActivityLaunching();</span><br><span class="line">        &#x2F;&#x2F;处理意图的应用程序组件的名称。</span><br><span class="line">        boolean componentSpecified &#x3D; intent.getComponent() !&#x3D; null;</span><br><span class="line">				&#x2F;&#x2F;返回向您发送当前正在处理的事务的进程的ID。 该pid可以与更高级别的系统服务一起使用，以确定其身份并检查权限。 如果当前线程当前未在执行传入事务，则返回其自己的pid。			</span><br><span class="line">        final int realCallingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">        &#x2F;&#x2F;Uid</span><br><span class="line">        final int realCallingUid &#x3D; Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Save a copy in case ephemeral needs it</span><br><span class="line">        &#x2F;&#x2F;保存副本以防临时需要</span><br><span class="line">        final Intent ephemeralIntent &#x3D; new Intent(intent);</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t modify the client&#39;s object!</span><br><span class="line">        intent &#x3D; new Intent(intent);        </span><br><span class="line">        ...                        </span><br><span class="line">						&#x2F;&#x2F;历史记录堆栈中的一个实体，代表一项活动。</span><br><span class="line">            final ActivityRecord[] outRecord &#x3D; new ActivityRecord[1];</span><br><span class="line">            int res &#x3D; startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                    voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                    ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                    allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">						&#x2F;&#x2F;将当前线程上的传入IPC的身份还原回&#123;@link #clearCallingIdentity&#125;返回的先前身份。</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还是走下面的方法</p>
<h3 id="startActivity-3"><a href="#startActivity-3" class="headerlink" title="startActivity()"></a>startActivity()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">            ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">            boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line"></span><br><span class="line">        if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastStartReason &#x3D; reason;</span><br><span class="line">        mLastStartActivityTimeMs &#x3D; System.currentTimeMillis();</span><br><span class="line">        mLastStartActivityRecord[0] &#x3D; null;</span><br><span class="line"></span><br><span class="line">        mLastStartActivityResult &#x3D; startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">                inTask, allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">        if (outActivity !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">            outActivity[0] &#x3D; mLastStartActivityRecord[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getExternalResult(mLastStartActivityResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样执行的还是很长很长的startActivity()方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            SafeActivityOptions options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">      	...</span><br><span class="line">        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                true &#x2F;* doResume *&#x2F;, checkedOptions, inTask, outActivity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码就是做一些规则判断，是否符合开启Activity的条件，不符合就直接返回错误码，<strong>还记得<code>Instrumentation</code>的<code>checkStartActivityResult（）</code>么，就是根据这里返回的结果抛出异常的比如：<code>ActivityNotFoundException</code></strong>最后还是执行startActivity方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">                int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">                ActivityRecord[] outActivity) &#123;</span><br><span class="line">        int result &#x3D; START_CANCELED;</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F;开始推迟布局传递。 在进行多项更改时很有用，但为了优化性能，仅应执行一次布局遍历。 可以多次调用此方法，并且在最后一个调用者致电&#123;@link continueSurfaceLayout&#125;后，将恢复布局</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">            &#x2F;&#x2F;注意：只能从&#123;@link startActivity&#125;调用此方法。</span><br><span class="line">            result &#x3D; startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; If we are not able to proceed, disassociate the activity from the task. Leaving an</span><br><span class="line">            &#x2F;&#x2F; activity in an incomplete state can lead to issues, such as performing operations</span><br><span class="line">            &#x2F;&#x2F; without a window container.</span><br><span class="line">            &#x2F;&#x2F;如果无法继续，请取消将活动与任务关联。 </span><br><span class="line">            &#x2F;&#x2F;将活动置于不完整状态可能会导致问题，例如在没有窗口容器的情况下执行操作。</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;当前任务的堆栈值，如果没有任务，则返回null。</span><br><span class="line">            final ActivityStack stack &#x3D; mStartActivity.getStack();</span><br><span class="line">            &#x2F;&#x2F;返回启动是否成功。</span><br><span class="line">            if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果此活动已从历史记录列表中删除，则返回true；如果仍在列表中并将稍后删除，则返回false。</span><br><span class="line">                stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                        null &#x2F;* intentResultData *&#x2F;, &quot;startActivity&quot;, true &#x2F;* oomAdj *&#x2F;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;延后布局恢复通过。 参见&#123;@link deferSurfaceLayout（）&#125;</span><br><span class="line">            mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要执行了<code>startActivityUnchecked</code>方法又是一个很长很长的方法，脑袋疼。</p>
<p>之后执行了<code>postStartActivityProcessing</code>,这个方法内部有一个描述</p>
<blockquote>
<p>//我们正在等待活动启动完成，但是该活动只是将另一个活动带到了前面。 我们还必须处理由于蹦床活动处于同一任务而导致任务已经在最前面的情况（由于蹦床将要完成，因此将被视为重点关注）。 让startActivityMayWait（）知道这一点，因此它等待新活动变为可见。</p>
<p>该活动已经在运行，因此尚未启动，但是由于它已经在最前面，所以要么被置于最前面，要么被传递给它新的意图。 通知对此信息感兴趣的任何人。</p>
</blockquote>
<h3 id="startActivityUnchecked"><a href="#startActivityUnchecked" class="headerlink" title="startActivityUnchecked()"></a><code>startActivityUnchecked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Note: This method should only be called from &#123;@link startActivity&#125;.</span><br><span class="line">    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            ActivityRecord[] outActivity) &#123;</span><br><span class="line">            ...</span><br><span class="line">				mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                        mOptions);</span><br><span class="line">				...</span><br><span class="line">        return START_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><p>ActivityStack是一个管理类，用来管理系统所有Activity的各种状态，其内部维护了TaskRecord的列表，因此从Activity任务栈这一角度来说，ActivityStack也可以理解为Activity堆栈。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。ActivityStackSupervisor中有多种ActivityStack实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">...</span><br><span class="line"> mStackSupervisor &#x3D; new ActivityStackSupervisor(this);</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityStackSupervisor implements DisplayListener &#123;</span><br><span class="line">   ...</span><br><span class="line">    ActivityStack mHomeStack;</span><br><span class="line">    ActivityStack mFocusedStack;</span><br><span class="line">    private ActivityStack mLastFocusedStack;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ActivityRecord</strong>：存在历史栈的一个实例，代表一个Activity。</li>
<li><strong>TaskRecord</strong>：Activity栈，内部维护一个ArrayList<ActivityRecord></li>
<li><strong>ActivityStack</strong>：并不是一个Activity栈，真正意义上的Activity栈是TaskRecord，这个类是负责管理各个Activity栈，内部维护一个ArrayList<TaskRecord></li>
<li><strong>ActivityStackSupervisor</strong>：内部持有一个ActivityStack，而ActivityStack内部也持有ActivityStackSupervisor，相当于ActivityStack的辅助管理类</li>
</ul>
<h3 id="resumeFocusedStackTopActivityLocked"><a href="#resumeFocusedStackTopActivityLocked" class="headerlink" title="resumeFocusedStackTopActivityLocked()"></a><code>resumeFocusedStackTopActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">        if (!readyToResume()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (targetStack !&#x3D; null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ActivityRecord r &#x3D; mFocusedStack.topRunningActivityLocked();</span><br><span class="line">        if (r &#x3D;&#x3D; null || !r.isState(RESUMED)) &#123;</span><br><span class="line">            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">        &#125; else if (r.isState(RESUMED)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">            mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a><code>ActivityStack</code></h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-35ca17cdd514d7cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="resumeTopActivityUncheckedLocked"><a href="#resumeTopActivityUncheckedLocked" class="headerlink" title="resumeTopActivityUncheckedLocked()"></a>resumeTopActivityUncheckedLocked()</h3><p>确保在栈顶部活动恢复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Ensure that the top activity in the stack is resumed.</span><br><span class="line"> *</span><br><span class="line"> * @param prev The previously resumed activity, for when in the process</span><br><span class="line"> * of pausing; can be null to call from elsewhere.</span><br><span class="line"> * @param options Activity options.</span><br><span class="line"> *</span><br><span class="line"> * @return Returns true if something is being resumed, or false if</span><br><span class="line"> * nothing happened.</span><br><span class="line"> *</span><br><span class="line"> * NOTE: It is not safe to call this method directly as it can cause an activity in a</span><br><span class="line"> *       non-focused stack to be resumed.</span><br><span class="line"> *       Use &#123;@link ActivityStackSupervisor#resumeFocusedStackTopActivityLocked&#125; to resume the</span><br><span class="line"> *       right activity for the current system state.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GuardedBy(&quot;mService&quot;)</span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t even start recursing.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Protect against recursion.</span><br><span class="line">        &#x2F;&#x2F;防止递归。</span><br><span class="line">        mStackSupervisor.inResumeTopActivity &#x3D; true;</span><br><span class="line">        result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; When resuming the top activity, it may be necessary to pause the top activity (for</span><br><span class="line">        &#x2F;&#x2F; example, returning to the lock screen. We suppress the normal pause logic in</span><br><span class="line">        &#x2F;&#x2F; &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span><br><span class="line">        &#x2F;&#x2F; end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span><br><span class="line">        &#x2F;&#x2F; to ensure any necessary pause logic occurs. In the case where the Activity will be</span><br><span class="line">        &#x2F;&#x2F; shown regardless of the lock screen, the call to</span><br><span class="line">        &#x2F;&#x2F; &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;恢复顶层活动时，可能有必要暂停顶层活动（例如，返回到锁定屏幕。由于顶层活动会在最后恢复，因此我们在&#123;@link #resumeTopActivityUncheckedLocked&#125;中取消了正常的暂停逻辑 为了确保发生任何必要的暂停逻辑，我们在此处再次调用&#123;@link ActivityStackSupervisor＃checkReadyForSleepLocked&#125;。</span><br><span class="line">        final ActivityRecord next &#x3D; topRunningActivityLocked(true &#x2F;* focusableOnly *&#x2F;);</span><br><span class="line">        if (next &#x3D;&#x3D; null || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resumeTopActivityInnerLocked"><a href="#resumeTopActivityInnerLocked" class="headerlink" title="resumeTopActivityInnerLocked()"></a><code>resumeTopActivityInnerLocked()</code></h3><pre><code>@GuardedBy(&quot;mService&quot;)
private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
    if (!mService.mBooting &amp;&amp; !mService.mBooted) {
        // Not ready yet!
        //还没有准备好！
        return false;
    }

          ...

        //堆栈中没有任何活动，让我们看看其他地方。
    if (!hasRunningActivity) {
        // There are no activities left in the stack, let&apos;s look somewhere else.
        return resumeTopActivityInNextFocusableStack(prev, options, &quot;noMoreActivities&quot;);
    }
        ...       
    mStackSupervisor.startSpecificActivityLocked(next, true, true);
    return true;
}</code></pre><h2 id="ActivityStackSupervisor-1"><a href="#ActivityStackSupervisor-1" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><h3 id="startSpecificActivityLocked"><a href="#startSpecificActivityLocked" class="headerlink" title="startSpecificActivityLocked()"></a><code>startSpecificActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        &#x2F;&#x2F; Is this activity&#39;s application already running?</span><br><span class="line">        &#x2F;&#x2F;此活动的应用程序已经在运行吗？</span><br><span class="line">        &#x2F;&#x2F;获取应用进程信息</span><br><span class="line">        ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line">				&#x2F;&#x2F;进程存在则启动</span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t add this if it is a platform component that is marked</span><br><span class="line">                    &#x2F;&#x2F; to run in multiple processes, because this is actually</span><br><span class="line">                    &#x2F;&#x2F; part of the framework so doesn&#39;t make sense to track as a</span><br><span class="line">                    &#x2F;&#x2F; separate apk in the process.</span><br><span class="line">                    &#x2F;&#x2F;如果它是标记为可以在多个进程中运行的平台组件，则不要添加它，因为它实际上是框架的一部分，因此在进程中作为单独的apk进行跟踪没有意义。</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a dead object exception was thrown -- fall through to</span><br><span class="line">            &#x2F;&#x2F; restart the application.</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;如果抛出了死对象异常-请重新启动应用程序。</span><br><span class="line">        &#125;</span><br><span class="line">				    &#x2F;&#x2F;进程不存在则创建</span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果进程存在调用<code>realStartActivityLocked</code>直接开起activity;如果没有进程则AMS创建一个进程<code>mService.startProcessLocked</code></p>
<h2 id="ActivityManagerService-1"><a href="#ActivityManagerService-1" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><p>AMS(ActivityManagerService)是贯穿Android系统组件的核心服务，负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作。</p>
<h3 id="startProcessLocked"><a href="#startProcessLocked" class="headerlink" title="startProcessLocked()"></a><code>startProcessLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">final ProcessRecord startProcessLocked(String processName,</span><br><span class="line">        ApplicationInfo info, boolean knownToBeDead, int intentFlags,</span><br><span class="line">        String hostingType, ComponentName hostingName, boolean allowWhileBooting,</span><br><span class="line">        boolean isolated, boolean keepIfLarge) &#123;</span><br><span class="line">    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">            hostingName, allowWhileBooting, isolated, 0 &#x2F;* isolatedUid *&#x2F;, keepIfLarge,</span><br><span class="line">            null &#x2F;* ABI override *&#x2F;, null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;,</span><br><span class="line">            null &#x2F;* crashHandler *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则校验的代码太多了此类会经过一系列的startxxx方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">            boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)&#123;</span><br><span class="line">            ...</span><br><span class="line">            checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;);</span><br><span class="line">       		 final boolean success &#x3D; startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">       		 checkTime(startTime, &quot;startProcess: done starting proc!&quot;);</span><br><span class="line">      		  ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final boolean startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) &#123;</span><br><span class="line">						...</span><br><span class="line">						return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                    startTime);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,</span><br><span class="line">            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">            long startTime) &#123;</span><br><span class="line">            	...</span><br><span class="line">            	final ProcessStartResult startResult &#x3D; startProcess(hostingType, entryPoint, app,</span><br><span class="line">                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        invokeWith, startTime);</span><br><span class="line">                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                        startSeq, false);</span><br><span class="line">            	...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startProcess"><a href="#startProcess" class="headerlink" title="startProcess()"></a><code>startProcess()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private ProcessStartResult startProcess(String hostingType, String entryPoint,</span><br><span class="line">            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">            long startTime) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (hostingType.equals(&quot;webview_service&quot;)) &#123;</span><br><span class="line">                startResult &#x3D; startWebView(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, null,</span><br><span class="line">                        new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith,</span><br><span class="line">                        new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>AMS最后会调用Process类中的start方法</p>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a><code>Process</code></h2><p>根据类的解释<code>Process</code>：用于管理操作系统进程的工具。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  int uid, int gid, int[] gids,</span><br><span class="line">                                  int runtimeFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String invokeWith,</span><br><span class="line">                                  String[] zygoteArgs) &#123;</span><br><span class="line">        return zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; **</span><br><span class="line"> 开始一个新的进程。</span><br><span class="line"> </span><br><span class="line"> &lt;p&gt;如果启用了进程，则会创建一个新进程，并在其中执行&lt;var&gt; processClass &lt;&#x2F; var&gt;的静态main（）函数。该函数返回后，该过程将继续运行。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;如果进程可用的，则会在调用者的进程中创建一个新进程，并在其中调用&lt;var&gt; processClass &lt;&#x2F; var&gt;的main（）。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; niceName参数（如果不是一个空字符串）是一个自定义名称，该名称将赋予进程而不是使用processClass。即使您使用相同的基本&lt;var&gt; processClass &lt;&#x2F; var&gt;启动它们，这也使您可以轻松识别进程。</span><br><span class="line">     *</span><br><span class="line">     *当invokeWith不为null时，该过程将作为一个新鲜的应用而不是合子叉启动。请注意，仅在uid 0或runtimeFlags包含DEBUG_ENABLE_DEBUGGER时才允许这样做。</span><br><span class="line">     *</span><br><span class="line">     * @param processClass用作流程的主要入口点的类。</span><br><span class="line">     * @param niceName用于该过程的更易读的名称。</span><br><span class="line">     * @param uid进程将在其下运行的用户ID。</span><br><span class="line">     * @param gid将在其下运行进程的组ID。</span><br><span class="line">     * @param gids与该进程关联的其他组ID。</span><br><span class="line">     * @param runtimeFlags运行时的其他标志。</span><br><span class="line">     * @param targetSdkVersion应用程序的目标SDK版本。</span><br><span class="line">     * @param seInfo为新进程提供空的SELinux信息。</span><br><span class="line">     * @param abi非空，此应用程序应以ABI开头。</span><br><span class="line">     * @paramstructionSet为null，确定要使用的指令集。</span><br><span class="line">     * @param appDataDir空-确定应用程序的数据目录。</span><br><span class="line">     * @param invokeWith null-确定要调用的命令。</span><br><span class="line">     * @param zygoteArgs提供给zygote进程的其他参数。</span><br><span class="line">     *</span><br><span class="line">     * @return一个对象，描述尝试启动该过程的结果。</span><br><span class="line">     * @致命启动失败时抛出RuntimeException</span><br><span class="line">     * &#x2F;</span><br></pre></td></tr></table></figure>

<p>最后执行的是<code>ZygoteProcess</code>中start方法.</p>
<h2 id="ZygoteProcess"><a href="#ZygoteProcess" class="headerlink" title="ZygoteProcess"></a><code>ZygoteProcess</code></h2><p>和孵化进程保持通讯状态。 此类负责和孵化进程打开套接字，并代表{@link android.os.Process}类启动进程。</p>
<h3 id="start-1"><a href="#start-1" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final Process.ProcessStartResult start(final String processClass,</span><br><span class="line">                                                  final String niceName,</span><br><span class="line">                                                  int uid, int gid, int[] gids,</span><br><span class="line">                                                  int runtimeFlags, int mountExternal,</span><br><span class="line">                                                  int targetSdkVersion,</span><br><span class="line">                                                  String seInfo,</span><br><span class="line">                                                  String abi,</span><br><span class="line">                                                  String instructionSet,</span><br><span class="line">                                                  String appDataDir,</span><br><span class="line">                                                  String invokeWith,</span><br><span class="line">                                                  String[] zygoteArgs) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, false &#x2F;* startChildZygote *&#x2F;,</span><br><span class="line">                    zygoteArgs);</span><br><span class="line">        &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startViaZygote"><a href="#startViaZygote" class="headerlink" title="startViaZygote()"></a><code>startViaZygote()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private Process.ProcessStartResult startViaZygote(final String processClass,</span><br><span class="line">                                                  final String niceName,</span><br><span class="line">                                                  final int uid, final int gid,</span><br><span class="line">                                                  final int[] gids,</span><br><span class="line">                                                  int runtimeFlags, int mountExternal,</span><br><span class="line">                                                  int targetSdkVersion,</span><br><span class="line">                                                  String seInfo,</span><br><span class="line">                                                  String abi,</span><br><span class="line">                                                  String instructionSet,</span><br><span class="line">                                                  String appDataDir,</span><br><span class="line">                                                  String invokeWith,</span><br><span class="line">                                                  boolean startChildZygote,</span><br><span class="line">                                                  String[] extraArgs)</span><br><span class="line">                                                  throws ZygoteStartFailedEx &#123;</span><br><span class="line">     &#x2F;&#x2F;Zygote进程Main方法中的参数                                             </span><br><span class="line">    ArrayList&lt;String&gt; argsForZygote &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; --runtime-args, --setuid&#x3D;, --setgid&#x3D;,</span><br><span class="line">    &#x2F;&#x2F; and --setgroups&#x3D; must go first</span><br><span class="line">    argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">    argsForZygote.add(&quot;--setuid&#x3D;&quot; + uid);</span><br><span class="line">    argsForZygote.add(&quot;--setgid&#x3D;&quot; + gid);</span><br><span class="line">    argsForZygote.add(&quot;--runtime-flags&#x3D;&quot; + runtimeFlags);</span><br><span class="line">    if (mountExternal &#x3D;&#x3D; Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--mount-external-default&quot;);</span><br><span class="line">    &#125; else if (mountExternal &#x3D;&#x3D; Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--mount-external-read&quot;);</span><br><span class="line">    &#125; else if (mountExternal &#x3D;&#x3D; Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--mount-external-write&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    argsForZygote.add(&quot;--target-sdk-version&#x3D;&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; --setgroups is a comma-separated list</span><br><span class="line">    if (gids !&#x3D; null &amp;&amp; gids.length &gt; 0) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        sb.append(&quot;--setgroups&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        int sz &#x3D; gids.length;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            if (i !&#x3D; 0) &#123;</span><br><span class="line">                sb.append(&#39;,&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(gids[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (niceName !&#x3D; null) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--nice-name&#x3D;&quot; + niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">    if (extraArgs !&#x3D; null) &#123;</span><br><span class="line">        for (String arg : extraArgs) &#123;</span><br><span class="line">            argsForZygote.add(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(mLock) &#123;</span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过孵化机制创建一个新的进程，这个方法还拼接了一些参数，在孵化进程中的main方法取出。</p>
<h3 id="openZygoteSocketIfNeeded"><a href="#openZygoteSocketIfNeeded" class="headerlink" title="openZygoteSocketIfNeeded()"></a><code>openZygoteSocketIfNeeded()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Tries to open socket to Zygote process if not already open. If</span><br><span class="line"> * already open, does nothing.  May block and retry.  Requires that mLock be held.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GuardedBy(&quot;mLock&quot;)</span><br><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);</span><br><span class="line"></span><br><span class="line">    if (primaryZygoteState &#x3D;&#x3D; null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            primaryZygoteState &#x3D; ZygoteState.connect(mSocket);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        maybeSetApiBlacklistExemptions(primaryZygoteState, false);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line">    if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The primary zygote didn&#39;t match. Try the secondary.</span><br><span class="line">    if (secondaryZygoteState &#x3D;&#x3D; null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            secondaryZygoteState &#x3D; ZygoteState.connect(mSecondarySocket);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        maybeSetApiBlacklistExemptions(secondaryZygoteState, false);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果尚未打开，则尝试打开套接字到Zygote进程。 如果已经打开，则不执行任何操作。 可能会阻止并重试。 要求保留mLock。</p>
<p>这个方法就是和孵化进程使用socker进行连接，如果连接了不执行操作。</p>
<p>现在socker已经连接上了孵化继承，就差通讯了。</p>
<h3 id="zygoteSendArgsAndGetResult"><a href="#zygoteSendArgsAndGetResult" class="headerlink" title="zygoteSendArgsAndGetResult()"></a><code>zygoteSendArgsAndGetResult()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Sends an argument list to the zygote process, which starts a new child</span><br><span class="line"> * and returns the child&#39;s pid. Please note: the present implementation</span><br><span class="line"> * replaces newlines in the argument list with spaces.</span><br><span class="line"> *</span><br><span class="line"> * @throws ZygoteStartFailedEx if process start failed for any reason</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GuardedBy(&quot;mLock&quot;)</span><br><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">        throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Throw early if any of the arguments are malformed. This means we can</span><br><span class="line">        &#x2F;&#x2F; avoid writing a partial response to the zygote.</span><br><span class="line">        int sz &#x3D; args.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            if (args.get(i).indexOf(&#39;\n&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span><br><span class="line">         * Presently the wire format to the zygote process is:</span><br><span class="line">         * a) a count of arguments (argc, in essence)</span><br><span class="line">         * b) a number of newline-separated argument strings equal to count</span><br><span class="line">         *</span><br><span class="line">         * After the zygote process reads these it will write the pid of</span><br><span class="line">         * the child or -1 on failure, followed by boolean to</span><br><span class="line">         * indicate whether a wrapper process was used.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">        final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg &#x3D; args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Should there be a timeout on this?</span><br><span class="line">        Process.ProcessStartResult result &#x3D; new Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Always read the entire result from the input stream to avoid leaving</span><br><span class="line">        &#x2F;&#x2F; bytes in the stream for future process starts to accidentally stumble</span><br><span class="line">        &#x2F;&#x2F; upon.</span><br><span class="line">        result.pid &#x3D; inputStream.readInt();</span><br><span class="line">        result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        if (result.pid &lt; 0) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将参数列表发送到Zygote进程，该进程将启动一个新的子进程并返回该子进程的pid。</p>
<p>此方法完成和Zygote进程socker通讯，阻塞等待socker信息返回，返回来的数据用ProcessStartResult包装。</p>
<p>接下来请看<strong>【Android进程创建流程】</strong>，经过层层代码，最后fork出一个新进程，利用反射进入<code>ActivityThread.main</code></p>
<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><p>这可以管理应用程序进程中主线程的执行，调度和执行活动，广播以及根据活动管理器的请求对其执行的其他操作。</p>
<h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（未完待续。。。）</p>
<p>请转移至<strong>【ActivityThread开启Activity】</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" itemprop="url">Android源码分析工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T14:15:45+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a></p>
<p><a href="https://android.googlesource.com/" target="_blank" rel="noopener">https://android.googlesource.com/</a></p>
<p><a href="https://cs.android.com/" target="_blank" rel="noopener">https://cs.android.com/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/" itemprop="url">Binder原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T13:28:45+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="什么是IPC"><a href="#什么是IPC" class="headerlink" title="什么是IPC"></a>什么是IPC</h2><p><strong>IPC(Inter-Process Communication)即进程间通信或者跨进程通信，指两个进程之间数据交换的过程</strong></p>
<p><strong>RPC(Remote Procedure Call的缩写) 是远程进程调用的意思。</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bundle</td>
<td align="center">简单易用</td>
<td align="center">只能传输bundle支持的数据类型</td>
<td align="center">四大组件间的进程通信</td>
</tr>
<tr>
<td align="center">文件共享</td>
<td align="center">简单易用</td>
<td align="center">不适合高并发环境，并且无法做到进程间的实时通讯</td>
<td align="center">无并发访问的情况，交换简单的数据，实时性不高的情况</td>
</tr>
<tr>
<td align="center">aidl</td>
<td align="center">功能强大，支持一对多并发通信，支持实时通信</td>
<td align="center">使用稍复杂，需要处理好线程同步</td>
<td align="center">一对多通信且且有RPC需求</td>
</tr>
<tr>
<td align="center">Messenger</td>
<td align="center">功能一般，支持一对多串行通信，支持实时通信</td>
<td align="center">不能处理好高并发的情况，不支持RPC，数据通过message进行传输，因此只能传输bundle支持的数据类型</td>
<td align="center">低并发一对多即时通讯无RPC需求，或者无法返回结构的RPC</td>
</tr>
<tr>
<td align="center">ContentProvider</td>
<td align="center">在数据源访问方面功能强大，支持一对多并发数据共享，可通过call方法扩展其它操作。</td>
<td align="center">可以理解受约束的AIDL，主要提供数据源的CRUD操作</td>
<td align="center">一对多进程间数据共享</td>
</tr>
<tr>
<td align="center">Socker</td>
<td align="center">功能强大，可以通过网络传输字节流，支持一对多并发实时通信。</td>
<td align="center">实现细节稍微有点繁琐，不支持直接的RPC</td>
<td align="center">网络数据交互</td>
</tr>
</tbody></table>
<h2 id="什么是AIDL"><a href="#什么是AIDL" class="headerlink" title="什么是AIDL"></a>什么是AIDL</h2><p>AIDL（Android Interface Definition Language）即Android接口定义语言，指Android 提供的一种进程间通信 (IPC) 机制。</p>
<h2 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h2><p>Binder是Android中一种跨进程通信的方式。从Android FrameWork角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。从Android应用层的角度来说， BInder是客户端和服务端进行通信的媒介。</p>
<p><strong>Binder线程池最大数为16，超过的请求会被阻塞。在进程间通信时处理并发时，如<code>ContentProvider</code>的CRUD（增删改查）操作方法最多有16个线程同时工作。</strong></p>
<h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p><strong>AIDL是基于Binder机制实现Android上的IPC。</strong></p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><p>简单介绍下什么是 Binder。Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。对于 Binder 更全面的定义，等我们介绍完 Binder 通信原理后再做详细说明。</p>
<ol>
<li>从IPC角度来说：Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有；</li>
<li>从Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h2 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h2><p><img src="http://gityuan.com/images/binder/java_binder/java_binder.jpg" alt="binder_arch"></p>
<h2 id="为什么必须理解-Binder-？"><a href="#为什么必须理解-Binder-？" class="headerlink" title="为什么必须理解 Binder ？"></a>为什么必须理解 Binder ？</h2><p>作为 Android 工程师的你，是不是常常会有这样的疑问：</p>
<ul>
<li>为什么 Activity 间传递对象需要序列化？</li>
<li>Activity 的启动流程是什么样的？</li>
<li>四大组件底层的通信机制是怎样的？</li>
<li>AIDL 内部的实现原理是什么？</li>
</ul>
<p>这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。</p>
<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。</p>
<h2 id="为什么使用-Binder"><a href="#为什么使用-Binder" class="headerlink" title="为什么使用 Binder ?"></a>为什么使用 Binder ?</h2><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<p>注：各种IPC方式数据拷贝次数，此表来源于<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现 - 设计篇</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-2160e70ca6e813ff28c34eec5ae8209c_1440w.jpg" alt="img"></p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<p><strong>最后用一张表格来总结下 Binder 的优势：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" alt="img"></p>
<h1 id="Linux-下传统的进程间通信原理"><a href="#Linux-下传统的进程间通信原理" class="headerlink" title="Linux 下传统的进程间通信原理"></a>Linux 下传统的进程间通信原理</h1><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="https://pic3.zhimg.com/80/v2-38e2ea1d22660b237e17d2a7f298f3d6_1440w.jpg" alt="img"></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h3 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-3c719337413b9c5c4ad0b6c6b8eb0291_1440w.jpg" alt="img"></p>
<h3 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() &#x2F;&#x2F;将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() &#x2F;&#x2F;将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h1 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC 通信原理</h1><p>理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。</p>
<p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy<em>from</em>user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy<em>to</em>user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aab2affe42958a659ea8a517ffaff5a0_1440w.jpg" alt="img"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ul>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ul>
<h1 id="Binder-跨进程通信原理"><a href="#Binder-跨进程通信原理" class="headerlink" title="Binder 跨进程通信原理"></a>Binder 跨进程通信原理</h1><p>理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。</p>
<h2 id="动态内核可加载模块-amp-amp-内存映射"><a href="#动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="动态内核可加载模块 &amp;&amp; 内存映射"></a>动态内核可加载模块 &amp;&amp; 内存映射</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p><strong>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</strong></p>
<p>该函数主要是创建虚拟内存区域 与 共享对象建立映射关系。用内存读写代替 I/O读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 函数原型</span><br><span class="line">  *&#x2F;</span><br><span class="line">void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure>

<p>内部原理：</p>
<ul>
<li>步骤1：创建虚拟内存区域</li>
<li>步骤2：实现地址映射关系(进程的虚拟地址空间关联到共享对象)</li>
</ul>
<p>使用时：</p>
<p>用户进程直接调用mmap()建立映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  *  MAP_SIZE的接收缓存区大小 ， 关联到共享对象中，即建立映射</span><br><span class="line">  *&#x2F;</span><br><span class="line">  mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);</span><br></pre></td></tr></table></figure>

<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h2 id="Binder-IPC-实现原理"><a href="#Binder-IPC-实现原理" class="headerlink" title="Binder IPC 实现原理"></a>Binder IPC 实现原理</h2><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy<em>from</em>user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_1440w.jpg" alt="img"></p>
<h1 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h1><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h2 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h2><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" alt="img"></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 对应的服务器。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7c68928e26f5b96b8b3471ebb1927107_1440w.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
<h2 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h2><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ul>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ul>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p><img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" alt="img"></p>
<h3 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-13361906ecda16e36a3b9cbe3d38cbc1_1440w.jpg" alt="img"></p>
<h2 id="Binder-的完整定义"><a href="#Binder-的完整定义" class="headerlink" title="Binder 的完整定义"></a>Binder 的完整定义</h2><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<h1 id="手动编码实现跨进程调用"><a href="#手动编码实现跨进程调用" class="headerlink" title="手动编码实现跨进程调用"></a>手动编码实现跨进程调用</h1><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<h2 id="各-Java-类职责描述"><a href="#各-Java-类职责描述" class="headerlink" title="各 Java 类职责描述"></a>各 Java 类职责描述</h2><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</li>
<li><strong>IInterface</strong> : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>
<li><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>
<li><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</li>
</ul>
<h2 id="实现过程讲解"><a href="#实现过程讲解" class="headerlink" title="实现过程讲解"></a>实现过程讲解</h2><p>一次跨进程通信必然会涉及到两个进程，在这个例子中 RemoteService 作为服务端进程，提供服务；ClientActivity 作为客户端进程，使用 RemoteService 提供的服务。如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7ca457119bd700a5acf7f69bb0c07e51_1440w.jpg" alt="img"></p>
<p>那么服务端进程具备什么样的能力？能为客户端提供什么样的服务呢？还记得我们前面介绍过的 IInterface 吗，它代表的就是服务端进程具体什么样的能力。因此我们需要定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端具备什么样的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类用来定义服务端 RemoteService 具备什么样的能力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只定义服务端具备什么样的能力是不够的，既然是跨进程调用，那么接下来我们得实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Stub extends Binder implements BookManager &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public static BookManager asInterface(IBinder binder) &#123;</span><br><span class="line">        if (binder &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        IInterface iin &#x3D; binder.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (iin !&#x3D; null &amp;&amp; iin instanceof BookManager)</span><br><span class="line">            return (BookManager) iin;</span><br><span class="line">        return new Proxy(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line"></span><br><span class="line">            case INTERFACE_TRANSACTION:</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            case TRANSAVTION_addBook:</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                Book arg0 &#x3D; null;</span><br><span class="line">                if (data.readInt() !&#x3D; 0) &#123;</span><br><span class="line">                    arg0 &#x3D; Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125;</span><br><span class="line">                this.addBook(arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stub 类中我们重点介绍下 <code>asInterface</code> 和 <code>onTransact</code>。</p>
<p>先说说 <code>asInterface</code>，当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如你在代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。</p>
<p>接下来我们就要实现这个代理类 Proxy 了，既然是代理类自然需要实现 BookManager 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements BookManager &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Proxy(IBinder remote) &#123;</span><br><span class="line">        this.remote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel replay &#x3D; Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            if (book !&#x3D; null) &#123;</span><br><span class="line">                data.writeInt(1);</span><br><span class="line">                book.writeToParcel(data, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data.writeInt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, 0);</span><br><span class="line">            replay.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看 addBook() 的实现；在 Stub 类中，addBook(Book book) 是一个抽象方法，Server 端需要去实现它。</p>
<ul>
<li>如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。</li>
<li>如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。</li>
</ul>
<p>在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。</p>
<p>这样一次跨进程调用就完成了。</p>
<h1 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h1><p><img src="http://gityuan.com/images/binder/summary/binder_proc_relation.png" alt="binder_proc_relation"></p>
<p>对于底层Binder驱动，通过<code>binder_procs</code>链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个<code>ProcessState</code>对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量<code>rb_root threads</code>，来记录当前进程内所有的binder_thread。</p>
<p>Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url">flutter项目中的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T12:38:57+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Scaffold</li>
<li>MaterialApp</li>
<li>route学习</li>
<li>Isolate使用</li>
<li>intl国际化和本地化</li>
<li>PreferredSizeWidget</li>
<li>AnimatedWidget</li>
<li>InkWell</li>
<li>IntrinsicHeight</li>
<li>CircleAvatar</li>
<li><a href="https://proandroiddev.com/flutter-for-android-developers-how-to-design-linearlayout-in-flutter-5d819c0ddf1a" target="_blank" rel="noopener">https://proandroiddev.com/flutter-for-android-developers-how-to-design-linearlayout-in-flutter-5d819c0ddf1a</a></li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/" itemprop="url">Java锁的分类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-17T20:34:29+08:00">
                2020-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">多线程开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="img"></p>
<h1 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h1><p><strong>定义</strong></p>
<ul>
<li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<ul>
<li>Java中，synchronized关键字和Lock的实现类都是悲观锁。</li>
</ul>
</li>
<li>乐观锁：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<ul>
<li>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li>
</ul>
</li>
</ul>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png" alt="img"></p>
<p><strong>使用场景</strong></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p><strong>使用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.base.multi_thread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ------------------------- 悲观锁的调用方式 -------------------------</span><br><span class="line">    public synchronized void testSynchronized() &#123;</span><br><span class="line">        &#x2F;&#x2F; 操作同步资源</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要保证多个线程使用的是同一个锁</span><br><span class="line">    private ReentrantLock reentrantLock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void testReentrant() &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        &#x2F;&#x2F; 操作同步资源</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ------------------------- 乐观锁的调用方式 -------------------------</span><br><span class="line">    &#x2F;&#x2F; 需要保证多个线程使用的是同一个AtomicInteger</span><br><span class="line">    private AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public void testAtomicInter() &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>要写入的新值 B</li>
</ul>
<p><strong>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</strong></p>
<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    private static final sun.misc.Unsafe U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    private static final long VALUE;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            VALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile int value;</span><br></pre></td></tr></table></figure>

<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li>unsafe： 获取并操作内存的数据。</li>
<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>
<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>
</ul>
<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ------------------------- JDK 8 -------------------------</span><br><span class="line">&#x2F;&#x2F; AtomicInteger 自增方法</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">  int var5;</span><br><span class="line">  do &#123;</span><br><span class="line">      var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------------------- OpenJDK 8 -------------------------</span><br><span class="line">&#x2F;&#x2F; Unsafe.java</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">   int v;</span><br><span class="line">   do &#123;</span><br><span class="line">       v &#x3D; getIntVolatile(o, offset);</span><br><span class="line">   &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * Atomically updates Java variable to &#123;@code x&#125; if it is currently</span><br><span class="line">  * holding &#123;@code expected&#125;.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line">  * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span><br><span class="line">  *</span><br><span class="line">  * @return &#123;@code true&#125; if successful</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @HotSpotIntrinsicCandidate</span><br><span class="line"> public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                                   int expected,</span><br><span class="line">                                                   int x);</span><br></pre></td></tr></table></figure>

<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>
<p><strong>CAS问题</strong></p>
<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>
<ul>
<li><p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
</ul>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
<h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png" alt="img"></p>
<p><strong>缺点</strong></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p><strong>自旋锁原理</strong></p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p><strong>常见自旋锁</strong></p>
<p>在自旋锁中 另有三种常见的锁形式:</p>
<ul>
<li>TicketLock</li>
<li>CLHlock</li>
<li>MCSlock</li>
</ul>
<h1 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h1><p>这四种锁是指锁的状态，专门针对synchronized的。</p>
<h2 id="为什么Synchronized能实现线程同步？"><a href="#为什么Synchronized能实现线程同步？" class="headerlink" title="为什么Synchronized能实现线程同步？"></a>为什么Synchronized能实现线程同步？</h2><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：</p>
<ul>
<li>Mark Word（标记字段）</li>
<li>Klass Pointer（类型指针）</li>
</ul>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p><strong>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</strong></p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="left">存储内容</th>
<th align="left">存储内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无锁</td>
<td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">偏向锁</td>
<td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">指向栈中锁记录的指针</td>
<td align="left">00</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">指向互斥量（重量级锁）的指针</td>
<td align="left">10</td>
</tr>
</tbody></table>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</strong></p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p><strong>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</strong></p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png" alt="img"></p>
<p><strong>综上，偏向锁通过对比Mark Word中的线程ID解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</strong></p>
<h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a23d746a.png" alt="img"></p>
<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>
<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/4499559e.png" alt="img"></p>
<p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7373984872572414699L;</span><br><span class="line">    &#x2F;** Synchronizer providing all implementation mechanics *&#x2F;</span><br><span class="line">    private final Sync sync;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base of synchronization control for this lock. Subclassed</span><br><span class="line">     * into fair and nonfair versions below. Uses AQS state to</span><br><span class="line">     * represent the number of holds on the lock.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">         * is to allow fast path for nonfair version.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        abstract void lock();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line">         * subclasses, but both need nonfair try for trylock method.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c &#x3D; getState() - releases;</span><br><span class="line">            if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free &#x3D; false;</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                free &#x3D; true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean isHeldExclusively() &#123;</span><br><span class="line">            &#x2F;&#x2F; While we must in general read state before owner,</span><br><span class="line">            &#x2F;&#x2F; we don&#39;t need to do so to check if current thread is owner</span><br><span class="line">            return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ConditionObject newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Methods relayed from outer class</span><br><span class="line"></span><br><span class="line">        final Thread getOwner() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getHoldCount() &#123;</span><br><span class="line">            return isHeldExclusively() ? getState() : 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLocked() &#123;</span><br><span class="line">            return getState() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Reconstitutes the instance from a stream (that is, deserializes it).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(0); &#x2F;&#x2F; reset to unlocked state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sync object for non-fair locks</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sync object for fair locks</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Fair version of tryAcquire.  Don&#39;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line">     * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync &#x3D; new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">     * given fairness policy.</span><br><span class="line">     *</span><br><span class="line">     * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png" alt="img"></p>
<p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        &#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class="line">        &#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class="line">        &#x2F;&#x2F; thread is first in queue.</span><br><span class="line">        Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        Node s;</span><br><span class="line">        return h !&#x3D; t &amp;&amp;</span><br><span class="line">            ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>
<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h1 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h1><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Widget &#123;</span><br><span class="line">    public synchronized void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;方法1执行...&quot;);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doOthers() &#123;</span><br><span class="line">        System.out.println(&quot;方法2执行...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>
<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/58fc5bc9.png" alt="img"></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ea597a0c.png" alt="img"></p>
<p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png" alt="img"></p>
<h1 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h1><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>
<p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>下图为ReentrantReadWriteLock的部分源码：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/762a042b.png" alt="img"></p>
<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p>
<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png" alt="img"></p>
<p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">	Thread current &#x3D; Thread.currentThread();</span><br><span class="line">	int c &#x3D; getState(); &#x2F;&#x2F; 取到当前锁的个数</span><br><span class="line">	int w &#x3D; exclusiveCount(c); &#x2F;&#x2F; 取写锁的个数w</span><br><span class="line">	if (c !&#x3D; 0) &#123; &#x2F;&#x2F; 如果已经有线程持有了锁(c!&#x3D;0)</span><br><span class="line">    &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)</span><br><span class="line">		if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread()) &#x2F;&#x2F; 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span><br><span class="line">			return false;</span><br><span class="line">		if (w + exclusiveCount(acquires) &gt; MAX_COUNT)    &#x2F;&#x2F; 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span><br><span class="line">      throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">		&#x2F;&#x2F; Reentrant acquire</span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#x2F;&#x2F; 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span><br><span class="line">		return false;</span><br><span class="line">	setExclusiveOwnerThread(current); &#x2F;&#x2F; 如果c&#x3D;0，w&#x3D;0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<p>接着是读锁的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">        return -1;                                   &#x2F;&#x2F; 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span><br><span class="line">    int r &#x3D; sharedCount(c);</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            firstReader &#x3D; current;</span><br><span class="line">            firstReaderHoldCount &#x3D; 1;</span><br><span class="line">        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line">            else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png" alt="img"></p>
<p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" itemprop="url">时间和空间复杂度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-15T17:03:35+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>算法，即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但是耗费的时间和资源是不同的。</p>
<h1 id="“好”算法的标准"><a href="#“好”算法的标准" class="headerlink" title="“好”算法的标准"></a>“好”算法的标准</h1><p>对于一个问题的算法来说，之所以称之为算法，首先它必须能够解决这个问题（称为准确性）。其次，通过这个算法编写的程序要求在任何情况下不能崩溃（称为健壮性）。</p>
<p>如果准确性和健壮性都满足，接下来，就要考虑最重要的一点：通过算法编写的程序，运行的效率怎么样。</p>
<p>运行效率体现在两方面：</p>
<ul>
<li>算法的运行时间。（称为“时间复杂度”）</li>
<li>运行算法所需的内存空间大小。（称为“空间复杂度”）</li>
</ul>
<p>好算法的标准就是：在符合算法本身的要求的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。所以，算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数<strong>（称为“频度”）</strong>。次数越少，算法的时间复杂度越低。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a) ++x; s&#x3D;0;</span><br><span class="line">b) for (int i&#x3D;1; i&lt;&#x3D;n; i++) &#123; ++x; s+&#x3D;x; &#125;</span><br><span class="line">c) for (int i&#x3D;1; i&lt;&#x3D;n; i++) &#123; for (int j&#x3D;1; i&lt;&#x3D;n; j++) &#123; ++x; s+&#x3D;x; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>上边这个例子中，a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。</p>
<p><strong>算法的时间复杂度的表示方式为：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(频度)</span><br></pre></td></tr></table></figure>

<p>这种表示方式称为<code>大“O”记法</code>。</p>
<blockquote>
<p>注意，是大写的字母<code>O</code>，不是数字<code>0</code>。</p>
</blockquote>
<p>对于上边的例子而言，a 的时间复杂度为<code>O(1)</code>，b 的时间复杂度为<code>O(n)</code>，c 的时间复杂度为为<code>O(n2)</code>。</p>
<p>如果a、b、c组成一段程序，那么算法的时间复杂度为<code>O(n2+n+1)</code>。但这么表示是不对的，还需要对<code>n2+n+1</code>进行简化。</p>
<p>简化的过程总结为3步：</p>
<ul>
<li>去掉运行时间中的所有加法常数。（例如 n²+n+1，直接变为 n²+n）</li>
<li>只保留最高项。（n²+n 变成 n²）</li>
<li>如果最高项存在但是系数不是1，去掉系数。（n² 系数为 1）</li>
</ul>
<p>所以，最终a、b和c合并而成的代码的时间复杂度为<code>O(n²)</code>。</p>
<blockquote>
<p>这里2时平方的意思</p>
</blockquote>
<p>常见的时间复杂度量级有：</p>
<ul>
<li>常数阶O(1)</li>
<li>对数阶O(logN)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(nlogN)</li>
<li>平方阶O(n²)</li>
<li>立方阶O(n³)</li>
<li>K次方阶O(n^k)</li>
<li>指数阶(2^n)</li>
</ul>
<p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p>
<p><strong>常数阶O(1)</strong></p>
<p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">int j &#x3D; 2;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m &#x3D; i + j;</span><br></pre></td></tr></table></figure>

<p><strong>对数阶O(logN)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">while(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i &#x3D; i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br>也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：<strong>O(logn)</strong></p>
<p><strong>线性阶O(n)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i&#x3D;1; i&lt;&#x3D;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j &#x3D; i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线性对数阶O(nlogN)</strong></p>
<p>将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(m&#x3D;1; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i &#x3D; 1;</span><br><span class="line">    while(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i &#x3D; i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平方阶O(n²)</strong></p>
<p>如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x&#x3D;1; i&lt;&#x3D;n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i&#x3D;1; i&lt;&#x3D;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j &#x3D; i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)</p>
<h3 id="拿时间换空间，用空间换时间"><a href="#拿时间换空间，用空间换时间" class="headerlink" title="拿时间换空间，用空间换时间"></a>拿时间换空间，用空间换时间</h3><p>算法的时间复杂度和空间复杂度是可以相互转化的。</p>
<p>谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。</p>
<p>算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。</p>
<p>如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。</p>
<p><strong>空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" itemprop="url">数据结构有哪些，常用数据结构详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-15T16:36:11+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据结构大致包含以下几种存储结构：</p>
<ul>
<li>线性表<ul>
<li>顺序表</li>
<li>链表</li>
<li>队列</li>
<li>栈</li>
</ul>
</li>
<li>树结构<ul>
<li>二叉树</li>
<li>索引二叉树</li>
<li>满二叉事</li>
<li>红黑树</li>
</ul>
</li>
<li>图结构</li>
</ul>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>数据元素的排列方式是线性的。例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。</p>
<p>线性表并不是一种具体的存储结构，它包含<strong>顺序存储结构和链式存储结构</strong>，是<strong>顺序表和链表</strong>的统称。</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表中的数据元素存储是连续的，内存划分的区域也是连续的。存储结构如下图：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/2-1Z426164G5347.gif" alt="顺序表结构"></p>
<p>ArrayList底层是数组实现的，底层元素在内存中是按顺序排列的，<strong>ArrayList</strong>是Java中顺序表的体现。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的。</p>
<p>链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-233e9330cada82fa0cbf5bcab9fbc4f7_1440w.png" alt="img"></p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。</p>
<p><strong>（先进后出）或者（后进先出）</strong>栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/2-1Z426164J5428.gif" alt="栈结构示意图"></p>
<p>队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。<strong>（先进先出）</strong></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/2-1Z426164K4453.gif" alt="队列结构示意图"></p>
<h1 id="树存储结构"><a href="#树存储结构" class="headerlink" title="树存储结构"></a>树存储结构</h1><p><strong>树存储结构适合存储具有“一对多”关系的数据。</strong></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/2-1Z426164P3416.gif" alt="树存储结构示意图"></p>
<p>其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。</p>
<h1 id="图存储结构"><a href="#图存储结构" class="headerlink" title="图存储结构"></a>图存储结构</h1><p><strong>图存储结构适合存储具有“多对多”关系的数据。</strong></p>
<p><img src="http://c.biancheng.net/uploads/allimg/190426/2-1Z4261A50Q16.gif" alt="图存储结构示意图"></p>
<p>从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">102</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
