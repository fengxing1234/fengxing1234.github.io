<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E7%AF%87/" itemprop="url">设计模式-开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-05T12:58:49+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E7%AF%87/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E7%AF%87/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><h3 id="1-1-六大设计原则"><a href="#1-1-六大设计原则" class="headerlink" title="1.1 六大设计原则"></a>1.1 六大设计原则</h3><ol>
<li>单一职责原则(SRP)：一个类只负责一个职责，不要存在多个导致类变更的原因；</li>
<li>接口隔离原则(ISP)：客户端不应该依赖它不需要的接口，多用组合,少用继承</li>
<li>依赖倒置原则(DIP)： 提高灵活性,高层不依赖低层,两个都应该依赖于抽象</li>
<li>里氏替换原则(LSP)：子类必须能够替换他们的基类</li>
<li>迪米特法则(LOD)：类间解耦，类之间联系尽可能少</li>
<li>开闭原则(OCP)： 扩展开放,修改封闭</li>
</ol>
<p>总结：类单一，类间解耦，接口隔离，子类和子接口可替换，依赖抽象，开闭</p>
<h3 id="1-2-设计模式总纲"><a href="#1-2-设计模式总纲" class="headerlink" title="1.2 设计模式总纲"></a>1.2 设计模式总纲</h3><p>设计模式主要分三个类型: 创建型、结构型和行为型 (总计23种)</p>
<table>
<thead>
<tr>
<th align="left">创建型</th>
<th align="left">结构型</th>
<th align="left">行为型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单例模式</td>
<td align="left">代理模式</td>
<td align="left">观察者模式</td>
</tr>
<tr>
<td align="left">抽象工厂</td>
<td align="left">适配器模式</td>
<td align="left">迭代器模式</td>
</tr>
<tr>
<td align="left">工厂方法</td>
<td align="left">组合模式</td>
<td align="left">职责链模式</td>
</tr>
<tr>
<td align="left">建造模式</td>
<td align="left">外观模式</td>
<td align="left">模板方法</td>
</tr>
<tr>
<td align="left">原型模式</td>
<td align="left">装饰模式</td>
<td align="left">中介者模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">桥模式</td>
<td align="left">策略模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">享元模式</td>
<td align="left">命令模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">状态模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">访问者模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">解释器模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">备忘录模式</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP-RESTful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP-RESTful/" itemprop="url">浅谈HTTP-RESTful</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-05T12:30:07+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP-RESTful/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP-RESTful/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>RESTful</strong> 是一种非常流行的软件架构，或者说设计风格而非新的技术标准。提供了一组设计原则和约束条件，主要用于<strong>客户端与服务器的交互</strong>。RESTful架构更简洁，更有层次，更易于实现缓存等机制。</p>
</blockquote>
<h2 id="理解RESTful"><a href="#理解RESTful" class="headerlink" title="理解RESTful"></a>理解RESTful</h2><p>RESTful, 全称Representational State Transfer。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。要理解RESTful概念，需要明白下面的概念：</p>
<h3 id="1-1-资源与URI"><a href="#1-1-资源与URI" class="headerlink" title="1.1 资源与URI"></a>1.1 资源与URI</h3><p>REST全称是表述性状态转移，表述指的就是资源。资源通过<code>URI(Uniform Resource Identifier)</code>来标示。URI的设计应该遵循可寻址性原则，具有自描述性。</p>
<p>这里以github网站为例，给出一些还算不错的URI：</p>
<ul>
<li><a href="https://github.com/git" target="_blank" rel="noopener">https://github.com/git</a></li>
<li><a href="https://github.com/git/git/blob/master/block-sha1/sha1.h" target="_blank" rel="noopener">https://github.com/git/git/blob/master/block-sha1/sha1.h</a></li>
<li><a href="https://github.com/git/git/pulls" target="_blank" rel="noopener">https://github.com/git/git/pulls</a></li>
<li><a href="https://github.com/git/git/pulls?state=closed" target="_blank" rel="noopener">https://github.com/git/git/pulls?state=closed</a></li>
</ul>
<p>关于URI设计技巧:</p>
<ul>
<li>使用 <strong>_</strong> 或 <strong>-</strong> 来让URI可读性更好，例如<code>http://www.github.com/blog/translate-reward-plan</code>。</li>
<li>使用 <strong>/</strong> 来表示资源的层级关系，例如上面的<code>/git/git/blob/master/block-sha1/sha1.h</code></li>
<li>使用 <strong>?</strong> 用来过滤资源，例如<code>/git/pulls?state=closed</code>用来表示git项目的所有推入请求中已经关闭的请求。</li>
<li>使用<strong>,</strong>或<strong>;</strong>表示同级资源关系，例如<code>/git/sha1/compare/ef7b53d18;bd638e8c1</code></li>
</ul>
<h3 id="1-2-统一资源接口"><a href="#1-2-统一资源接口" class="headerlink" title="1.2 统一资源接口"></a>1.2 统一资源接口</h3><p>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，所有资源的访问接口应该使用标准的HTTP方法如GET，PUT，POST，DELETE，并遵循这些方法的语义。</p>
<p>如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和POST请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、POST、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。</p>
<p>下面列出了GET，DELETE，PUT和POST的典型用法:</p>
<h4 id="1-2-1-GET表"><a href="#1-2-1-GET表" class="headerlink" title="1.2.1 GET表"></a>1.2.1 GET表</h4><p>安全且幂等，获取表示，变更时获取表示（缓存）</p>
<ul>
<li>200（OK） - 表示已在响应中发出</li>
<li>204（无内容） - 资源有空表示</li>
<li>301（Moved Permanently） - 资源的URI已被更新</li>
<li>303（See Other） - 其他（如，负载均衡）</li>
<li>304（not modified）- 资源未更改（缓存）</li>
<li>400 （bad request）- 指代坏请求（如，参数错误）</li>
<li>404 （not found）- 资源不存在</li>
<li>406 （not acceptable）- 服务端不支持所需表示</li>
<li>500 （internal server error）- 通用错误响应</li>
<li>503 （Service Unavailable）- 服务端当前无法处理请求</li>
</ul>
<h4 id="1-2-2-POST"><a href="#1-2-2-POST" class="headerlink" title="1.2.2 POST"></a>1.2.2 POST</h4><p>不安全且不幂等，使用服务端管理的实例号创建资源，创建子资源，部分更新资源</p>
<ul>
<li>200（OK）- 如果现有资源已被更改</li>
<li>201（created）- 如果新资源被创建</li>
<li>202（accepted）- 已接受处理请求但尚未完成（异步处理）</li>
<li>301（Moved Permanently）- 资源的URI被更新</li>
<li>303（See Other）- 其他（如，负载均衡）</li>
<li>400（bad request）- 指代坏请求</li>
<li>404 （not found）- 资源不存在</li>
<li>406 （not acceptable）- 服务端不支持所需表示</li>
<li>409 （conflict）- 通用冲突</li>
<li>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li>
<li>415 （unsupported media type）- 接受到的表示不受支持</li>
<li>500 （internal server error）- 通用错误响应</li>
<li>503 （Service Unavailable）- 服务当前无法处理请求</li>
</ul>
<h4 id="1-2-3-PUT"><a href="#1-2-3-PUT" class="headerlink" title="1.2.3 PUT"></a>1.2.3 PUT</h4><p>不安全但幂等，用客户端管理的实例号创建一个资源，通过替换的方式更新资源</p>
<ul>
<li>200 （OK）- 如果已存在资源被更改</li>
<li>201 （created）- 如果新资源被创建</li>
<li>301（Moved Permanently）- 资源的URI已更改</li>
<li>303 （See Other）- 其他（如，负载均衡 ）</li>
<li>400 （bad request）- 指代坏请求</li>
<li>404 （not found）- 资源不存在</li>
<li>406 （not acceptable）- 服务端不支持所需表示</li>
<li>409 （conflict）- 通用冲突</li>
<li>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li>
<li>415 （unsupported media type）- 接受到的表示不受支持</li>
<li>500 （internal server error）- 通用错误响应</li>
<li>503 （Service Unavailable）- 服务当前无法处理请求</li>
</ul>
<h4 id="1-2-4-DELETE"><a href="#1-2-4-DELETE" class="headerlink" title="1.2.4 DELETE"></a>1.2.4 DELETE</h4><p>不安全但幂等，删除资源</p>
<ul>
<li>200 （OK）- 资源已被删除</li>
<li>301 （Moved Permanently）- 资源的URI已更改</li>
<li>303 （See Other）- 其他，如负载均衡</li>
<li>400 （bad request）- 指代坏请求</li>
<li>404 （not found）- 资源不存在</li>
<li>409 （conflict）- 通用冲突</li>
<li>500 （internal server error）- 通用错误响应</li>
<li>503 （Service Unavailable）- 服务端当前无法处理请求</li>
</ul>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h4><p>接下来再按一些实践中的常见问题</p>
<ul>
<li>POST和PUT在创建资源的区别：所创建的资源的名称(URI)是否由客户端决定。 例如博客增加一个Android的分类，生成的路径就是分类名/categories/android，那么就可以采用PUT方法。</li>
<li>客户端不一定都支持这些HTTP方法：较古老的基于浏览器的客户端，只能支持GET和POST两种方法。妥协的解决方法，通过隐藏参数_method=DELETE来传递真实的请求方法等措施来规避。</li>
<li>统一资源接口对URI的意义：统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作，如下是一些不符合统一接口要求的URI:<ul>
<li>GET /getUser/1</li>
<li>POST /createUser</li>
<li>PUT /updateUser/1</li>
<li>DELETE /deleteUser/1</li>
</ul>
</li>
</ul>
<p>正确写法应该是 /User/1，不应该包含动词，具体的动作由请求方法来体现。</p>
<h3 id="1-3-资源的表述"><a href="#1-3-资源的表述" class="headerlink" title="1.3 资源的表述"></a>1.3 资源的表述</h3><p>资源的表述是指对资源在特定时刻的状态的描述，客户端通过HTTP方法可以获取资源，更准确说是资源的表述而已。 资源在外界的具体呈现，可以有多种表述形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。</p>
<p>资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。</p>
<h3 id="1-4-资源的链接"><a href="#1-4-资源的链接" class="headerlink" title="1.4 资源的链接"></a>1.4 资源的链接</h3><p>REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。这种反模式忽略了一个核心概念：”超媒体即应用状态引擎”。 超媒体是什么?当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.</p>
<p>要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。</p>
<p>下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。</p>
<p><img src="http://gityuan.com/images/http-restful/1.jpg" alt="get"></p>
<p>又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。</p>
<p><img src="http://gityuan.com/images/http-restful/2.jpg" alt="get"></p>
<p>上面的例子展示了如何使用超媒体来增强资源的连通性。很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于”资源的CRUD”。</p>
<h3 id="1-5-状态的转移"><a href="#1-5-状态的转移" class="headerlink" title="1.5 状态的转移"></a>1.5 状态的转移</h3><p>REST原则中的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。</p>
<p><strong>应用状态与资源状态</strong></p>
<p>客户端负责维护应用状态，而服务端维护资源状态。客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。</p>
<p>服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。 在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。</p>
<p>但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。</p>
<p><strong>应用状态的转移</strong></p>
<p>状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。</p>
<p>这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从资源的定义、获取、表述、关联、状态变迁等角度，试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/" itemprop="url">浅谈HTTP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-05T11:37:59+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/05/%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>HTTP是一个属于应用层的面向对象的协议，工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端发送请求。本文只介绍目前应用比较广泛的<strong>HTTP/1.1</strong>协议，下面从请求与响应两部分分开展开讲解。</p>
</blockquote>
<h2 id="一-请求-Request"><a href="#一-请求-Request" class="headerlink" title="一. 请求(Request)"></a>一. 请求(Request)</h2><h3 id="1-消息格式"><a href="#1-消息格式" class="headerlink" title="1.消息格式"></a>1.消息格式</h3><p><img src="http://gityuan.com/images/http/request_header.png" alt="http request"></p>
<p>一个完整的 HTTP/1.1消息格式分三部分：</p>
<ul>
<li><strong>请求行</strong>: {请求方法} {资源路径} {协议版本}</li>
<li><strong>请求头</strong>: 紧跟请求行的下一行，所有的请求头，除Host外都是可选的。</li>
<li><strong>消息体</strong>: 消息的主体部分，消息体的数据格式通过 header 里面的 Content-Type 属性指定。</li>
</ul>
<p>此外请求行必须以CRLF结尾，不允许出现单独的CR或LF字符。</p>
<h3 id="3-请求方法"><a href="#3-请求方法" class="headerlink" title="3.请求方法"></a>3.请求方法</h3><p>HTTP/1.1协议共定义八种请求方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody></table>
<h3 id="4-请求头"><a href="#4-请求头" class="headerlink" title="4.请求头"></a>4.请求头</h3><p>提供了关于请求，响应或者其他的发送实体的信息</p>
<table>
<thead>
<tr>
<th align="left">头</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">服务器支持哪些请求方法（如GET、POST等）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">指定浏览器可以支持的web服务器返回内容压缩编码类型</td>
<td align="left">Accept-Encoding: gzip</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">文档的<strong>编码方法</strong>，只有在解码后才得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间,但并非所有浏览器都支持gzip。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">表示<strong>实体内容长度</strong>，只有当浏览器使用持久HTTP连接时才需要这个数据。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">表示文档的<strong>MIME类型</strong>, Servlet默认为text/plain，但通常需要显式地指定为text/html，HttpServletResponse提供了一个专用的方法setContentType。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">当前的<strong>GMT时间</strong>，可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">文档的<strong>有效期时长</strong>，过期则不再缓存</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">文档的<strong>最后改动时间</strong>，Last-Modified也可用setDateHeader方法来设置。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">表示提取<strong>文档位置</strong>，Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">表示浏览器的文件的<strong>刷新间隔</strong>，N秒后刷新本页面或访问指定页面，此为扩展头，不属于HTTP 1.1正式规范。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置和页面关联的Cookie，应使用HttpServletResponse提供的专用方法addCookie。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="二-响应-Response"><a href="#二-响应-Response" class="headerlink" title="二. 响应(Response)"></a>二. 响应(Response)</h2><h3 id="1-消息格式-1"><a href="#1-消息格式-1" class="headerlink" title="1.消息格式"></a>1.消息格式</h3><p><img src="http://gityuan.com/images/http/response_header.png" alt="http response"></p>
<p>一个完整的 HTTP/1.1消息格式分三部分：</p>
<ul>
<li><strong>响应行</strong>：{协议版本} {状态码} {状态描述}</li>
<li><strong>响应头</strong>： 紧跟响应行的下一行，详细请接下去看。</li>
<li><strong>响应体</strong>：消息的主体部分，就是服务器返回的资源内容。</li>
</ul>
<p>此外请求行必须以CRLF结尾，不允许出现单独的CR或LF字符。</p>
<h3 id="2-响应实例"><a href="#2-响应实例" class="headerlink" title="2.响应实例"></a>2.响应实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Mon, 25 Jul 2008 12:12:32 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, 12 Jul 2008 18:18:20 GMT</span><br><span class="line">ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 50</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text&#x2F;plain</span><br></pre></td></tr></table></figure>

<h3 id="3-状态码表"><a href="#3-状态码表" class="headerlink" title="3.状态码表"></a>3.状态码表</h3><ul>
<li>1xx消息——请求已被服务器接收，继续处理</li>
<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>
<li>3xx重定向——需要后续操作才能完成这一请求</li>
<li>4xx请求错误——请求含有词法错误或者无法被执行</li>
<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>
</ul>
<p>详细列表</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">英文名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h3 id="4-Content-Type"><a href="#4-Content-Type" class="headerlink" title="4.Content-Type"></a>4.Content-Type</h3><p>IANA机构定义了8个大类的媒体类型，对应于HTTP头中的Content-Type的值，媒体类型分别是:</p>
<ul>
<li>application— (比如: application/vnd.ms-excel.)</li>
<li>audio (比如: audio/mpeg.)</li>
<li>image (比如: image/png.)</li>
<li>message (比如,:message/http.)</li>
<li>model(比如:model/vrml.)</li>
<li>multipart (比如:multipart/form-data.)</li>
<li>text(比如:text/html.)</li>
<li>video(比如:video/quicktime.)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/flutter/Flutter%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/flutter/Flutter%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" itemprop="url">跨平台演进及架构开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T18:17:47+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/flutter/Flutter%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/flutter/Flutter%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flutter开发规范"><a href="#Flutter开发规范" class="headerlink" title="Flutter开发规范"></a>Flutter开发规范</h1><h2 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h2><h3 id="1-1-要-使用-UpperCamelCase-风格命名类型。"><a href="#1-1-要-使用-UpperCamelCase-风格命名类型。" class="headerlink" title="1.1 要 使用 UpperCamelCase 风格命名类型。"></a>1.1 <strong>要</strong> 使用 <code>UpperCamelCase</code> 风格命名类型。</h3><ul>
<li>Classes（类名）</li>
<li>enums（枚举类型）</li>
<li>typedefs（类型定义）</li>
<li>type parameters（类型参数）</li>
</ul>
<p>应该把每个单词的首字母都大写（包含第一个单词），不使用分隔符。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliderMenu</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Predicate&lt;T&gt; = <span class="built_in">bool</span> <span class="built_in">Function</span>(T value);</span><br></pre></td></tr></table></figure>

<p>这里包括使用元数据注解的类。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Foo([arg]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span>(anArg)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>如果注解类的构造函数是无参函数，则可以使用一个 <code>lowerCamelCase</code> 风格的常量来初始化这个注解。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Foo();</span><br><span class="line"></span><br><span class="line"><span class="meta">@foo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-要-使用-UpperCamelCase-风格类型作为扩展名"><a href="#1-2-要-使用-UpperCamelCase-风格类型作为扩展名" class="headerlink" title="1.2 要 使用 UpperCamelCase 风格类型作为扩展名"></a>1.2 <strong>要</strong> 使用 <code>UpperCamelCase</code> 风格类型作为扩展名</h3><p>与类型命名一样，扩展名也应大写每个单词的首字母（包括第一个单词），并且不使用分隔符。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> MyFancyList&lt;T&gt; <span class="keyword">on</span> <span class="built_in">List</span>&lt;T&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> SmartIterable&lt;T&gt; <span class="keyword">on</span> <span class="built_in">Iterable</span>&lt;T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>版本提示:</strong></p>
<blockquote>
<p>Extensions 是 Dart 语言 2.7 版本的新增功能。详情请参考 <a href="https://github.com/dart-lang/language/blob/master/accepted/2.6/static-extension-members/feature-specification.md#dart-static-extension-methods-design" target="_blank" rel="noopener">extensions 设计文档。</a></p>
</blockquote>
<h3 id="1-3-要-在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名。"><a href="#1-3-要-在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名。" class="headerlink" title="1.3 要 在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名。"></a>1.3 <strong>要</strong> 在<code>库</code>，<code>包</code>，<code>文件夹</code>，<code>源文件</code>中使用 <code>lowercase_with_underscores</code> 方式命名。</h3><p>一些文件系统不区分大小写，所以很多项目要求文件名必须是小写字母。使用分隔符这种形式可以保证命名的可读性。使用下划线作为分隔符可确保名称仍然是有效的Dart标识符，如果语言后续支持符号导入，这将会起到非常大的帮助。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议使用</span></span><br><span class="line"><span class="keyword">library</span> peg_parser.source_scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'file_system.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'slider_menu.dart'</span>;</span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line"><span class="keyword">library</span> pegparser.SourceScanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'file-system.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'SliderMenu.dart'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-要-用-lowercase-with-underscores-风格命名库和源文件名。"><a href="#1-4-要-用-lowercase-with-underscores-风格命名库和源文件名。" class="headerlink" title="1.4 要 用 lowercase_with_underscores 风格命名库和源文件名。"></a>1.4 <strong>要</strong> 用 <code>lowercase_with_underscores</code> 风格命名库和源文件名。</h3><p><strong>建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39; as math;</span><br><span class="line">import &#39;package:angular_components&#x2F;angular_components&#39;</span><br><span class="line">    as angular_components;</span><br><span class="line">import &#39;package:js&#x2F;js.dart&#39; as js;</span><br></pre></td></tr></table></figure>

<p><strong>不建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39; as Math;</span><br><span class="line">import &#39;package:angular_components&#x2F;angular_components&#39;</span><br><span class="line">    as angularComponents;</span><br><span class="line">import &#39;package:js&#x2F;js.dart&#39; as JS;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-要-使用-lowerCamelCase-风格来命名其他的标识符。"><a href="#1-5-要-使用-lowerCamelCase-风格来命名其他的标识符。" class="headerlink" title="1.5 要 使用 lowerCamelCase 风格来命名其他的标识符。"></a>1.5 <strong>要</strong> 使用 <code>lowerCamelCase</code> 风格来命名其他的标识符。</h3><ul>
<li>类成员</li>
<li>顶级定义</li>
<li>变量</li>
<li>参数</li>
<li>命名参数等</li>
</ul>
<p><em>除了</em>第一个单词，每个单词首字母都应大写，并且不使用分隔符。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"></span><br><span class="line">HttpRequest httpRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> align(<span class="built_in">bool</span> clearItems) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-推荐使用-lowerCamelCase-来命名常量。"><a href="#1-6-推荐使用-lowerCamelCase-来命名常量。" class="headerlink" title="1.6 推荐使用 lowerCamelCase 来命名常量。"></a>1.6 <strong>推荐</strong>使用 <code>lowerCamelCase</code> 来命名常量。</h3><p>在新的代码中，使用 <code>lowerCamelCase</code> 来命名常量，包括枚举的值。</p>
<p><strong>建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const pi &#x3D; 3.14;</span><br><span class="line">const defaultTimeout &#x3D; 1000;</span><br><span class="line">final urlScheme &#x3D; RegExp(&#39;^([a-z]+):&#39;);</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">  static final numberGenerator &#x3D; Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const PI &#x3D; 3.14;</span><br><span class="line">const DefaultTimeout &#x3D; 1000;</span><br><span class="line">final URL_SCHEME &#x3D; RegExp(&#39;^([a-z]+):&#39;);</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">  static final NUMBER_GENERATOR &#x3D; Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 我们一开始使用 Java <code>SCREAMING_CAPS</code> 风格来命名常量。我们之所以不再使用，是因为：</p>
<ul>
<li><code>SCREAMING_CAPS</code> 很多情况下看起来比较糟糕，尤其类似于 CSS 颜色这类的枚举值。</li>
<li>常量常常被修改为 final 类型的非常量变量，这种情况你还需要修改变量的名字为小写字母形式。</li>
<li>在枚举类型中自动定义的 <code>values</code> 属性为常量并且是小写字母形式的。</li>
</ul>
<h3 id="1-7-把超过两个字母的首字母大写缩略词和缩写词当做一般单词来对待。"><a href="#1-7-把超过两个字母的首字母大写缩略词和缩写词当做一般单词来对待。" class="headerlink" title="1.7 把超过两个字母的首字母大写缩略词和缩写词当做一般单词来对待。"></a>1.7 把超过两个字母的首字母大写缩略词和缩写词当做一般单词来对待。</h3><p>首字母大写缩略词比较难阅读，特别是多个缩略词连载一起的时候会引起歧义。例如，一个以 <code>HTTPSFTP</code> 开头的名字，没有办法判断它是指 HTTPS FTP 还是 HTTP SFTP。</p>
<p>为了避免上面的情况，缩略词和缩写词要像普通单词一样首字母大写，两个字母的单词除外。（像 ID 和 Mr. 这样的双字母<em>缩写词</em>仍然像一般单词一样首字母大写。）</p>
<p><strong>建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpConnectionInfo</span><br><span class="line">uiHandler</span><br><span class="line">IOStream</span><br><span class="line">HttpRequest</span><br><span class="line">Id</span><br><span class="line">DB</span><br></pre></td></tr></table></figure>

<p><strong>不建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPConnection</span><br><span class="line">UiHandler</span><br><span class="line">IoStream</span><br><span class="line">HTTPRequest</span><br><span class="line">ID</span><br><span class="line">Db</span><br></pre></td></tr></table></figure>

<h2 id="二、顺序-不强制要求，但不能太乱"><a href="#二、顺序-不强制要求，但不能太乱" class="headerlink" title="二、顺序(不强制要求，但不能太乱)"></a>二、顺序(不强制要求，但不能太乱)</h2><p>为了使文件前面部分保持整洁，我们规定了关键字出现顺序的规则。每个“部分”应该使用空行分割。</p>
<h3 id="2-1-要-把-“dart-”-导入语句放到其他导入语句之前。"><a href="#2-1-要-把-“dart-”-导入语句放到其他导入语句之前。" class="headerlink" title="2.1 要 把 “dart:” 导入语句放到其他导入语句之前。"></a>2.1 <strong>要</strong> 把 “dart:” 导入语句放到其他导入语句之前。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:async&#39;;</span><br><span class="line">import &#39;dart:html&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;package:bar&#x2F;bar.dart&#39;;</span><br><span class="line">import &#39;package:foo&#x2F;foo.dart&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-要-把-“package-”-导入语句放到项目相关导入语句之前。"><a href="#2-2-要-把-“package-”-导入语句放到项目相关导入语句之前。" class="headerlink" title="2.2 要 把 “package:” 导入语句放到项目相关导入语句之前。"></a>2.2 <strong>要</strong> 把 “package:” 导入语句放到项目相关导入语句之前。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:bar&#x2F;bar.dart&#39;;</span><br><span class="line">import &#39;package:foo&#x2F;foo.dart&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;util.dart&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-要-把导出（export）语句作为一个单独的部分放到所有导入语句之后。"><a href="#2-3-要-把导出（export）语句作为一个单独的部分放到所有导入语句之后。" class="headerlink" title="2.3 要 把导出（export）语句作为一个单独的部分放到所有导入语句之后。"></a>2.3 <strong>要</strong> 把导出（export）语句作为一个单独的部分放到所有导入语句之后。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'src/error.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'src/foo_bar.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/error.dart'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>不建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#39;src&#x2F;error.dart&#39;;</span><br><span class="line">export &#39;src&#x2F;error.dart&#39;;</span><br><span class="line">import &#39;src&#x2F;foo_bar.dart&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-要-按照字母顺序来排序每个部分中的语句。"><a href="#2-4-要-按照字母顺序来排序每个部分中的语句。" class="headerlink" title="2.4 要 按照字母顺序来排序每个部分中的语句。"></a>2.4 <strong>要</strong> 按照字母顺序来排序每个部分中的语句。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:bar&#x2F;bar.dart&#39;;</span><br><span class="line">import &#39;package:foo&#x2F;foo.dart&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;foo.dart&#39;;</span><br><span class="line">import &#39;foo&#x2F;foo.dart&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>不建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:foo&#x2F;foo.dart&#39;;</span><br><span class="line">import &#39;package:bar&#x2F;bar.dart&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;foo&#x2F;foo.dart&#39;;</span><br><span class="line">import &#39;foo.dart&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="三、格式化"><a href="#三、格式化" class="headerlink" title="三、格式化"></a>三、格式化</h2><p>和其他大部分语言一样， Dart 忽略空格。但是，<em>人</em>不会。具有一致的空格风格有助于帮助我们能够用编译器相同的方式理解代码。</p>
<h3 id="3-1-要-使用-dartfmt-格式化你的代码。"><a href="#3-1-要-使用-dartfmt-格式化你的代码。" class="headerlink" title="3.1 要 使用 dartfmt 格式化你的代码。"></a><strong>3.1 要</strong> 使用 <code>dartfmt</code> 格式化你的代码。</h3><p>格式化是一项繁琐的工作，尤其在重构过程中特别耗时。庆幸的是，你不必担心。我们提供了一个名为 <a href="https://github.com/dart-lang/dart_style" target="_blank" rel="noopener">dartfmt</a> 的优秀的自动代码格式化程序，它可以为你完成格式化工作。我们有一些关于它适用的规则的 <a href="https://github.com/dart-lang/dart_style/wiki/Formatting-Rules" target="_blank" rel="noopener">文档</a> ， Dart 中任何官方的空格处理规则由 <em>dartfmt 生成</em>。</p>
<p>其余格式指南用于 dartfmt 无法修复的一些规则。</p>
<h3 id="3-2-考虑-修改你的代码让格式更友好。"><a href="#3-2-考虑-修改你的代码让格式更友好。" class="headerlink" title="3.2 考虑 修改你的代码让格式更友好。"></a>3.2 考虑 修改你的代码让格式更友好。</h3><p>无论你扔给格式化程序什么样代码，它都会尽力去处理，但是格式化程序不会创造奇迹。如果代码里有特别长的标识符，深层嵌套的表达式，混合的不同类型运算符等。格式化输出的代码可能任然很难阅读。</p>
<p>当有这样的情况发生时，那么就需要重新组织或简化你的代码。考虑缩短局部变量名或者将表达式抽取为一个新的局部变量。换句话说，你应该做一些手动格式化并增加代码的可读性的修改。在工作中应该把 dartfmt 看做一个合作伙伴，在代码的编写和迭代过程中互相协作输出优质的代码。</p>
<h3 id="3-3-避免-单行超过-80-个字符。"><a href="#3-3-避免-单行超过-80-个字符。" class="headerlink" title="3.3 避免 单行超过 80 个字符。"></a>3.3 避免 单行超过 80 个字符。</h3><p>可读性研究表明，长行的文字不易阅读，长行文字移动到下一行的开头时，眼睛需要移动更长的距离。这也是为什么报纸和杂志会使用多列样式的文字排版。</p>
<p>如果你真的发现你需要的文字长度超过了 80 个字符，根据我们的经验，你的代码很可能过于冗长，而且有方式可以让它更紧凑。最常见的的一种情况就是使用 <code>VeryLongCamelCaseClassNames</code> （非常长的类名字和变量名字）。当遇到这种情况时，请自问一下：“那个类型名称中的每个单词都会告诉我一些关键的内容或阻止名称冲突吗？”，如果不是，考虑删除它。</p>
<p>注意，dartfmt 能自动处理 99% 的情况，但是剩下的 1% 需要你自己处理。 dartfmt 不会把很长的字符串字面量分割为 80 个字符的列，所以这种情况你<strong>需要</strong>自己手工确保每行不超过 80 个字符。</p>
<p><strong>例外：</strong> 当情况出现在注释或字符串是（通常在导入和导出语句中），即使文字超出行限制，也可能会保留在一行中。这样可以更轻松地搜索给定路径的源文件。</p>
<h3 id="3-4-要-对所有流控制结构使用花括号。"><a href="#3-4-要-对所有流控制结构使用花括号。" class="headerlink" title="3.4 要 对所有流控制结构使用花括号。"></a>3.4 <strong>要</strong> 对所有流控制结构使用花括号。</h3><p>这样可以避免 <a href="https://en.wikipedia.org/wiki/Dangling_else" target="_blank" rel="noopener">dangling else</a>（else悬挂）的问题。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWeekDay) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Bike to work!'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Go dancing or read a book!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个例外：一个没有 <code>else</code> 的 <code>if</code> 语句，并且这个 <code>if</code> 语句以及它的执行体适合在一行中实现。在这种情况下，如果您愿意，可以不用括号：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) <span class="keyword">return</span> defaultValue;</span><br></pre></td></tr></table></figure>

<p>但是，如果执行体包含下一行，请使用大括号：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (overflowChars != other.overflowChars) &#123;</span><br><span class="line">  <span class="keyword">return</span> overflowChars &lt; other.overflowChars;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (overflowChars != other.overflowChars)</span><br><span class="line">  <span class="keyword">return</span> overflowChars &lt; other.overflowChars;</span><br></pre></td></tr></table></figure>

<h2 id="四、注释规范"><a href="#四、注释规范" class="headerlink" title="四、注释规范"></a>四、注释规范</h2><h3 id="4-1-要-像句子一样来格式化注释"><a href="#4-1-要-像句子一样来格式化注释" class="headerlink" title="4.1 要 像句子一样来格式化注释"></a>4.1 <strong>要</strong> 像句子一样来格式化注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Not if there is nothing before it.</span><br><span class="line">if (_chunks.isEmpty) return false;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-不要-使用块注释作用作解释说明。"><a href="#4-2-不要-使用块注释作用作解释说明。" class="headerlink" title="4.2 不要 使用块注释作用作解释说明。"></a>4.2 <strong>不要</strong> 使用块注释作用作解释说明。</h3><p><strong>建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet(name) &#123;</span><br><span class="line">  &#x2F;&#x2F; Assume we have a valid name.</span><br><span class="line">  print(&#39;Hi, $name!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不建议</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet(name) &#123;</span><br><span class="line">  &#x2F;* Assume we have a valid name. *&#x2F;</span><br><span class="line">  print(&#39;Hi, $name!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、文档注释"><a href="#五、文档注释" class="headerlink" title="五、文档注释"></a>五、文档注释</h2><p>文档注释特别有用，应为通过 <a href="https://github.com/dart-lang/dartdoc" target="_blank" rel="noopener">dartdoc</a> 解析这些注释可以生成 <a href="https://api.dart.dev/stable" target="_blank" rel="noopener">漂亮的文档网页</a>。文档注释包括所有出现在声明之前并使用 <code>///</code> 语法的注释，这些注释使用使用 dartdoc 检索。</p>
<h3 id="5-1-要-使用-文档注释来注释成员和类型。"><a href="#5-1-要-使用-文档注释来注释成员和类型。" class="headerlink" title="5.1 要 使用 /// 文档注释来注释成员和类型。"></a>5.1 要 使用 <code>///</code> 文档注释来注释成员和类型。</h3><p>使用文档注释可以让 <a href="https://github.com/dart-lang/dartdoc" target="_blank" rel="noopener">dartdoc</a> 来为你生成代码 API 文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; The number of characters in this chunk when unsplit.</span><br><span class="line">int get length &#x3D;&gt; ...</span><br></pre></td></tr></table></figure>

<p>由于历史原因，dartdoc 支持两种格式的文档注释：<code>///</code> (“C# 格式”) 和 <code>/** ... */</code> (“JavaDoc 格式”)。我们推荐使用 <code>///</code> 是因为其更加简洁。 <code>/**</code> 和 <code>*/</code> 在多行注释中间添加了开头和结尾的两行多余内容。 <code>///</code> 在一些情况下也更加易于阅读，例如，当文档注释中包含有使用 <code>*</code> 标记的列表内容的时候。</p>
<p>如果你现在还在使用 JavaDoc 风格格式，请考虑使用新的格式。</p>
<h3 id="5-2-推荐-为公开发布的-API-编写文档注释。"><a href="#5-2-推荐-为公开发布的-API-编写文档注释。" class="headerlink" title="5.2 推荐 为公开发布的 API 编写文档注释。"></a><strong>5.2 推荐</strong> 为公开发布的 API 编写文档注释。</h3><h3 id="5-3-推荐-为私有API-编写文档注释。"><a href="#5-3-推荐-为私有API-编写文档注释。" class="headerlink" title="5.3 推荐 为私有API 编写文档注释。"></a>5.3 推荐 为私有API 编写文档注释。</h3><p>文档注释不仅仅适用于外部用户使用你库的公开 API. 它也同样有助于理解那些私有成员，这些私有成员会被库的其他部分调用。</p>
<h3 id="5-4-要在文档注释开头有一个单句总结。"><a href="#5-4-要在文档注释开头有一个单句总结。" class="headerlink" title="5.4 要在文档注释开头有一个单句总结。"></a>5.4 要在文档注释开头有一个单句总结。</h3><p>注释文档要以一个以用户为中心，简要的描述作为开始。通常句子片段就足够了。为读者提供足够的上下文来定位自己，并决定是否应该继续阅读，或寻找其他解决问题的方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Deletes the file at [path] from the file system.</span></span></span><br><span class="line"><span class="keyword">void</span> delete(<span class="built_in">String</span> path) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-要-让文档注释的第一句从段落中分开。"><a href="#5-5-要-让文档注释的第一句从段落中分开。" class="headerlink" title="5.5 要 让文档注释的第一句从段落中分开。"></a>5.5 <strong>要</strong> 让文档注释的第一句从段落中分开。</h3><p>在第一句之后添加一个空行，将其拆分为自己的段落。如果不止一个解释句子有用，请将其余部分放在后面的段落中。</p>
<p>这有助于您编写一个紧凑的第一句话来总结文档。此外，像Dartdoc这样的工具使用第一段作为类和类成员列表等地方的简短摘要。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Deletes the file at [path].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Throws an [IOError] if the file could not be found. Throws a</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">[PermissionError] if the file is present but could not be deleted.</span></span></span><br><span class="line"><span class="keyword">void</span> delete(<span class="built_in">String</span> path) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、项目通用工具"><a href="#五、项目通用工具" class="headerlink" title="五、项目通用工具"></a>五、项目通用工具</h2><h3 id="统一标题栏"><a href="#统一标题栏" class="headerlink" title="统一标题栏"></a>统一标题栏</h3><p>/widgets/mcp_title_bar.dart</p>
<h3 id="按钮样式"><a href="#按钮样式" class="headerlink" title="按钮样式"></a>按钮样式</h3><p>/res/styles.dart/BtnStyles.class</p>
<h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><p>/res/styles.dart/TextStyles.class</p>
<h3 id="自定义TabBar-指示器"><a href="#自定义TabBar-指示器" class="headerlink" title="自定义TabBar 指示器"></a>自定义TabBar 指示器</h3><p>因TabBar默认无法满足UI需要，所以自定义指示器<br>/widgets/tab_bottom_shape_indicator.dart.dart</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/%E7%BB%99ITerm%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/%E7%BB%99ITerm%E4%BB%A3%E7%90%86/" itemprop="url">跨平台演进及架构开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T18:17:47+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/%E7%BB%99ITerm%E4%BB%A3%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/%E7%BB%99ITerm%E4%BB%A3%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用-shadowsocks-加速-Mac-自带终端或iTerm-2"><a href="#使用-shadowsocks-加速-Mac-自带终端或iTerm-2" class="headerlink" title="使用 shadowsocks 加速 Mac 自带终端或iTerm 2"></a>使用 shadowsocks 加速 Mac 自带终端或iTerm 2</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>对于经常需要依赖国外资源的开发者，终端的下载速度让人抓狂，诸如常见的 wget、curl、git、brew 等命令行工具超慢，甚至无法获取资源，这就需要搭建一个科学上网利器，例如目前流行的<code>shadowsocks</code>，我们配置好 shadowsocks 服务器端后，安装对应系统的客户端便可，然而当你构建的时候还是会很慢，这时你发现系统自带的终端或 iTerm 2 是不走 Socks5 。</p>
<p>因终端下<code>Socks5</code>代理的支持并不太友好，遂改用<code>http</code>代理，达到曲径通幽的目的。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>在 Linux系统下相对简单，安装 proxychains-NG 等软件就可以解决了，但在Mac下有点麻烦。OS X 10.11之前的系统，都还比较顺利，但是OS X 10.11之后较新的系统默认设置下不会安装成功。苹果在新系统中加入了SIP安全机制，他会阻止第三方程序向系统目录内（/System，/bin，/sbin，/usr(除了/usr/local)）进行写操作，sudo也不行。办法是先把SIP关了，等装好软件配置好后再打开SIP。或者改用其他软件。</p>
<p>关闭SIP也麻烦，遂用<code>privoxy</code>这个经典软件，它刚好就是安装在/usr/local内，不需要关闭SIP也可以正常使用。</p>
<h2 id="privoxy安装和使用说明-↓"><a href="#privoxy安装和使用说明-↓" class="headerlink" title="privoxy安装和使用说明 ↓"></a>privoxy安装和使用说明 ↓</h2><h3 id="确保安装了-Homebrew"><a href="#确保安装了-Homebrew" class="headerlink" title="确保安装了 Homebrew"></a>确保安装了 Homebrew</h3><p>Mac OS 下不可或缺的套件管理器： <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">Homebrew</a></p>
<h3 id="privoxy-安装"><a href="#privoxy-安装" class="headerlink" title="privoxy 安装"></a>privoxy 安装</h3><p>使用下面命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install privoxy</span><br></pre></td></tr></table></figure>



<h3 id="privoxy-配置"><a href="#privoxy-配置" class="headerlink" title="privoxy 配置"></a>privoxy 配置</h3><p>因为是 Homebrew 方式安装的 privoxy，所以跟官方网站的使用方式不一样，请以此文为准。</p>
<p>打开配置文件 /usr/local/etc/privoxy/config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure>

<p>在 config 配置文件的最底部，手动加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen-address 0.0.0.0:8118</span><br><span class="line">forward-socks5 &#x2F; localhost:1080 .</span><br></pre></td></tr></table></figure>

<p>** 或者用<code>echo</code>命令直接写入，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;</span><br><span class="line">echo &#39;listen-address 0.0.0.0:8118\nforward-socks5 &#x2F; localhost:1080 .&#39; &gt;&gt; config</span><br></pre></td></tr></table></figure>

<p>注意：<code>0.0.0.0</code> 可以让其他设备访问到，若不需要，请修改成用 <code>127.0.0.1</code>；<code>8118</code>是HTTP代理的默认端口；localhost:1080 是 SOCKS5（shadowsocks） 默认的地址，可根据需要自行修改，且注意不要忘了最后有一个空格和点号。</p>
<h3 id="启动-privoxy"><a href="#启动-privoxy" class="headerlink" title="启动 privoxy"></a>启动 privoxy</h3><p>因没有安装在系统目录内，所以启动的时候需要打全路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;privoxy &#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure>

<p>查看是否启动成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na | grep 8118</span><br></pre></td></tr></table></figure>

<p>看到有类似如下信息就表示启动成功了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp4	0	0  *.8118		*.*		LISTEN</span><br></pre></td></tr></table></figure>

<p>注意：如果没有，可查阅日志信息，分析哪里出了问题。打开配置文件找到 logdir 配置项，查看log文件。</p>
<h3 id="终端里-privoxy-的使用"><a href="#终端里-privoxy-的使用" class="headerlink" title="终端里 privoxy 的使用"></a>终端里 privoxy 的使用</h3><p>在命令行终端中输入如下命令后，该终端即可走代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;&#39;http:&#x2F;&#x2F;localhost:8118&#39;</span><br><span class="line">export https_proxy&#x3D;&#39;http:&#x2F;&#x2F;localhost:8118&#39;</span><br></pre></td></tr></table></figure>

<p>注意：是当前终端标签页走代理，其他终端标签页或新窗口则不是！</p>
<p>取消命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure>

<p>如果关闭终端标签页或窗口，功能就会失效。</p>
<p>如果需要代理一直生效，则可以把上述两行代码添加到 ~/.bash_profile 文件最后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">export http_proxy&#x3D;&#39;http:&#x2F;&#x2F;localhost:8118&#39;</span><br><span class="line">export https_proxy&#x3D;&#39;http:&#x2F;&#x2F;localhost:8118&#39;</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>使以上配置立即生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source  ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<p>还可以在 ~/.bash_profile 里加入开关函数，使用起来更方便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function proxy_off()&#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset https_proxy</span><br><span class="line">    echo -e &quot;已关闭代理&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function proxy_on() &#123;</span><br><span class="line">    export no_proxy&#x3D;&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot;</span><br><span class="line">    export http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8118&quot;</span><br><span class="line">    export https_proxy&#x3D;$http_proxy</span><br><span class="line">    echo -e &quot;已开启代理&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试当前终端标签/窗口是否走代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl ip.gs</span><br><span class="line">当前 IP：8.8.8.8 来自：美国加利福尼亚州洛杉矶 choopa.com</span><br></pre></td></tr></table></figure>

<h2 id="利用-Charles-fiddler-抓包软件"><a href="#利用-Charles-fiddler-抓包软件" class="headerlink" title="利用 Charles/fiddler 抓包软件"></a>利用 Charles/fiddler 抓包软件</h2><p>利用 Charles/fiddler 抓包软件，也可以将Sock5转换成一个http代理哦，这里就不介绍了。</p>
<h2 id="新版客户端-ShadowsocksX-NG"><a href="#新版客户端-ShadowsocksX-NG" class="headerlink" title="新版客户端 ShadowsocksX-NG"></a>新版客户端 ShadowsocksX-NG</h2><p>嫌以上麻烦，可以直接使用新版客户端 ShadowsocksX-NG，它自身集成了以上功能，但这个软件体积好大！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/flutter/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%94%E8%BF%9B%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/flutter/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%94%E8%BF%9B%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/" itemprop="url">跨平台演进及架构开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T18:17:47+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/flutter/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%94%E8%BF%9B%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/flutter/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%94%E8%BF%9B%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、移动跨平台技术演进"><a href="#一、移动跨平台技术演进" class="headerlink" title="一、移动跨平台技术演进"></a>一、移动跨平台技术演进</h2><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><p>移动互联网发展十余年，伴随着 Android、iOS 等智能手机的不断普及，移动端已逐步取代 PC 端，成为兵家必争之地。正所谓“得移动端者得天下”，移动端已成为互联网领域最大的流量分发入口，一大批互联网公司正是在这大趋势下崛起。</p>
<h4 id="2-为什么需要跨平台技术"><a href="#2-为什么需要跨平台技术" class="headerlink" title="2. 为什么需要跨平台技术"></a>2. 为什么需要跨平台技术</h4><p>伴随着移动互联网的高速发展，公司间竞争越来越激烈，如何将好想法快速落地、快速试错，成为备受关注的问题。提升研发效率、缩短研发周期，保障产品快速试错并能快速迭代新功能，让新产品新功能以最快的速度同时抵达 Android、iOS 等多端用户。</p>
<p>众所周知，Android 应用采用 Java 或 Kotlin 编写，iOS 应用采用 Objective-C 或 Swift 编写，Web 端采用 HTML /CSS/JavaScript 编写。当需要开发支持多端的应用，每一端都需要独立研发、测试，一直到上线，以及后续的维护工作，工作量成倍增涨，势必延长研发周期。</p>
<p>为了解决多端独立开发的问题，跨平台技术便应运而生，各大互联网公司为此都投入大量人力，于是出现了各种跨平台技术框架，<strong>面对移动领域的跨平台技术方案的层出不穷，又该如何做技术选型呢？</strong></p>
<h4 id="3-移动端技术选型"><a href="#3-移动端技术选型" class="headerlink" title="3. 移动端技术选型"></a>3. 移动端技术选型</h4><p>作为移动端的跨端技术方案，所关注无外乎以下这4个方面：研发效率、动态性、多端一致性、性能体验。</p>
<p><img src="http://gityuan.com/img/flutter-arch/1.png" alt="img"></p>
<ol>
<li>研发效率：最大化代码复用，减少多端差异的适配工作量，降低开发成本，专注业务开发，实现“write once，run everywhere”的终极目标。效率提升是贯穿整个业务的生命周期线，即便业务上线后，可持续降低后续的维护成本，加快新feature的迭代速度，这是一个持续的效率收益。当然，这里不得不说，任何一门新技术在开发启动学习阶段会有一些成本，但上手后的收益是长期的。</li>
<li>动态化：突破渠道的更新频率，可快速迭代新功能，这一点不仅是跨平台技术的诉求，也是Native技术必备的杀手锏，这也是评估跨端技术的一个重要考核点。</li>
<li>多端一致性：好产品在多端UI设计上，往往是整体风格统一，所以业务方采用原生各自独立开发完成后，还需额外花不少时间来修改UI以保证多端一致性；可见，各端独立实现开发方式，带来的效率滞后，不仅仅是Android和iOS各开发一份代码的工作量，还有双端UI的一致性对齐的工作。</li>
<li>性能体验：一般地，跨端技术方案拥有以上多重优势，但在性能方面比原生流畅更差些。牺牲部分体验换来效率提升，这一点也是情理之中，试想一下，跨平台技术方案同时兼得这4点，那么原生技术恐怕已退出历史舞台，早已是跨平台技术的天下，所以往往跨平台技术的性能优劣便成为核心指标。</li>
</ol>
<h4 id="4-跨平台技术划分"><a href="#4-跨平台技术划分" class="headerlink" title="4. 跨平台技术划分"></a>4. 跨平台技术划分</h4><p>对研发效率和体验的不断追逐，移动端的跨平台技术方框架层出不穷，然则天下武功众多，万变不离其宗，从其核心本质来划分，可大致分为以下三大类：</p>
<p><img src="http://gityuan.com/img/flutter-arch/2.png" alt="img"></p>
<ol>
<li>Web技术：主要依赖于WebView的技术，功能支持受限，性能体验很差，比如PhoneGap、Cordova、小程序。</li>
<li>原生渲染：使用JavaScript作为编程语言，通过中间层转化为原生控件来渲染UI界面，比如React Native、Weex。</li>
<li>自渲染技术：自行实现一套渲染框架，可通过调用skia等方式完成自渲染，而不依赖于原生控件，比如Flutter、Unity。</li>
</ol>
<h4 id="5-跨平台技术演进"><a href="#5-跨平台技术演进" class="headerlink" title="5. 跨平台技术演进"></a>5. 跨平台技术演进</h4><p>跨平台技术，一直以来是每一个有追求的开发者所追逐的梦想，同时也是守旧者的噩梦，跨平台的多端一体化方案势必颠覆现有的原生各端独立开发模式，接下来列举众多的跨平台技术中最为关键的几个技术方案的演进阶段。</p>
<p><img src="http://gityuan.com/img/flutter-arch/3.png" alt="img"></p>
<p>从上图可以看出，技术演进过程大致分以下三个阶段： 第一阶段，采用WebView技术绘制界面的Hybrid混合开发技术，通过JS Bridge 将系统部分能力暴露给 JS 调用，其缺点是性能较差，功能受限，扩展性差，不适合交互复杂的场景，比如Cordova。 第二阶段，针对WebView界面性能等问题，于是绘制交还原生渲染，仅仅通过JS调用原生控件，相比WebView技术性能体验更好，这是目前绝大部分跨平台框架的设计思路，比如React Native、Weex。另外，最近小程序也比较火，第一和第二阶段的融合，依然采用WebView作为渲染容器，通过限制Web技术栈的子集，规范化组件使用，并逐步引入原生控件代表WebView渲染，以提升性能。 第三阶段，虽然通过桥接技术使用原生控件解决了功能受限问题，提升性能体验，但相比原生体验差距还是比较大，以及处理平台差异性非常耗费人力。于是Flutter提出自带渲染引擎的解决方案，尽可能减少不同平台间的差异性, 同时媲美原生的高性能体验，因此业界对 Flutter有着极高的关注度。</p>
<p><strong>面对现有的如此多跨平台方案，为何当下最火的跨平台技术是Flutter，有哪些优势呢？</strong></p>
<p>RN、Weex均使用JavaScript作为编程语言，JavaScript作为前端开发语言，在跨平台开发中可谓大放异彩，利用web技术不仅能开发出网站，也可以开发手机端web应用和移动端应用程序，似有一统三界(Android、iOS、Web)的趋势，这就是大家常说的“大前端”时代。这些技术方案流畅度不太好，平台一致性较差，至今还没能大面积取代原生开发。</p>
<p>Flutter是以Dart语言编写，开发体验更接近客户端，从大家使用反馈来看也是如此，Flutter开发环境这一套的流程对于前端开发来说并不太友好。Flutter的定位同样是多端一体化，但是以客户端为首，先磨平Android和iOS双端开发体验，再逐步向Web端渗透，从Flutter规划的Roadmap也能看出，Flutter for web目前仍处于预览版，Flutter客户端方向都已经如火如荼上线了不少应用。</p>
<p>在此之前，大家常说“大前端”，对于Flutter技术，在笔者看来称之为“大移动端”更贴切，Flutter的UI框架优先支持客户端(Android/iOS)应用的同时，然后再适配Web端。移动互联网时代，不少公司都制定“移动优先”的战略，甚至只开发移动端，没有Web端。移动互联网的时代造就“大移动端”，Flutter作为一款能做到媲美原生的高性能跨平台技术方案，或许一统天下。</p>
<p>在跨平台技术领域，只要挑战在，技术就不会停滞，伴随着技术不断演进与革新，终将走向美好。</p>
<h4 id="6-Flutter技术优势"><a href="#6-Flutter技术优势" class="headerlink" title="6. Flutter技术优势"></a>6. Flutter技术优势</h4><p>Flutter是彻底的跨平台方案，既没有采用webView，也没有采用JS桥接原生控件，而是自行实现一套UI框架，在引擎底层通过Skia渲染到屏幕。对于UI之外所需要使用的移动设备自身提供的服务，比如相机、定位、屏幕触摸等，则采用Platform Channels跟原生系统通信的方式来实现。</p>
<p>对于Flutter优势，回到前面讲到移动端技术选型的4要素，研发效率、动态性、多端一致性、性能体验，分别对应下面这一组词语。</p>
<p><img src="http://gityuan.com/img/flutter-arch/4.png" alt="img"></p>
<ol>
<li>高效率：采用dart语言编写代码，虽然刚开始上手需要点时间，但熟练后效率比较高。一套代码适用多个平台(Android、iOS、Web)，以及高效的Hot Reload能快速辅助调试；</li>
<li>动态化：2017年3月苹果下发警告邮件，禁止JSPatch等 iOS App热更新方案，从此iOS动态化成为一个不宜公开讨论的话题。同样地，Flutter引擎在某一个官方版本对动态化做过一些尝试，但后续基于风险考虑移除，当然并没有阻碍大家对技术的探索，这里不方便展开讨论；</li>
<li>高一致性：实现UI像素级的控制，Flutter渲染引擎依靠跨平台Skia图形库来实现，仅依赖系统图形绘制相关的接口，比如未来Android会支持vulkan，iOS会支持metal，这些都是通过skia封装调用。可最大程度上保证不同平台的体验一致性，见下图所示。</li>
</ol>
<p><img src="http://gityuan.com/img/flutter-arch/5.png" alt="img"></p>
<ol>
<li>高性能：渲染性能优于现有的各种跨平台框架，可媲美原生性能的跨平台技术方案，Dart代码执行效率比JS高，通过AOT编译成平台原生代码，渲染采用自渲染skia方案，既不需要JS Bridge桥接，也不需要Art虚拟机参与。再从渲染原理来看看Flutter的高性能的底气在哪里。</li>
</ol>
<p><img src="http://gityuan.com/img/flutter-arch/6_flutter_compare.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>Android原生框架，通过调用Java Framework层，再调用到skia来渲染界面；</li>
<li>其他跨平台方案(如RN)，通过JSBridge中间层来将JS写的APP转换成相应的原生渲染逻辑，可见比Native代码增加了更多逻辑，性能逊色差于原生框架；</li>
<li>Flutter框架，APP通过调用Dart Framework层，再直接调用到skia来渲染界面，并没有经过原生Framework过程，可见其渲染性能并不会弱于Native技术，这是一个性能上限很高的跨平台技术。</li>
</ul>
<p>当然，不得不说目前的Flutter确实不够尽善尽美，会存在一些不够尽善尽美之处，比如生态不够健全，包体积问题，但其该方案的上限比较高，想象空间比较大，相信更多开发者参与进来，经过更多打磨，未来会做得更好。</p>
<h4 id="7-业界发展近况"><a href="#7-业界发展近况" class="headerlink" title="7. 业界发展近况"></a>7. 业界发展近况</h4><p>2017年5月Google I/O大会正式对外公布Flutter，到2018年12月发布Flutter1.0，引发全球大量的开发者和企业开始研究Flutter。StackOverflow 2019年的全球开发者文件调查中，Flutter被评选为最受开发者欢迎的框架之一，超过了TensorFlow和Node.js。</p>
<p><img src="http://gityuan.com/img/flutter-arch/7_flutter_rank.png" alt="img"></p>
<p>到目前，全球越来越多的公司已经在大家耳熟能详的知名APP中使用Flutter技术并落地，尤其国内知名互联网公司对Flutter投入度很大，社区也是非常活跃。</p>
<h4 id="8-Flutter未来趋势"><a href="#8-Flutter未来趋势" class="headerlink" title="8. Flutter未来趋势"></a>8. Flutter未来趋势</h4><p>目前Flutter主要在移动端Android/iOS双端跨端，Flutter 的愿景是成为一个多端运行的 UI 框架，能够支持不仅仅是移动端，还包括Web、桌面、甚至嵌入式设备。在2019 Google I/O 开发者大会上推出的使用 Flutter 开发 Web 应用的框架，同年9月发布Flutter 1.9，并将Flutter web合入Flutter主仓库。</p>
<p><img src="http://gityuan.com/img/flutter-arch/9_flutter_multi_arch.png" alt="img"></p>
<p>从架构图看，Flutter采用同一个Dart Framework层来统一Flutter C++引擎和Web引擎，最终可以运行在Android，iOS，Browser上，从Flutter引擎代码不难看出Flutter也是支持Fuchsia操作系统。</p>
<p>Fuchsia是Google内部正在开发的一款新的操作系统，采用Flutter作为系统默认的UI框架，也就是说Flutter天然支持Fuchsia，这无疑让Flutter在众多的跨平台方案更有优势。</p>
<p>从Fuchsia技术架构来看，内核层zircon的基础LK是专为嵌入式应用中小型系统设计的内核，代码简洁，适合嵌入式设备和高性能设备，比如IOT、移动可穿戴设备等，目前这些领域还没有标准化级别的垄断者。以及在框架层中有着语音交互、云端以及智能化等模块，由此笔者揣测未来Fuchsia率先应用在音控等智能嵌入式设备。</p>
<p><img src="http://gityuan.com/img/flutter-arch/10_fuchsia.png" alt="img"></p>
<p>目前大家普遍比较看好的未来两个技术就是5G和IoT时代。对于5G的需求，很大程度上是因为移动互联网发展到“IoT时代”的阶段。这个发展阶段，全球上网设备的数量可能会达到500亿个。随着5G+IOT时代的到来，现在大家比较关注的Flutter包大小也同样不再是一个问题，或许Flutter技术的生命期比客户端更长，或许Fuchsia正在驰骋IOT疆场，你所掌握的Flutter技术栈可以无缝迁移，一次弯道超车的机会。</p>
<p>到此，介绍完跨平台技术演进以及Flutter的优势。看到这，相信你可能对Flutter技术有一定兴趣，为了能让大家快速了解Flutter内部原理而不枯燥，Gityuan通过一系列图来帮大家从整体架构来快速理解Flutter。</p>
<h2 id="二、Flutter引擎架构"><a href="#二、Flutter引擎架构" class="headerlink" title="二、Flutter引擎架构"></a>二、Flutter引擎架构</h2><h4 id="1-Flutter技术架构"><a href="#1-Flutter技术架构" class="headerlink" title="1. Flutter技术架构"></a>1. Flutter技术架构</h4><p>先来看看Flutter整体的技术架构，分为四层，从上之下依次是Dart APP，Dart Framework， C++ Engine，Platform。</p>
<p><img src="http://gityuan.com/img/flutter-arch/11_flutter_arch.png" alt="img"></p>
<p>Flutter架构最核心的便是Framework（框架）和Engine（引擎）：</p>
<ul>
<li>Flutter Framework层：用Dart编写，封装整个Flutter架构的核心功能，包括Widget、动画、绘制、手势等功能，有Material（Android风格UI）和Cupertino（iOS风格）的UI界面， 可构建Widget控件以及实现UI布局。</li>
<li>Flutter Engine层：用C++编写，用于高质量移动应用的轻量级运行时环境，实现了Flutter的核心库，包括Dart虚拟机、动画和图形、文字渲染、通信通道、事件通知、插件架构等。引擎渲染采用的是2D图形渲染库Skia，虚拟机采用的是面向对象语言Dart VM，并将它们托管到Flutter的嵌入层。shell实现了平台相关的代码，比如跟屏幕键盘IME和系统应用生命周期事件的交互。不同平台有不同的shell，比如Android和iOS的shell。</li>
</ul>
<h4 id="2-Flutter编译产物"><a href="#2-Flutter编译产物" class="headerlink" title="2. Flutter编译产物"></a>2. Flutter编译产物</h4><p>看完Flutter内部架构，或许你好奇，Flutter不用Android/iOS的本地语言技术开发，Dart编写完的代码如何让不同系统可以识别，最终编译后得到的产物是什么呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/12_flutter_artifact.png" alt="img"></p>
<p>Flutter产物分为Dart业务代码和Engine代码各自生成的产物，图中的Dart Code包含开发者编写的业务代码，Engine Code是引擎代码，如果并没有定制化引擎，则无需重新编译引擎代码。</p>
<p>一份Dart代码，可编译生成双端产物，实现跨平台的能力。经过编译工具处理后可生成双端产物，图中便是release模式的编译产物，Android产物是由vm、isolate各自的指令段和数据段以及flutter.jar组成的app.apk，iOS产物是由App.framework和Flutter.framework组成的Runner.app。</p>
<p>这个过程涉及frontend_server、gen_snapshot、xcrun、ninja编译工具。frontend_server前端编译器会进行词法分析、语法分析以及相关全局转换等工作，将dart代码转换为AST(抽象语法树)，并生成app.dill格式的dart kernel。gen_snapshot经过CHA、内联等一系列执行流的优化，根据中间代码生成优化后的FlowGraph对象，再转换为具体相应系统架构（arm/arm64等）的二进制指令。</p>
<h4 id="3-Flutter引擎启动"><a href="#3-Flutter引擎启动" class="headerlink" title="3. Flutter引擎启动"></a>3. Flutter引擎启动</h4><p>既然了解了Flutter的编译产物，那你或许又好奇，Flutter这台引擎如何发动的，怎么跟Native衔接呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/13_flutter_engine_startup.png" alt="img"></p>
<p>这里以Android为例，熟悉Android的开发者，应该都了解APP启动过程，会执行Application和Activity的onCreate()方法，FlutterApplication和FlutterActivity的onCreate()方法正是连接Native和Flutter的枢纽。</p>
<ul>
<li>FlutterApplication.java的onCreate过程主要完成初始化配置、加载引擎libflutter.so、注册JNI方法；</li>
<li>FlutterActivity.java的onCreate过程，通过FlutterJNI的AttachJNI()方法来初始化引擎Engine、Dart虚拟机、Isolate、taskRunner等对象。再经过层层处理最终调用main.dart中main()方法，执行runApp(Widget app)来处理整个Dart业务代码。</li>
</ul>
<p>Flutter引擎启动中会创建有4个TaskRunner以及创建虚拟机，分别来看看它们的工作原理。</p>
<h4 id="4-TaskRunner工作原理"><a href="#4-TaskRunner工作原理" class="headerlink" title="4. TaskRunner工作原理"></a>4. TaskRunner工作原理</h4><p>Flutter引擎启动过程，会创建UI/GPU/IO这3个线程，会为这些线程依次创建MessageLoop对象，启动后处于epoll_wait等待状态。对于Flutter的消息机制跟Android原生的消息机制有很多相似之处，都有消息(或者任务)、消息队列(或任务队列)以及Looper；有一点不同的是Android有一个Handler类，用于发送消息以及执行回调方法，相对应Flutter中有着相近功能的便是TaskRunner。</p>
<p><img src="http://gityuan.com/img/flutter-arch/14_task_loop.png" alt="img"></p>
<p>上图是从源码中提炼而来的任务处理流程，比官方流程图更容易理解一些复杂流程的时序问题，后续会专门讲解个中原由。Flutter的任务队列处理机制跟Android的消息队列处理相通，只不过Flutter分为Task和MicroTask两种类型，引擎和Dart虚拟机的事件以及Future都属于Task，Dart层执行scheduleMicrotask()所产生的属于Microtask。</p>
<p>每次Flutter引擎在消费任务时调用FlushTasks()方法，遍历整个延迟任务队列delayed_tasks_，将已到期的任务加入task队列，然后开始处理任务。</p>
<ul>
<li>Step 1: 检查task，当task队列不为空，先执行一个task；</li>
<li>Step 2: 检查microTask，当microTask不为空，则执行microTask；不断循环Step 2 直到microTask队列为空，再回到执行Step 1；</li>
</ul>
<p>可简单理解为先处理完所有的Microtask，然后再处理Task。因为scheduleMicrotask()方法的调用自身就处于一个Task，执行完当前的task，也就意味着马上执行该Microtask。</p>
<p>了解了其工作机制，再来看看这4个Task Runner的具体工作内容。</p>
<ul>
<li>Platform Task Runner：运行在Android或者iOS的主线程，尽管阻塞该线程并不会影响Flutter渲染管道，平台线程建议不要执行耗时操作；否则可能触发watchdog来结束该应用。比如Android、iOS都是使用平台线程来传递用户输入事件，一旦平台线程被阻塞则会引起手势事件丢失。</li>
<li>UI Task Runner: 运行在ui线程，比如1.ui，用于引擎执行root isolate中的所有Dart代码，执行渲染与处理Vsync信号，将widget转换生成Layer Tree。除了渲染之外，还有处理Native Plugins消息、Timers、Microtasks等工作；</li>
<li>GPU Task Runner：运行在gpu线程，比如1.gpu，用于将Layer Tree转换为具体GPU指令，执行设备GPU相关的skia调用，转换相应平台的绘制方式，比如OpenGL, vulkan, metal等。每一帧的绘制需要UI Runner和GPU Runner配合完成，任何一个环节延迟都可能导致掉帧；</li>
<li>IO Task Runner：运行在io线程，比如1.io，前3个Task Runner都不允许执行耗时操作，该Runner用于将图片从磁盘读取出来，解压转换为GPU可识别的格式后，再上传给GPU线程。为了能访问GPU，IO Runner跟GPU Runner的Context在同一个ShareGroup。比如ui.image通过异步调用让IO Runner来异步加载图片，该线程不能执行其他耗时操作，否则可能会影响图片加载的性能。</li>
</ul>
<h4 id="5-Dart虚拟机工作"><a href="#5-Dart虚拟机工作" class="headerlink" title="5. Dart虚拟机工作"></a>5. Dart虚拟机工作</h4><p>Flutter引擎启动会创建Dart虚拟机以及Root Isolate。DartVM自身也拥有自己的Isolate，完全由虚拟机自己管理的，Flutter引擎也无法直接访问。Dart的UI相关操作，是由Root Isolate通过Dart的C++调用，或者是发送消息通知的方式，将UI渲染相关的任务提交到UIRunner执行，这样就可以跟Flutter引擎相关模块进行交互。</p>
<p>何为Isolate，从字面上理解是“隔离”，isolate之间是逻辑隔离的。Isolate中的代码也是按顺序执行，因为Dart没有共享内存的并发，没有竞争的可能性，故不需要加锁，也没有死锁风险。对于Dart程序的并发则需要依赖多个isolate来实现。</p>
<p><img src="http://gityuan.com/img/flutter-arch/15_isolate_heap.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>isolate堆是运该isolate中代码分配的所有对象的GC管理的内存存储；</li>
<li>vm isolate是一个伪isolate，里面包含不可变对象，比如null，true，false；</li>
<li>isolate堆能引用vm isolate堆中的对象，但vm isolate不能引用isolate堆；</li>
<li>isolate彼此之间不能相互引用；</li>
<li>每个isolate都有一个执行dart代码的Mutator thread，一个处理虚拟机内部任务(比如GC, JIT等)的helper thread； 可见，isolate是拥有内存堆和控制线程，虚拟机中可以有很多isolate，但彼此之间内存不共享，无法直接访问，只能通过dart特有的Port端口通信；isolate除了拥有一个mutator控制线程，还有一些其他辅助线程，比如后台JIT编译线程、GC清理/并发标记线程；</li>
</ul>
<h4 id="6-Widget架构概览"><a href="#6-Widget架构概览" class="headerlink" title="6. Widget架构概览"></a>6. Widget架构概览</h4><p>Flutter引擎启动后执行Dart业务，是通过runApp(Widget app)方法，那Widget又是什么呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/16_widget_arch.png" alt="img"></p>
<p>Widget是所有Flutter应用程序的基石，Widget可以是一个按钮，一种字体或者颜色，一个布局属性等，在Flutter的UI世界可谓是“万物皆Widget”。常见的Widget子类为StatelessWidget(无状态)和StatefulWidget(有状态)；</p>
<ul>
<li>StatelessWidget：内部没有保存状态，UI界面创建后不会发生改变；</li>
<li>StatefulWidget：内部有保存状态，当状态发生改变，调用setState()方法会触发StatefulWidget的UI发生更新，对于自定义继承自StatefulWidget的子类，必须要重写createState()方法。</li>
</ul>
<p><strong>三棵树</strong></p>
<p><img src="http://gityuan.com/img/flutter-arch/17_three_tree.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>Widget是为Element描述需要的配置， 负责创建Element，决定Element是否需要更新。Flutter Framework通过差分算法比对Widget树前后的变化，决定Element的State是否改变。当重建Widget树后并未发生改变， 则Element不会触发重绘，则就是Widget树的重建并不一定会触发Element树的重建。</li>
<li>Element表示Widget配置树的特定位置的一个实例，同时持有Widget和RenderObject，负责管理Widget配置和RenderObject渲染。Element状态由Flutter Framework管理， 开发人员只需更改Widget即可。</li>
<li>RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如测量大小、位置、绘制等都由RenderObject完成。</li>
</ul>
<p>可见，开发者通过Widget配置，Framework通过比对Widget配置来更新Element，最后调度RenderObject Tree完成布局排列和绘制。</p>
<h4 id="7-渲染原理"><a href="#7-渲染原理" class="headerlink" title="7. 渲染原理"></a>7. 渲染原理</h4><p>Dart的UI采用Widget来实现，最终转换为RenderObject，那界面又是如何渲染的呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/18_gpu_pipeline.png" alt="img"></p>
<p>渲染过程，UI线程完成布局、绘制操作，生成Layer Tree；GPU线程执行合成并光栅化后交给GPU来处理，其中几个关键步骤：</p>
<ul>
<li>Animate: 遍历_transientCallbacks，执行动画回调方法；</li>
<li>Build: 对于dirty的元素会执行build构造，没有dirty元素则不会执行，对应于buildScope()</li>
<li>Layout: 计算渲染对象的大小和位置，对应于flushLayout()，这个过程可能会嵌套再调用build操作；</li>
<li>Compositing bits: 更新具有【脏】合成位的任何渲染对象， 对应于flushCompositingBits()；</li>
<li>Paint: 将绘制命令记录到Layer， 对应于flushPaint()；</li>
<li>Compositing: 将Compositing bits发送给GPU， 对应于compositeFrame()；</li>
</ul>
<p>GPU线程通过skia向GPU硬件绘制一帧的数据，GPU将帧信息保存到FrameBuffer里面，然后视频控制器会根据VSync信号从FrameBuffer取帧数据传递给显示器，从而显示出最终的画面。</p>
<h4 id="8-Platform-Channels"><a href="#8-Platform-Channels" class="headerlink" title="8. Platform Channels"></a>8. Platform Channels</h4><p>Flutter框架提供了UI的控件支持，对于APP除了UI还有其他依赖于Native平台的支持，比如调用Camera的功能，该怎么办呢？为此，Flutter通过提供Platform Channel的功能，使得Dart代码具备与Native交互的能力。</p>
<p><img src="http://gityuan.com/img/flutter-arch/19_platform_channels.png" alt="img"></p>
<p>Platform Channel用于Flutter与Native之间的消息传递，整个过程的消息与响应是异步执行，不会阻塞用户界面。Flutter引擎框架已完成桥接的通道，这样开发者只需在Native层编写定制的Android/iOS代码，即可在Dart代码中直接调用，这也就是Flutter Plugin插件的一种形式。</p>
<h2 id="三、Flutter源码解读"><a href="#三、Flutter源码解读" class="headerlink" title="三、Flutter源码解读"></a>三、Flutter源码解读</h2><p>笔者(Gityuan)之前一直从事于Android操作系统底层研发工作，今年刚接触Flutter，Flutter作为一门全新的跨平台技术框架，不断深究会发现这是一个小型系统，涉及到的技术很广：</p>
<ul>
<li>编译技术如何将dart代码转换为AST(抽象语法树)，如何汇编转换为机器码，打包产物是什么？</li>
<li>Flutter这台引擎如何发动的，怎么跟Native原生系统衔接运行，如何识别产物并加载到内存？</li>
<li>引擎启动后，TaskRunner如何分发任务，跟原生系统消息机制有什么关系？</li>
<li>Dart虚拟机如何管理内存，跟isolate又有什么关系？</li>
<li>开发者编写的Widget控件如何渲染到屏幕上？</li>
<li>Flutter如何通过plugin支持移动设备提供的服务？</li>
</ul>
<p>这些疑问在前面都逐一简要解答，如果仅仅是用Flutter做业务开发，并不需要掌握这么深度技术，不过，知其然知其所以然，能让你游刃有余。</p>
<h4 id="启动篇"><a href="#启动篇" class="headerlink" title="启动篇"></a>启动篇</h4><ul>
<li><a href="http://gityuan.com/2019/06/22/flutter_booting/" target="_blank" rel="noopener">深入理解Flutter引擎启动</a></li>
<li><a href="http://gityuan.com/2019/06/23/dart-vm/" target="_blank" rel="noopener">深入理解Dart虚拟机启动</a></li>
<li><a href="http://gityuan.com/2019/06/29/flutter_run_app/" target="_blank" rel="noopener">深入理解Flutter应用启动</a></li>
</ul>
<h4 id="通信篇"><a href="#通信篇" class="headerlink" title="通信篇"></a>通信篇</h4><ul>
<li><a href="http://gityuan.com/2019/07/20/flutter_message_loop/" target="_blank" rel="noopener">深入理解Flutter消息机制</a></li>
<li><a href="http://gityuan.com/2019/08/10/flutter_channel/" target="_blank" rel="noopener">深入理解Flutter的Platform Channel机制</a></li>
<li><a href="http://gityuan.com/2019/07/21/flutter_future/" target="_blank" rel="noopener">深入理解Flutter异步Future机制</a></li>
<li><a href="http://gityuan.com/2019/07/27/flutter-isolate/" target="_blank" rel="noopener">深入理解Flutter的Isolate创建过程</a></li>
</ul>
<h4 id="渲染篇"><a href="#渲染篇" class="headerlink" title="渲染篇"></a>渲染篇</h4><ul>
<li><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">Flutter渲染机制—UI线程</a></li>
<li><a href="http://gityuan.com/2019/06/16/flutter_gpu_draw/" target="_blank" rel="noopener">Flutter渲染机制—GPU线程</a></li>
<li><a href="http://gityuan.com/2019/07/06/flutter_set_state/" target="_blank" rel="noopener">深入理解setState更新机制</a></li>
<li><a href="http://gityuan.com/2019/07/13/flutter_animator/" target="_blank" rel="noopener">深入理解Flutter动画原理</a></li>
</ul>
<p>后续笔者将持续研究与梳理Flutter内部机制的文章。</p>
<h2 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h2><p>本文分为三部分全方位逐级深入的分析Flutter技术，先讲述跨平台技术的过去与未来，再解读Flutter架构设计原理，最后剖析Flutter内部源码，后续将持续更新更多剖析技术深度细节以及实战经验，以彻底揭秘更多Flutter技术。</p>
<p>科技不断在进步，技术不断发展，移动跨平台技术几乎从Android、iOS诞生不久便出现，已发展快10年。时至今日，兼具跨端高效率与高性能体验的Flutter力压群雄，崭露头角，已然成为当下最热门的移动端新技术，全球越来越多的公司在Flutter技术布局并落地产品应用，社区也非常活跃。</p>
<p>随着5G+IOT时代的到来，Fuchsia系统或许发力IOT新战场，你所掌握的Flutter技术栈可以无缝迁移，这是一次弯道超车的机会。即便Fuchsia落败，相信只要深扎Flutter系统技术的精髓，其他任何的移动端新技术都可以轻松快速地掌握。</p>
<p>最后，用一句话来结束本次分享，“有时候，你选择一个方向，不是因为它一定会成为未来，而是它有可能成为不一样的未来。”</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/Android/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/" itemprop="url">组件化基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T15:02:38+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%BB%84%E4%BB%B6%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">组件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/Android/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/Android/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>多module划分为业务和基础功能</strong></p>
<ul>
<li><strong>组件</strong>：指的是单一的功能组件，如视频组件（VideoSDK）、支付组件（PaySDK）、路由组件（Router）等，每个组件都能单独抽出来制作成SDK。</li>
<li><strong>模块</strong>: 指的是独立的业务模块，如直播模块（LiveModule）、首页模块（HomeModule）、即时通信模块（IMModule）等。模块相对于组件来说粒度更大，模块可能包含多种不同的组件。</li>
</ul>
<p><strong>组件化开发的好处：</strong></p>
<ul>
<li>避免重复造轮子，可以节省开发和维护的成本。</li>
<li>可以通过组件和模块为业务基准合理地安排人力，提高开发效率。</li>
<li>不同的项目可以共用一个组件或模块，确保整体技术方案的统一性。</li>
<li>为未来插件化共用同一套底层模型做准备。</li>
</ul>
<p><strong>模块化开发的好处：</strong></p>
<ul>
<li>业务模块的解耦，业务移植更加简单。</li>
<li>多团队根据业务内容进行并行开发和测试。</li>
<li>单个业务可以单独编译打包，加快编译速度。</li>
<li>多个App共用模块，降低了研发和维护成本。</li>
</ul>
<p><strong>两者的缺点：</strong></p>
<ul>
<li>旧项目重新适配组件化的开发需要相应的人力及时间成本。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" itemprop="url">Binder通信架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T13:54:37+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" itemprop="url">彻底理解Android Binder通信架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T13:52:26+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/Android/Binder/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Android%20Binder%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-引言"><a href="#一-引言" class="headerlink" title="一. 引言"></a>一. 引言</h2><h4 id="1-1-Binder架构的思考"><a href="#1-1-Binder架构的思考" class="headerlink" title="1.1 Binder架构的思考"></a>1.1 Binder架构的思考</h4><p>Android内核是基于Linux系统, 而Linux现存多种进程间IPC方式:管道, 消息队列, 共享内存, 套接字, 信号量, 信号. 为什么Android非要用Binder来进行进程间通信呢. 从我个人的理解角度, 曾尝试着在知乎回答同样一个问题 <a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a>. 这是Gityuan第一次认认真真地在知乎上回答问题, 收到很多网友的点赞与回复, 让我很受鼓舞, 也决心分享更多优先地文章回报读者和粉丝, 为Android圈贡献自己的微薄之力。</p>
<p>在说到Binder架构之前, 先简单说说大家熟悉的TCP/IP的五层通信体系结构:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/tcp_ip_arch.jpg" alt="tcp_ip_arch"></p>
<ul>
<li>应用层: 直接为用户提供服务;</li>
<li>传输层: 传输的是报文(TCP数据)或者用户数据报(UDP数据)</li>
<li>网络层: 传输的是包(Packet), 例如路由器</li>
<li>数据链路层: 传输的是帧(Frame), 例如以太网交换机</li>
<li>物理层: 相邻节点间传输bit, 例如集线器,双绞线等</li>
</ul>
<p>这是经典的五层TPC/IP协议体系, 这样分层设计的思想, 让每一个子问题都设计成一个独立的协议, 这协议的设计/分析/实现/测试都变得更加简单:</p>
<ul>
<li>层与层具有独立性, 例如应用层可以使用传输层提供的功能而无需知晓其实现原理;</li>
<li>设计灵活, 层与层之间都定义好接口, 即便层内方法发生变化,只有接口不变, 对这个系统便毫无影响;</li>
<li>结构的解耦合, 让每一层可以用更适合的技术方案, 更合适的语言;</li>
<li>方便维护, 可分层调试和定位问题;</li>
</ul>
<p>Binder架构也是采用分层架构设计, 每一层都有其不同的功能:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/binder_ipc_arch.jpg" alt="binder_ipc_arch"></p>
<ul>
<li><strong>Java应用层:</strong> 对于上层应用通过调用AMP.startService, 完全可以不用关心底层,经过层层调用,最终必然会调用到AMS.startService.</li>
<li><strong>Java IPC层:</strong> Binder通信是采用C/S架构, Android系统的基础架构便已设计好Binder在Java framework层的Binder客户类BinderProxy和服务类Binder;</li>
<li><strong>Native IPC层:</strong> 对于Native层,如果需要直接使用Binder(比如media相关), 则可以直接使用BpBinder和BBinder(当然这里还有JavaBBinder)即可, 对于上一层Java IPC的通信也是基于这个层面.</li>
<li><strong>Kernel物理层:</strong> 这里是Binder Driver, 前面3层都跑在用户空间,对于用户空间的内存资源是不共享的,每个Android的进程只能运行在自己进程所拥有的虚拟地址空间, 而内核空间却是可共享的. 真正通信的核心环节还是在Binder Driver.</li>
</ul>
<h4 id="1-2-分析起点"><a href="#1-2-分析起点" class="headerlink" title="1.2 分析起点"></a>1.2 分析起点</h4><p>前面通过一个<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列-开篇</a>来从源码讲解了Binder的各个层面, 但是Binder牵涉颇为广泛, 几乎是整个Android架构的顶梁柱, 虽说用了十几篇文章来阐述Binder的各个过程. 但依然还是没有将Binder IPC(进程间通信)的过程彻底说透.</p>
<p>Binder系统如此庞大, 那么这里需要寻求一个出发点来穿针引线, 一窥视Binder全貌. 那么本文将从全新的视角,以<a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService流程分析</a>为例子来说说Binder所其作用. 首先在发起方进程调用AMP.startService，经过binder驱动，最终调用系统进程AMS.startService,如下图:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/start_server_binder.jpg" alt="start_server_binder"></p>
<p>AMP和AMN都是实现了IActivityManager接口,AMS继承于AMN. 其中AMP作为Binder的客户端,运行在各个app所在进程, AMN(或AMS)运行在系统进程system_server.</p>
<h4 id="1-3-Binder-IPC原理"><a href="#1-3-Binder-IPC原理" class="headerlink" title="1.3 Binder IPC原理"></a>1.3 Binder IPC原理</h4><p>Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。下面说说startService过程所涉及的Binder对象的架构图：</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/ams_ipc.jpg" alt="ams_ipc"></p>
<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务, 当然查找到目标信息可以缓存起来则不需要每次都向ServiceManager请求。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li><strong>注册服务</strong>：首先AMS注册到ServiceManager。该过程：AMS所在进程(system_server)是客户端，ServiceManager是服务端。</li>
<li><strong>获取服务</strong>：Client进程使用AMS前，须先向ServiceManager中获取AMS的代理类AMP。该过程：AMP所在进程(app process)是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>： app进程根据得到的代理类AMP,便可以直接与AMS所在进程交互。该过程：AMP所在进程(app process)是客户端，AMS所在进程(system_server)是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder Driver进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层.</p>
<p>这3大过程每一次都是一个完整的Binder IPC过程, 接下来从源码角度, 仅介绍<strong>第3过程使用服务</strong>, 即展开<code>AMP.startService是如何调用到AMS.startService的过程</code>.</p>
<p><strong>Tips:</strong> 如果你只想了解大致过程,并不打算细扣源码, 那么你可以略过通信过程源码分析, 仅看本文第一段落和最后段落也能对Binder所有理解.</p>
<h2 id="二-通信过程"><a href="#二-通信过程" class="headerlink" title="二. 通信过程"></a>二. 通信过程</h2><h3 id="2-1-AMP-startService"><a href="#2-1-AMP-startService" class="headerlink" title="2.1 AMP.startService"></a>2.1 AMP.startService</h3><p>[-&gt; ActivityManagerNative.java ::ActivityManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F;获取或创建Parcel对象【见小节2.2】</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller !&#x3D; null ? caller.asBinder() : null);</span><br><span class="line">    service.writeToParcel(data, 0);</span><br><span class="line">    &#x2F;&#x2F;写入Parcel数据 【见小节2.3】</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过Binder传递数据【见小节2.5】</span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    &#x2F;&#x2F;读取应答消息的异常情况</span><br><span class="line">    reply.readException();</span><br><span class="line">    &#x2F;&#x2F;根据reply数据来创建ComponentName对象</span><br><span class="line">    ComponentName res &#x3D; ComponentName.readFromParcel(reply);</span><br><span class="line">    &#x2F;&#x2F;【见小节2.2.3】</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能:</p>
<ul>
<li>获取或创建两个Parcel对象,data用于发送数据，reply用于接收应答数据.</li>
<li>将startService相关数据都封装到Parcel对象data, 其中descriptor = “android.app.IActivityManager”;</li>
<li>通过Binder传递数据,并将应答消息写入reply;</li>
<li>读取reply应答消息的异常情况和组件对象;</li>
</ul>
<h3 id="2-2-Parcel-obtain"><a href="#2-2-Parcel-obtain" class="headerlink" title="2.2 Parcel.obtain"></a>2.2 Parcel.obtain</h3><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static Parcel obtain() &#123;</span><br><span class="line">    final Parcel[] pool &#x3D; sOwnedPool;</span><br><span class="line">    synchronized (pool) &#123;</span><br><span class="line">        Parcel p;</span><br><span class="line">        &#x2F;&#x2F;POOL_SIZE &#x3D; 6</span><br><span class="line">        for (int i&#x3D;0; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            p &#x3D; pool[i];</span><br><span class="line">            if (p !&#x3D; null) &#123;</span><br><span class="line">                pool[i] &#x3D; null;</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当缓存池没有现成的Parcel对象，则直接创建[见流程2.2.1]</span><br><span class="line">    return new Parcel(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sOwnedPool</code>是一个大小为6，存放着parcel对象的缓存池,这样设计的目标是用于节省每次都创建Parcel对象的开销。obtain()方法的作用：</p>
<ol>
<li>先尝试从缓存池<code>sOwnedPool</code>中查询是否存在缓存Parcel对象，当存在则直接返回该对象;</li>
<li>如果没有可用的Parcel对象，则直接创建Parcel对象。</li>
</ol>
<h4 id="2-2-1-new-Parcel"><a href="#2-2-1-new-Parcel" class="headerlink" title="2.2.1 new Parcel"></a>2.2.1 new Parcel</h4><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Parcel(long nativePtr) &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化本地指针</span><br><span class="line">    init(nativePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void init(long nativePtr) &#123;</span><br><span class="line">    if (nativePtr !&#x3D; 0) &#123;</span><br><span class="line">        mNativePtr &#x3D; nativePtr;</span><br><span class="line">        mOwnsNativeParcelObject &#x3D; false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 首次创建,进入该分支[见流程2.2.2]</span><br><span class="line">        mNativePtr &#x3D; nativeCreate();</span><br><span class="line">        mOwnsNativeParcelObject &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeCreate这是native方法,经过JNI进入native层, 调用android_os_Parcel_create()方法.</p>
<h4 id="2-2-2-android-os-Parcel-create"><a href="#2-2-2-android-os-Parcel-create" class="headerlink" title="2.2.2 android_os_Parcel_create"></a>2.2.2 android_os_Parcel_create</h4><p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static jlong android_os_Parcel_create(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    Parcel* parcel &#x3D; new Parcel();</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建C++层的Parcel对象, 该对象指针强制转换为long型, 并保存到Java层的<code>mNativePtr</code>对象. 创建完Parcel对象利用Parcel对象写数据. 接下来以writeString为例.</p>
<h4 id="2-2-3-Parcel-recycle"><a href="#2-2-3-Parcel-recycle" class="headerlink" title="2.2.3 Parcel.recycle"></a>2.2.3 Parcel.recycle</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void recycle() &#123;</span><br><span class="line">    &#x2F;&#x2F;释放native parcel对象</span><br><span class="line">    freeBuffer();</span><br><span class="line">    final Parcel[] pool;</span><br><span class="line">    &#x2F;&#x2F;根据情况来选择加入相应池</span><br><span class="line">    if (mOwnsNativeParcelObject) &#123;</span><br><span class="line">        pool &#x3D; sOwnedPool;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mNativePtr &#x3D; 0;</span><br><span class="line">        pool &#x3D; sHolderPool;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (pool) &#123;</span><br><span class="line">        for (int i&#x3D;0; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            if (pool[i] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                pool[i] &#x3D; this;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将不再使用的Parcel对象放入缓存池，可回收重复利用，当缓存池已满则不再加入缓存池。这里有两个Parcel线程池,<code>mOwnsNativeParcelObject</code>变量来决定:</p>
<ul>
<li><code>mOwnsNativeParcelObject</code>=true, 即调用不带参数obtain()方法获取的对象, 回收时会放入<code>sOwnedPool</code>对象池;</li>
<li><code>mOwnsNativeParcelObject</code>=false, 即调用带nativePtr参数的obtain(long)方法获取的对象, 回收时会放入<code>sHolderPool</code>对象池;</li>
</ul>
<h3 id="2-3-writeString"><a href="#2-3-writeString" class="headerlink" title="2.3 writeString"></a>2.3 writeString</h3><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void writeString(String val) &#123;</span><br><span class="line">    &#x2F;&#x2F;[见流程2.3.1]</span><br><span class="line">    nativeWriteString(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-nativeWriteString"><a href="#2-3-1-nativeWriteString" class="headerlink" title="2.3.1 nativeWriteString"></a>2.3.1 nativeWriteString</h4><p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_Parcel_writeString(JNIEnv* env, jclass clazz, jlong nativePtr, jstring val) &#123;</span><br><span class="line">    Parcel* parcel &#x3D; reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel !&#x3D; NULL) &#123;</span><br><span class="line">        status_t err &#x3D; NO_MEMORY;</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            const jchar* str &#x3D; env-&gt;GetStringCritical(val, 0);</span><br><span class="line">            if (str) &#123;</span><br><span class="line">                &#x2F;&#x2F;[见流程2.3.2]</span><br><span class="line">                err &#x3D; parcel-&gt;writeString16(</span><br><span class="line">                    reinterpret_cast&lt;const char16_t*&gt;(str),</span><br><span class="line">                    env-&gt;GetStringLength(val));</span><br><span class="line">                env-&gt;ReleaseStringCritical(val, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            err &#x3D; parcel-&gt;writeString16(NULL, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-writeString16"><a href="#2-3-2-writeString16" class="headerlink" title="2.3.2 writeString16"></a>2.3.2 writeString16</h4><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeString16(const char16_t* str, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    if (str &#x3D;&#x3D; NULL) return writeInt32(-1);</span><br><span class="line"></span><br><span class="line">    status_t err &#x3D; writeInt32(len);</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        len *&#x3D; sizeof(char16_t);</span><br><span class="line">        uint8_t* data &#x3D; (uint8_t*)writeInplace(len+sizeof(char16_t));</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            &#x2F;&#x2F;数据拷贝到data所指向的位置</span><br><span class="line">            memcpy(data, str, len);</span><br><span class="line">            *reinterpret_cast&lt;char16_t*&gt;(data+len) &#x3D; 0;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        err &#x3D; mError;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 除了writeString(),在<code>Parcel.java</code>中大量的native方法, 都是调用<code>android_os_Parcel.cpp</code>相对应的方法, 该方法再调用<code>Parcel.cpp</code>中对应的方法.<br>调用流程: Parcel.java –&gt; android_os_Parcel.cpp –&gt; Parcel.cpp.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/Parcel.java</span><br><span class="line">frameworks/base/core/jni/android_os_Parcel.cpp</span><br><span class="line">frameworks/<span class="keyword">native</span>/libs/binder/Parcel.cpp</span><br></pre></td></tr></table></figure>

<p>简单说,就是</p>
<h3 id="2-4-mRemote究竟为何物"><a href="#2-4-mRemote究竟为何物" class="headerlink" title="2.4 mRemote究竟为何物"></a>2.4 mRemote究竟为何物</h3><p>mRemote的出生,要出先说说ActivityManagerProxy对象(简称AMP)创建说起, AMP是通过ActivityManagerNative.getDefault()来获取的.</p>
<h4 id="2-4-1-AMN-getDefault"><a href="#2-4-1-AMN-getDefault" class="headerlink" title="2.4.1 AMN.getDefault"></a>2.4.1 AMN.getDefault</h4><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [见流程2.4.2]</span></span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gDefault的数据类型为<code>Singleton&lt;IActivityManager&gt;</code>, 这是一个单例模式, 接下来看看Singleto.get()的过程</p>
<h4 id="2-4-2-gDefault-get"><a href="#2-4-2-gDefault-get" class="headerlink" title="2.4.2 gDefault.get"></a>2.4.2 gDefault.get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Singleton&lt;IActivityManager&gt; &#123;</span><br><span class="line">    public final IActivityManager get() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;首次调用create()来获取AMP对象[见流程2.4.3]</span><br><span class="line">                mInstance &#x3D; create();</span><br><span class="line">            &#125;</span><br><span class="line">            return mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次调用时需要创建,创建完之后保持到mInstance对象,之后可直接使用.</p>
<h4 id="2-4-3-gDefault-create"><a href="#2-4-3-gDefault-create" class="headerlink" title="2.4.3 gDefault.create"></a>2.4.3 gDefault.create</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取名为&quot;activity&quot;的服务</span><br><span class="line">        IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建AMP对象[见流程2.4.4]</span><br><span class="line">        IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文章<a href="http://gityuan.com/2015/11/21/binder-framework/#section-4" target="_blank" rel="noopener">Binder系列7—framework层分析</a>，可知ServiceManager.getService(“activity”)返回的是指向目标服务AMS的代理对象<code>BinderProxy</code>对象，由该代理对象可以找到目标服务AMS所在进程</p>
<h4 id="2-4-4-AMN-asInterface"><a href="#2-4-4-AMN-asInterface" class="headerlink" title="2.4.4 AMN.asInterface"></a>2.4.4 AMN.asInterface</h4><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager &#123;</span><br><span class="line">    static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;此处obj &#x3D; BinderProxy, descriptor &#x3D; &quot;android.app.IActivityManager&quot;; [见流程2.4.5]</span><br><span class="line">        IActivityManager in &#x3D; (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123; &#x2F;&#x2F;此处为null</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;[见流程2.4.6]</span><br><span class="line">        return new ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时obj为BinderProxy对象, 记录着远程进程system_server中AMS服务的binder线程的handle.</p>
<h4 id="2-4-5-queryLocalInterface"><a href="#2-4-5-queryLocalInterface" class="headerlink" title="2.4.5 queryLocalInterface"></a>2.4.5 queryLocalInterface</h4><p>[Binder.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    &#x2F;&#x2F;对于Binder对象的调用,则返回值不为空</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        &#x2F;&#x2F;mDescriptor的初始化在attachInterface()过程中赋值</span><br><span class="line">        if (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">            return mOwner;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;由上一小节[2.4.4]调用的流程便是此处,返回Null</span><br><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    &#x2F;&#x2F;BinderProxy对象的调用, 则返回值为空</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Binder IPC的过程中, 同一个进程的调用则会是asInterface()方法返回的便是本地的Binder对象;对于不同进程的调用则会是远程代理对象BinderProxy.</p>
<h4 id="2-4-6-创建AMP"><a href="#2-4-6-创建AMP" class="headerlink" title="2.4.6 创建AMP"></a>2.4.6 创建AMP</h4><p>[-&gt; ActivityManagerNative.java :: AMP]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager &#123;</span><br><span class="line">    public ActivityManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知<code>mRemote</code>便是指向AMS服务的<code>BinderProxy</code>对象。</p>
<h3 id="2-5-mRemote-transact"><a href="#2-5-mRemote-transact" class="headerlink" title="2.5 mRemote.transact"></a>2.5 mRemote.transact</h3><p>[-&gt; Binder.java ::BinderProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        &#x2F;&#x2F;用于检测Parcel大小是否大于800k</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">        &#x2F;&#x2F;【见2.6】</span><br><span class="line">        return transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote.transact()方法中的code=START_SERVICE_TRANSACTION, data保存了<code>descriptor</code>，<code>caller</code>, <code>intent</code>, <code>resolvedType</code>, <code>callingPackage</code>, <code>userId</code>这6项信息。</p>
<p>transactNative是native方法，经过jni调用android_os_BinderProxy_transact方法。</p>
<h3 id="2-6-android-os-BinderProxy-transact"><a href="#2-6-android-os-BinderProxy-transact" class="headerlink" title="2.6 android_os_BinderProxy_transact"></a>2.6 android_os_BinderProxy_transact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">    jint code, jobject dataObj, jobject replyObj, jint flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;将java Parcel转为c++ Parcel</span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;gBinderProxyOffsets.mObject中保存的是new BpBinder(handle)对象</span><br><span class="line">    IBinder* target &#x3D; (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此处便是BpBinder::transact()【见小节2.7】</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;最后根据transact执行具体情况，抛出相应的Exception</span><br><span class="line">    signalExceptionForError(env, obj, err, true , data-&gt;dataSize());</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gBinderProxyOffsets.mObject中保存的是<code>BpBinder</code>对象, 这是开机时Zygote调用<code>AndroidRuntime::startReg</code>方法来完成jni方法的注册.</p>
<p>其中register_android_os_Binder()过程就有一个初始并注册BinderProxy的操作,完成gBinderProxyOffsets的赋值过程. 接下来就进入该方法.</p>
<h3 id="2-7-BpBinder-transact"><a href="#2-7-BpBinder-transact" class="headerlink" title="2.7 BpBinder.transact"></a>2.7 BpBinder.transact</h3><p>[-&gt; BpBinder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        &#x2F;&#x2F; 【见小节2.8】</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState::self()采用单例模式，保证每个线程只有一个实例对象。</p>
<h3 id="2-8-IPC-transact"><a href="#2-8-IPC-transact" class="headerlink" title="2.8 IPC.transact"></a>2.8 IPC.transact</h3><p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err &#x3D; data.errorCheck(); &#x2F;&#x2F;数据错误检查</span><br><span class="line">    flags |&#x3D; TF_ACCEPT_FDS;</span><br><span class="line">    ....</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">         &#x2F;&#x2F; 传输数据 【见小节2.9】</span><br><span class="line">        err &#x3D; writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError &#x3D; err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果</span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            &#x2F;&#x2F;reply对象不为空 【见小节2.10】</span><br><span class="line">            err &#x3D; waitForResponse(reply);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err &#x3D; waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err &#x3D; waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transact主要过程:</p>
<ul>
<li>先执行writeTransactionData()已向Parcel数据类型的<code>mOut</code>写入数据，此时<code>mIn</code>还没有数据；</li>
<li>然后执行waitForResponse()方法，循环执行，直到收到应答消息. 调用talkWithDriver()跟驱动交互，收到应答消息，便会写入<code>mIn</code>, 则根据收到的不同响应吗，执行相应的操作。</li>
</ul>
<p>此处调用waitForResponse根据是否有设置<code>TF_ONE_WAY</code>的标记:</p>
<ul>
<li>当已设置oneway时, 则调用waitForResponse(NULL, NULL);</li>
<li>当未设置oneway时, 则调用waitForResponse(reply) 或 waitForResponse(&amp;fakeReply)</li>
</ul>
<h3 id="2-9-IPC-writeTransactionData"><a href="#2-9-IPC-writeTransactionData" class="headerlink" title="2.9 IPC.writeTransactionData"></a>2.9 IPC.writeTransactionData</h3><p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</span><br><span class="line">    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr &#x3D; 0;</span><br><span class="line">    tr.target.handle &#x3D; handle; &#x2F;&#x2F; handle指向AMS</span><br><span class="line">    tr.code &#x3D; code;            &#x2F;&#x2F; START_SERVICE_TRANSACTION</span><br><span class="line">    tr.flags &#x3D; binderFlags;    &#x2F;&#x2F; 0</span><br><span class="line">    tr.cookie &#x3D; 0;</span><br><span class="line">    tr.sender_pid &#x3D; 0;</span><br><span class="line">    tr.sender_euid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    const status_t err &#x3D; data.errorCheck();</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        &#x2F;&#x2F; data为startService相关信息</span><br><span class="line">        tr.data_size &#x3D; data.ipcDataSize();   &#x2F;&#x2F; mDataSize</span><br><span class="line">        tr.data.ptr.buffer &#x3D; data.ipcData(); &#x2F;&#x2F; mData指针</span><br><span class="line">        tr.offsets_size &#x3D; data.ipcObjectsCount()*sizeof(binder_size_t); &#x2F;&#x2F;mObjectsSize</span><br><span class="line">        tr.data.ptr.offsets &#x3D; data.ipcObjects(); &#x2F;&#x2F;mObjects指针</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mOut.writeInt32(cmd);         &#x2F;&#x2F;cmd &#x3D; BC_TRANSACTION</span><br><span class="line">    mOut.write(&amp;tr, sizeof(tr));  &#x2F;&#x2F;写入binder_transaction_data数据</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将数据写入mOut</p>
<h3 id="2-10-IPC-waitForResponse"><a href="#2-10-IPC-waitForResponse" class="headerlink" title="2.10 IPC.waitForResponse"></a>2.10 IPC.waitForResponse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break; &#x2F;&#x2F; 【见小节2.11】</span><br><span class="line">        err &#x3D; mIn.errorCheck();</span><br><span class="line">        if (err &lt; NO_ERROR) break; &#x2F;&#x2F;当存在error则退出循环</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;每当跟Driver交互一次，若mIn收到数据则往下执行一次BR命令</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd &#x3D; mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            &#x2F;&#x2F;只有当不需要reply, 也就是oneway时 才会跳出循环,否则还需要等待.</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish; break;</span><br><span class="line"></span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            err &#x3D; DEAD_OBJECT;         goto finish;</span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            err &#x3D; FAILED_TRANSACTION;  goto finish;</span><br><span class="line">        case BR_REPLY: ...             goto finish;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; executeCommand(cmd);  &#x2F;&#x2F;【见小节2.12】</span><br><span class="line">            if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err); &#x2F;&#x2F;将发送的错误代码返回给最初的调用者</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中, 收到以下任一BR_命令，处理后便会退出waitForResponse()的状态:</p>
<ul>
<li>BR_TRANSACTION_COMPLETE: binder驱动收到BC_TRANSACTION事件后的应答消息; 对于oneway transaction,当收到该消息,则完成了本次Binder通信;</li>
<li>BR_DEAD_REPLY: 回复失败，往往是线程或节点为空. 则结束本次通信Binder;</li>
<li>BR_FAILED_REPLY:回复失败，往往是transaction出错导致. 则结束本次通信Binder;</li>
<li>BR_REPLY: Binder驱动向Client端发送回应消息; 对于非oneway transaction时,当收到该消息,则完整地完成本次Binder通信;</li>
</ul>
<p>除了以上命令，其他命令的处理流程【见小节2.12】</p>
<h3 id="2-11-IPC-talkWithDriver"><a href="#2-11-IPC-talkWithDriver" class="headerlink" title="2.11 IPC.talkWithDriver"></a>2.11 IPC.talkWithDriver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;mOut有数据，mIn还没有数据。doReceive默认值为true</span><br><span class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    const bool needRead &#x3D; mIn.dataPosition() &gt;&#x3D; mIn.dataSize();</span><br><span class="line">    const size_t outAvail &#x3D; (!doReceive || needRead) ? mOut.dataSize() : 0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; outAvail;</span><br><span class="line">    bwr.write_buffer &#x3D; (uintptr_t)mOut.data();</span><br><span class="line"></span><br><span class="line">    if (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        &#x2F;&#x2F;接收数据缓冲区信息的填充。当收到驱动的数据，则写入mIn</span><br><span class="line">        bwr.read_size &#x3D; mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t)mIn.data();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bwr.read_size &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当同时没有输入和输出数据则直接返回</span><br><span class="line">    if ((bwr.write_size &#x3D;&#x3D; 0) &amp;&amp; (bwr.read_size &#x3D;&#x3D; 0)) return NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.read_consumed &#x3D; 0;</span><br><span class="line">    status_t err;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;ioctl执行binder读写操作，经过syscall，进入Binder驱动。调用Binder_ioctl【小节3.1】</span><br><span class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;&#x3D; 0)</span><br><span class="line">            err &#x3D; NO_ERROR;</span><br><span class="line">        else</span><br><span class="line">            err &#x3D; -errno;</span><br><span class="line">        ...</span><br><span class="line">    &#125; while (err &#x3D;&#x3D; -EINTR);</span><br><span class="line"></span><br><span class="line">    if (err &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (bwr.write_consumed &gt; 0) &#123;</span><br><span class="line">            if (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(0, bwr.write_consumed);</span><br><span class="line">            else</span><br><span class="line">                mOut.setDataSize(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bwr.read_consumed &gt; 0) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://gityuan.com/2015/11/01/binder-driver/#binderwriteread" target="_blank" rel="noopener">binder_write_read结构体</a>用来与Binder设备交换数据的结构, 通过ioctl与mDriverFD通信，是真正与Binder驱动进行数据读写交互的过程。</p>
<h3 id="2-12-IPC-executeCommand"><a href="#2-12-IPC-executeCommand" class="headerlink" title="2.12 IPC.executeCommand"></a>2.12 IPC.executeCommand</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">    case BR_ERROR: ...</span><br><span class="line">    case BR_OK: ...</span><br><span class="line">    case BR_ACQUIRE: ...</span><br><span class="line">    case BR_RELEASE: ...</span><br><span class="line">    case BR_INCREFS: ...</span><br><span class="line">    case BR_TRANSACTION: ... &#x2F;&#x2F;Binder驱动向Server端发送消息</span><br><span class="line">    case BR_DEAD_BINDER: ...</span><br><span class="line">    case BR_CLEAR_DEATH_NOTIFICATION_DONE: ...</span><br><span class="line">    case BR_NOOP: ...</span><br><span class="line">    case BR_SPAWN_LOOPER: ... &#x2F;&#x2F;创建新binder线程</span><br><span class="line">    default: ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到【小节2.11】，可知ioctl()方法经过syscall最终调用到Binder_ioctl()方法.</p>
<h2 id="三、Binder-driver"><a href="#三、Binder-driver" class="headerlink" title="三、Binder driver"></a>三、Binder driver</h2><h4 id="3-1-binder-ioctl"><a href="#3-1-binder-ioctl" class="headerlink" title="3.1 binder_ioctl"></a>3.1 binder_ioctl</h4><p>[-&gt; Binder.c]</p>
<p>由【小节2.11】传递过出来的参数 cmd=<code>BINDER_WRITE_READ</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line">    struct binder_thread *thread;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当binder_stop_on_user_error&gt;&#x3D;2时，则该线程加入等待队列并进入休眠状态. 该值默认为0</span><br><span class="line">    ret &#x3D; wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">    ...</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    &#x2F;&#x2F;查找或创建binder_thread结构体</span><br><span class="line">    thread &#x3D; binder_get_thread(proc);</span><br><span class="line">    ...</span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">        case BINDER_WRITE_READ:</span><br><span class="line">            &#x2F;&#x2F;【见小节3.2】</span><br><span class="line">            ret &#x3D; binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    if (thread)</span><br><span class="line">        thread-&gt;looper &amp;&#x3D; ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先,根据传递过来的文件句柄指针获取相应的binder_proc结构体, 再从中查找binder_thread,如果当前线程已经加入到proc的线程队列则直接返回， 如果不存在则创建binder_thread，并将当前线程添加到当前的proc.</p>
<ul>
<li>当返回值为-ENOMEM，则意味着内存不足，往往会出现创建binder_thread对象失败;</li>
<li>当返回值为-EINVAL，则意味着CMD命令参数无效；</li>
</ul>
<h4 id="3-2-binder-ioctl-write-read"><a href="#3-2-binder-ioctl-write-read" class="headerlink" title="3.2 binder_ioctl_write_read"></a>3.2 binder_ioctl_write_read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static int binder_ioctl_write_read(struct file *filp,</span><br><span class="line">                unsigned int cmd, unsigned long arg,</span><br><span class="line">                struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line">    unsigned int size &#x3D; _IOC_SIZE(cmd);</span><br><span class="line">    void __user *ubuf &#x3D; (void __user *)arg;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    if (size !&#x3D; sizeof(struct binder_write_read)) &#123;</span><br><span class="line">        ret &#x3D; -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将用户空间bwr结构体拷贝到内核空间</span><br><span class="line">    if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123;</span><br><span class="line">        ret &#x3D; -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;将数据放入目标进程【见小节3.3】</span><br><span class="line">        ret &#x3D; binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer,</span><br><span class="line">                      bwr.write_size,</span><br><span class="line">                      &amp;bwr.write_consumed);</span><br><span class="line">        &#x2F;&#x2F;当执行失败，则直接将内核bwr结构体写回用户空间，并跳出该方法</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            bwr.read_consumed &#x3D; 0;</span><br><span class="line">            if (copy_to_user_preempt_disabled(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">                ret &#x3D; -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;读取自己队列的数据 【见小节3.5】</span><br><span class="line">        ret &#x3D; binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">             bwr.read_size,</span><br><span class="line">             &amp;bwr.read_consumed,</span><br><span class="line">             filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        &#x2F;&#x2F;当进程的todo队列有数据,则唤醒在该队列等待的进程</span><br><span class="line">        if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">            wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">        &#x2F;&#x2F;当执行失败，则直接将内核bwr结构体写回用户空间，并跳出该方法</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            if (copy_to_user_preempt_disabled(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">                ret &#x3D; -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">        ret &#x3D; -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时arg是一个<code>binder_write_read</code>结构体，<code>mOut</code>数据保存在write_buffer，所以write_size&gt;0，但此时read_size=0。首先,将用户空间bwr结构体拷贝到内核空间,然后执行binder_thread_write()操作.</p>
<h4 id="3-3-binder-thread-write"><a href="#3-3-binder-thread-write" class="headerlink" title="3.3 binder_thread_write"></a>3.3 binder_thread_write</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">            struct binder_thread *thread,</span><br><span class="line">            binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">            binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    void __user *buffer &#x3D; (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">    void __user *ptr &#x3D; buffer + *consumed;</span><br><span class="line">    void __user *end &#x3D; buffer + size;</span><br><span class="line">    while (ptr &lt; end &amp;&amp; thread-&gt;return_error &#x3D;&#x3D; BR_OK) &#123;</span><br><span class="line">        &#x2F;&#x2F;拷贝用户空间的cmd命令，此时为BC_TRANSACTION</span><br><span class="line">        if (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BC_TRANSACTION:</span><br><span class="line">        case BC_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data tr;</span><br><span class="line">            &#x2F;&#x2F;拷贝用户空间的binder_transaction_data</span><br><span class="line">            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))   return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(tr);</span><br><span class="line">            &#x2F;&#x2F; 见小节3.4】</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd &#x3D;&#x3D; BC_REPLY);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    *consumed &#x3D; ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断从binder_buffer所指向的地址获取cmd, 当只有<code>BC_TRANSACTION</code>或者<code>BC_REPLY</code>时, 则调用binder_transaction()来处理事务.</p>
<h4 id="3-4-binder-transaction"><a href="#3-4-binder-transaction" class="headerlink" title="3.4 binder_transaction"></a>3.4 binder_transaction</h4><p>发送的是BC_TRANSACTION时，此时reply=0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">               struct binder_thread *thread,</span><br><span class="line">               struct binder_transaction_data *tr, int reply)&#123;</span><br><span class="line">     struct binder_transaction *t;</span><br><span class="line">     struct binder_work *tcomplete;</span><br><span class="line">     binder_size_t *offp, *off_end;</span><br><span class="line">     binder_size_t off_min;</span><br><span class="line">     struct binder_proc *target_proc;</span><br><span class="line">     struct binder_thread *target_thread &#x3D; NULL;</span><br><span class="line">     struct binder_node *target_node &#x3D; NULL;</span><br><span class="line">     struct list_head *target_list;</span><br><span class="line">     wait_queue_head_t *target_wait;</span><br><span class="line">     struct binder_transaction *in_reply_to &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            &#x2F;&#x2F; 由handle 找到相应 binder_ref, 由binder_ref 找到相应 binder_node</span><br><span class="line">            ref &#x3D; binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            target_node &#x3D; ref-&gt;node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target_node &#x3D; binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 由binder_node 找到相应 binder_proc</span><br><span class="line">        target_proc &#x3D; target_node-&gt;proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread &#x3D; target_thread-&gt;pid;</span><br><span class="line">        target_list &#x3D; &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait &#x3D; &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;首次执行target_thread为空</span><br><span class="line">        target_list &#x3D; &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait &#x3D; &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t &#x3D; kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">    tcomplete &#x3D; kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;非oneway的通信方式，把当前thread保存到transaction的from字段</span><br><span class="line">    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from &#x3D; thread;</span><br><span class="line">    else</span><br><span class="line">        t-&gt;from &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    t-&gt;sender_euid &#x3D; task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc &#x3D; target_proc; &#x2F;&#x2F;此次通信目标进程为system_server</span><br><span class="line">    t-&gt;to_thread &#x3D; target_thread;</span><br><span class="line">    t-&gt;code &#x3D; tr-&gt;code;  &#x2F;&#x2F;此次通信code &#x3D; START_SERVICE_TRANSACTION</span><br><span class="line">    t-&gt;flags &#x3D; tr-&gt;flags;  &#x2F;&#x2F; 此次通信flags &#x3D; 0</span><br><span class="line">    t-&gt;priority &#x3D; task_nice(current);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从目标进程target_proc中分配内存空间【3.4.1】</span><br><span class="line">    t-&gt;buffer &#x3D; binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line"></span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free &#x3D; 0;</span><br><span class="line">    t-&gt;buffer-&gt;transaction &#x3D; t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node &#x3D; target_node;</span><br><span class="line"></span><br><span class="line">    if (target_node)</span><br><span class="line">        binder_inc_node(target_node, 1, 0, NULL); &#x2F;&#x2F;引用计数加1</span><br><span class="line">    &#x2F;&#x2F;binder对象的偏移量</span><br><span class="line">    offp &#x3D; (binder_size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到目标进程的binder_buffer</span><br><span class="line">    copy_from_user(t-&gt;buffer-&gt;data,</span><br><span class="line">        (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp,</span><br><span class="line">        (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    off_end &#x3D; (void *)offp + tr-&gt;offsets_size;</span><br><span class="line"></span><br><span class="line">    for (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        struct flat_binder_object *fp;</span><br><span class="line">        fp &#x3D; (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        off_min &#x3D; *offp + sizeof(struct flat_binder_object);</span><br><span class="line">        switch (fp-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case BINDER_TYPE_HANDLE:</span><br><span class="line">        case BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            &#x2F;&#x2F;处理引用计数情况</span><br><span class="line">            struct binder_ref *ref &#x3D; binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">            if (ref-&gt;node-&gt;proc &#x3D;&#x3D; target_proc) &#123;</span><br><span class="line">                if (fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type &#x3D; BINDER_TYPE_BINDER;</span><br><span class="line">                else</span><br><span class="line">                    fp-&gt;type &#x3D; BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder &#x3D; ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie &#x3D; ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_BINDER, 0, NULL);</span><br><span class="line">            &#125; else &#123;    </span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                new_ref &#x3D; binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                fp-&gt;handle &#x3D; new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            goto err_bad_object_type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        &#x2F;&#x2F;BC_REPLY的过程</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        &#x2F;&#x2F;BC_TRANSACTION 且 非oneway,则设置事务栈信息</span><br><span class="line">        t-&gt;need_reply &#x3D; 1;</span><br><span class="line">        t-&gt;from_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;BC_TRANSACTION 且 oneway,则加入异步todo队列</span><br><span class="line">        if (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">            target_list &#x3D; &amp;target_node-&gt;async_todo;</span><br><span class="line">            target_wait &#x3D; NULL;</span><br><span class="line">        &#125; else</span><br><span class="line">            target_node-&gt;has_async_transaction &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION添加到目标队列,即target_proc-&gt;todo</span><br><span class="line">    t-&gt;work.type &#x3D; BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程队列，即thread-&gt;todo</span><br><span class="line">    tcomplete-&gt;type &#x3D; BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;唤醒等待队列，本次通信的目标队列为target_proc-&gt;wait</span><br><span class="line">    if (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能:</p>
<ol>
<li><p>查询目标进程的过程： handle -&gt; binder_ref -&gt; binder_node -&gt; binder_proc</p>
</li>
<li><p>将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BINDER_WORK_TRANSACTION</span><br></pre></td></tr></table></figure>

<p>添加到目标队列target_list:</p>
<ul>
<li>call事务， 则目标队列target_list=<code>target_proc-&gt;todo</code>;</li>
<li>reply事务，则目标队列target_list=<code>target_thread-&gt;todo</code>;</li>
<li>async事务，则目标队列target_list=<code>target_node-&gt;async_todo</code>.</li>
</ul>
</li>
<li><p>数据拷贝</p>
<ul>
<li>将用户空间binder_transaction_data中ptr.buffer和ptr.offsets拷贝到目标进程的binder_buffer-&gt;data；</li>
<li>这就是只拷贝一次的真理所在；</li>
</ul>
</li>
<li><p>设置事务栈信息</p>
<ul>
<li>BC_TRANSACTION且非oneway, 则将当前事务添加到thread-&gt;transaction_stack；</li>
</ul>
</li>
<li><p>事务分发过程：</p>
<ul>
<li>将<code>BINDER_WORK_TRANSACTION</code>添加到目标队列(此时为target_proc-&gt;todo队列);</li>
<li>将<code>BINDER_WORK_TRANSACTION_COMPLETE</code>添加到当前线程thread-&gt;todo队列;</li>
</ul>
</li>
<li><p>唤醒目标进程target_proc开始执行事务。</p>
</li>
</ol>
<p>该方法中proc/thread是指当前发起方的进程信息，而binder_proc是指目标接收端进程。 此时当前线程thread的todo队列已经有事务, 接下来便会进入binder_thread_read来处理相关的事务.</p>
<h4 id="3-4-1-binder-alloc-buf"><a href="#3-4-1-binder-alloc-buf" class="headerlink" title="3.4.1 binder_alloc_buf"></a>3.4.1 binder_alloc_buf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,</span><br><span class="line">                          size_t data_size, size_t offsets_size, int is_async)</span><br><span class="line">&#123;</span><br><span class="line">    struct rb_node *n &#x3D; proc-&gt;free_buffers.rb_node;</span><br><span class="line">    struct binder_buffer *buffer;</span><br><span class="line">    size_t buffer_size;</span><br><span class="line">    struct rb_node *best_fit &#x3D; NULL;</span><br><span class="line">    void *has_page_addr;</span><br><span class="line">    void *end_page_addr;</span><br><span class="line">    size_t size;</span><br><span class="line">    ..</span><br><span class="line">    size &#x3D; ALIGN(data_size, sizeof(void *)) + ALIGN(offsets_size, sizeof(void *));</span><br><span class="line">    if (is_async &amp;&amp; proc-&gt;free_async_space &lt; size + sizeof(struct binder_buffer)) &#123;</span><br><span class="line">        return NULL; &#x2F;&#x2F; 剩余可用的异步空间，小于所需的大小</span><br><span class="line">    &#125;</span><br><span class="line">    while (n) &#123;  &#x2F;&#x2F;从binder_buffer的红黑树中查找大小相等的buffer块</span><br><span class="line">        buffer &#x3D; rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size &#x3D; binder_buffer_size(proc, buffer);</span><br><span class="line">        if (size &lt; buffer_size) &#123;</span><br><span class="line">            best_fit &#x3D; n;</span><br><span class="line">            n &#x3D; n-&gt;rb_left;</span><br><span class="line">        &#125; else if (size &gt; buffer_size)</span><br><span class="line">            n &#x3D; n-&gt;rb_right;</span><br><span class="line">        else &#123;</span><br><span class="line">            best_fit &#x3D; n;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    if (n &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        buffer &#x3D; rb_entry(best_fit, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size &#x3D; binder_buffer_size(proc, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has_page_addr &#x3D;(void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">    if (n &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        if (size + sizeof(struct binder_buffer) + 4 &gt;&#x3D; buffer_size)</span><br><span class="line">            buffer_size &#x3D; size;</span><br><span class="line">        else</span><br><span class="line">            buffer_size &#x3D; size + sizeof(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;末端地址</span><br><span class="line">    end_page_addr &#x3D;     (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + buffer_size);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;分配物理页</span><br><span class="line">    if (binder_update_page_range(proc, 1,</span><br><span class="line">        (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr, NULL))</span><br><span class="line">        return NULL;</span><br><span class="line">    rb_erase(best_fit, &amp;proc-&gt;free_buffers);</span><br><span class="line">    buffer-&gt;free &#x3D; 0;</span><br><span class="line">    binder_insert_allocated_buffer(proc, buffer);</span><br><span class="line">    if (buffer_size !&#x3D; size) &#123;</span><br><span class="line">        struct binder_buffer *new_buffer &#x3D; (void *)buffer-&gt;data + size;</span><br><span class="line">        list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">        new_buffer-&gt;free &#x3D; 1;</span><br><span class="line">        binder_insert_free_buffer(proc, new_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;data_size &#x3D; data_size;</span><br><span class="line">    buffer-&gt;offsets_size &#x3D; offsets_size;</span><br><span class="line">    buffer-&gt;async_transaction &#x3D; is_async;</span><br><span class="line">    if (is_async) &#123; &#x2F;&#x2F;调整异步可用内存空间大小</span><br><span class="line">        proc-&gt;free_async_space -&#x3D; size + sizeof(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-binder-thread-read"><a href="#3-5-binder-thread-read" class="headerlink" title="3.5 binder_thread_read"></a>3.5 binder_thread_read</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">    &#x2F;&#x2F;当已使用字节数为0时，将BR_NOOP响应码放入指针ptr</span><br><span class="line">    if (*consumed &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            if (put_user(BR_NOOP, (uint32_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    &#x2F;&#x2F;binder_transaction()已设置transaction_stack不为空，则wait_for_proc_work为false.</span><br><span class="line">    wait_for_proc_work &#x3D; thread-&gt;transaction_stack &#x3D;&#x3D; NULL &amp;&amp;</span><br><span class="line">            list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    if (wait_for_proc_work)</span><br><span class="line">      proc-&gt;ready_threads++; &#x2F;&#x2F;进程中空闲binder线程加1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;只有当前线程todo队列为空，并且transaction_stack也为空，才会开始处于当前进程的事务</span><br><span class="line">    if (wait_for_proc_work) &#123;</span><br><span class="line">        if (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else</span><br><span class="line">            &#x2F;&#x2F;当进程todo队列没有数据,则进入休眠等待状态</span><br><span class="line">            ret &#x3D; wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else</span><br><span class="line">            &#x2F;&#x2F;当线程todo队列有数据则执行往下执行；当线程todo队列没有数据，则进入休眠等待状态</span><br><span class="line">            ret &#x3D; wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (wait_for_proc_work)</span><br><span class="line">      proc-&gt;ready_threads--; &#x2F;&#x2F;退出等待状态, 则进程中空闲binder线程减1</span><br><span class="line">    thread-&gt;looper &amp;&#x3D; ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        uint32_t cmd;</span><br><span class="line">        struct binder_transaction_data tr;</span><br><span class="line">        struct binder_work *w;</span><br><span class="line">        struct binder_transaction *t &#x3D; NULL;</span><br><span class="line">        &#x2F;&#x2F;先从线程todo队列获取事务数据</span><br><span class="line">        if (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">            w &#x3D; list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#x2F;&#x2F; 线程todo队列没有数据, 则从进程todo对获取事务数据</span><br><span class="line">        &#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">            w &#x3D; list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;没有数据,则返回retry</span><br><span class="line">            if (ptr - buffer &#x3D;&#x3D; 4 &amp;&amp;</span><br><span class="line">                !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))</span><br><span class="line">                goto retry;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (w-&gt;type) &#123;</span><br><span class="line">            case BINDER_WORK_TRANSACTION:</span><br><span class="line">                &#x2F;&#x2F;获取transaction数据</span><br><span class="line">                t &#x3D; container_of(w, struct binder_transaction, work);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case BINDER_WORK_TRANSACTION_COMPLETE:</span><br><span class="line">                cmd &#x3D; BR_TRANSACTION_COMPLETE;</span><br><span class="line">                &#x2F;&#x2F;将BR_TRANSACTION_COMPLETE写入*ptr，并跳出循环。</span><br><span class="line">                put_user(cmd, (uint32_t __user *)ptr)；</span><br><span class="line">                list_del(&amp;w-&gt;entry);</span><br><span class="line">                kfree(w);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case BINDER_WORK_NODE: ...    break;</span><br><span class="line">            case BINDER_WORK_DEAD_BINDER:</span><br><span class="line">            case BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">            case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: ...   break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;只有BINDER_WORK_TRANSACTION命令才能继续往下执行</span><br><span class="line">        if (!t)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        if (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取目标node</span><br><span class="line">            struct binder_node *target_node &#x3D; t-&gt;buffer-&gt;target_node;</span><br><span class="line">            tr.target.ptr &#x3D; target_node-&gt;ptr;</span><br><span class="line">            tr.cookie &#x3D;  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority &#x3D; task_nice(current);</span><br><span class="line">            ...</span><br><span class="line">            cmd &#x3D; BR_TRANSACTION;  &#x2F;&#x2F;设置命令为BR_TRANSACTION</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tr.target.ptr &#x3D; NULL;</span><br><span class="line">            tr.cookie &#x3D; NULL;</span><br><span class="line">            cmd &#x3D; BR_REPLY; &#x2F;&#x2F;设置命令为BR_REPLY</span><br><span class="line">        &#125;</span><br><span class="line">        tr.code &#x3D; t-&gt;code;</span><br><span class="line">        tr.flags &#x3D; t-&gt;flags;</span><br><span class="line">        tr.sender_euid &#x3D; t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        if (t-&gt;from) &#123;</span><br><span class="line">            struct task_struct *sender &#x3D; t-&gt;from-&gt;proc-&gt;tsk;</span><br><span class="line">            &#x2F;&#x2F;当非oneway的情况下,将调用者进程的pid保存到sender_pid</span><br><span class="line">            tr.sender_pid &#x3D; task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;当oneway的的情况下,则该值为0</span><br><span class="line">            tr.sender_pid &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr.data_size &#x3D; t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size &#x3D; t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        tr.data.ptr.buffer &#x3D; (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets &#x3D; tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将cmd和数据写回用户空间</span><br><span class="line">        if (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(tr);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free &#x3D; 1;</span><br><span class="line">        if (cmd &#x3D;&#x3D; BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread &#x3D; thread;</span><br><span class="line">            thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            kfree(t); &#x2F;&#x2F;通信完成,则运行释放</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    *consumed &#x3D; ptr - buffer;</span><br><span class="line">    &#x2F;&#x2F;当满足请求线程加已准备线程数等于0，已启动线程数小于最大线程数(15)，</span><br><span class="line">    &#x2F;&#x2F;且looper状态为已注册或已进入时创建新的线程。</span><br><span class="line">    if (proc-&gt;requested_threads + proc-&gt;ready_threads &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        &#x2F;&#x2F; 生成BR_SPAWN_LOOPER命令，用于创建新的线程</span><br><span class="line">        put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法功能说明:</p>
<p>此处wait_for_proc_work是指当前线程todo队列为空，并且transaction_stack也为空,该值为true.</p>
<ol>
<li>当wait_for_proc_work = false, 则进入线程的等待队列thread-&gt;wait, 直到thread-&gt;todo队列有事务才往下执行;<ul>
<li>获取并处理thread-&gt;todo队列中的事务;将相应的cmd和数据写回用户空间.</li>
</ul>
</li>
<li>当wait_for_proc_work = true, 则进入线程的等待队列proc-&gt;wait, 直到proc-&gt;todo队列有事务才往下执行;<ul>
<li>获取并处理proc-&gt;todo队列中的事务;将相应的cmd和数据写回用户空间.</li>
</ul>
</li>
</ol>
<p>到这里,可能有人好奇,对于[小节3.4]介绍了target_list有3种, 这里只会处理前2种:thread-&gt;todo, proc-&gt;todo.那么对于 target_node-&gt;async_todo的处理过程时间呢? [见小节5.4]</p>
<h4 id="3-6-下一步何去何从"><a href="#3-6-下一步何去何从" class="headerlink" title="3.6 下一步何去何从"></a>3.6 下一步何去何从</h4><ol>
<li>执行完binder_thread_write方法后, 通过binder_transaction()首先写入<code>BINDER_WORK_TRANSACTION_COMPLETE</code>写入当前线程.</li>
<li>这时bwr.read_size &gt; 0, 回到binder_ioctl_write_read方法, 便开始执行binder_thread_read();</li>
<li>在binder_thread_read()方法, 将获取cmd=BR_TRANSACTION_COMPLETE, 再将cmd和数据写回用户空间;</li>
<li>一次Binder_ioctl完成,接着回调用户空间方法talkWithDriver(),刚才的数据以写入mIn.</li>
<li>这时mIn有可读数据, 回到【小节2.10】IPC.waitForResponse()方法,完成BR_TRANSACTION_COMPLETE过程. 如果本次transaction采用非oneway方式, 这次Binder通信便完成, 否则还是要等待Binder服务端的返回。</li>
</ol>
<p>对于startService过程, 采用的便是非oneway方式,那么发起者进程还会继续停留在waitForResponse()方法,继续talkWithDriver()，然后休眠在binder_thread_read()的wait_event_freezable()过程，等待当前线程的todo队列有数据的到来，即等待收到BR_REPLY消息.</p>
<p>由于在前面binder_transaction()除了向自己所在线程写入了<code>BINDER_WORK_TRANSACTION_COMPLETE</code>, 还向目标进程(此处为system_server)写入了<code>BINDER_WORK_TRANSACTION</code>命令，那么接下里介绍system_server进程的工作。</p>
<h2 id="四-回到用户空间"><a href="#四-回到用户空间" class="headerlink" title="四. 回到用户空间"></a>四. 回到用户空间</h2><p><code>system_server</code>的binder线程是如何运转的，那么就需要从Binder线程的创建开始说起， Binder线程的创建有两种方式：</p>
<ul>
<li>ProcessState::self()-&gt;startThreadPool();</li>
<li>IPCThreadState::self()-&gt;joinThreadPool();</li>
</ul>
<p>从文章<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">addService 小节4.1</a>，可知，调用链如下： startThreadPool()过程会创建新Binder线程，再经过层层调用也会进入joinThreadPool()方法。 <code>system_server</code>的binder线程从IPC.joinThreadPool –&gt; IPC.getAndExecuteCommand() -&gt; IPC.talkWithDriver() ,但talkWithDriver收到事务之后, 便进入IPC.executeCommand()方法。</p>
<p>接下来从joinThreadPool说起：</p>
<h3 id="4-1-IPC-joinThreadPool"><a href="#4-1-IPC-joinThreadPool" class="headerlink" title="4.1 IPC.joinThreadPool"></a>4.1 IPC.joinThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        processPendingDerefs(); &#x2F;&#x2F;处理对象引用</span><br><span class="line">        result &#x3D; getAndExecuteCommand();&#x2F;&#x2F;获取并执行命令【见小节4.2】</span><br><span class="line"></span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result !&#x3D; TIMED_OUT &amp;&amp; result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF) &#123;</span><br><span class="line">            ALOGE(&quot;getAndExecuteCommand(fd&#x3D;%d) returned unexpected error %d, aborting&quot;,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;对于binder非主线程不再使用，则退出</span><br><span class="line">        if(result &#x3D;&#x3D; TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-IPC-getAndExecuteCommand"><a href="#4-2-IPC-getAndExecuteCommand" class="headerlink" title="4.2 IPC.getAndExecuteCommand"></a>4.2 IPC.getAndExecuteCommand</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line"></span><br><span class="line">    result &#x3D; talkWithDriver(); &#x2F;&#x2F;该Binder Driver进行交互</span><br><span class="line">    if (result &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        size_t IN &#x3D; mIn.dataAvail();</span><br><span class="line">        if (IN &lt; sizeof(int32_t)) return result;</span><br><span class="line">        cmd &#x3D; mIn.readInt32(); &#x2F;&#x2F;读取命令</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        result &#x3D; executeCommand(cmd); &#x2F;&#x2F;【见小节4.3】</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        set_sched_policy(mMyThreadId, SP_FOREGROUND);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时system_server的binder线程空闲便是停留在binder_thread_read()方法来处理进程/线程新的事务。 由【小节3.4】可知收到的是<code>BINDER_WORK_TRANSACTION</code>命令, 再经过inder_thread_read()后生成命令cmd=<code>BR_TRANSACTION</code>.再将cmd和数据写回用户空间。</p>
<h3 id="4-3-IPC-executeCommand"><a href="#4-3-IPC-executeCommand" class="headerlink" title="4.3 IPC.executeCommand"></a>4.3 IPC.executeCommand</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result &#x3D; mIn.read(&amp;tr, sizeof(tr)); &#x2F;&#x2F;读取mIn数据</span><br><span class="line">            if (result !&#x3D; NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            &#x2F;&#x2F;当buffer对象回收时，则会调用freeBuffer来回收内存【见小节4.3.1】</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size&#x2F;sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid &#x3D; mCallingPid;</span><br><span class="line">            const uid_t origUid &#x3D; mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy &#x3D; mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags &#x3D; mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;设置调用者的pid和uid</span><br><span class="line">            mCallingPid &#x3D; tr.sender_pid;</span><br><span class="line">            mCallingUid &#x3D; tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; tr.flags;</span><br><span class="line"></span><br><span class="line">            int curPrio &#x3D; getpriority(PRIO_PROCESS, mMyThreadId);</span><br><span class="line">            if (gDisableBackgroundScheduling) &#123;</span><br><span class="line">                ... &#x2F;&#x2F;不进入此分支</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (curPrio &gt;&#x3D; ANDROID_PRIORITY_BACKGROUND) &#123;</span><br><span class="line">                    set_sched_policy(mMyThreadId, SP_BACKGROUND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                &#x2F;&#x2F;尝试通过弱引用获取强引用</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; tr.cookie里存放的是BBinder子类JavaBBinder [见流程4.4]</span><br><span class="line">                    error &#x3D; reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error &#x3D; UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error &#x3D; the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                &#x2F;&#x2F;对于非oneway, 需要reply通信过程,则向Binder驱动发送BC_REPLY命令【见小节4.3.1】</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;恢复pid和uid信息</span><br><span class="line">            mCallingPid &#x3D; origPid;</span><br><span class="line">            mCallingUid &#x3D; origUid;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">        case ...</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            result &#x3D; UNKNOWN_ERROR;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mLastError &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于oneway的场景, 执行完本次transact()则全部结束.</li>
<li>对于非oneway, 需要reply的通信过程,则向Binder驱动发送BC_REPLY命令【见小节5.1】</li>
</ul>
<h4 id="4-3-1-ipcSetDataReference"><a href="#4-3-1-ipcSetDataReference" class="headerlink" title="4.3.1 ipcSetDataReference"></a>4.3.1 ipcSetDataReference</h4><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,</span><br><span class="line">    const binder_size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    binder_size_t minOffset &#x3D; 0;</span><br><span class="line">    freeDataNoInit(); &#x2F;&#x2F;【见小节4.3.2】</span><br><span class="line">    mError &#x3D; NO_ERROR;</span><br><span class="line">    mData &#x3D; const_cast&lt;uint8_t*&gt;(data);</span><br><span class="line">    mDataSize &#x3D; mDataCapacity &#x3D; dataSize;</span><br><span class="line">    mDataPos &#x3D; 0;</span><br><span class="line">    mObjects &#x3D; const_cast&lt;binder_size_t*&gt;(objects);</span><br><span class="line">    mObjectsSize &#x3D; mObjectsCapacity &#x3D; objectsCount;</span><br><span class="line">    mNextObjectHint &#x3D; 0;</span><br><span class="line">    mOwner &#x3D; relFunc;</span><br><span class="line">    mOwnerCookie &#x3D; relCookie;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        binder_size_t offset &#x3D; mObjects[i];</span><br><span class="line">        if (offset &lt; minOffset) &#123;</span><br><span class="line">            mObjectsSize &#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset &#x3D; offset + sizeof(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的功能，Parcel成员变量说明：</p>
<ul>
<li>mData：parcel数据起始地址</li>
<li>mDataSize：parcel数据大小</li>
<li>mObjects：flat_binder_object地址偏移量</li>
<li>mObjectsSize：parcel中flat_binder_object个数</li>
<li>mOwner：释放函数freebuffer</li>
<li>mOwnerCookie：释放函数所需信息</li>
</ul>
<h4 id="4-3-2-freeDataNoInit"><a href="#4-3-2-freeDataNoInit" class="headerlink" title="4.3.2 freeDataNoInit"></a>4.3.2 freeDataNoInit</h4><p>[-&gt; Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::freeDataNoInit()</span><br><span class="line">&#123;</span><br><span class="line">    if (mOwner) &#123;</span><br><span class="line">        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F;mOwner为空， 进入该分支</span><br><span class="line">        releaseObjects(); &#x2F;&#x2F;【见小节4.3.3】</span><br><span class="line">        if (mData) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;gParcelGlobalAllocSizeLock);</span><br><span class="line">            if (mDataCapacity &lt;&#x3D; gParcelGlobalAllocSize) &#123;</span><br><span class="line">              gParcelGlobalAllocSize &#x3D; gParcelGlobalAllocSize - mDataCapacity;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              gParcelGlobalAllocSize &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (gParcelGlobalAllocCount &gt; 0) &#123;</span><br><span class="line">              gParcelGlobalAllocCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;gParcelGlobalAllocSizeLock);</span><br><span class="line">            free(mData);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mObjects) free(mObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-releaseObjects"><a href="#4-3-3-releaseObjects" class="headerlink" title="4.3.3 releaseObjects"></a>4.3.3 releaseObjects</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Parcel::releaseObjects()</span><br><span class="line">&#123;</span><br><span class="line">    const sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    size_t i &#x3D; mObjectsSize;</span><br><span class="line">    uint8_t* const data &#x3D; mData;</span><br><span class="line">    binder_size_t* const objects &#x3D; mObjects;</span><br><span class="line">    while (i &gt; 0) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        const flat_binder_object* flat</span><br><span class="line">            &#x3D; reinterpret_cast&lt;flat_binder_object*&gt;(data+objects[i]);</span><br><span class="line">        &#x2F;&#x2F;【见小节4.3.4】</span><br><span class="line">        release_object(proc, *flat, this, &amp;mOpenAshmemSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-release-object"><a href="#4-3-4-release-object" class="headerlink" title="4.3.4 release_object"></a>4.3.4 release_object</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void release_object(const sp&lt;ProcessState&gt;&amp; proc, const flat_binder_object&amp; obj, const void* who, size_t* outAshmemSize) &#123;</span><br><span class="line">    switch (obj.type) &#123;</span><br><span class="line">        case BINDER_TYPE_BINDER:</span><br><span class="line">            if (obj.binder) &#123;</span><br><span class="line">                reinterpret_cast&lt;IBinder*&gt;(obj.cookie)-&gt;decStrong(who);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        case BINDER_TYPE_WEAK_BINDER:</span><br><span class="line">            if (obj.binder)</span><br><span class="line">                reinterpret_cast&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;decWeak(who);</span><br><span class="line">            return;</span><br><span class="line">        case BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">            const sp&lt;IBinder&gt; b &#x3D; proc-&gt;getStrongProxyForHandle(obj.handle);</span><br><span class="line">            if (b !&#x3D; NULL) &#123;</span><br><span class="line">                b-&gt;decStrong(who);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            const wp&lt;IBinder&gt; b &#x3D; proc-&gt;getWeakProxyForHandle(obj.handle);</span><br><span class="line">            if (b !&#x3D; NULL) b.get_refs()-&gt;decWeak(who);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case BINDER_TYPE_FD: &#123;</span><br><span class="line">            ...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据flat_binder_object的类型，来决定减少相应的强弱引用。</p>
<h4 id="4-3-5-Parcel"><a href="#4-3-5-Parcel" class="headerlink" title="4.3.5 ~Parcel"></a>4.3.5 ~Parcel</h4><p>[-&gt; Parcel.cpp]</p>
<p>当[小节4.3]executeCommand执行完成后， 便会释放局部变量Parcel buffer，则会析构Parcel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parcel::~Parcel()</span><br><span class="line">&#123;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Parcel::freeDataNoInit()</span><br><span class="line">&#123;</span><br><span class="line">    if (mOwner) &#123; &#x2F;&#x2F;此处mOwner等于freeBuffer 【见小节4.3.6】</span><br><span class="line">        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);</span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，进入IPC的freeBuffer过程。</p>
<h4 id="4-3-6-freeBuffer"><a href="#4-3-6-freeBuffer" class="headerlink" title="4.3.6 freeBuffer"></a>4.3.6 freeBuffer</h4><p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data,</span><br><span class="line">                                size_t &#x2F;*dataSize*&#x2F;,</span><br><span class="line">                                const binder_size_t* &#x2F;*objects*&#x2F;,</span><br><span class="line">                                size_t &#x2F;*objectsSize*&#x2F;, void* &#x2F;*cookie*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    if (parcel !&#x3D; NULL) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state &#x3D; self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((uintptr_t)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向Binder驱动写入BC_FREE_BUFFER命令。</p>
<h3 id="4-4-BBinder-transact"><a href="#4-4-BBinder-transact" class="headerlink" title="4.4 BBinder.transact"></a>4.4 BBinder.transact</h3><p>[-&gt; Binder.cpp ::BBinder ]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">status_t BBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">    status_t err &#x3D; NO_ERROR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; onTransact(code, data, reply, flags); &#x2F;&#x2F;【见流程4.5】</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reply !&#x3D; NULL) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-JavaBBinder-onTransact"><a href="#4-5-JavaBBinder-onTransact" class="headerlink" title="4.5 JavaBBinder.onTransact"></a>4.5 JavaBBinder.onTransact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">virtual status_t onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags &#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv* env &#x3D; javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">    IPCThreadState* thread_state &#x3D; IPCThreadState::self();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用Binder.execTransact [见流程4.6]</span><br><span class="line">    jboolean res &#x3D; env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">        code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags);</span><br><span class="line"></span><br><span class="line">    jthrowable excep &#x3D; env-&gt;ExceptionOccurred();</span><br><span class="line">    if (excep) &#123;</span><br><span class="line">        res &#x3D; JNI_FALSE;</span><br><span class="line">        &#x2F;&#x2F;发生异常, 则清理JNI本地引用</span><br><span class="line">        env-&gt;DeleteLocalRef(excep);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return res !&#x3D; JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得AndroidRuntime::startReg过程吗, 其中有一个过程便是register_android_os_Binder(),该过程会把gBinderOffsets.mExecTransact便是Binder.java中的execTransact()方法.详见见<a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Binder系列7—framework层分析</a>文章中的第二节初始化的过程.</p>
<p>另外,此处mObject是在服务注册addService过程,会调用writeStrongBinder方法, 将Binder对象传入了JavaBBinder构造函数的参数, 最终赋值给mObject. 在本次通信过程中Object为ActivityManagerNative对象.</p>
<p>此处斗转星移, 从C++代码回到了Java代码. 进入AMN.execTransact, 由于AMN继续于Binder对象, 接下来进入Binder.execTransact</p>
<h3 id="4-6-Binder-execTransact"><a href="#4-6-Binder-execTransact" class="headerlink" title="4.6 Binder.execTransact"></a>4.6 Binder.execTransact</h3><p>[Binder.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain(dataObj);</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain(replyObj);</span><br><span class="line"></span><br><span class="line">    boolean res;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用子类AMN.onTransact方法 [见流程4.7]</span><br><span class="line">        res &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;非oneway的方式,则会将异常写回reply</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; true;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; true;</span><br><span class="line">    &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">        RuntimeException re &#x3D; new RuntimeException(&quot;Out of memory&quot;, e);</span><br><span class="line">        reply.setDataPosition(0);</span><br><span class="line">        reply.writeException(re);</span><br><span class="line">        res &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生RemoteException, RuntimeException, OutOfMemoryError, 对于非oneway的情况下都会把异常传递给调用者.</p>
<h3 id="4-7-AMN-onTransact"><a href="#4-7-AMN-onTransact" class="headerlink" title="4.7 AMN.onTransact"></a>4.7 AMN.onTransact</h3><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    ...</span><br><span class="line">     case START_SERVICE_TRANSACTION: &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b &#x3D; data.readStrongBinder();</span><br><span class="line">        &#x2F;&#x2F;生成ApplicationThreadNative的代理对象，即ApplicationThreadProxy对象</span><br><span class="line">        IApplicationThread app &#x3D; ApplicationThreadNative.asInterface(b);</span><br><span class="line">        Intent service &#x3D; Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType &#x3D; data.readString();</span><br><span class="line">        String callingPackage &#x3D; data.readString();</span><br><span class="line">        int userId &#x3D; data.readInt();</span><br><span class="line">        &#x2F;&#x2F;调用ActivityManagerService的startService()方法【见流程4.8】</span><br><span class="line">        ComponentName cn &#x3D; startService(app, service, resolvedType, callingPackage, userId);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        ComponentName.writeToParcel(cn, reply);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-AMS-startService"><a href="#4-8-AMS-startService" class="headerlink" title="4.8 AMS.startService"></a>4.8 AMS.startService</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ComponentName res &#x3D; mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>历经千山万水, 总算是进入了AMS.startService. 当system_server收到BR_TRANSACTION的过程后，通信并没有完全结束，还需将服务启动完成的回应消息 告诉给发起端进程。</p>
<h2 id="五-Reply流程"><a href="#五-Reply流程" class="headerlink" title="五. Reply流程"></a>五. Reply流程</h2><p>还记得前面【小节2.10】IPC.waitForResponse()过程，对于非oneway的方式，还仍在一直等待system_server这边的响应呢，只有收到BR_REPLY，或者BR_DEAD_REPLY，或者BR_FAILED_REPLY，再或许其他BR_命令执行出错的情况下，该waitForResponse()才会退出。</p>
<p>BR_REPLY命令是如何来的呢？【小节4.3】IPC.executeCommand()过程处理完BR_TRANSACTION命令的同时，还会通过sendReply()向Binder Driver发送BC_REPLY消息，接下来从该方法说起。</p>
<h4 id="5-1-IPC-sendReply"><a href="#5-1-IPC-sendReply" class="headerlink" title="5.1 IPC.sendReply"></a>5.1 IPC.sendReply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::sendReply(const Parcel&amp; reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line">    status_t statusBuffer;</span><br><span class="line">    &#x2F;&#x2F;[见小节2.10]</span><br><span class="line">    err &#x3D; writeTransactionData(BC_REPLY, flags, -1, 0, reply, &amp;statusBuffer);</span><br><span class="line">    if (err &lt; NO_ERROR) return err;</span><br><span class="line">    &#x2F;&#x2F;[见小节5.3]</span><br><span class="line">    return waitForResponse(NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将数据写入mOut；再进waitForResponse，等待应答，此时同理也是等待BR_TRANSACTION_COMPLETE。 同理经过IPC.talkWithDriver -&gt; binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write， 再就是进入binder_transaction方法。</p>
<h4 id="5-2-BC-REPLY"><a href="#5-2-BC-REPLY" class="headerlink" title="5.2 BC_REPLY"></a>5.2 BC_REPLY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reply &#x3D;true</span><br><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">             struct binder_thread *thread,</span><br><span class="line">             struct binder_transaction_data *tr, int reply)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  if (reply) &#123;</span><br><span class="line">    in_reply_to &#x3D; thread-&gt;transaction_stack; &#x2F;&#x2F;接收端的事务栈</span><br><span class="line">    ...</span><br><span class="line">    thread-&gt;transaction_stack &#x3D; in_reply_to-&gt;to_parent;</span><br><span class="line">    target_thread &#x3D; in_reply_to-&gt;from; &#x2F;&#x2F;发起端的线程</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发起端线程不能为空</span><br><span class="line">    if (target_thread &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">      return_error &#x3D; BR_DEAD_REPLY;</span><br><span class="line">      goto err_dead_binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发起端线程的事务栈 要等于 接收端的事务栈</span><br><span class="line">    if (target_thread-&gt;transaction_stack !&#x3D; in_reply_to) &#123;</span><br><span class="line">      return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">      in_reply_to &#x3D; NULL;</span><br><span class="line">      target_thread &#x3D; NULL;</span><br><span class="line">      goto err_dead_binder;</span><br><span class="line">    &#125;</span><br><span class="line">    target_proc &#x3D; target_thread-&gt;proc; &#x2F;&#x2F;发起端的进程</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (target_thread) &#123;</span><br><span class="line">      &#x2F;&#x2F;发起端的线程</span><br><span class="line">      target_list &#x3D; &amp;target_thread-&gt;todo;</span><br><span class="line">      target_wait &#x3D; &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t &#x3D; kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">    tcomplete &#x3D; kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">      t-&gt;from &#x3D; thread;</span><br><span class="line">    else</span><br><span class="line">      t-&gt;from &#x3D; NULL; &#x2F;&#x2F;进入该分支</span><br><span class="line">    t-&gt;sender_euid &#x3D; task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc &#x3D; target_proc;</span><br><span class="line">    t-&gt;to_thread &#x3D; target_thread;</span><br><span class="line">    t-&gt;code &#x3D; tr-&gt;code;</span><br><span class="line">    t-&gt;flags &#x3D; tr-&gt;flags;</span><br><span class="line">    t-&gt;priority &#x3D; task_nice(current);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发起端进程分配buffer</span><br><span class="line">    t-&gt;buffer &#x3D; binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">      tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free &#x3D; 0;</span><br><span class="line">    t-&gt;buffer-&gt;transaction &#x3D; t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node &#x3D; target_node;</span><br><span class="line">    if (target_node)</span><br><span class="line">      binder_inc_node(target_node, 1, 0, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到内核</span><br><span class="line">    copy_from_user(t-&gt;buffer-&gt;data,</span><br><span class="line">       (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp,</span><br><span class="line">       (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">      binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION添加到目标队列，本次通信的目标队列为target_thread-&gt;todo</span><br><span class="line">    t-&gt;work.type &#x3D; BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程的todo队列</span><br><span class="line">    tcomplete-&gt;type &#x3D; BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;唤醒等待队列，本次通信的目标队列为target_thread-&gt;wait</span><br><span class="line">    if (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>

<p>binder_transaction -&gt; binder_thread_read -&gt; IPC.waitForResponse，收到BR_REPLY来回收buffer.</p>
<h4 id="5-3-BR-REPLY"><a href="#5-3-BR-REPLY" class="headerlink" title="5.3 BR_REPLY"></a>5.3 BR_REPLY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break; &#x2F;&#x2F; 【见小节2.11】</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line">        ...</span><br><span class="line">        cmd &#x3D; mIn.readInt32();</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">          ...</span><br><span class="line">          case BR_REPLY:</span><br><span class="line">           &#123;</span><br><span class="line">               binder_transaction_data tr;</span><br><span class="line">               err &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">               if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line"></span><br><span class="line">               if (reply) &#123;</span><br><span class="line">                   ...</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F; 释放buffer[见小节5.4]</span><br><span class="line">                   freeBuffer(NULL,</span><br><span class="line">                       reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                       tr.data_size,</span><br><span class="line">                       reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                       tr.offsets_size&#x2F;sizeof(binder_size_t), this);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           goto finish;</span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; executeCommand(cmd);</span><br><span class="line">            ...</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-IPC-freeBuffer"><a href="#5-4-IPC-freeBuffer" class="headerlink" title="5.4 IPC.freeBuffer"></a>5.4 IPC.freeBuffer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data,</span><br><span class="line">                                size_t &#x2F;*dataSize*&#x2F;,</span><br><span class="line">                                const binder_size_t* &#x2F;*objects*&#x2F;,</span><br><span class="line">                                size_t &#x2F;*objectsSize*&#x2F;, void* &#x2F;*cookie*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    if (parcel !&#x3D; NULL) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state &#x3D; self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((uintptr_t)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将BC_FREE_BUFFER写入mOut,再talkWithDriver()</p>
<h5 id="5-5-BC-FREE-BUFFER"><a href="#5-5-BC-FREE-BUFFER" class="headerlink" title="5.5 BC_FREE_BUFFER"></a>5.5 BC_FREE_BUFFER</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">            struct binder_thread *thread,</span><br><span class="line">            binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">            binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    void __user *buffer &#x3D; (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">    void __user *ptr &#x3D; buffer + *consumed;</span><br><span class="line">    void __user *end &#x3D; buffer + size;</span><br><span class="line">    while (ptr &lt; end &amp;&amp; thread-&gt;return_error &#x3D;&#x3D; BR_OK) &#123;</span><br><span class="line">        &#x2F;&#x2F;拷贝用户空间的cmd命令，此时为BC_FREE_BUFFER</span><br><span class="line">        if (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BC_TRANSACTION:</span><br><span class="line">        case BC_REPLY: ...</span><br><span class="line">        case BC_FREE_BUFFER: &#123;</span><br><span class="line">            void __user *data_ptr;</span><br><span class="line">            struct binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">            if (get_user(data_ptr, (void * __user *)ptr)) return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(void *);</span><br><span class="line"></span><br><span class="line">            buffer &#x3D; binder_buffer_lookup(proc, data_ptr);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            if (buffer-&gt;transaction) &#123;</span><br><span class="line">                buffer-&gt;transaction-&gt;buffer &#x3D; NULL;</span><br><span class="line">                buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; binder_buffer存在异步事务,且binder_node不为空</span><br><span class="line">            if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123;</span><br><span class="line">                if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))</span><br><span class="line">                    buffer-&gt;target_node-&gt;has_async_transaction &#x3D; 0;</span><br><span class="line">                else</span><br><span class="line">                    &#x2F;&#x2F;当异步队列async_todo也不为空,则事务追加到该线程todo队列.</span><br><span class="line">                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            binder_transaction_buffer_release(proc, buffer, NULL);</span><br><span class="line">            binder_free_buf(proc, buffer);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *consumed &#x3D; ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收端线程处理BC_FREE_BUFFER命令:</p>
<ul>
<li>当binder_buffer存在异步事务,当异步队列async_todo也不为空,则事务追加到该线程todo队列.</li>
<li>释放当前的buffer.</li>
</ul>
<h5 id="5-6-binder-thread-read"><a href="#5-6-binder-thread-read" class="headerlink" title="5.6 binder_thread_read"></a>5.6 binder_thread_read</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">    ...</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        uint32_t cmd;</span><br><span class="line">        struct binder_transaction_data tr;</span><br><span class="line">        struct binder_work *w;</span><br><span class="line">        struct binder_transaction *t &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从线程todo队列获取事务数据</span><br><span class="line">        if (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">            w &#x3D; list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (w-&gt;type) &#123;</span><br><span class="line">            case BINDER_WORK_TRANSACTION:</span><br><span class="line">                &#x2F;&#x2F;获取transaction数据</span><br><span class="line">                t &#x3D; container_of(w, struct binder_transaction, work);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取目标node</span><br><span class="line">            struct binder_node *target_node &#x3D; t-&gt;buffer-&gt;target_node;</span><br><span class="line">            tr.target.ptr &#x3D; target_node-&gt;ptr;</span><br><span class="line">            tr.cookie &#x3D;  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority &#x3D; task_nice(current);</span><br><span class="line">            ...</span><br><span class="line">            cmd &#x3D; BR_TRANSACTION;  &#x2F;&#x2F;设置命令为BR_TRANSACTION</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tr.target.ptr &#x3D; NULL;</span><br><span class="line">            tr.cookie &#x3D; NULL;</span><br><span class="line">            cmd &#x3D; BR_REPLY; &#x2F;&#x2F;设置命令为BR_REPLY</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr.code &#x3D; t-&gt;code;</span><br><span class="line">        tr.flags &#x3D; t-&gt;flags;</span><br><span class="line">        tr.sender_euid &#x3D; t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;将cmd和数据写回用户空间</span><br><span class="line">        if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))  return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(tr);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free &#x3D; 1;</span><br><span class="line">        if (cmd &#x3D;&#x3D; BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread &#x3D; thread;</span><br><span class="line">            thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            kfree(t); &#x2F;&#x2F;通信完成,则运行释放</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>本文详细地介绍如何从AMP.startService是如何通过Binder一步步调用进入到system_server进程的AMS.startService. 整个过程涉及Java framework, native, kernel driver各个层面知识. 仅仅一个Binder IPC调用, 就花费了如此大篇幅来讲解, 可见系统之庞大. 整个过程的调用流程:</p>
<h3 id="6-1-通信流程"><a href="#6-1-通信流程" class="headerlink" title="6.1 通信流程"></a>6.1 通信流程</h3><p>从通信流程角度来看整个过程:<img src="http://gityuan.com/images/binder/binder_start_service/binder_ipc_process.jpg" alt="binder_ipc_process"></p>
<p>图解:</p>
<ol>
<li>发起端线程向Binder Driver发起binder ioctl请求后, 便采用环不断talkWithDriver,此时该线程处于阻塞状态, 直到收到如下BR_XXX命令才会结束该过程.<ul>
<li>BR_TRANSACTION_COMPLETE: oneway模式下,收到该命令则退出</li>
<li>BR_REPLY: 非oneway模式下,收到该命令才退出;</li>
<li>BR_DEAD_REPLY: 目标进程/线程/binder实体为空, 以及释放正在等待reply的binder thread或者binder buffer;</li>
<li>BR_FAILED_REPLY: 情况较多,比如非法handle, 错误事务栈, security, 内存不足, buffer不足, 数据拷贝失败, 节点创建失败, 各种不匹配等问题</li>
<li>BR_ACQUIRE_RESULT: 目前未使用的协议;</li>
</ul>
</li>
<li>左图中waitForResponse收到BR_TRANSACTION_COMPLETE,则直接退出循环, 则没有机会执行executeCommand()方法, 故将其颜色画为灰色. 除以上5种BR_XXX命令, 当收到其他BR命令,则都会执行executeCommand过程.</li>
<li>目标Binder线程创建后, 便进入joinThreadPool()方法, 采用循环不断地循环执行getAndExecuteCommand()方法, 当bwr的读写buffer都没有数据时,则阻塞在binder_thread_read的wait_event过程. 另外,正常情况下binder线程一旦创建则不会退出.</li>
</ol>
<h3 id="6-2-通信协议"><a href="#6-2-通信协议" class="headerlink" title="6.2 通信协议"></a>6.2 通信协议</h3><p>从通信协议的角度来看这个过程:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/binder_transaction.jpg" alt="binder_transaction"></p>
<ul>
<li>Binder客户端或者服务端向Binder Driver发送的命令都是以BC_开头,例如本文的<code>BC_TRANSACTION</code>和<code>BC_REPLY</code>, 所有Binder Driver向Binder客户端或者服务端发送的命令则都是以BR_开头, 例如本文中的<code>BR_TRANSACTION</code>和<code>BR_REPLY</code>.</li>
<li>只有当<code>BC_TRANSACTION</code>或者<code>BC_REPLY</code>时, 才调用binder_transaction()来处理事务. 并且都会回应调用者一个<code>BINDER_WORK_TRANSACTION_COMPLETE</code>事务, 经过binder_thread_read()会转变成<code>BR_TRANSACTION_COMPLETE</code>.</li>
<li>startService过程便是一个非oneway的过程, 那么oneway的通信过程如下所述.</li>
</ul>
<h3 id="6-3-说一说oneway"><a href="#6-3-说一说oneway" class="headerlink" title="6.3 说一说oneway"></a>6.3 说一说oneway</h3><p>上图是非oneway通信过程的协议图, 下图则是对于oneway场景下的通信协议图:</p>
<p><img src="http://gityuan.com/images/binder/binder_start_service/binder_transaction_oneway.jpg" alt="binder_transaction_oneway"></p>
<p>当收到BR_TRANSACTION_COMPLETE则程序返回,有人可能觉得好奇,为何oneway怎么还要等待回应消息? 我举个例子,你就明白了.</p>
<p>你(app进程)要给远方的家人(system_server进程)邮寄一封信(transaction), 你需要通过邮寄员(Binder Driver)来完成.整个过程如下:</p>
<ol>
<li>你把信交给邮寄员(<code>BC_TRANSACTION</code>);</li>
<li>邮寄员收到信后, 填一张单子给你作为一份回执(<code>BR_TRANSACTION_COMPLETE</code>). 这样你才放心知道邮递员已确定接收信, 否则就这样走了,信到底有没有交到邮递员手里都不知道,这样的通信实在太让人不省心, 长时间收不到远方家人的回信, 无法得知是在路的中途信件丢失呢,还是压根就没有交到邮递员的手里. 所以说oneway也得知道信是投递状态是否成功.</li>
<li>邮递员利用交通工具(Binder Driver),将信交给了你的家人(<code>BR_TRANSACTION</code>);</li>
</ol>
<p>当你收到回执(BR_TRANSACTION_COMPLETE)时心里也不期待家人回信, 那么这便是一次oneway的通信过程.</p>
<p>如果你希望家人回信, 那便是非oneway的过程,在上述步骤2后并不是直接返回,而是继续等待着收到家人的回信, 经历前3个步骤之后继续执行:</p>
<ol>
<li>家人收到信后, 立马写了个回信交给邮递员<code>BC_REPLY</code>;</li>
<li>同样,邮递员要写一个回执(<code>BR_TRANSACTION_COMPLETE</code>)给你家人;</li>
<li>邮递员再次利用交通工具(Binder Driver), 将回信成功交到你的手上(<code>BR_REPLY</code>)</li>
</ol>
<p>这便是一次完成的非oneway通信过程.</p>
<p>oneway与非oneway: 都是需要等待Binder Driver的回应消息BR_TRANSACTION_COMPLETE. 主要区别在于oneway的通信收到BR_TRANSACTION_COMPLETE则返回,而不会再等待BR_REPLY消息的到来. 另外，oneway的binder IPC则接收端无法获取对方的pid.</p>
<h3 id="6-4-小规律"><a href="#6-4-小规律" class="headerlink" title="6.4 小规律"></a>6.4 小规律</h3><ul>
<li>BC_TRANSACTION + BC_REPLY = BR_TRANSACTION_COMPLETE + BR_DEAD_REPLY + BR_FAILED_REPLY</li>
<li>Binder线程只有当本线程的thread-&gt;todo队列为空，并且thread-&gt;transaction_stack也为空，才会去处理当前进程的事务， 否则会继续处理或等待当前线程的todo队列事务。换句话说，就是只有当前线程的事务;</li>
<li>binder_thread_write: 添加成员到todo队列;</li>
<li>binder_thread_read: 消耗todo队列;</li>
<li>对于处于空闲可用的,或者Ready的binder线程是指停在binder_thread_read()的wait_event地方的Binder线程;</li>
<li>每一次BR_TRANSACTION或者BR_REPLY结束之后都会调用freeBuffer().</li>
<li>ProcessState.mHandleToObject记录着handle与对应的BpBinder信息。</li>
</ul>
<p>整个过程copy once便是指binder_transaction()过程把binder_transaction_data-&gt;data拷贝到目标进程的buffer。</p>
<h3 id="6-5-数据流"><a href="#6-5-数据流" class="headerlink" title="6.5 数据流"></a>6.5 数据流</h3><p><img src="http://gityuan.com/images/binder/binder_transaction_data.jpg" alt="binder_transaction_data"></p>
<ul>
<li>[2.1]AMP.startService：组装flat_binder_object对象等组成的Parcel data；</li>
<li>[2.9]IPC.writeTransactionData：组装BC_TRANSACTION和binder_transaction_data结构体，写入mOut;</li>
<li>[2.11]IPC.talkWithDriver: 组装BINDER_WRITE_READ和binder_write_read结构体，通过ioctl传输到驱动层。</li>
</ul>
<p>进入驱动后</p>
<ul>
<li>[3.3]binder_thread_write: 处理binder_write_read.write_buffer数据</li>
<li>[3.4]binder_transaction: 处理write_buffer.binder_transaction_data数据；<ul>
<li>创建binder_transaction结构体，记录事务通信的线程来源以及事务链条等相关信息；</li>
<li>分配binder_buffer结构体，拷贝当前线程binder_transaction_data的data数据到binder_buffer-&gt;data；</li>
</ul>
</li>
<li>[3.5]binder_thread_read: 处理binder_transaction结构体数据<ul>
<li>组装cmd=BR_TRANSACTION和binder_transaction_data结构体，写入binder_write_read.read_buffer数据</li>
</ul>
</li>
</ul>
<p>回到用户空间</p>
<ul>
<li>[4.3]IPC.executeCommand：处理BR_TRANSACTION命令, 将binder_transaction_data数据解析成BBinder.transact()所需的参数</li>
<li>[4.7] AMN.onTransact: 层层回调，进入该方法，反序列化数据后，调用startService()方法。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Service/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Service/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" itemprop="url">startService启动过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-04T11:02:54+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Service/" itemprop="url" rel="index">
                    <span itemprop="name">Service</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Service/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Service/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>看过前面介绍<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列</a>文章，相信对Binder架构有了较深地理解。在<a href="http://gityuan.com/2016/01/03/android-boot/" target="_blank" rel="noopener">Android系统启动-开篇</a>中讲述了Binder的地位是非常之重要，整个Java framework的提供ActivityManagerService、PackageManagerService等服务都是基于Binder架构来通信的，另外 <a href="http://gityuan.com/2015/12/26/handler-message/" target="_blank" rel="noopener">handle消息机制</a>在进程内的通信使用非常多。本文将开启对ActivityManagerService的分析。</p>
<p>ActivityManagerService是Android的Java framework的服务框架最重要的服务之一。对于Andorid的Activity、Service、Broadcast、ContentProvider四剑客的管理，包含其生命周期都是通过ActivityManagerService来完成的。对于这四剑客的介绍，此处先略过，后续博主会针对这4剑客分别阐述。</p>
<h4 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h4><p>下面先看看ActivityManagerService相关的类图：</p>
<p><img src="http://gityuan.com/images/android-service/am/activity_manager_classes.png" alt="activity_manager_classes"></p>
<p>单单就一个ActivityManagerService.java文件就代码超过2万行，我们需要需要一个线，再结合binder的知识，来把我们想要了解的东西串起来，那么本文将从App启动的视角来分析ActivityManagerService。</p>
<h4 id="1-2-流程图"><a href="#1-2-流程图" class="headerlink" title="1.2 流程图"></a>1.2 流程图</h4><p>在app中启动一个service，就一行语句搞定，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startService()； &#x2F;&#x2F;或 binderService()</span><br></pre></td></tr></table></figure>

<p>该过程如下：</p>
<p><img src="http://gityuan.com/images/android-service/am/start_service.png" alt="start_service"></p>
<p>当App通过调用Android API方法startService()或binderService()来生成并启动服务的过程，主要是由ActivityManagerService来完成的。</p>
<ol>
<li>ActivityManagerService通过Socket通信方式向Zygote进程请求生成(fork)用于承载服务的进程ActivityThread。此处讲述启动远程服务的过程，即服务运行于单独的进程中，对于运行本地服务则不需要启动服务的过程。ActivityThread是应用程序的主线程；</li>
<li>Zygote通过fork的方法，将zygote进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程；</li>
<li>ActivityManagerService向新生成的ActivityThread进程，通过Binder方式发送生成服务的请求；</li>
<li>ActivityThread启动运行服务，这便于服务启动的简易过程，真正流程远比这服务；</li>
</ol>
<p><strong>启动服务的流程图：</strong></p>
<p><img src="http://gityuan.com/images/android-service/am/Seq_start_service.png" alt="Seq_start_service"></p>
<p>图中涉及的首字母缩写：</p>
<ul>
<li>AMP:ActivityManagerProxy</li>
<li>AMN:ActivityManagerNative</li>
<li>AMS:ActivityManagerService</li>
<li>AT:ApplicationThread</li>
<li>ATP:ApplicationThreadProxy</li>
<li>ATN:ApplicationThreadNative</li>
</ul>
<p>接下来，我们正式从代码角度来分析服务启动的过程。首先在我们应用程序的Activity类的调用startService()方法，该方法调用【流程1】的方法。</p>
<h2 id="二-发起进程端"><a href="#二-发起进程端" class="headerlink" title="二. 发起进程端"></a>二. 发起进程端</h2><h3 id="1-CW-startService"><a href="#1-CW-startService" class="headerlink" title="1. CW.startService"></a>1. CW.startService</h3><p>[-&gt; ContextWrapper.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        return mBase.startService(service); &#x2F;&#x2F;其中mBase为ContextImpl对象 【见流程2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-CI-startService"><a href="#2-CI-startService" class="headerlink" title="2. CI.startService"></a>2. CI.startService</h3><p>[-&gt; ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        &#x2F;&#x2F;当system进程调用此方法时输出warn信息，system进程建立调用startServiceAsUser方法</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        return startServiceCommon(service, mUser); &#x2F;&#x2F;【见流程3】</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-CI-startServiceCommon"><a href="#3-CI-startServiceCommon" class="headerlink" title="3. CI.startServiceCommon"></a>3. CI.startServiceCommon</h3><p>[-&gt; ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private ComponentName startServiceCommon(Intent service, UserHandle user) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;检验service，当service为空则throw异常</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        &#x2F;&#x2F; 调用ActivityManagerNative类 【见流程3.1以及流程4】</span><br><span class="line">        ComponentName cn &#x3D; ActivityManagerNative.getDefault().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line">        if (cn !&#x3D; null) &#123;</span><br><span class="line">            if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(&quot;Not allowed to start service &quot; +</span><br><span class="line">                    service + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">            &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(&quot;Unable to start service &quot; +</span><br><span class="line">                    service  &quot;: &quot; + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cn;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-AMN-getDefault"><a href="#3-1-AMN-getDefault" class="headerlink" title="3.1 AMN.getDefault"></a>3.1 AMN.getDefault</h4><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gDefault为Singleton类型对象，此次采用单例模式，mInstance为IActivityManager类的代理对象，即ActivityManagerProxy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Singleton&lt;T&gt; &#123;</span><br><span class="line">    public final T get() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;首次调用create()来获取AMP对象</span><br><span class="line">                mInstance &#x3D; create();</span><br><span class="line">            &#125;</span><br><span class="line">            return mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看create()的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取名为&quot;activity&quot;的服务，服务都注册到ServiceManager来统一管理</span><br><span class="line">        IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">        IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是ActivityManagerProxy对象，那么下一步调用ActivityManagerProxy.startService()方法。</p>
<p>通过Binder通信过程中，提供了一个IActivityManager服务接口，ActivityManagerProxy类与ActivityManagerService类都实现了IActivityManager接口。ActivityManagerProxy作为binder通信的客户端，ActivityManagerService作为binder通信的服务端，根据<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列</a>文章，ActivityManagerProxy.startService()最终调用ActivityManagerService.startService()，整个流程图如下：</p>
<p><img src="http://gityuan.com/images/android-service/am/Activity_Manager_Service.png" alt="Activity_Manager_Service"></p>
<h3 id="4-AMP-startService"><a href="#4-AMP-startService" class="headerlink" title="4. AMP.startService"></a>4. AMP.startService</h3><p>该类位于文件ActivityManagerNative.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller !&#x3D; null ? caller.asBinder() : null);</span><br><span class="line">    service.writeToParcel(data, 0);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    &#x2F;&#x2F;通过Binder 传递数据　【见流程5】</span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.readException();</span><br><span class="line">    ComponentName res &#x3D; ComponentName.readFromParcel(reply);</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote.transact()是binder通信的客户端发起方法，经过binder驱动，最后回到binder服务端ActivityManagerNative的onTransact()方法。</p>
<h2 id="三-system-server端"><a href="#三-system-server端" class="headerlink" title="三. system_server端"></a>三. system_server端</h2><p>借助于AMP/AMN这对Binder对象，便完成了从发起端所在进程到system_server的调用过程</p>
<h3 id="5-AMN-onTransact"><a href="#5-AMN-onTransact" class="headerlink" title="5. AMN.onTransact"></a>5. AMN.onTransact</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    ...</span><br><span class="line">     case START_SERVICE_TRANSACTION: &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b &#x3D; data.readStrongBinder();</span><br><span class="line">        &#x2F;&#x2F;生成ApplicationThreadNative的代理对象，即ApplicationThreadProxy对象</span><br><span class="line">        IApplicationThread app &#x3D; ApplicationThreadNative.asInterface(b);</span><br><span class="line">        Intent service &#x3D; Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType &#x3D; data.readString();</span><br><span class="line">        String callingPackage &#x3D; data.readString();</span><br><span class="line">        int userId &#x3D; data.readInt();</span><br><span class="line">        &#x2F;&#x2F;调用ActivityManagerService的startService()方法【见流程6】</span><br><span class="line">        ComponentName cn &#x3D; startService(app, service, resolvedType, callingPackage, userId);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        ComponentName.writeToParcel(cn, reply);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整个调用过程涉及两个进程，不妨令startService的发起进程记为进程A，ServiceManagerService记为进程B；那么进程A通过Binder机制（采用IActivityManager接口）向进程B发起请求服务，进程B则通过Binder机制(采用IApplicationThread接口)向进程A发起请求服务。也就是说进程A与进程B能相互间主动发起请求，进程通信。</p>
<p>这里涉及IApplicationThread，那么下面直接把其相关的类图展示如下：</p>
<p><img src="http://gityuan.com/images/android-service/am/application_thread_classes.png" alt="application_thread_classes"></p>
<p>与IActivityManager的binder通信原理一样，<code>ApplicationThreadProxy</code>作为binder通信的客户端，<code>ApplicationThreadNative</code>作为Binder通信的服务端，其中<code>ApplicationThread</code>继承ApplicationThreadNative类，覆写其中的部分方法。</p>
<h3 id="6-AMS-startService"><a href="#6-AMS-startService" class="headerlink" title="6. AMS.startService"></a>6. AMS.startService</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">    &#x2F;&#x2F;当调用者是孤立进程，则抛出异常。</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line"></span><br><span class="line">    if (service !&#x3D; null &amp;&amp; service.hasFileDescriptors() &#x3D;&#x3D; true) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (callingPackage &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">            &quot;startService: &quot; + service + &quot; type&#x3D;&quot; + resolvedType);</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        final int callingPid &#x3D; Binder.getCallingPid(); &#x2F;&#x2F;调用者pid</span><br><span class="line">        final int callingUid &#x3D; Binder.getCallingUid(); &#x2F;&#x2F;调用者uid</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        &#x2F;&#x2F;此次的mServices为ActiveServices对象 【见流程7】</span><br><span class="line">        ComponentName res &#x3D; mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法参数说明：</p>
<ul>
<li>caller：IApplicationThread类型，复杂处理</li>
<li>service：Intent类型，包含需要运行的service信息</li>
<li>resolvedType：String类型</li>
<li>callingPackage: String类型，调用该方法的package</li>
<li>userId: int类型，用户的id</li>
</ul>
<h3 id="7-AS-startServiceLocked"><a href="#7-AS-startServiceLocked" class="headerlink" title="7. AS.startServiceLocked"></a>7. AS.startServiceLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, String callingPackage, int userId) throws TransactionTooLargeException &#123;</span><br><span class="line"></span><br><span class="line">    final boolean callerFg;</span><br><span class="line">    if (caller !&#x3D; null) &#123;</span><br><span class="line">        final ProcessRecord callerApp &#x3D; mAm.getRecordForAppLocked(caller);</span><br><span class="line">        if (callerApp &#x3D;&#x3D; null)</span><br><span class="line">            throw new SecurityException(&quot;&quot;); &#x2F;&#x2F;抛出异常，此处省略异常字符串</span><br><span class="line">        callerFg &#x3D; callerApp.setSchedGroup !&#x3D; Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        callerFg &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;检索服务信息</span><br><span class="line">    ServiceLookupResult res &#x3D;  retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, true, callerFg);</span><br><span class="line">    if (res &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (res.record &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!&quot;, res.permission !&#x3D; null</span><br><span class="line">                ? res.permission : &quot;private to package&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceRecord r &#x3D; res.record;</span><br><span class="line">    if (!mAm.getUserManagerLocked().exists(r.userId)) &#123; &#x2F;&#x2F;检查是否存在启动服务的user</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    NeededUriGrants neededGrants &#x3D; mAm.checkGrantUriPermissionFromIntentLocked(</span><br><span class="line">            callingUid, r.packageName, service, service.getFlags(), null, r.userId);</span><br><span class="line"></span><br><span class="line">    r.lastActivity &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">    r.startRequested &#x3D; true;</span><br><span class="line">    r.delayedStop &#x3D; false;</span><br><span class="line">    r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants));</span><br><span class="line">    final ServiceMap smap &#x3D; getServiceMap(r.userId);</span><br><span class="line">    boolean addToStarting &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;对于非前台进程的调度</span><br><span class="line">    if (!callerFg &amp;&amp; r.app &#x3D;&#x3D; null &amp;&amp; mAm.mStartedUsers.get(r.userId) !&#x3D; null) &#123;</span><br><span class="line">        ProcessRecord proc &#x3D; mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, false);</span><br><span class="line">        if (proc &#x3D;&#x3D; null || proc.curProcState &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            if (r.delayed) &#123;  &#x2F;&#x2F;已计划延迟启动</span><br><span class="line">                return r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            if (smap.mStartingBackground.size() &gt;&#x3D; mMaxStartingBackground) &#123;</span><br><span class="line">                &#x2F;&#x2F;当超出 同一时间允许后续启动的最大服务数，则将该服务加入延迟启动的队列。</span><br><span class="line">                smap.mDelayedStartList.add(r);</span><br><span class="line">                r.delayed &#x3D; true;</span><br><span class="line">                return r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            addToStarting &#x3D; true;</span><br><span class="line">        &#125; else if (proc.curProcState &gt;&#x3D; ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">            &#x2F;&#x2F;将新的服务加入到后台启动队列，该队列也包含当前正在运行其他services或者receivers的进程</span><br><span class="line">            addToStarting &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见流程8】</span><br><span class="line">    return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种重要的标记符callerFg, 用于标记是前台还是后台:</p>
<ul>
<li>当发起方进程不等于Process.THREAD_GROUP_BG_NONINTERACTIVE,或者发起方为空, 则callerFg= true;</li>
<li>否则,callerFg= false;</li>
</ul>
<h3 id="8-AS-startServiceInnerLocked"><a href="#8-AS-startServiceInnerLocked" class="headerlink" title="8. AS.startServiceInnerLocked"></a>8. AS.startServiceInnerLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">    ProcessStats.ServiceState stracker &#x3D; r.getTracker();</span><br><span class="line">    if (stracker !&#x3D; null) &#123;</span><br><span class="line">        stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    r.callStart &#x3D; false;</span><br><span class="line">    synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked(); &#x2F;&#x2F;用于耗电统计，开启运行的状态</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见流程9】</span><br><span class="line">    String error &#x3D; bringUpServiceLocked(r, service.getFlags(), callerFg, false);</span><br><span class="line">    if (error !&#x3D; null) &#123;</span><br><span class="line">        return new ComponentName(&quot;!!&quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line">    if (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        boolean first &#x3D; smap.mStartingBackground.size() &#x3D;&#x3D; 0;</span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        r.startingBgTimeout &#x3D; SystemClock.uptimeMillis() + BG_START_TIMEOUT;</span><br><span class="line">        if (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStarts();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (callerFg) &#123;</span><br><span class="line">        smap.ensureNotStartingBackground(r);</span><br><span class="line">    &#125;</span><br><span class="line">    return r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-AS-bringUpServiceLocked"><a href="#9-AS-bringUpServiceLocked" class="headerlink" title="9. AS.bringUpServiceLocked"></a>9. AS.bringUpServiceLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123;</span><br><span class="line">    if (r.app !&#x3D; null &amp;&amp; r.app.thread !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用service.onStartCommand()过程</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, false);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!whileRestarting &amp;&amp; r.restartDelay &gt; 0) &#123;</span><br><span class="line">        return null; &#x2F;&#x2F;等待延迟重启的过程，则直接返回</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 启动service前，把service从重启服务队列中移除</span><br><span class="line">    if (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;service正在启动，将delayed设置为false</span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确保拥有该服务的user已经启动，否则停止；</span><br><span class="line">    if (mAm.mStartedUsers.get(r.userId) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        String msg &#x3D; &quot;&quot;;</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;服务正在启动，设置package停止状态为false</span><br><span class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">            r.packageName, false, r.userId);</span><br><span class="line"></span><br><span class="line">    final boolean isolated &#x3D; (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) !&#x3D; 0;</span><br><span class="line">    final String procName &#x3D; r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (!isolated) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据进程名和uid，查询ProcessRecord</span><br><span class="line">        app &#x3D; mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                &#x2F;&#x2F; 启动服务 【见流程10】</span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                return null;</span><br><span class="line">            &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        app &#x3D; r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对于进程没有启动的情况</span><br><span class="line">    if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;启动service所要运行的进程 【见流程9.1】</span><br><span class="line">        if ((app&#x3D;mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,</span><br><span class="line">                &quot;service&quot;, r.name, false, isolated, false)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            String msg &#x3D; &quot;&quot;</span><br><span class="line">            bringDownServiceLocked(r); &#x2F;&#x2F; 进程启动失败</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isolated) &#123;</span><br><span class="line">            r.isolatedProc &#x3D; app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        r.delayedStop &#x3D; false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r); &#x2F;&#x2F;停止服务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当目标进程已存在，则直接执行realStartServiceLocked()；</li>
<li>当目标进程不存在，则先执行<a href="http://gityuan.com/2016/10/09/app-process-create-2/" target="_blank" rel="noopener">startProcessLocked</a>创建进程， 经过层层调用最后会调用到AMS.attachApplicationLocked, 然后再执行realStartServiceLocked()。</li>
</ul>
<p>对于非前台进程调用而需要启动的服务，如果已经有其他的后台服务正在启动中，那么我们可能希望延迟其启动。这是用来避免启动同时启动过多的进程(非必须的)。</p>
<h4 id="9-1-AMS-attachApplicationLocked"><a href="#9-1-AMS-attachApplicationLocked" class="headerlink" title="9.1 AMS.attachApplicationLocked"></a>9.1 AMS.attachApplicationLocked</h4><p>[-&gt; ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123;</span><br><span class="line">    ...</span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">            profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">            app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class="line">            isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">            new Configuration(mConfiguration), app.compat,</span><br><span class="line">            getCommonServicesLocked(app.isolated),</span><br><span class="line">            mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (!badApp) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;寻找所有需要在该进程中运行的服务 【见流程9.2】</span><br><span class="line">            didSomething |&#x3D; mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-AS-attachApplicationLocked"><a href="#9-2-AS-attachApplicationLocked" class="headerlink" title="9.2 AS.attachApplicationLocked"></a>9.2 AS.attachApplicationLocked</h4><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord proc, String processName) throws RemoteException &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;启动mPendingServices队列中，等待在该进程启动的服务</span><br><span class="line">    if (mPendingServices.size() &gt; 0) &#123;</span><br><span class="line">        ServiceRecord sr &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i&#x3D;0; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr &#x3D; mPendingServices.get(i);</span><br><span class="line">                if (proc !&#x3D; sr.isolatedProc &amp;&amp; (proc.uid !&#x3D; sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                &#x2F;&#x2F; 将当前服务的包信息加入到proc</span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                &#x2F;&#x2F; 启动服务，即将进入服务的生命周期 【见流程10】</span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Exception in new application when starting service &quot;</span><br><span class="line">                    + sr.shortName, e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对于正在等待重启并需要运行在该进程的服务，现在是启动它们的大好时机</span><br><span class="line">    if (mRestartingServices.size() &gt; 0) &#123;</span><br><span class="line">        ServiceRecord sr &#x3D; null;</span><br><span class="line">        for (int i&#x3D;0; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line">            sr &#x3D; mRestartingServices.get(i);</span><br><span class="line">            if (proc !&#x3D; sr.isolatedProc &amp;&amp; (proc.uid !&#x3D; sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当需要创建新进程,则创建后经历过attachApplicationLocked,则会再调用realStartServiceLocked();</li>
<li>当不需要创建进程, 即在[流程9]中直接就进入了realStartServiceLocked();</li>
</ul>
<h3 id="10-AS-realStartServiceLocked"><a href="#10-AS-realStartServiceLocked" class="headerlink" title="10. AS.realStartServiceLocked"></a>10. AS.realStartServiceLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    r.app &#x3D; app;</span><br><span class="line">    r.restartTime &#x3D; r.lastActivity &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">    final boolean newService &#x3D; app.services.add(r);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送delay消息【见流程10.1】</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">    mAm.updateLruProcessLocked(app, false, null);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line">    boolean created &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        &#x2F;&#x2F;服务进入 onCreate() 【见流程11】</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created &#x3D; true;</span><br><span class="line">    &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app); &#x2F;&#x2F;应用死亡处理</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!created) &#123;</span><br><span class="line">            final boolean inDestroying &#x3D; mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            if (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;尝试重新启动服务</span><br><span class="line">            if (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">    updateServiceClientActivitiesLocked(app, null, true);</span><br><span class="line"></span><br><span class="line">    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                null, null));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;服务 进入onStartCommand() 【见流程17】</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line">    if (r.delayed) &#123;</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (r.delayedStop) &#123;</span><br><span class="line">        r.delayedStop &#x3D; false;</span><br><span class="line">        if (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r); &#x2F;&#x2F;停止服务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在bumpServiceExecutingLocked会发送一个延迟处理的消息SERVICE_TIMEOUT_MSG。在方法scheduleCreateService执行完成，也就是onCreate回调执行完成之后，便会remove掉该消息。但是如果没能在延时时间之内remove该消息，则会进入执行service timeout流程。</p>
<h4 id="10-1-AS-bumpServiceExecutingLocked"><a href="#10-1-AS-bumpServiceExecutingLocked" class="headerlink" title="10.1 AS.bumpServiceExecutingLocked"></a>10.1 AS.bumpServiceExecutingLocked</h4><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) &#123;</span><br><span class="line">    long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">    if (r.executeNesting &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        r.executeFg &#x3D; fg;</span><br><span class="line">        ...</span><br><span class="line">        if (r.app !&#x3D; null) &#123;</span><br><span class="line">            r.app.executingServices.add(r);</span><br><span class="line">            r.app.execServicesFg |&#x3D; fg;</span><br><span class="line">            if (r.app.executingServices.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (r.app !&#x3D; null &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line">        r.app.execServicesFg &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;[见流程10.2]</span><br><span class="line">        scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line">    r.executeFg |&#x3D; fg;</span><br><span class="line">    r.executeNesting++;</span><br><span class="line">    r.executingStart &#x3D; now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-scheduleServiceTimeoutLocked"><a href="#10-2-scheduleServiceTimeoutLocked" class="headerlink" title="10.2 scheduleServiceTimeoutLocked"></a>10.2 scheduleServiceTimeoutLocked</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123;</span><br><span class="line">    if (proc.executingServices.size() &#x3D;&#x3D; 0 || proc.thread &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">    Message msg &#x3D; mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj &#x3D; proc;</span><br><span class="line">    &#x2F;&#x2F;当超时后仍没有remove该SERVICE_TIMEOUT_MSG消息，则执行service Timeout流程</span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">            proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送延时消息SERVICE_TIMEOUT_MSG,延时时长：</p>
<ul>
<li>对于前台服务，则超时为SERVICE_TIMEOUT，即timeout=20s；</li>
<li>对于后台服务，则超时为SERVICE_BACKGROUND_TIMEOUT，即timeout=200s；</li>
</ul>
<h3 id="11-ATP-scheduleCreateService"><a href="#11-ATP-scheduleCreateService" class="headerlink" title="11. ATP.scheduleCreateService"></a>11. ATP.scheduleCreateService</h3><p>[-&gt; ApplicationThreadProxy.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    info.writeToParcel(data, 0);</span><br><span class="line">    compatInfo.writeToParcel(data, 0);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;【见流程12】</span><br><span class="line">        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY);</span><br><span class="line">    &#125; catch (TransactionTooLargeException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-目标进程端"><a href="#四-目标进程端" class="headerlink" title="四. 目标进程端"></a>四. 目标进程端</h2><p>借助于ATP/ATN这对Binder对象，便完成了从system_server所在进程到Service所在进程调用过程</p>
<h3 id="12-ATN-onTransact"><a href="#12-ATN-onTransact" class="headerlink" title="12. ATN.onTransact"></a>12. ATN.onTransact</h3><p>[-&gt; ApplicationThreadNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">    case SCHEDULE_CREATE_SERVICE_TRANSACTION: &#123;</span><br><span class="line">        data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">        IBinder token &#x3D; data.readStrongBinder();</span><br><span class="line">        ServiceInfo info &#x3D; ServiceInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        CompatibilityInfo compatInfo &#x3D; CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        int processState &#x3D; data.readInt();</span><br><span class="line">        &#x2F;&#x2F; 【见流程13】</span><br><span class="line">        scheduleCreateService(token, info, compatInfo, processState);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-AT-scheduleCreateService"><a href="#13-AT-scheduleCreateService" class="headerlink" title="13. AT.scheduleCreateService"></a>13. AT.scheduleCreateService</h3><p>[-&gt; ApplicationThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    CreateServiceData s &#x3D; new CreateServiceData(); &#x2F;&#x2F;准备服务创建所需的数据</span><br><span class="line">    s.token &#x3D; token;</span><br><span class="line">    s.info &#x3D; info;</span><br><span class="line">    s.compatInfo &#x3D; compatInfo;</span><br><span class="line">    &#x2F;&#x2F;发送消息 【见流程14】</span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的执行在ActivityThread线程</p>
<h4 id="14-handleMessage"><a href="#14-handleMessage" class="headerlink" title="14. handleMessage"></a>14. handleMessage</h4><p>[-&gt; ActivityThread.java ::H]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case CREATE_SERVICE:</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj); &#x2F;&#x2F;【见流程15】</span><br><span class="line">            break;</span><br><span class="line">        case BIND_SERVICE:</span><br><span class="line">            handleBindService((BindServiceData)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case UNBIND_SERVICE:</span><br><span class="line">            handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">            break;</span><br><span class="line">        case SERVICE_ARGS:</span><br><span class="line">            handleServiceArgs((ServiceArgsData)msg.obj);  &#x2F;&#x2F; serviceStart</span><br><span class="line">            break;</span><br><span class="line">        case STOP_SERVICE:</span><br><span class="line">            handleStopService((IBinder)msg.obj);</span><br><span class="line">            maybeSnapshot();</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-AT-handleCreateService"><a href="#15-AT-handleCreateService" class="headerlink" title="15. AT.handleCreateService"></a>15. AT.handleCreateService</h3><p>[-&gt; ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">    &#x2F;&#x2F;当应用处于后台即将进行GC，而此时被调回到活动状态，则跳过本次gc。</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    LoadedApk packageInfo &#x3D; getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    java.lang.ClassLoader cl &#x3D; packageInfo.getClassLoader();</span><br><span class="line">    &#x2F;&#x2F;通过反射创建目标服务对象</span><br><span class="line">    Service service &#x3D; (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;创建ContextImpl对象</span><br><span class="line">        ContextImpl context &#x3D; ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        &#x2F;&#x2F;创建Application对象</span><br><span class="line">        Application app &#x3D; packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        &#x2F;&#x2F;调用服务onCreate()方法 【见流程15.1】</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        &#x2F;&#x2F;调用服务创建完成【见流程16】</span><br><span class="line">        ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-1-Service-onCreate"><a href="#15-1-Service-onCreate" class="headerlink" title="15.1 Service.onCreate"></a>15.1 Service.onCreate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Service extends ContextWrapper implements ComponentCallbacks2 &#123;</span><br><span class="line">    public void onCreate()&#123;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用Service.onCreate()方法，对于目标服务都是继承于Service，并覆写该方式，调用目标服务的onCreate()方法。拨云见日，到此总算是进入了Service的生命周期。</p>
<h3 id="16-AMS-serviceDoneExecuting"><a href="#16-AMS-serviceDoneExecuting" class="headerlink" title="16 AMS.serviceDoneExecuting"></a>16 AMS.serviceDoneExecuting</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; [见流程16.1]</span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由[流程10.1]的bumpServiceExecutingLocked()发送一个延时消息SERVICE_TIMEOUT_MSG</p>
<h4 id="16-1-AS-serviceDoneExecutingLocked"><a href="#16-1-AS-serviceDoneExecutingLocked" class="headerlink" title="16.1 AS.serviceDoneExecutingLocked"></a>16.1 AS.serviceDoneExecutingLocked</h4><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123;</span><br><span class="line">    boolean inDestroying &#x3D; mDestroyingServices.contains(r);</span><br><span class="line">    if (r !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        &#x2F;&#x2F; [见流程16.2]</span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-2-serviceDoneExecutingLocked"><a href="#16-2-serviceDoneExecutingLocked" class="headerlink" title="16.2 serviceDoneExecutingLocked"></a>16.2 serviceDoneExecutingLocked</h4><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123;</span><br><span class="line">    r.executeNesting--;</span><br><span class="line">    if (r.executeNesting &lt;&#x3D; 0) &#123;</span><br><span class="line">        if (r.app !&#x3D; null) &#123;</span><br><span class="line">            r.app.execServicesFg &#x3D; false;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            if (r.app.executingServices.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;移除服务启动超时的消息</span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">            &#125; else if (r.executeFg) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            if (inDestroying) &#123;</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        r.executeFg &#x3D; false;</span><br><span class="line">        ...</span><br><span class="line">        if (finishing) &#123;</span><br><span class="line">            if (r.app !&#x3D; null &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">            &#125;</span><br><span class="line">            r.app &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleCreateService()执行后便会移除服务启动超时的消息SERVICE_TIMEOUT_MSG。 Service启动过程出现ANR，”executing service [发送超时serviceRecord信息]”， 这往往是service的onCreate()回调方法执行时间过长。</p>
<p>前面小节[10]realStartServiceLocked方法在完成onCreate操作,解析来便是进入onStartCommand方法. 见下文.</p>
<h3 id="17-AS-sendServiceArgsLocked"><a href="#17-AS-sendServiceArgsLocked" class="headerlink" title="17. AS.sendServiceArgsLocked"></a>17. AS.sendServiceArgsLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) throws TransactionTooLargeException &#123;</span><br><span class="line">    final int N &#x3D; r.pendingStarts.size();</span><br><span class="line">    if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (r.pendingStarts.size() &gt; 0) &#123;</span><br><span class="line">        Exception caughtException &#x3D; null;</span><br><span class="line">        ServiceRecord.StartItem si;</span><br><span class="line">        try &#123;</span><br><span class="line">            si &#x3D; r.pendingStarts.remove(0);</span><br><span class="line">            if (si.intent &#x3D;&#x3D; null &amp;&amp; N &gt; 1) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            si.deliveredTime &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            r.deliveredStarts.add(si);</span><br><span class="line">            si.deliveryCount++;</span><br><span class="line">            if (si.neededGrants !&#x3D; null) &#123;</span><br><span class="line">                mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                        si.getUriPermissionsLocked());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;标记启动开始【见10.1】</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);</span><br><span class="line">            if (!oomAdjusted) &#123;</span><br><span class="line">                oomAdjusted &#x3D; true;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line">            int flags &#x3D; 0;</span><br><span class="line">            if (si.deliveryCount &gt; 1) &#123;</span><br><span class="line">                flags |&#x3D; Service.START_FLAG_RETRY;</span><br><span class="line">            &#125;</span><br><span class="line">            if (si.doneExecutingCount &gt; 0) &#123;</span><br><span class="line">                flags |&#x3D; Service.START_FLAG_REDELIVERY;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;该过程类似[流程11~16]，最终会调用onStartCommand</span><br><span class="line">            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            caughtException &#x3D; e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (caughtException !&#x3D; null) &#123;</span><br><span class="line">            final boolean inDestroying &#x3D; mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            if (caughtException instanceof TransactionTooLargeException) &#123;</span><br><span class="line">                throw (TransactionTooLargeException)caughtException;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[流程10]中的AS.realStartServiceLocked的过程先后依次执行如下方法：</p>
<ul>
<li>执行scheduleCreateService()方法，层层调用最终回调Service.onCreate(); [见流程11~16]</li>
<li>执行scheduleServiceArgs()方法，层层调用最终回调Service.onStartCommand(); [见流程17]，这两个过程类似，此处省略。</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><h3 id="5-1-流程说明"><a href="#5-1-流程说明" class="headerlink" title="5.1 流程说明"></a>5.1 流程说明</h3><p>在整个startService过程，从进程角度看服务启动过程</p>
<ul>
<li><strong>Process A进程：</strong>是指调用startService命令所在的进程，也就是启动服务的发起端进程，比如点击桌面App图标，此处Process A便是Launcher所在进程。</li>
<li><strong>system_server进程：</strong>系统进程，是java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的，每个进程binder线程个数的上限为16。</li>
<li><strong>Zygote进程：</strong>是由<code>init</code>进程孵化而来的，用于创建Java层进程的母体，所有的Java层进程都是由Zygote进程孵化而来；</li>
<li><strong>Remote Service进程：</strong>远程服务所在进程，是由Zygote进程孵化而来的用于运行Remote服务的进程。主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），当然还有其他线程，这里不是重点就不提了。</li>
</ul>
<p><img src="http://gityuan.com/images/android-service/start_service/start_service_processes.jpg" alt="start_service_process"></p>
<p>图中涉及3种IPC通信方式：<code>Binder</code>、<code>Socket</code>以及<code>Handler</code>，在图中分别用3种不同的颜色来代表这3种通信方式。一般来说，同一进程内的线程间通信采用的是 <a href="http://gityuan.com/2015/12/26/handler-message/" target="_blank" rel="noopener">Handler消息队列机制</a>，不同进程间的通信采用的是<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">binder机制</a>，另外与Zygote进程通信采用的<code>Socket</code>。</p>
<p>启动流程：</p>
<ol>
<li>Process A进程采用Binder IPC向system_server进程发起startService请求；</li>
<li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li>
<li>zygote进程fork出新的子进程Remote Service进程；</li>
<li>Remote Service进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li>
<li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向remote Service进程发送scheduleCreateService请求；</li>
<li>Remote Service进程的binder线程在收到请求后，通过handler向主线程发送CREATE_SERVICE消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Service，并回调Service.onCreate()方法。</li>
</ol>
<p>到此，服务便正式启动完成。当创建的是本地服务或者服务所属进程已创建时，则无需经过上述步骤2、3，直接创建服务即可。</p>
<h3 id="5-2-生命周期"><a href="#5-2-生命周期" class="headerlink" title="5.2 生命周期"></a>5.2 生命周期</h3><p>startService的生命周期为onCreate, onStartCommand, onDestroy,流程如下图: <a href="http://www.gityuan.com/images/ams/service_lifeline.jpg" target="_blank" rel="noopener">点击查看大图</a></p>
<p><img src="http://gityuan.com/images/ams/service_lifeline.jpg" alt="service_lifeline"></p>
<p>由上图可见,造成ANR可能的原因有Binder full{step 7, 12}, MessageQueue(step 10), AMS Lock (step 13).</p>
<p>当进程启动Service其所在进程还没有启动时, 需要先启动其目标进程,流程如下图: <a href="http://www.gityuan.com/images/ams/start_service_process.jpg" target="_blank" rel="noopener">点击查看大图</a></p>
<p><img src="http://gityuan.com/images/ams/start_service_process.jpg" alt="start_service_process"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
