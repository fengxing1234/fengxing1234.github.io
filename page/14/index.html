<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/14/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Java/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="url">Java面试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>​        面向对象简称OO（Object Oriented），一种基于面向过程的新思想，该思想就是站在对象的角度思考问题，把多个功能合理的放在不同的对象中，强调的是具备某些功能的对象。</p>
<p>​        具备某种功能的实体，称之为对象。面向对象最小的程序单位是<strong>类</strong>。面向对象更加符合常规的思维方式<strong>稳定性好，可重用性强，有良好的可重用性</strong>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>所谓对象就是真实世界的实体，对象与实体一一对应，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>java中面向对象的三大特性：封装、继承、多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>隐藏内部实现，提供公共方法进行访问</strong>。所谓封装就是把数据和操作数据的方法封装起来，对数据的访问和操作只能通过已定义的接口进行访问。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类拥有父类的特征和行为，并可以对父类进行扩展。形容类的关系。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一种类型的对象，执行相同方法，有不同的表现。</p>
<p><strong>多态的必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>向上转型</li>
</ul>
<p><strong>向上转型</strong></p>
<p>父类指向子类的引用</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><p>JVM由三个主要的子系统构成：</p>
<ul>
<li>类加载子系统：负责加载类或者接口</li>
<li>运行时数据去（内存结构）：包含方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器</li>
<li>执行引擎：负责执行包含在已装载的类或接口中的指令</li>
</ul>
<h3 id="类加载系统"><a href="#类加载系统" class="headerlink" title="类加载系统"></a>类加载系统</h3><p><a href="https://zhuanlan.zhihu.com/p/54693308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54693308</a></p>
<h4 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h4><p>答：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>类的生命周期包括加载、连接、初始化、使用和卸载。</p>
<ul>
<li><p>加载：查找并加载类的二进制数据，并在堆内存中创建对象。</p>
</li>
<li><p>连接：连接又分为三步：验证、准备、解析</p>
<ul>
<li>验证：验证文件格式、元数据、字节码、符号引用。</li>
<li>准备：为类的静态变量分配内存并初始化默认值。</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li><p>初始化：为类的静态变量赋予正确的初始值</p>
</li>
<li><p>使用：new出对象程序中使用</p>
</li>
<li><p>卸载：执行垃圾回收</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="https://img-blog.csdnimg.cn/20190603164758648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li>
<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li>
</ul>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。双亲委派模型能保证基础类仅加载一次，不会让jvm中存在重名的类。</p>
<h5 id="ExtClassLoader为什么没有设置parent？"><a href="#ExtClassLoader为什么没有设置parent？" class="headerlink" title="ExtClassLoader为什么没有设置parent？"></a>ExtClassLoader为什么没有设置parent？</h5><p>因为BootstrapClassLoader是由c++实现的，所以并不存在一个Java的类。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="https://img-blog.csdnimg.cn/20190603165013168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>方法区和堆是<strong>所有线程共享</strong>的内存区域；而java栈、本地方法栈和程序计数器是<strong>运行时线程私有</strong>的内存区域。</p>
<p>JVM把内存划分成了如下几个区域：</p>
<ul>
<li><p>堆区（Heap）：存放<strong>通过new创建的对象实例</strong>，容易OutOfMemoryEroor。</p>
</li>
<li><p>方法区（Method Area）：存放类的信息（字段和方法的字节码、构造函数、接口定义等）、静态变量，常量，运行时常量池。</p>
</li>
<li><p>虚拟机栈（VM Stack）：用于存储局部变量表、操作数栈、动态链接、方法出口等。只要线程已结束栈就出栈，生命周期与线程一致，其内存管理如下：</p>
<ul>
<li>方法中的基础数据类型直接在栈空间分配</li>
<li>方法中的引用数据类型，需要new来创建，既在栈中分配空间，也在堆中分配对象，栈中的地址指向堆内对象</li>
<li>方法的形式参数直接在栈空间分配，方法调用完毕在栈空间回收</li>
<li>方法中的引用参数，在栈中分配空间指向堆中对象，方法执行完毕回收栈空间。</li>
<li>字符串常量,static静态变量在方法区分配空间。</li>
</ul>
</li>
<li><p>本地方法栈（Native Method Stack）：可理解为java中jni调用。用于支持native方法执行</p>
</li>
<li><p>程序计数器（Program Counter Register）：每个方法在运行时都存储着一个独立的程序计数器，程序计数器是指定程序运行的行数指针。</p>
</li>
</ul>
<h3 id="Object-o-new-Object"><a href="#Object-o-new-Object" class="headerlink" title="Object o=new Object()"></a>Object o=new Object()</h3><p><img src="https://pic4.zhimg.com/80/v2-eddc430b991c58039dfc79dd6f3139cc_1440w.jpg" alt="img"></p>
<h3 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h3><p><img src="https://img-blog.csdnimg.cn/20190604161655494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>内存分为:</p>
<ul>
<li>新生代(<strong>1/3堆空间</strong>)<ul>
<li>Eden(伊甸园区)</li>
<li>Survivor From（幸存者区）</li>
<li>Survivor To（幸存者区）</li>
</ul>
</li>
<li>老年代(<strong>2/3堆空间</strong>)</li>
<li>持久代。(<strong>直接内存JDK1.8后</strong>)</li>
</ul>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代中98%的对象都是”朝生夕死”的，所以并不需要按照1 : 1的比例来划分内存空间，而是将内存(新生代内存)分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间（8:1:1），每次使用Eden和其中一块Survivor（两个Survivor区域一个称为From区，另一个称为To区域）。</p>
<p><strong>当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。(复制算法)</strong></p>
<p>HotSpot实现的复制算法流程如下:</p>
<ul>
<li><p>当Eden区满的时候,会触发第一次Minor gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。</p>
</li>
<li><p>当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。</p>
</li>
<li><p>部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p>
</li>
</ul>
<p>也有例外出现，对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生。</p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象。</p>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>不属于堆内存，属于内存空间。真正与堆隔离。方法区是类逻辑上的一个抽象模板，而元空间是<strong>方法区的实现</strong>，是真实存在的内存。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul>
<li><p>虚拟机在进行MinorGC（新生代的GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC。</p>
</li>
<li><p>刚分配对象在Eden中，如果空间不足尝试进行GC，回收空间，如果进行了MinorGC空间依旧不够就放入Old Generation，如果OldGeneration空间还不够就OOM了。</p>
</li>
<li><p>比较大的对象，数组等，大于某值（可配置）就直接分配到老年代，（避免频繁内存拷贝）</p>
</li>
<li><p>年轻代和年老代属于Heap空间的，Permanent Generation（永久代）可以理解成方法区，（它属于方法区）也有可能发生GC，例如类的实例对象全部被GC了，同时它的类加载器也被GC掉了，这个时候就会触发永久代中对象的GC。</p>
</li>
<li><p>如果OldGeneration满了就会产生FullGC。老年代满原因：</p>
<ul>
<li>1、from survive中对象的生命周期到一定阈值</li>
<li>2、分配的对象直接是大对象</li>
<li>3、由于To 空间不够，进行GC直接把对象拷贝到年老代（年老代GC时候采用不同的算法）</li>
</ul>
</li>
<li><p>如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的时候速度是远远低于Young Generation回收速度。</p>
</li>
</ul>
<h4 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h4><ul>
<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值对象进入老年区。</li>
<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<h1 id="Java中的堆栈"><a href="#Java中的堆栈" class="headerlink" title="Java中的堆栈"></a>Java中的堆栈</h1><p><strong>栈内存</strong></p>
<p>在函数中定义的基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</p>
<p>当在一段代码块中声明了一个变量时，java就会在栈内存中为这个变量分配内存空间，当超过变量的作用域之后，java也会自动释放为该变量分配的空间，而这个回收的空间可以即刻用作他用。</p>
<p><strong>堆内存</strong></p>
<p>堆内存用于存放由new创建的对象和数组。</p>
<p>在堆内存中分配的内存空间，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，变量的值就等于数组或对象在堆内存中的首地址，而这个栈中的特殊变量，也就成为数组或对象的引用变量。以后可以在程序中使用栈内存中的引用变量访问堆内存中的数组或对象了。引用变量相当于是为数组或对象起的一个别名，或者是代号。</p>
<p>数组和对象在没有引用变量指向它的时候，才变成垃圾，不能被继续使用，但是仍然会占用堆内存空间，而后在一个不确定的时间内，由java虚拟机自动垃圾回收器回收，这也是java程序为什么会占用很大内存的原因。</p>
<h1 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h1><ul>
<li>垃圾：无任何对象引用的对象。</li>
<li>回收：清理“垃圾”占用的内存空间而非对象本身。</li>
<li>发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。</li>
<li>发生时间：程序空闲时间不定时回收。</li>
</ul>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><h3 id="创建阶段-Created"><a href="#创建阶段-Created" class="headerlink" title="创建阶段(Created)"></a>创建阶段(Created)</h3><p>在创建阶段系统通过下面的几个步骤来完成对象的创建过程：</p>
<ul>
<li><p>为对象分配存储空间</p>
<ul>
<li>开始构造对象</li>
<li>从超类到子类对static成员进行初始化</li>
<li>超累成员变量按顺序初始化，递归调用超累的构造方法</li>
<li>子类成员变量按顺序初始化，子类构造方法调用</li>
</ul>
</li>
<li><p>应用阶段(In Use)：对象至少被一个强引用持有。</p>
</li>
<li><p>不可见阶段(Invisible)：简单说就是程序的执行已经超出了该对象的作用域了。</p>
</li>
<li><p>不可达阶段(Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。</p>
</li>
<li><p>收集阶段(Collected)：</p>
</li>
<li><p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)：当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ul>
<h2 id="判断对象是否是垃圾算法"><a href="#判断对象是否是垃圾算法" class="headerlink" title="判断对象是否是垃圾算法"></a>判断对象是否是垃圾算法</h2><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<h4 id="根搜索算法（可达性分析算法）"><a href="#根搜索算法（可达性分析算法）" class="headerlink" title="根搜索算法（可达性分析算法）"></a>根搜索算法（可达性分析算法）</h4><p><img src="https://upload-images.jianshu.io/upload_images/4118241-bdc59e28c5775caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从一个GC ROOT节点开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<p><strong>所谓的GC根对象包括：</strong></p>
<ul>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常亮引用的对象</li>
<li>本地方法栈中引用的对象（Native对象）</li>
</ul>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-整理算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h3><p>标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象（<strong>这一过程在可达性分析过程中进行</strong>），标记完成之后统一清除对象。</p>
<p><strong>它的主要缺点：</strong></p>
<ul>
<li>标记和清除过程效率不高 。</li>
<li>标记清除之后会产生大量不连续的内存碎片。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-ab33b8257a3ed8bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记整理，标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。</p>
<p>主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-e02d7d3ebf1d75af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="复制算法-新生代算法"><a href="#复制算法-新生代算法" class="headerlink" title="复制算法(新生代算法)"></a>复制算法(新生代算法)</h3><p>复制算法，它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-98d9dff8f994e8bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p>
<h3 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h3><p>串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序（单CPU、新生代空间较小及对暂停时间要求不是非常高的应用）。是client级别默认的GC方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20190605151624561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h3><p>并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，当执行垃圾回收的时候它也会冻结所有的应用程序线程。</p>
<h3 id="并发标记扫描垃圾回收器"><a href="#并发标记扫描垃圾回收器" class="headerlink" title="并发标记扫描垃圾回收器"></a>并发标记扫描垃圾回收器</h3><p>并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。<br>（1）当标记的引用对象在Tenured区域；<br>（2）在进行垃圾回收的时候，堆内存的数据被并发的改变。<br>相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。</p>
<h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>JVM调优，调的是什么？<br>每一次Full GC都会使JVM停止运行–&gt;使Full GC不执行，使Minor GC尽可能少地执行</p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user&#x3D;0.17 sys&#x3D;0.08, real&#x3D;0.07 secs]</span><br><span class="line"></span><br><span class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user&#x3D;1.75 sys&#x3D;0.02, real&#x3D;0.68 secs]</span><br></pre></td></tr></table></figure>

<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p><img src="https://img-blog.csdnimg.cn/20190603181024771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190603181041398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h3><ul>
<li><strong>不要显式调用System.gc()</strong>：此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</li>
<li><strong>尽量减少临时对象的使用</strong>：临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</li>
<li><strong>对象不用时最好显式置为Null</strong>：一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</li>
<li><strong>尽量使用StringBuffer,而不用String来累加字符串</strong>：由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</li>
<li><strong>能用基本类型如Int,Long,就不用Integer,Long对象</strong>：基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</li>
<li><strong>尽量少用静态对象变量</strong></li>
<li>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</li>
<li><strong>分散对象创建或删除的时间</strong>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</li>
</ul>
<h2 id="Java代码编译和执行整个过程"><a href="#Java代码编译和执行整个过程" class="headerlink" title="Java代码编译和执行整个过程"></a>Java代码编译和执行整个过程</h2><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被类加载器装入内存，一旦字节码进入虚拟机，它就会被解释器（执行引擎）解释执行。</p>
<p><strong>步骤1：Java代码编译是由Java源码编译器来完成，也就是Java代码到JVM字节码（.class文件）的过程。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190605130338211.png" alt="在这里插入图片描述"></p>
<p><strong>步骤2：Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190605130355535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java代码编译和执行的整个过程包含了三个重要机制：</p>
<ul>
<li>Java源码编译机制</li>
<li>类加载机制</li>
<li>类执行机制</li>
</ul>
<h2 id="Java虚拟机和Dalvik虚拟机区别"><a href="#Java虚拟机和Dalvik虚拟机区别" class="headerlink" title="Java虚拟机和Dalvik虚拟机区别"></a>Java虚拟机和Dalvik虚拟机区别</h2><ul>
<li>java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</li>
<li>Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。</li>
<li>java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.</li>
</ul>
<h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><p><strong>基本数据类型</strong></p>
<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>char</li>
<li>float</li>
<li>double</li>
<li>boolean</li>
</ul>
<p><strong>引用数据类型</strong></p>
<ul>
<li>对象</li>
<li>数组</li>
</ul>
<p><img src="https://img-blog.csdn.net/20140531091306906" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190526183106748.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>区别:</strong></p>
<ul>
<li>基本数据类型保存的是值，引用类型保存的是内存地址</li>
<li>基本数据类型存储在栈中，引用数据类型首先在栈上给引用分配内存空间，对象的具体信息存储在堆中。</li>
<li>基本数据类型的赋值其实是创建新的拷贝，而引用类型的赋值是传递引用。</li>
<li>基本数据类型的==其实是比较值，而引用数据类型比较的是地址（引用）。</li>
<li>一个方法不能修改一个基本类型的参数；一个方法可以修改引用类型参数中对象所指向的值。</li>
</ul>
<p><a href="https://blog.csdn.net/javazejian/article/details/51192130?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5" target="_blank" rel="noopener">数据类型分析</a></p>
<p><strong>int与Integer不同</strong></p>
<ul>
<li>Integer是int的包装类，int则是java的一种基本数据类型</li>
<li>Integer变量必须实例化后才能使用，而int变量不需要</li>
<li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li>
<li>Integer的默认值是null，int的默认值是0</li>
</ul>
<p><strong>延伸：关于Integer和int的比较</strong></p>
<ul>
<li><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; new Integer(100);</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">int j &#x3D; 100；</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;public static Integer valueOf(int i)&#123;</span><br><span class="line">  assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">  if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">      return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  &#125;</span><br><span class="line">  return new Integer(i);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
<h2 id="数组与链表的区别"><a href="#数组与链表的区别" class="headerlink" title="数组与链表的区别"></a>数组与链表的区别</h2><ul>
<li>数组从栈中分配空间，对程序员方便快速，自由度小。</li>
<li>链表从堆中分配内存。自由度大但申请管理比较麻烦。</li>
<li>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减情况（数据插入、删除比较麻烦）。当数据增加时，可能会超出数组的最大空间（越界）；当数据减少时，造成内存浪费。</li>
<li>链表动态地进行存储分配，可以适应数据动态地增减情况（数据插入删除简单）（数组中插入、删除数据项时，需要移动其他项），但链表查找元素时需要遍历整个链表。</li>
</ul>
<h1 id="Java自动装箱与拆箱"><a href="#Java自动装箱与拆箱" class="headerlink" title="Java自动装箱与拆箱"></a>Java自动装箱与拆箱</h1><h2 id="什么是自动装箱、拆箱"><a href="#什么是自动装箱、拆箱" class="headerlink" title="什么是自动装箱、拆箱"></a>什么是自动装箱、拆箱</h2><p>装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h2 id="自动装箱的原理及使用场景"><a href="#自动装箱的原理及使用场景" class="headerlink" title="自动装箱的原理及使用场景"></a>自动装箱的原理及使用场景</h2><p>基本数据类型–&gt;封装类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10;</span><br></pre></td></tr></table></figure>

<p>执行时实际上系统执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; Integer.valueOf(10);</span><br></pre></td></tr></table></figure>

<p>分析Integer的valueOf源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if(i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; IntegerCache.high)　　&#x2F;&#x2F; 没有设置的话，IngegerCache.high 默认是127</span><br><span class="line">        return IntegerCache.cache[i + 128];</span><br><span class="line">    else</span><br><span class="line">        return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于–128到127（默认是127）之间的值，Integer.valueOf(int i) 返回的是缓存的Integer对象（并不是新建对象），而其他值，执行Integer.valueOf(int i) 返回的是一个新建的 Integer对象。装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响性能。</p>
<h2 id="自动拆箱的原理及使用场景"><a href="#自动拆箱的原理及使用场景" class="headerlink" title="自动拆箱的原理及使用场景"></a>自动拆箱的原理及使用场景</h2><p>封装类–&gt;基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10; &#x2F;&#x2F;装箱 </span><br><span class="line">int t &#x3D; i; &#x2F;&#x2F;拆箱，实际上执行了 int t &#x3D; i.intValue();</span><br></pre></td></tr></table></figure>

<p>进行运算时也可以进行拆箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10; </span><br><span class="line">System.out.println(i++);</span><br></pre></td></tr></table></figure>

<p>Integer与int运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 10;</span><br><span class="line">Integer integer1 &#x3D; new Integer(10); </span><br><span class="line">System.out.println(i&#x3D;&#x3D;integer1);&#x2F;&#x2F;true,integer1自动拆箱</span><br></pre></td></tr></table></figure>

<p>intValue函数很简单，直接返回value值即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int intValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h1><ul>
<li>final类说明是一个不可变对象</li>
<li>内部使用value[]数组实现</li>
<li>声明int类型hash</li>
</ul>
<p><strong>==与equals()</strong></p>
<p>答：</p>
<ul>
<li><p>==</p>
<ul>
<li>若操作数的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的值是否相等</li>
<li>若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。        </li>
</ul>
</li>
<li><p>equals</p>
<ul>
<li>在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</li>
<li>但是一般像String就重写了equels方法。</li>
</ul>
</li>
</ul>
<p><strong>定义为String类型的st1和st2是否相等，为什么</strong></p>
<p>答：常量池个特点，如果发现已经存在，就不在创建重复的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;abc&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2)); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：true</span><br><span class="line"></span><br><span class="line">第二行：true</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180409133349472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NDE5NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>内存过程：</p>
<ol>
<li>运行编译，当前类class文件加载进方法区</li>
<li>方法main压栈</li>
<li>常量池创建“abc”对象，产生一个内存地址</li>
<li>然后把内存地址执行st1，st1根据内存地址，指向了常量池中的“abc”。</li>
<li>当代码执行<code>Stringst2 =”abc”</code>,发现常量池中存在”abc”对象所以不会创建对象，直接把”abc”内存地址复制给st2。</li>
<li>最后st1和st2都指向了内存中同一个地址，所以两者是完全相同的。</li>
</ol>
<p><strong>下面这句话在内存中创建了几个对象</strong></p>
<p><code>String st1 = new String(“abc”);</code></p>
<p>答：两个对象。一个是常量池“abc”对象，一个是堆内存String对象。</p>
<p><img src="https://img-blog.csdn.net/20180409133238683?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NDE5NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>判定以下定义为String类型的st1和st2是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：false true</p>
<ul>
<li>==比较的是地址值，st1指向堆内存中的string对象，st2指向常量池的‘abc’对象。</li>
<li>equals默认也是比较地址值，但是String类中重写了此方法，实际比较的是值。（首先比较地址）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString &#x3D; (String)anObject;</span><br><span class="line">            int n &#x3D; length();</span><br><span class="line">            if (n &#x3D;&#x3D; anotherString.length()) &#123;</span><br><span class="line">                int i &#x3D; 0;</span><br><span class="line">                while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                    if (charAt(i) !&#x3D; anotherString.charAt(i))</span><br><span class="line">                            return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>判定以下定义为String类型的st1和st2是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：true 和 true</p>
<blockquote>
<p>“a”,”b”,”c”三个本来就是字符串常量，进行+符号拼接之后变成了“abc”，“abc”本身就是字符串常量（Java中有常量优化机制），所以常量池立马会创建一个“abc”的字符串常量对象，在进行st2=”abc”,这个时候，常量池存在“abc”，所以不再创建。所以，不管比较内存地址还是比较字符串序列，都相等。</p>
</blockquote>
<p><strong>判断以下st2和st3是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;ab&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     String st3 &#x3D; st1 + &quot;c&quot;;</span><br><span class="line">     System.out.println(st2 &#x3D;&#x3D; st3);</span><br><span class="line">     System.out.println(st2.equals(st3));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：false 和 true</p>
<blockquote>
<p>s1和s2都会在常量池中创建对象，st3在编译时期不能确定st3的值，只能在运行期间确定<code>st3=&quot;abc&quot;</code>,在运行期间就只能放在堆内存中。所以不是同一个引用。</p>
</blockquote>
<h1 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h1><p><img src="https://img-blog.csdnimg.cn/20190526180828781.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>不可变对象即对象一旦创建它的状态就不能发生改变（对象的数据，属性值），反之即为可变对象。</p>
<p>不可变对象的类即为不可变类，String、基本类型的包装类、BigInteger和BigDecimal等都是不可变类。</p>
<p><strong>不可变的对象必须满足的条件</strong></p>
<ul>
<li>将类声明为final</li>
<li>声明属性为private 和 final</li>
<li>不要提供任何会修改对象状态的方法</li>
</ul>
<p><strong>改变”不可变对象”</strong></p>
<p>现在我们已经知道了String的成员变量是private final 的，也就是初始化之后不可改变的。同时也提到value这个成员变量其实也是一个引用，指向真正的数组内存地址，不能改变它的引用指向，我们能不能直接改变内存数组中的数据呢，那么就需要获取到value，而value是私有的，可用反射获取</p>
<h1 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h1><p>java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p>
<ul>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li>
<li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。</p>
<p>序列化的作用就是为了保存java的类对象的状态，并将对象转换成可存储或者可传输的状态，用于不同jvm之间进行类实例间的共享。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>实现序列化的两种方式：</p>
<ul>
<li>实现Serializable接口：Java专用</li>
<li>实现Parcelable接口：Android专用</li>
</ul>
<h3 id="Serializable-和Parcelable的对比"><a href="#Serializable-和Parcelable的对比" class="headerlink" title="Serializable 和Parcelable的对比"></a>Serializable 和Parcelable的对比</h3><p>Android上应该尽量采用Parcelable，效率至上,Parcelable的速度比高十倍以上。</p>
<p><strong>Serializable</strong>的迷人之处在于你只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<p><strong>Parcelable</strong>方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>定义在类内部的类就被称为内部类。外部类按常规的类访问方式使用内部类，唯一的差别是内部类可以访问外部类的所有方法与属性，包括私有方法与属性。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>定义在类内部的静态类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public static class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner是静态内部类。静态内部类可以访问外部类所有静态变量和方法。静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out.Inner inner &#x3D; new Out.Inner();</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>



<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在类内部的非静态类称为成员内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和实例，私有和非私有。和静态内部类不同的是，每一个成员内部类的实例都依赖一个外部类的实例（成员内部类是依附外部类而存在的）。其它类使用内部类必须要先创建一个外部类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out out &#x3D; new Out();</span><br><span class="line">Out.Inner inner &#x3D; out.new Inner();</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>

<ul>
<li>成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</li>
<li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</li>
<li>成员内部类与外部类可以拥有同名的成员变量或方法，默认情况下访问的是成员内部类的成员。如果要外部类的同名成员，需用下面的形式访问：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutterClass(外部类).this.成员</span><br></pre></td></tr></table></figure>



<p><strong>为什么Java中成员内部类可以访问外部类成员？</strong></p>
<ul>
<li>成员内部类的创建需要外部类的对象</li>
<li>内部类对象持有指向外部类对象的引用。</li>
</ul>
<p><strong>静态内部类与成员内部类对比</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190528190801750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="局部内部类-amp-闭包"><a href="#局部内部类-amp-闭包" class="headerlink" title="局部内部类&amp;闭包"></a>局部内部类&amp;闭包</h3><p>定义在外部类方法中的类，叫局部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public void test(final int c) &#123;</span><br><span class="line">        final int d &#x3D; 1;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testStatic(final int c) &#123;</span><br><span class="line">        final int d &#x3D; 1;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                &#x2F;&#x2F;定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                &#x2F;&#x2F;System.out.println(b);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部类只能在定义该局部类的方法中使用。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。同时局部类还可以访问方法的参数和方法中的局部变量，这些参数和变量必须要声明为final的。否则会报错</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    private Object obj &#x3D; new Object() &#123;</span><br><span class="line">        private String name &#x3D; &quot;匿名内部类&quot;;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Object obj &#x3D; new Object() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String toString() &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                return String.valueOf(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类可以访问外部类所有的变量和方法。</p>
<h3 id="内部类特点"><a href="#内部类特点" class="headerlink" title="内部类特点"></a>内部类特点</h3><ul>
<li>非静态内部类对象不仅指向该内部类，还指向实例化该内部类的外部类对象的内存。</li>
<li>内部类和普通类一样可以重写Object类的方法，如toString方法；并且有构造函数，执行顺序依旧是先初始化属性，再执行构造函数</li>
<li>在编译完之后，会出现（外部类.class）和（外部类﹩内部类.class）两个类文件名。</li>
<li>内部类可以被修饰为private，只能被外部类所访问。事实上一般也都是如此书写。</li>
<li>内部类可以被写在外部类的任意位置，如成员位置，方法内。</li>
</ul>
<h4 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h4><ul>
<li>静态时，静态内部类只能访问外部类静态成员;非静态内部类都可以直接访问。（原因是：内部类有一个外部类名.this的指引）当访问外部类静态成员出现重名时，通过(外部类名.静态成员变量名)访问。如，Out.show();</li>
<li>重名情况下，非静态时，内部类访问自己内部类通过this.变量名。访问外部类通过（外部类名.this.变量名）访问 。如Out.this.show();</li>
<li>在没有重名的情况下，无论静态非静态，内部类直接通过变量名访问外部成员变量。</li>
</ul>
<h4 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h4><ul>
<li>内部类为非静态时，外部类访问内部类，必须建立内部类对象。建立对象方法，如前所述。</li>
<li>内部类为静态时，外部类访问非静态成员，通过（外部类对象名.内部类名.方法名）访问，如new Out().In.function();</li>
<li>内部类为静态时，外部类访问静态成员时，直接通过（外部类名.内部类名.方法名），如 Out.In.funchtion();</li>
<li>当内部类中定义了静态成员时，内部类必须是静态的；当外部静态方法访问内部类时，内部类也必须是静态的才能访问。</li>
</ul>
<h1 id="静态（static）"><a href="#静态（static）" class="headerlink" title="静态（static）"></a>静态（static）</h1><p>把一个变量声明为静态变量通常基于以下三个目的：</p>
<ul>
<li>作为共享变量</li>
<li>减少对象的创建</li>
<li>保留唯一副本</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul>
<li>静态变量在内存中只有一份拷贝，JVM只为静态分配一次内存，在类加载的过程中完成静态变量的内存分配。可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。</li>
<li>实例变量，每次创建实例，都会对实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</li>
</ul>
<h3 id="静态变量与实例变量区别"><a href="#静态变量与实例变量区别" class="headerlink" title="静态变量与实例变量区别"></a>静态变量与实例变量区别</h3><ul>
<li>所属不同，静态变量属于类，普通成员变量所有当前对象。</li>
<li>存储区域不同，静态变量存在方法区，普通成员变量存在堆（成员变量存储在堆中的对象里面）。</li>
<li>生命周期不同，静态变量生周期与类相同；普通成员变量与当前对象相同。</li>
<li>序列化时，静态变量会被拆除在外。</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法可以直接使用类名调用，静态方法中不能使用this、super，不能直接访问成员变量，成员方法，只能访问类下的静态变量、静态方法，因为实例成员和实例方法与当前对象关联，静态属于类。静态方法不能被抽象。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<h3 id="静态方法和静态代码块的区别"><a href="#静态方法和静态代码块的区别" class="headerlink" title="静态方法和静态代码块的区别"></a>静态方法和静态代码块的区别</h3><ul>
<li>如果有些代码必须在项目启动的时候就执行,就需要使用静态代码块,这种代码是主动执行的；</li>
<li>需要在项目启动的时候就初始化但是不执行,在不创建对象的情况下,可以供其他程序调用,而在调用的时候才执行，这需要使用静态方法,这种代码是被动执行的。 静态方法在类加载的时候 就已经加载 可以用类名直接调用。</li>
</ul>
<p>一句话：类加载时初始化，静态代码块是自动执行的；静态方法是被调用的时候才执行的。</p>
<h3 id="静态内部类和非静态内部类的区别"><a href="#静态内部类和非静态内部类的区别" class="headerlink" title="静态内部类和非静态内部类的区别"></a>静态内部类和非静态内部类的区别</h3><ul>
<li>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</li>
<li>非静态内部类会持有外部类的引用；静态内部类不会持有外部类的引用。</li>
</ul>
<h3 id="父类的静态方法能不能被子类重写"><a href="#父类的静态方法能不能被子类重写" class="headerlink" title="父类的静态方法能不能被子类重写"></a>父类的静态方法能不能被子类重写</h3><h4 id="重写-重载"><a href="#重写-重载" class="headerlink" title="重写/重载"></a>重写/重载</h4><ul>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</li>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li>
</ul>
<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。</p>
<p>在java中，所有的东西都是对象，对象的抽象就是类，对于一个类而言，如果要使用他的成员（类中的属性，方法等），一般情况下，必须先实例化对象后，通过对象的引用才能访问这些成员。但是，如果要使用的成员使用了static修饰，就可以不通过实例化获得该成员。</p>
<h4 id="父类的静态方法能不能被子类重写-1"><a href="#父类的静态方法能不能被子类重写-1" class="headerlink" title="父类的静态方法能不能被子类重写"></a>父类的静态方法能不能被子类重写</h4><p>不能</p>
<p>因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。</p>
<h1 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h1><p>异常知识体系树如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190530174605603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Error是程序代码无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止退出，其表示程序在运行期间出现了十分严重、不可恢复的错误，应用程序只能中止运行。</li>
<li>Exception分运行时异常和非运行时异常。<ul>
<li>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常也是不检查异常，程序代码中自行选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序代码应该从逻辑角度尽可能避免这类异常的发生。</li>
<li>所有继承Exception且不是RuntimeException的异常都是非运行时异常，也称检查异常，如上图中的IOException和ClassNotFoundException，编译器会对其作检查，故程序中一定会对该异常进行处理，处理方法要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。</li>
</ul>
</li>
</ul>
<h2 id="抛出异常的方式"><a href="#抛出异常的方式" class="headerlink" title="抛出异常的方式"></a>抛出异常的方式</h2><ul>
<li><p>使用 <code>throw</code> 抛出异常：throw<code>总是出现在**函数体**中，用来抛出一个</code>Throwable<code>类型的异常，例如抛出一个</code> <code>IOException</code> 类的异常对象。</p>
</li>
<li><p>使用 <code>throws</code> 抛出异常：如果一个方法可能会出现异常，但没有能力处理这种异常，可以在<strong>方法声明处</strong>用 <code>throws</code> 子句来声明抛出异常。</p>
</li>
</ul>
<p><strong>throw 和 throws 的区别？</strong></p>
<ul>
<li>throw用于方法内部，throws用于方法声明上</li>
<li>throw后跟异常对象，throws后跟异常类型</li>
<li>throw后只能跟一个异常对象，throws后可以一次声明多种异常类型</li>
</ul>
<h2 id="final、finally、finalize-有什么区别"><a href="#final、finally、finalize-有什么区别" class="headerlink" title="final、finally、finalize 有什么区别"></a>final、finally、finalize 有什么区别</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void omitFinally() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			int i &#x3D; 0;</span><br><span class="line">			i +&#x3D; 1;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void omitCatch() &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i +&#x3D; 1;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<p><strong>在以下 4 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ul>
<h2 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h2><ul>
<li>NullPointerException 当应用程序试图访问空对象时，则抛出该异常。</li>
<li>SQLException 提供关于数据库访问错误或其他错误信息的异常。</li>
<li>IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li>NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li>FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li>IOException当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>
<li>ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li>ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>
<li>NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li>NoSuchMethodException无法找到某一特定方法时，抛出该异常。</li>
<li>SecurityException由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li>UnsupportedOperationException当不支持请求的操作时，抛出该异常。</li>
<li>RuntimeExceptionRuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><a href="https://www.zhihu.com/question/24304289" target="_blank" rel="noopener">https://www.zhihu.com/question/24304289</a></p>
<p><img src="http://image.tengj.top/Javareflect.png" alt="img"></p>
<ul>
<li>java代码在计算机中经历的阶段（三阶段）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190901141812427.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170513133210763" alt="img"></p>
<p>Java反射机制是指在运行状态中，可以对任意类，都知道它的属性和方法并调用。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。一句话<strong>反射可以在运行时知道类的属性和方法</strong>。</p>
<p>反射就是把Java类中的各种成分映射成对象的Java类，然后对这个java类进行操作。（比如：类的成员属性Field、类的成员方法Method、类的构造方法）</p>
<ul>
<li>反射的好处<ul>
<li>可以在程序运行时操作这些对象。</li>
<li>可以解耦，提高程序可扩展性。</li>
</ul>
</li>
<li>反射的缺点<ul>
<li>反射的效率很低</li>
<li>会破坏封装，通过反射可以访问类的私有方法，不安全</li>
</ul>
</li>
</ul>
<h2 id="字节码Class对象"><a href="#字节码Class对象" class="headerlink" title="字节码Class对象"></a>字节码Class对象</h2><h3 id="Class类对象——描述-class字节码文件"><a href="#Class类对象——描述-class字节码文件" class="headerlink" title="Class类对象——描述.class字节码文件"></a>Class类对象——描述.class字节码文件</h3><p>将java文件经过编译后变成class字节码文件通过类加载器加载到内存，通过java.lang.Class类对象对字节码文件进行描述。每一个类都是一个class类对象的实例。<strong>class类对象是用来对类的描述，主要包括三个成员变量</strong>：</p>
<ul>
<li>类成员变量 Field[] fields</li>
<li>类成员方法 Method[] methods</li>
<li>类构造函数 Constructor[] constructors</li>
</ul>
<h3 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h3><p>Class类构造函数是私有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;*</span><br><span class="line">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span><br><span class="line">     * This constructor is not used and prevents the default constructor being</span><br><span class="line">     * generated.</span><br><span class="line">     *&#x2F;</span><br><span class="line">private Class() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Class.forName(“全类名”)</p>
<p><strong>在Source源代码阶段</strong>，此时java类仍位于硬盘上。多用于配置文件，将类名定义在配置文件中。读取文件，并触发类构造器加载类。Class.forName() 方法如果写错类的路径会报 ClassNotFoundException 的异常。</p>
</li>
<li><p>类名.class：通过类名的属性class获取</p>
<p><strong>在Class类对象阶段</strong>，此时java类位于内存中，但没有实际对象。多用于参数的传递。通过这种方式时，只会加载Dog类，并不会触发其类构造器的初始化。</p>
</li>
<li><p>对象.getClass()：getClass（）方法在Object类中定义</p>
<p><strong>在运行阶段</strong>，此时已经获取类的实例对象，多用于对象的获取字节码的方式。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法1：Class.forName(&quot;全类名&quot;)</span><br><span class="line">      try &#123;</span><br><span class="line">          Class cls1 &#x3D; Class.forName(&quot;com.test.demo.Dog&quot;);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">      &#x2F;&#x2F; 方法2：类名.class</span><br><span class="line">      Class cls2 &#x3D; Dog.class;</span><br><span class="line">      &#x2F;&#x2F; 方法3：对象.getClass()</span><br><span class="line">      Dog dog &#x3D; new Dog();</span><br><span class="line">  	Class cls3 &#x3D; dog.getClass();</span><br><span class="line">&#x2F;&#x2F; 用 &#x3D;&#x3D; 比较3个对象是否为同一个对象（指向同一物理地址）</span><br><span class="line">System.out.print(cls1 &#x3D;&#x3D; cls2);	&#x2F;&#x2F;	true</span><br><span class="line">System.out.print(cls1 &#x3D;&#x3D; cls3);	&#x2F;&#x2F;	true</span><br></pre></td></tr></table></figure>

<p>同一个字节码文件（<em>.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。*</em>也就是说在运行期间，一个类，只有一个Class对象产生。**</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h1 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h1><h2 id="什么是范型"><a href="#什么是范型" class="headerlink" title="什么是范型"></a>什么是范型</h2><p>用来规定类、接口、方法接受数据的类型。</p>
<p>泛型的本质就是利用编译器实现的Java语法糖，编译器将java文件转换为class文件前，会进行泛型擦除，所以在反编译的class文件中，是看不到泛型声明的</p>
<h2 id="范型的优缺点"><a href="#范型的优缺点" class="headerlink" title="范型的优缺点"></a>范型的优缺点</h2><p><strong>范型的优点：</strong></p>
<ul>
<li><strong>提高安全性:</strong> 将运行期的错误转换到编译期. 如果我们在对一个对象所赋的值不符合其泛型的规定, 就会编译报错.</li>
<li><strong>避免强转:</strong> 比如我们在使用List时, 如果我们不使用泛型, 当从List中取出元素时, 其类型会是默认的Object, 我们必须将其向下转型为String才能使用。</li>
</ul>
<p><strong>范型的缺点：</strong></p>
<ul>
<li>类型擦除问题</li>
</ul>
<h3 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a>范型擦除</h3><p>在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<h2 id="范型的使用"><a href="#范型的使用" class="headerlink" title="范型的使用"></a>范型的使用</h2><p>泛型有三种使用方式，分别为：</p>
<ul>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
</ul>
<p>范型使用规则：</p>
<ul>
<li>泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</li>
<li>泛型只在编译阶段有效。</li>
<li>在实例化泛型类时，必须指定具体类型，如果不传入泛型类型实参的话，不会起到限制的作用，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</li>
<li>不能对确切的泛型类型使用instanceof操作</li>
<li>当实现泛型接口的类，未传入泛型实参时，声明类需将泛型的声明也一起加到类中，如果不声明，编译器会报错。</li>
<li>public 与 返回值中间<T>，可以理解为声明此方法为泛型方法。</li>
<li>只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li>
</ul>
<h3 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h3><p>泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Base&lt;Double&gt; base &#x3D; new Base&lt;Double&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="范型接口"><a href="#范型接口" class="headerlink" title="范型接口"></a>范型接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化泛型类时，必须指定具体类型，如果不传入泛型类型实参的话，不会起到限制的作用，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] fruits &#x3D; new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand &#x3D; new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="范型方法"><a href="#范型方法" class="headerlink" title="范型方法"></a>范型方法</h3><p>print是范型方法，其它的get set 不是范型方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;E, K&gt; K print(E e, K k) &#123;</span><br><span class="line"></span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型中的通配符"><a href="#泛型中的通配符" class="headerlink" title="泛型中的通配符"></a>泛型中的通配符</h2><p>范型中的通配符规定只允许某一部分类作为泛型。</p>
<h3 id="通配符分类"><a href="#通配符分类" class="headerlink" title="通配符分类"></a>通配符分类</h3><ul>
<li>无边界通配符(&lt;?&gt;)：让泛型能够接受未知类型的数据</li>
<li>固定上边界通配符(&lt;? extends E&gt;),即传入的类型实参必须是指定类型的子类型。注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类.</li>
<li>固定下边界通配符（? super E）即传入的类型实参必须是指定类型的父类型</li>
</ul>
<h2 id="关于泛型数组"><a href="#关于泛型数组" class="headerlink" title="关于泛型数组"></a>关于泛型数组</h2><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。</p>
<p>也就是说下面的这个例子是不可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList&lt;String&gt;[10];</span><br></pre></td></tr></table></figure>

<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls &#x3D; new ArrayList&lt;?&gt;[10];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList[10];</span><br></pre></td></tr></table></figure>

<p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">的一篇文档</a>的一个例子来说明这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa &#x3D; new List&lt;String&gt;[10]; &#x2F;&#x2F; Not really allowed.    </span><br><span class="line">Object o &#x3D; lsa;    </span><br><span class="line">Object[] oa &#x3D; (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(new Integer(3));    </span><br><span class="line">oa[1] &#x3D; li; &#x2F;&#x2F; Unsound, but passes run time store check    </span><br><span class="line">String s &#x3D; lsa[1].get(0); &#x2F;&#x2F; Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
</blockquote>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
<p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa &#x3D; new List&lt;?&gt;[10]; &#x2F;&#x2F; OK, array of unbounded wildcard type.    </span><br><span class="line">Object o &#x3D; lsa;    </span><br><span class="line">Object[] oa &#x3D; (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(new Integer(3));    </span><br><span class="line">oa[1] &#x3D; li; &#x2F;&#x2F; Correct.    </span><br><span class="line">Integer i &#x3D; (Integer) lsa[1].get(0); &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>



<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解（Annotation），也叫元数据，一种代码级别的说明。JDK1.5引入的特性，与类、接口、枚举是在同一个层次，它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<strong>注解的本质就是一个继承了 Annotation 接口的接口</strong>，所有的注解类型都继承自Annotation。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p>
<ul>
<li><p>@Target：<strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    &#x2F;** 表示可以用来修饰类、接口、注解类型或枚举类型Class, interface (including annotation type), or enum declaration *&#x2F;</span><br><span class="line">    TYPE,</span><br><span class="line">    &#x2F;** 可以用来修饰属性（包括枚举常量）Field declaration (includes enum constants) *&#x2F;</span><br><span class="line">    FIELD,</span><br><span class="line">    &#x2F;** 可以用来修饰方法Method declaration *&#x2F;</span><br><span class="line">    METHOD,</span><br><span class="line">    &#x2F;** 可以用来修饰参数 Formal parameter declaration *&#x2F;</span><br><span class="line">    PARAMETER,</span><br><span class="line">    &#x2F;** 可以用来修饰构造器 Constructor declaration *&#x2F;</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    &#x2F;** 可用来修饰局部变量Local variable declaration *&#x2F;</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    &#x2F;** 可以用来修饰注解类型Annotation type declaration *&#x2F;</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    &#x2F;** 可以用来修饰包Package declaration *&#x2F;</span><br><span class="line">    PACKAGE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 标注在类型参数上Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于标注任意类型(不包括class)Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>@Retention：<strong>定义了<code>Annotation</code>的生命周期</strong></p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息）</p>
<p><strong>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</strong></p>
</li>
</ul>
</li>
<li><p>@Documented：<strong>用来描述注解是否被抽取到api文档中。在生成javadoc文档的时候将该Annotation也写入到文档中。</strong></p>
</li>
<li><p>@Inherited：<strong>如果一个使用了<code>@Inherited</code>修饰的<code>annotation</code>类型被用于一个class，则这个<code>annotation</code>将被用于该class的子类。并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</strong></p>
</li>
<li><p>@Repeatable：它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的。</p>
</li>
</ul>
<h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ul>
<li><p>@Override：用于标记该方法是复写的父类中的某个方法。属于标记注解，不需要设置属性值；只能添加在方法的前面。</p>
</li>
<li><p>@Deprecated：说明被修饰内容已被“废弃”，不再建议用户使用。</p>
</li>
<li><p>@SuppressWarnings：忽略警告。</p>
</li>
<li><p>@TargetApi：版本注解。</p>
</li>
<li><p>@SuppressLint：避免在lint检查时报错</p>
</li>
<li><p><strong>Nullable</strong>：用于标记方法参数或者返回值可以为空；</p>
</li>
<li><p><strong>@NonNull:</strong>用于标记方法参数或者返回值不能为空，如果为空编译器会报警告；</p>
</li>
<li><p>@IdRes：Android中一系列<strong>资源类型注解</strong>。</p>
</li>
<li><p>使用整型常量代替枚举类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class IceCreamFlavourManager &#123;</span><br><span class="line">    private int flavour;</span><br><span class="line"></span><br><span class="line">    public static final int VANILLA &#x3D; 0;</span><br><span class="line">    public static final int CHOCOLATE &#x3D; 1;</span><br><span class="line">    public static final int STRAWBERRY &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    @IntDef(&#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</span><br><span class="line">    public @interface Flavour &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Flavour</span><br><span class="line">    public int getFlavour() &#123;</span><br><span class="line">        return flavour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlavour(@Flavour int flavour) &#123;</span><br><span class="line">        this.flavour &#x3D; flavour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@UiThread :等线程注解</p>
</li>
<li><p>@Size、@IntRange、@FloatRange等值约束注解。</p>
</li>
<li><p>权限注解</p>
</li>
<li><p>@CheckResult：<strong>返回值注解</strong>。</p>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><h4 id="编译时期使用注解"><a href="#编译时期使用注解" class="headerlink" title="编译时期使用注解"></a>编译时期使用注解</h4><p>编译时注解指的是@Retention的值为CLASS的注解。对于这类注解的解析，我们只需做好以下两件事儿：</p>
<ul>
<li>自定义一个派生自 AbstractProcessor的“注解处理类”；</li>
<li>重写process 函数。</li>
</ul>
<p>实际上，javac中包含的注解处理器在编译时会自动查找所有继承自 AbstractProcessor 的类，然后调用它们的 process 方法。因此我们只要做好上面两件事，编译器就会主动去解析我们的编译时注解。现在，我们把上面定义的TestAnnotation的Retention改为CLASS，我们就可以按照以下代码来解析它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;com.zhyen.com.TestAnnotation&quot;)</span><br><span class="line">public class TestAnnotationClass extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (TypeElement element : annotations) &#123;</span><br><span class="line">            for (Element e : roundEnv.getElementsAnnotatedWith(element)) &#123;</span><br><span class="line">                TestAnnotation annotation&#x3D;e.getAnnotation(TestAnnotation.class);</span><br><span class="line">                map.put(e.getEnclosingElement().toString(),annotation.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SupportedAnnotationTypes注解指出了MyProcessor向要解析的注解的完整名字（全限定名称）。process+函数的annotations参数表示待处理的注解集，通过env我们可以得到被特定注解所修饰的程序元素。process函数的返回值表示annotations中的注解是否被这个Processor接受。&amp;oq=%40SupportedAnnotationTypes注解指出了MyProcessor向要解析的注解的完整名字（全限定名称）。process+函数的annotations参数表示待处理的注解集，通过env我们可以得到被特定注解所修饰的程序元素。process函数的返回值表示annotations中的注解是否被这个Processor接受</p>
<h4 id="运行时期使用直接"><a href="#运行时期使用直接" class="headerlink" title="运行时期使用直接"></a>运行时期使用直接</h4><p>Class 类中提供了以下一些方法用于反射注解：</p>
<ul>
<li><p>getAnnotation：返回指定的注解</p>
</li>
<li><p>isAnnotationPresent：判定当前元素是否被指定注解修饰</p>
</li>
<li><p>getAnnotations：返回所有的注解</p>
</li>
<li><p>getDeclaredAnnotation：返回本元素的指定注解</p>
</li>
<li><p>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</p>
</li>
</ul>
<p><strong>方法、字段中相关反射注解的方法基本是类似的</strong></p>
<h3 id="案例一个"><a href="#案例一个" class="headerlink" title="案例一个"></a>案例一个</h3><p>注解类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TestAnnotation &#123;</span><br><span class="line">    String value() default &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">    public String name() default &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    int index() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestAnnotationClass &#123;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;汪汪汪&quot;, name &#x3D; &quot;dog&quot;, index &#x3D; 100)</span><br><span class="line">    public String dog;</span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;喵喵喵&quot;, name &#x3D; &quot;cat&quot;, index &#x3D; 200)</span><br><span class="line">    public String cat;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;爱爆炸&quot;, index &#x3D; 10, name &#x3D; &quot;三星&quot;)</span><br><span class="line">    public void phone() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;细&quot;, index &#x3D;20, name &#x3D; &quot;ARM&quot;)</span><br><span class="line">    public void CPU() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取注解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TestAnnotationClass&gt; clazz &#x3D; TestAnnotationClass.class;</span><br><span class="line">        Field[] fields &#x3D; clazz.getFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            TestAnnotation annotation &#x3D; field.getAnnotation(TestAnnotation.class);</span><br><span class="line">            String name &#x3D; annotation.name();</span><br><span class="line">            int index &#x3D; annotation.index();</span><br><span class="line">            String value &#x3D; annotation.value();</span><br><span class="line">            Log.d(TAG, &quot;name &#x3D; &quot; + name + &quot; ,index &#x3D; &quot; + index + &quot;, value &#x3D; &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TestAnnotation annotation &#x3D; method.getAnnotation(TestAnnotation.class);</span><br><span class="line">            String name &#x3D; annotation.name();</span><br><span class="line">            int index &#x3D; annotation.index();</span><br><span class="line">            String value &#x3D; annotation.value();</span><br><span class="line">            Log.d(TAG, &quot;name &#x3D; &quot; + name + &quot; ,index &#x3D; &quot; + index + &quot;, value &#x3D; &quot; + value);</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; cat ,index &#x3D; 200, value &#x3D; 喵喵喵</span><br><span class="line">name &#x3D; dog ,index &#x3D; 100, value &#x3D; 汪汪汪</span><br><span class="line">方法名: CPU </span><br><span class="line">name &#x3D; ARM ,index &#x3D; 20, value &#x3D; 细</span><br><span class="line">equals</span><br><span class="line">方法名: getClass</span><br><span class="line">方法名: hashCode</span><br><span class="line">方法名: notify</span><br><span class="line">方法名: phone</span><br><span class="line">name &#x3D; 三星 ,index &#x3D; 10, value &#x3D; 爱爆炸</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h1 id="抽象类（Abstract-Class）"><a href="#抽象类（Abstract-Class）" class="headerlink" title="抽象类（Abstract Class）"></a>抽象类（Abstract Class）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。抽象类用abstract修饰。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>不能实例化，因为抽象类中含有无法具体实现的方法。</li>
<li>可在抽象类中定义公共成员变量、成员方法、构造方法等。</li>
<li>只要包含一个抽象方法的类，该类必须要定义成抽象类（抽象方法是一种特殊的方法，它只有声明但没有具体的实现，抽象方法必须为public或protected）。故可理解为抽象类是在普通类结构里增加抽象方法的组成部分。</li>
<li>如果子类继承于一个抽象类，则该子类可以有选择性决定是否覆写父类的抽象方法，如果子类没有实现父类的抽象方法，则必须将子类也定义为抽象类（抽象类可以继承抽象类）</li>
<li>继承只能单继承，一个子类只能继承一个抽象类。</li>
<li>abstract不能与final并列修饰同一个类。</li>
<li>abstract 不能与private、static、final或native并列修饰同一个方法。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;&#x2F;&#x2F;定义一个抽象类</span><br><span class="line">	</span><br><span class="line">	public void fun()&#123;&#x2F;&#x2F;普通方法</span><br><span class="line">		System.out.println(&quot;存在方法体的方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public abstract void print();&#x2F;&#x2F;抽象方法，没有方法体，有abstract关键字做修饰</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="抽象类必须有抽象方法吗"><a href="#抽象类必须有抽象方法吗" class="headerlink" title="抽象类必须有抽象方法吗"></a>抽象类必须有抽象方法吗</h3><p>不是</p>
<h3 id="抽象类可以继承普通类吗"><a href="#抽象类可以继承普通类吗" class="headerlink" title="抽象类可以继承普通类吗"></a>抽象类可以继承普通类吗</h3><p>可以</p>
<h3 id="抽象类有构造方法吗？"><a href="#抽象类有构造方法吗？" class="headerlink" title="抽象类有构造方法吗？"></a>抽象类有构造方法吗？</h3><p>有</p>
<h3 id="抽象类可以用final声明么？"><a href="#抽象类可以用final声明么？" class="headerlink" title="抽象类可以用final声明么？"></a>抽象类可以用final声明么？</h3><p>不能，因为抽象类必须有子类，而final定义的类不能有子类；</p>
<h3 id="抽象类能否使用static声明？"><a href="#抽象类能否使用static声明？" class="headerlink" title="抽象类能否使用static声明？"></a>抽象类能否使用static声明？</h3><p>外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p>
<h3 id="可以直接调用抽象类中用static声明的方法么？"><a href="#可以直接调用抽象类中用static声明的方法么？" class="headerlink" title="可以直接调用抽象类中用static声明的方法么？"></a>可以直接调用抽象类中用static声明的方法么？</h3><p>任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</p>
<h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。</li>
<li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li>
<li>一个接口可以继承于另一个接口，或者另一些接口，接口也可以继承，并且可以多继承。接口不能实现(implement)另一个接口</li>
<li>一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。</li>
<li>不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的</li>
<li>接口没有构造方法</li>
<li>接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的。</li>
<li>接口支持多继承（一个类可以实现多个接口）</li>
<li>一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。</li>
<li>接口也被用来实现解耦。</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Door&#123;</span><br><span class="line">void open ();</span><br><span class="line">void close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public class BigDoor implements Door &#123;</span><br><span class="line"></span><br><span class="line">void open ()&#123;</span><br><span class="line">System.out.println(&quot;BigDoor is opening...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void close()&#123;</span><br><span class="line">System.out.println(&quot;BigDoor is closing...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口的标识用法"><a href="#接口的标识用法" class="headerlink" title="接口的标识用法"></a>接口的标识用法</h2><p>虽然接口内部定义了一些抽象方法，但是并不是所有的接口内部都必须要有方法，比如Seriallizable接口，Seriallizable接口的作用是使对象能够“序列化”，但是Seriallizable接口中却没有任何内容，也就是说，如果有一个类需要实现“序列化”的功能，则这个类必须去实现Seriallizable接口，但是却并不用实现方法（因为接口中没有方法），此时，这个Serilizable接口就仅仅是一个“标识”接口，是用来标志一个类的，标志这个类具有这个“序列化”功能。</p>
<h1 id="抽象类与接口区别"><a href="#抽象类与接口区别" class="headerlink" title="抽象类与接口区别"></a>抽象类与接口区别</h1><ul>
<li>抽象类中可以有自己的方法实现。也可以有抽象方法。接口只有抽象方法。</li>
<li>一个子类只能继承一个父类，但可以实现多个接口。</li>
<li>子类使用extends关键字继承抽象类。子类可以选择性重写抽象类中需要使用的方法;子类使用implements关键字实现接口。子类需要提供接口中所有声明的方法的实现。</li>
<li>抽象类可以有构造方法，但接口没有构造方法。但抽象类的构造器不用于创造对象，而是让其子类调用这些构造器完成抽象类的初始化操作。</li>
<li>抽象方法比接口速度快。接口需要时间去寻找在类中实现的方法，故速度较慢。</li>
<li>抽象类是对事物的一种抽象，描述的是某一类特性的事物。表示 这个对象是什么。（is-a关系——强调所属关系）;接口是对行为功能的抽象，描述是否具备某种行为特征。表示 这个对象能做什么。（has-a关系——强调功能实现）</li>
</ul>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h2><h3 id="使用new操作符创建一个对象"><a href="#使用new操作符创建一个对象" class="headerlink" title="使用new操作符创建一个对象"></a>使用new操作符创建一个对象</h3><p>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p>
<h3 id="使用clone方法复制一个对象"><a href="#使用clone方法复制一个对象" class="headerlink" title="使用clone方法复制一个对象"></a>使用clone方法复制一个对象</h3><p>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p>
<h2 id="clone的使用"><a href="#clone的使用" class="headerlink" title="clone的使用"></a>clone的使用</h2><ul>
<li><p>实现Cloneable接口</p>
</li>
<li><p>重写Object中clone方法，定位为public</p>
</li>
<li><p>调用super.clone();</p>
</li>
<li><p>实现try catch 捕获异常</p>
</li>
<li><p>clone默认实现的是浅拷贝。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book implements Cloneable &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (Book)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone规则"><a href="#clone规则" class="headerlink" title="clone规则"></a>clone规则</h3><ul>
<li>如果变量是基本类型，克隆的是其<strong>值</strong>比如int、float等。</li>
<li>如果变量是实例对象，则拷贝其<strong>地址引用</strong>，也就是说新对象和原来对象是共用实例变量的。</li>
<li>若变量是string字符串，拷贝其地址引用，但是在修改时，它会从字符串池中重新生成一个新的字符串，原有的对象保持不变。</li>
<li>clone默认实现的是浅拷贝。</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<ul>
<li>如果原型对象的成员变量是值类型，将复制一份给克隆对象，</li>
<li>如果原型对象的成员变量是引用类型，则将引用类型的地址复制一份给克隆对象。<strong>也就是说原型对象和克隆对象的成员变量指向相同的内存地址</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8ec91452d46a20ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在深拷贝中无论值类型还是引用类型都会复制一份给克隆对象，深拷贝将原型对象的所有引用对象也复制一份给克隆对象。</p>
<p>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>如果想要深拷贝一个对象， 这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-c2b9f8dbacd2bffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-76e0e5813178abab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Java多线程之同步集合与并发集合"><a href="#Java多线程之同步集合与并发集合" class="headerlink" title="Java多线程之同步集合与并发集合"></a>Java多线程之同步集合与并发集合</h1><h2 id="同步集合类"><a href="#同步集合类" class="headerlink" title="同步集合类"></a>同步集合类</h2><p>包括<code>Hashtable</code>、<code>Vector</code>、同步集合包装类，<code>Collections.synchronizedMap()</code>和<code>Collections.synchronizedList()</code>。</p>
<h2 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h2><p>包括<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteHashSet</code></p>
<p>同步集合比并发集合会慢得多，主要原因是锁，同步集合会对整个Map或List加锁。</p>
<ul>
<li><strong>ConcurrentHashMap：</strong>把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。</li>
<li><strong>CopyOnWriteArrayList：</strong>允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。</li>
</ul>
<p>一般不需要多线程的情况，只用到HashMap、ArrayList，只要真正用到多线程的时候就一定要考虑同步。所以这时候才需要考虑同步集合或并发集合。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-cefab31cd3461494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="JDK1-7-amp-JDK1-8-对比"><a href="#JDK1-7-amp-JDK1-8-对比" class="headerlink" title="JDK1.7 &amp; JDK1.8 对比"></a>JDK1.7 &amp; JDK1.8 对比</h4><ol>
<li><p>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p>
</li>
<li><p>保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</p>
</li>
<li><p>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p>
</li>
<li><p>链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p>
</li>
<li><p>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
</li>
</ol>
<h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<h1 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-98c472afe493c25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-891a1d42c08637a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="wait-与-sleep-的区别与联系"><a href="#wait-与-sleep-的区别与联系" class="headerlink" title="wait 与 sleep 的区别与联系"></a>wait 与 sleep 的区别与联系</h2><p>wait和sleep均能使线程处于等待状态</p>
<ul>
<li>wait方法定义在Object里面，基于对象锁，所有的对象都能使用（Java里面每一个对象都有隐藏锁，也叫监视器(monitor)。当一个线程进入一个synchronized方法的时候它会获得一个当前对象的锁。）；sleep方法定义在Thread里面，是基于当前线程。</li>
<li>wait必须在同步环境（synchronized方法）下使用，否则会报IllegalMonitorStateException异常<br>sleep方法可在任意条件下使用</li>
<li>wait/notify一起使用，用于线程间的通信。wait用于让线程进入等待状态，notify则唤醒正在等待的线程；sleep用于暂停当前线程的执行，它会在一定时间内释放CPU资源给其他线程执行，超过睡眠时间则会正常唤醒。</li>
<li>在同步环境中调用wait方法会释放当前持有的锁；调用sleep则不会释放锁，一直持有锁（直到睡眠结束）</li>
</ul>
<h2 id="线程阻塞的原因"><a href="#线程阻塞的原因" class="headerlink" title="线程阻塞的原因"></a>线程阻塞的原因</h2><ul>
<li>Thread.sleep(int millsecond) 调用 sleep 的线程会在一定时间内将 CPU 资源给其他线程执行，超过睡眠事件后唤醒。与是否持有同步锁无关。进程处于 TIMED_WAITING 状态</li>
<li>线程执行一段同步代码（Synchronic）代码，但无法获取同步锁：同步锁用于实现线程同步执行，未获得同步锁而无法进入同步块的线程处于 BLOCKED 状态</li>
<li>线程对象调用 wait 方法，进入同步块的线程发现运行条件不满足，此时会释放锁，并释放CPU，等待其他线程norify。此时线程处于 WAITING 状态</li>
<li>执行阻塞式I/O操作，等待相关I/O设备（如键盘、网卡等），为了节省CPU资源，释放CPU。此时线程处于RUNNABLE状态。</li>
</ul>
<h2 id="线程控制方法"><a href="#线程控制方法" class="headerlink" title="线程控制方法"></a>线程控制方法</h2><p>JVM充分地利用现代多核处理器的强大性能。采用异步调用线程，提高使用性能，缺点就是会造成线程不安全。为了保证线程安全性，即确保Java内存模型的可见性、原子性和有序性。Java主要通过volatile、synchronized实现线程安全。</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized 规定了同一个时刻只允许一条线程可以进入临界区（互斥性），同时还保证了共享变量的内存可见性。此规则决定了持有同一个对象锁的多个同步块只能串行执行。</p>
<p>Java中的每个对象都可以为锁：</p>
<ul>
<li>普通同步方法，锁是当前实例对象。</li>
<li>静态同步方法，锁是当前类的class对象。</li>
<li>同步代码块，锁是括号中的对象。</li>
</ul>
<p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某个对象的监视器）。当某个线程并不持有监视器的使用权时，去wait或notify，会抛出java.lang.IllegalMonitorStateException。</p>
<p>当某个线程wait之后，其他执行该同步快的线程可以进入该同步块执行。</p>
<h4 id="锁的内部机制：从偏向锁到重量级锁"><a href="#锁的内部机制：从偏向锁到重量级锁" class="headerlink" title="锁的内部机制：从偏向锁到重量级锁"></a>锁的内部机制：从偏向锁到重量级锁</h4><h5 id="对象头和monitor"><a href="#对象头和monitor" class="headerlink" title="对象头和monitor"></a>对象头和monitor</h5><p>Java对象在内存中的存储结构主要有一下三个部分：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>填充数据</li>
</ul>
<p>monitor是线程私有的数据结构，每一个线程都有一个可用monitor列表，同时还有一个全局的可用列表，先来看monitor的内部。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718141919602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li>EntryQ：关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor失败的线程。</li>
<li>RcThis：表示blocked或waiting在该monitor上的所有线程的个数。</li>
<li>Nest：用来实现重入锁的计数。</li>
<li>HashCode：保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li>Candidate：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值：0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。</li>
</ul>
<p>在 java 虚拟机中，线程一旦进入到被synchronized修饰的方法或代码块时，指定的锁对象通过某些操作将对象头中的LockWord指向monitor 的起始地址与之关联，同时monitor 中的Owner存放拥有该锁的线程的唯一标识，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>当线程执行到临界区（critical section）时，此时会利用CAS(Compare and Swap)操作，将线程ID插入到Markword中，同时修改偏向锁的标志位。</p>
<p>此时偏向锁标志位为1。</p>
<p><strong>偏向锁是jdk1.6引入的一项锁优化，其中的“偏”是偏心的偏。它的意思就是说，这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。</strong></p>
<p><strong>在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行加锁或者解锁操作，而是会做以下的步骤：</strong></p>
<ul>
<li>Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.</li>
<li>如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.</li>
<li>如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。</li>
<li>如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
<li>如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。</li>
</ul>
<p>即偏向锁是针对于一个线程而言的，线程获得锁之后就不会进行解锁操作，节省了很多开销。为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。在Jdk1.6中，偏向锁的开关是默认开启的，适用于只有一个线程访问同步块的场景。</p>
<p>下述代码中，当线程访问同步方法method1时，会在对象头（SynchronizedTest.class对象的对象头）和栈帧的锁记录中存储锁偏向的线程ID，下次该线程在进入method2，只需要判断对象头存储的线程ID是否为当前线程，而不需要进行CAS操作进行加锁和解锁（因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    private static Object lock &#x3D; new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method1();</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized static void method1() &#123;&#125;</span><br><span class="line">    synchronized static void method2() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。下面先简单描述下锁撤销之后，升级为轻量级锁的过程：</p>
<ul>
<li>线程在自己的栈桢中创建锁记录 LockRecord。</li>
<li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li>
<li>将锁记录中的Owner指针指向锁对象。</li>
<li>将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
</ul>
<p>轻量级锁主要是自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。注意，锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。自旋锁有一些问题：</p>
<ul>
<li>如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu。</li>
<li>本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。</li>
</ul>
<p>基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Java/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="url">Java容器类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java集合框架图"><a href="#java集合框架图" class="headerlink" title="java集合框架图"></a>java集合框架图</h1><p>java集合框架图</p>
<p><img src="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java集合的类结构图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>java集合继承关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。</p>
<p>简单来看，Collection代表的是单个元素对象的序列，（可以有序/无序，可重复/不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代表的是“键值对”对象的集合（同样可以有序/无序 等依据具体实现）</p>
<ul>
<li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li>
<li>Set：无序，不可重复；</li>
<li>Map：键值对，键唯一，值多个；</li>
</ul>
<h1 id="Collection-集合接口"><a href="#Collection-集合接口" class="headerlink" title="Collection 集合接口"></a>Collection 集合接口</h1><p>Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。有些容器允许重复元素有的不允许，有些有序有些无需。由Collection接口派生的两个接口是List和Set。这个接口的设计目的是希望能最大程度抽象出元素的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型即该Collection中元素对象的类型，继承的Iterable是定义的一个遍历操作接口，采用hasNext next的方式进行遍历。具体实现还是放在具体类中去实现。</p>
<p>主要方法</p>
<ul>
<li>boolean add(Object o) 添加对象到集合</li>
<li>boolean remove(Object o) 删除指定的对象</li>
<li>int size() 返回当前集合中元素的数量</li>
<li>boolean contains(Object o) 查找集合中是否有指定的对象</li>
<li>boolean isEmpty() 判断集合是否为空</li>
<li>Iterator iterator() 返回一个迭代器</li>
<li>boolean containsAll(Collection c) 查找集合中是否有集合c中的元素</li>
<li>boolean addAll(Collection c) 将集合c中所有的元素添加给该集合</li>
<li>void clear() 删除集合中所有元素</li>
<li>void removeAll(Collection c) 从集合中删除c集合中也有的元素</li>
<li>void retainAll(Collection c) 从集合中删除集合c中不包含的元素</li>
</ul>
<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><p>List是一个允许重复元素的指定索引、有序集合。</p>
<p>从List接口的方法来看，List接口增加了面向位置的操作，允许在指定位置上操作元素。用户可以使用这个接口精准掌控元素插入，还能够使用索引index（元素在List中的位置，类似于数组下标）来访问List中的元素。List接口有两个重要的实现类：ArrayList和LinkedList。</p>
<p><strong>Set里面和List最大的区别是Set里面的元素对象不可重复。</strong></p>
<h3 id="ArrayList-数组"><a href="#ArrayList-数组" class="headerlink" title="ArrayList 数组"></a>ArrayList 数组</h3><p>ArrayList的底层数据结构就是一个数组，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。默认列表长度10，也可以自己指定长度。ArrayList中的对象数组的最大数组容量为Integer.MAX_VALUE – 8。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>ArrayList实现了List接口的可变大小的数组。（数组可动态创建，如果元素个数超过数组容量，那么就创建一个更大的新数组）</li>
<li>它允许所有元素，包括null</li>
<li>它的size, isEmpty, get, set, iterator,add这些方法的时间复杂度是O(1),如果add n个数据则时间复杂度是O(n)</li>
<li>ArrayList没有同步方法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。</li>
<li>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。</li>
<li>根据下标遍历元素，效率高。</li>
<li>根据下标访问元素，效率高。</li>
<li>可以自动扩容，默认为每次扩容为原来的1.5倍。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除元素的效率不高。</li>
<li>根据元素下标查找元素需要遍历整个元素数组，效率不高。</li>
<li>线程不安全。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>Boolean add(Object o)将指定元素添加到列表的末尾</li>
<li>Boolean add(int index,Object element)在列表中指定位置加入指定元素</li>
<li>Boolean addAll(Collection c)将指定集合添加到列表末尾</li>
<li>Boolean addAll(int index,Collection c)在列表中指定位置加入指定集合</li>
<li>Boolean clear()删除列表中所有元素</li>
<li>Boolean clone()返回该列表实例的一个拷贝</li>
<li>Boolean contains(Object o)判断列表中是否包含元素</li>
<li>Boolean ensureCapacity(int m)增加列表的容量,如果必须,该列表能够容纳m个元素</li>
<li>Object get(int index)返回列表中指定位置的元素</li>
<li>Int indexOf(Object elem)在列表中查找指定元素的下标</li>
<li>Int size()返回当前列表的元素个数</li>
</ul>
<h4 id="常见源码分析"><a href="#常见源码分析" class="headerlink" title="常见源码分析"></a>常见源码分析</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">        elementData[size++] &#x3D; e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 确认能否装得下size+1的对象</span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;计算容量</span><br><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是默认长度，就比较默认长度和size+1,取最大值</span><br><span class="line">        if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;如果容量大于数组的长度</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;扩容</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;取数组的长度</span><br><span class="line">        int oldCapacity &#x3D; elementData.length;</span><br><span class="line">        &#x2F;&#x2F;计算新长度，新长度&#x3D;旧长度+旧长度&#x2F;2</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity &#x3D; minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">        &#x2F;&#x2F;最后按照新容量进行扩容，复制。</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在add()方法中主要完成了三件事：首先确保能够将希望添加到集合中的元素能够添加到集合中，即确保ArrayList的容量（判断是否需要扩容）；然后将元素添加到elementData数组的指定位置；最后将集合中实际的元素个数加1。</p>
<p>ArrayList的实际默认容量直到调用add()方法才会真正扩容到10，这里通过new ArrayList（）在内存分配的是一个空数组，并没有直接new Object[10],这样设计是很巧妙的，可以节省很多空间。</p>
<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F;判断是否越界</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">   &#x2F;&#x2F; 重新复制数组，把index+1位置往后的对象全部后移</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       &#x2F;&#x2F;覆盖index位置的对象                 </span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的指定位置添加对象方法，需要把指定位置后面的全部对象后移，所以这样也是ArrayList相对于linkList添加耗时的地方。</p>
<h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     return elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的get(int index) 方法比较简单，只有两步，第一，检查是否越界，第二，返回数组索引位置的数据。</p>
<h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;父类的属性，用来记录list修改的次数，后续迭代器中会用到</span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">      int numMoved &#x3D; size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">      &#x2F;&#x2F;把index位置后面的元素左移</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的remove（int index）方法主要分为 3步:</p>
<ul>
<li>第一步，判断下标是否越界</li>
<li>第二步，记录修改次数，并左移index位置后面的元素，</li>
<li>第三，把最后位置赋值为null，用于快速垃圾回收。</li>
</ul>
<h4 id="for循环问题"><a href="#for循环问题" class="headerlink" title="for循环问题"></a>for循环问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; new ArrayList&lt;&gt;(5);</span><br><span class="line">     integers.add(1);</span><br><span class="line">     integers.add(2);</span><br><span class="line">     integers.add(3);</span><br><span class="line">     integers.add(4);</span><br><span class="line">     integers.add(5);</span><br><span class="line"></span><br><span class="line">     for (int i &#x3D; 0; i &lt; integers.size(); i++) &#123;</span><br><span class="line">         integers.remove(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(integers.size());</span><br></pre></td></tr></table></figure>

<p>这里首先申明一个长度为5的ArrayList的集合，然后添加五个元素，最后通过循环遍历删除，理论结果输出0，但是输出的结果却是2，为什么呢？之前分析remove源码我们知道，ArrayList每删除一次就会把后面的全部元素左移，以这5个元素为例，第一个正常删除没问题，删除后，元素就只剩下[2,3,4,5],这个时候remove(1),还剩[2,4,5],再remove(2),剩下[2,4],后面再remove没有元素了，所以最后size为2。</p>
<h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a>LinkedList 链表</h3><p><strong><code>LinkedList</code> 保存链表的第一个节点和最后一个节点,每个节点上有三个字段：当前节点的数据字段（data）,指向上一个节点的字段（prev），和指向下一个节点的字段（next）。</strong></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p><strong><code>LinkedList</code> 集合底层实现的数据结构为双向链表</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 集合中元素允许为 null</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 允许存入重复的数据</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 中元素存放顺序为插入顺序。</strong></p>
</li>
<li><p><code>LinkedList</code>实现<code>Deque</code>接口使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<ul>
<li><strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong></li>
<li><strong>当<code>Deque</code> 作为栈使用的时候，遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的</strong>。</li>
</ul>
</li>
<li><p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。</p>
</li>
<li><p>分配内存空间不是连续的。</p>
</li>
<li><p>插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；</p>
</li>
<li><p>访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；</p>
</li>
</ul>
<h4 id="结点定义（双向链表）"><a href="#结点定义（双向链表）" class="headerlink" title="结点定义（双向链表）"></a>结点定义（双向链表）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前节点的元素值</span><br><span class="line">   E item;</span><br><span class="line">   &#x2F;&#x2F; 下一个节点的索引</span><br><span class="line">   Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; 上一个节点的索引</span><br><span class="line">   Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">       this.item &#x3D; element;</span><br><span class="line">       this.next &#x3D; next;</span><br><span class="line">       this.prev &#x3D; prev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h4><p>每个LinkedList中会持有链表的头指针和尾指针,LinkedList 主要成员变量有下边三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedList 中的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的第一个节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的最后一个节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p>之所以 LinkedList 要保存链表的第一个节点和最后一个节点是因为，我们都知道，链表数据结构相对于数组结构， 优点在于增删，缺点在于查找。如果我们保存了LinkedList 的头尾两端，当我们需要以索引来查找节点的时候，我们可以根据 <code>index</code> 和 <code>size/2</code> 的大小,来决定从头查找还是从尾部查找，这也算是一定程度上弥补了单链表数据结构的缺点。</p>
<h4 id="LinkedList-的构造函数"><a href="#LinkedList-的构造函数" class="headerlink" title="LinkedList 的构造函数"></a>LinkedList 的构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空参数的构造由于生成一个空链表 first &#x3D; last &#x3D; null</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入一个集合类，来构造一个具有一定元素的 LinkedList 集合</span><br><span class="line"> * @param  c  其内部的元素将按顺序作为 LinkedList 节点</span><br><span class="line"> * @throws NullPointerException 如果 参数 collection 为空将抛出空指针异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   this();</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在 index 节点前插入包含所有 c 集合元素的节点。</span><br><span class="line"> * 返回值表示是否成功添加了对应的元素.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   &#x2F;&#x2F; 查看索引是否满足 0 &#x3D;&lt; index &#x3D;&lt; size 的要求</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 调用对应 Collection 实现类的 toArray 方法将集合转为数组</span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   &#x2F;&#x2F;检查数组长度，如果为 0 则直接返回 false 表示没有添加任何元素</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">       return false;</span><br><span class="line">   &#x2F;&#x2F; 保存 index 当前的节点为 succ，当前节点的上一个节点为 pred</span><br><span class="line">   Node&lt;E&gt; pred, succ;</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 表示在链表尾部插入</span><br><span class="line">   if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">       succ &#x3D; null;</span><br><span class="line">       pred &#x3D; last;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       succ &#x3D; node(index);</span><br><span class="line">       pred &#x3D; succ.prev;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历数组将对应的元素包装成节点添加到链表中</span><br><span class="line">   for (Object o : a) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">       Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">       &#x2F;&#x2F;如果 pred 为空表示 LinkedList 集合中还没有元素</span><br><span class="line">       &#x2F;&#x2F;生成的第一个节点将作为头节点 赋值给 first 成员变量</span><br><span class="line">       if (pred &#x3D;&#x3D; null)</span><br><span class="line">           first &#x3D; newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next &#x3D; newNode;</span><br><span class="line">       pred &#x3D; newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果 index 位置的元素为 null 则遍历数组后 pred 所指向的节点即为新链表的末节点，赋值给 last 成员变量</span><br><span class="line">   if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; pred;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 否则将 pred 的 next 索引指向 succ ，succ 的 prev 索引指向 pred</span><br><span class="line">       pred.next &#x3D; succ;</span><br><span class="line">       succ.prev &#x3D; pred;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 更新当前链表的长度 size 并返回 true 表示添加成功</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   modCount++;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 批量添加节点的实现。大体分下面几个步骤：</p>
<ul>
<li>检查索引值是否合法，不合法将抛出角标越界异常</li>
<li>保存 index 位置的节点，和 index-1 位置的节点。</li>
<li>将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。</li>
<li>更新链表长度并返回添加 true 表示添加成功。</li>
</ul>
<p>越界检查最后都调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-添加节点的方法"><a href="#LinkedList-添加节点的方法" class="headerlink" title="LinkedList 添加节点的方法"></a>LinkedList 添加节点的方法</h4><p>LinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the beginning of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法默认调用<code>linkLast</code>添加到最后一个节点。</p>
<h5 id="linkXXX-方法：linkFirst、linkLast"><a href="#linkXXX-方法：linkFirst、linkLast" class="headerlink" title="linkXXX 方法：linkFirst、linkLast"></a><code>linkXXX</code> 方法：<code>linkFirst、linkLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 添加一个元素在链表的头节点位置</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加元素之前的头节点</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   &#x2F;&#x2F;以添加的元素为节点值构建新的头节点 并将 next 指针指向 之前的头节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">   &#x2F;&#x2F; first 索引指向将新的节点</span><br><span class="line">   first &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果添加之前链表空则新的节点也作为未节点</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       last &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       f.prev &#x3D; newNode;&#x2F;&#x2F;否则之前头节点的 prev 指针指向新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在链表末尾添加一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> void linkLast(E e) &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F;保存之前的未节点</span><br><span class="line">   &#x2F;&#x2F;构建新的未节点，并将新节点 prev 指针指向 之前的未节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">   &#x2F;&#x2F;last 索引指向末节点</span><br><span class="line">   last &#x3D; newNode;</span><br><span class="line">   if (l &#x3D;&#x3D; null)&#x2F;&#x2F;如果之前链表为空则新节点也作为头节点</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else&#x2F;&#x2F;否则将之前的未节点的 next 指针指向新节点</span><br><span class="line">       l.next &#x3D; newNode;</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-int-index-E-element-、addAll"><a href="#add-int-index-E-element-、addAll" class="headerlink" title="add(int index, E element)、addAll"></a>add(int index, E element)、addAll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在指定 index 位置插入节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 检查角标是否越界</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 代表是在尾部插入节点</span><br><span class="line">   if (index &#x3D;&#x3D; size)</span><br><span class="line">       linkLast(element);</span><br><span class="line">   else</span><br><span class="line">       linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="node-index-方法的实现"><a href="#node-index-方法的实现" class="headerlink" title="node(index) 方法的实现"></a>node(index) 方法的实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回一个非空节点，这个非空节点位于 index 位置</span><br><span class="line"> *&#x2F;</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 如果 index &lt; size&#x2F;2 则从0开始寻找指定角标的节点</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果 index &gt;&#x3D; size&#x2F;2 则从 size-1 开始寻找指定角标的节点</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会疑惑为什么这里注释为返回一个非空节点？其实仔细想下就明白了，这里的节点一定不为 null，如果一开始链表为空的时候，index 为 0 的位置肯定为 null，为什么不会产生异常情况呢？其实如果一开始链表中没有元素 size = 0，如果我们向 <code>index = 0</code> 的位置添加元素是不会走到 else 中的，而是会调用 <code>linkLast(element);</code> 方法去添加元素。 因此<strong>node 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;</strong></p>
<h6 id="linkBefore-E-e-Node-succ-实现"><a href="#linkBefore-E-e-Node-succ-实现" class="headerlink" title="linkBefore(E e, Node succ)实现"></a>linkBefore(E e, Node<E> succ)实现</h6><p>为什么要叫做 linkBefore 呢，因为在链表的中间位置添加节点，其实就是将 index 原来的节点前添加一个节点，添加节点我们需要知道该节点的前一个节点和当前节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; 由于 succ 一定不为空，所以可以直接获取 prev 节点</span><br><span class="line">   final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">   &#x2F;&#x2F; 新节点 prev 节点为 pred，next 节点为 succ</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">   &#x2F;&#x2F; 原节点的 prev 指向新节点</span><br><span class="line">   succ.prev &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果 pred 为空即头节点出插入了一个节点，则将新的节点赋值给 first 索引</span><br><span class="line">   if (pred &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       pred.next &#x3D; newNode;&#x2F;&#x2F;否则 pred 的下一个节点改为新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将构造的新节点前指针 prev 指向 index 的前一个元素，</p>
</li>
<li><p>新节点前指针 next 指针指向 index 位置的节点，</p>
</li>
<li><p>index 位置节点 prev 指针指向新节点</p>
</li>
<li><p>index 位置前节点（pred）的 next 指针指向新节点</p>
</li>
</ul>
<h4 id="LinkedList-删除节点的方法"><a href="#LinkedList-删除节点的方法" class="headerlink" title="LinkedList 删除节点的方法"></a>LinkedList 删除节点的方法</h4><h5 id="removeFirst、removeLast"><a href="#removeFirst、removeLast" class="headerlink" title="removeFirst、removeLast"></a><code>removeFirst</code>、<code>removeLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  删除头节点</span><br><span class="line"> * @return 删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  删除尾节点</span><br><span class="line"> *</span><br><span class="line"> * @return  删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException  如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="unlinkFirst、unlinkLast"><a href="#unlinkFirst、unlinkLast" class="headerlink" title="unlinkFirst、unlinkLast"></a><code>unlinkFirst</code>、<code>unlinkLast</code></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 移除头节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 头节点的 element 这里作为返回值使用</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    &#x2F;&#x2F; 头节点下个节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    &#x2F;&#x2F; 释放头节点的 next 指针，和 element 下次 gc 的时候回收这个内部类</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F; 将 first 索引指向新的节点</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    &#x2F;&#x2F; 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;否则 next 的 prev 指针指向 null</span><br><span class="line">    size--;&#x2F;&#x2F;改变链表长度</span><br><span class="line">    modCount++;&#x2F;&#x2F;修改操作数</span><br><span class="line">    return element;&#x2F;&#x2F;返回删除节点的值</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 移除未节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    &#x2F;&#x2F;未节点的前一个节点，</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    &#x2F;&#x2F;释放未节点的内容</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F;将 last 索引指向新的未节点</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    &#x2F;&#x2F; 链表只有一个节点的时候，first 指向 null</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刚才已经分析过node(index)方法了，就是找到index位置的节点。</p>
<h6 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Unlinks non-null node x.</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">   final E element &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F;保存 index 节点的前后两个节点</span><br><span class="line">   final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">   final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为头节点，则做 unlinkFirst 相同操作</span><br><span class="line">   if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">       first &#x3D; next;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则将上一个节点的 next 指针指向下个节点</span><br><span class="line">       prev.next &#x3D; next;</span><br><span class="line">       &#x2F;&#x2F; 释放 index 位置 prev 指针</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为尾节点，则将 last 索引指向上个节点</span><br><span class="line">   if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; prev;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则下个节点 prev 指针指向上个节点</span><br><span class="line">       next.prev &#x3D; prev;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   x.item &#x3D; null;</span><br><span class="line">   size--;</span><br><span class="line">   modCount++;</span><br><span class="line">   return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完 <code>unlink</code> 操作结合之前说的 <code>node(index)</code>，下边两种删除节点的操作，就很好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定索引位置的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *删除从头节点其第一个与 o 相同的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F; 区别对待 null 元素，比较元素时候使用 &#x3D;&#x3D; 而不是 equals</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item)) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完单个删除节点的方法 LinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Removes all of the elements from this list.</span><br><span class="line">* The list will be empty after this call returns.</span><br><span class="line">*&#x2F;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">   &#x2F;&#x2F; 依次清除节点，帮助释放内存空间</span><br><span class="line">   for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">       Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">       x.item &#x3D; null;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">       x &#x3D; next;</span><br><span class="line">   &#125;</span><br><span class="line">   first &#x3D; last &#x3D; null;</span><br><span class="line">   size &#x3D; 0;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-查询节点的方法"><a href="#LinkedList-查询节点的方法" class="headerlink" title="LinkedList 查询节点的方法"></a>LinkedList 查询节点的方法</h4><p>LinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 <code>ArrayList</code> 去替代。</p>
<h5 id="get-int-index-、getFirst-、getLast"><a href="#get-int-index-、getFirst-、getLast" class="headerlink" title="get(int index)、getFirst() 、getLast"></a><code>get(int index)、getFirst() 、getLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 根据索引查询</span><br><span class="line">*</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 first 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the first element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 last 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the last element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">   if (l &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexOf-Object-o-、lastIndexOf-Object-o"><a href="#indexOf-Object-o-、lastIndexOf-Object-o" class="headerlink" title="indexOf(Object o)、lastIndexOf(Object o)"></a><code>indexOf(Object o)、lastIndexOf(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">* 返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**头节点**起的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">* </span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return </span><br><span class="line">*&#x2F;</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 区别对待 null 元素，用 &#x3D;&#x3D; 判断，非空元素用 equels 方法判断 </span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">**返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**尾节点起**的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">*</span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return the index of the last occurrence of the specified element in</span><br><span class="line">*         this list, or -1 if this list does not contain the element</span><br><span class="line">*&#x2F;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; size;</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法分别返回从<strong>头节点起</strong>第一个与参数元素相同的节点索引，和从<strong>尾节点起</strong>第一个与参数元素相同的节点索引。</p>
<h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a><code>contains(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) !&#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 indexOf 从头结点开始查询元素位置遍历完成后若 返回值 !=-1 则表示存在，反之不存在</p>
<h4 id="LinkedList-的修改节点方法"><a href="#LinkedList-的修改节点方法" class="headerlink" title="LinkedList 的修改节点方法"></a>LinkedList 的修改节点方法</h4><p><code>LinkedList</code> 只提供了 <code>set(int index, E element)</code> 一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 判断角标是否越界</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 采用 node 方法查找对应索引的节点</span><br><span class="line">   Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">   &#x2F;&#x2F;保存节点原有的内容值</span><br><span class="line">   E oldVal &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F; 设置新值</span><br><span class="line">   x.item &#x3D; element;</span><br><span class="line">   &#x2F;&#x2F; 返回旧的值</span><br><span class="line">   return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-作为双向队列的增删改查"><a href="#LinkedList-作为双向队列的增删改查" class="headerlink" title="LinkedList 作为双向队列的增删改查"></a>LinkedList 作为双向队列的增删改查</h4><p><code>LinkedList</code>实现<code>Deque</code>接口，可实现双向队列。</p>
<h5 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h5><p><code>Queue</code> 是一个队列，遵循 FIFO 准则，我们也知道 <code>Stack</code> 是一个栈结构，遵循 FILO 准则。 而<code>Deque</code> 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。</p>
<p>Deque接口中的方法:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">头部</th>
<th align="center">头部</th>
<th align="center">尾部</th>
<th align="center">尾部</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="center">addFirst(e)</td>
<td align="center">offerFirst(e)</td>
<td align="center">addLast(e)</td>
<td align="center">offerLast(e)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="center">removeFirst()</td>
<td align="center">pollFirst()</td>
<td align="center">remveLast()</td>
<td align="center">pollLast</td>
</tr>
<tr>
<td align="left">获取</td>
<td align="center">getFirst()</td>
<td align="center">peekFirst()</td>
<td align="center">getLast()</td>
<td align="center">peekLast</td>
</tr>
</tbody></table>
<p>由于 <code>Deque</code> 接口继承 <code>Queue</code> 接口，<strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong>。我们现在复习下 <code>Queue</code> 中的方法及区别：</p>
<ul>
<li><code>Queue</code> 的 <code>offer</code> 和 <code>add</code> 都是在队列中插入一个元素，具体区别在于，对于一些 Queue 的实现的队列是有大小限制的，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。此时调用 <code>add()</code>方法会抛出异常，而 <code>offer()</code> 只是返回的 false。</li>
<li><code>remove()</code> 和 <code>poll()</code> 方法都是从队列中删除第一个元素。remove()也将抛出异常，而 <code>poll()</code> 则会返回 <code>null</code></li>
<li><code>element()</code> 和 <code>peek()</code> 用于在队列的头部查询元素。在队列为空时， <code>element()</code> 抛出一个异常，而 <code>peek()</code> 返回 <code>null</code>。</li>
</ul>
<h5 id="Deque-和-Queue-添加元素的方法"><a href="#Deque-和-Queue-添加元素的方法" class="headerlink" title="Deque 和 Queue 添加元素的方法"></a>Deque 和 Queue 添加元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">   return add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提及到 <code>Queue</code>的 <code>offer</code> 和 <code>add</code> 的区别针对容量有限制的实现，很明显 <code>LinkedList</code> 的大小并没有限制，所以在 <code>LinkedList</code> 中他们的实现并没有实质性不同。</p>
<h5 id="Deque-和-Queue-删除元素的方法"><a href="#Deque-和-Queue-删除元素的方法" class="headerlink" title="Deque 和 Queue 删除元素的方法"></a>Deque 和 Queue 删除元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 removeFirst 会抛出 NoSuchElement 异常</span><br><span class="line">public E remove() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的删除方法实现</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E poll() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deque-和-Queue-获取队列头部元素的实现"><a href="#Deque-和-Queue-获取队列头部元素的实现" class="headerlink" title="Deque 和 Queue 获取队列头部元素的实现"></a>Deque 和 Queue 获取队列头部元素的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line"> public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述我们分析了，双端队列作为队列使用的时候的各个方法的区别，也可是看出 <code>LinkedList</code> 对对应方法的实现，遵循了队列设计原则。</p>
<h4 id="LinkedList作为Stack使用"><a href="#LinkedList作为Stack使用" class="headerlink" title="LinkedList作为Stack使用"></a><code>LinkedList</code>作为<code>Stack</code>使用</h4><p>下面我们来看看下双端队列作为栈 <code>Stack</code>使用的时候方法对应关系，与 <code>Queue</code> 不同，<code>Stack</code> 本身就是实现类，他拥有 FILO 的原则， <code>Stack</code> 的入栈操作通过 <code>push</code> 方法进行，出栈操作通过 <code>pop</code> 方法进行，查询操作通过 <code>peek</code> 操作进行。 <strong><code>Deque</code> 作为栈使用的时候，也遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的。</strong></p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFist(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><code>LinkedList</code>中的<code>push</code>、<code>pop</code>、<code>peek</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在头部添加一个元素</span><br><span class="line">public void push(E e) &#123;</span><br><span class="line">   addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取并删除第一个元素</span><br><span class="line">public E pop() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取不删除第一个元素</span><br><span class="line">public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-的遍历"><a href="#LinkedList-的遍历" class="headerlink" title="LinkedList 的遍历"></a>LinkedList 的遍历</h4><p>在 <code>ArrayList</code> 分析的时候，我们就知道 <code>List</code> 的实现类，有4中遍历方式：for 循环，高级 for 循环，<code>Iterator</code> 迭代器方法， <code>ListIterator</code> 迭代方法。</p>
<p><code>LinkedList</code> 没有单独 <code>Iterator</code> 实现类，它的 <code>iterator</code> 和 <code>listIterator</code> 方法均返回 <code>ListItr</code>的一个对象。 LinkedList 作为双向链表数据结构，获取上个元素和下个元素很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 上一个遍历的节点</span><br><span class="line">   private Node&lt;E&gt; lastReturned;</span><br><span class="line">   &#x2F;&#x2F; 下一次遍历返回的节点</span><br><span class="line">   private Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; cursor 指针下一次遍历返回的节点</span><br><span class="line">   private int nextIndex;</span><br><span class="line">   &#x2F;&#x2F; 期望的操作数</span><br><span class="line">   private int expectedModCount &#x3D; modCount;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; 根据参数 index 确定生成的迭代器 cursor 的位置</span><br><span class="line">   ListItr(int index) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert isPositionIndex(index);</span><br><span class="line">       &#x2F;&#x2F; 如果 index &#x3D;&#x3D; size 则 next 为 null 否则寻找 index 位置的节点</span><br><span class="line">       next &#x3D; (index &#x3D;&#x3D; size) ? null : node(index);</span><br><span class="line">       nextIndex &#x3D; index;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 判断指针是否还可以移动</span><br><span class="line">   public boolean hasNext() &#123;</span><br><span class="line">       return nextIndex &lt; size;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 返回下一个带遍历的元素</span><br><span class="line">  public E next() &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查操作数是否合法</span><br><span class="line">       checkForComodification();</span><br><span class="line">       &#x2F;&#x2F; 如果 hasNext 返回 false 抛出异常，所以我们在调用 next 前应先调用 hasNext 检查</span><br><span class="line">       if (!hasNext())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 移动 lastReturned 指针</span><br><span class="line">       lastReturned &#x3D; next;</span><br><span class="line">        &#x2F;&#x2F; 移动 next 指针</span><br><span class="line">       next &#x3D; next.next;</span><br><span class="line">       &#x2F;&#x2F; 移动 nextIndex cursor</span><br><span class="line">       nextIndex++;</span><br><span class="line">       &#x2F;&#x2F; 返回移动后 lastReturned</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前游标位置是否还有前一个元素</span><br><span class="line">   public boolean hasPrevious() &#123;</span><br><span class="line">       return nextIndex &gt; 0;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 当前游标位置的前一个元素</span><br><span class="line">   public E previous() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (!hasPrevious())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 等同于 lastReturned &#x3D; next；next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">        &#x2F;&#x2F; 发生在 index &#x3D; size 时</span><br><span class="line">       lastReturned &#x3D; next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">       nextIndex--;</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public int nextIndex() &#123;</span><br><span class="line">       return nextIndex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int previousIndex() &#123;</span><br><span class="line">       return nextIndex - 1;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 删除链表当前节点也就是调用 next&#x2F;previous 返回的这节点，也就 lastReturned</span><br><span class="line">   public void remove() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; lastNext &#x3D; lastReturned.next;</span><br><span class="line">       &#x2F;&#x2F;调用LinkedList 的删除节点的方法</span><br><span class="line">       unlink(lastReturned);</span><br><span class="line">       if (next &#x3D;&#x3D; lastReturned)</span><br><span class="line">           next &#x3D; lastNext;</span><br><span class="line">       else</span><br><span class="line">           nextIndex--;</span><br><span class="line">       &#x2F;&#x2F;上一次所操作的 节点置位空    </span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置当前遍历的节点的值</span><br><span class="line">   public void set(E e) &#123;</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned.item &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 在 next 节点位置插入及节点</span><br><span class="line">   public void add(E e) &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       if (next &#x3D;&#x3D; null)</span><br><span class="line">           linkLast(e);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(e, next);</span><br><span class="line">       nextIndex++;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;简单哈操作数是否合法</span><br><span class="line">   final void checkForComodification() &#123;</span><br><span class="line">       if (modCount !&#x3D; expectedModCount)</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>链表LinkedList和数组ArrayList的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同。实际使用时根据特定的需求选用合适的类。</p>
<ul>
<li><p>ArrayList基于数组；LinkedList基于双向链表。</p>
</li>
<li><p>查找方面。数组的效率更高，可以直接索引出查找；而链表必须从头查找。</p>
</li>
<li><p>插入删除方面。特别是在中间进行插入删除，这时候链表体现出了极大的便利性，只需要在插入或者删除的地方断掉链然后插入或者移除元素，然后再将前后链重新组装；但是数组必须重新复制一份将所有数据后移或者前移。</p>
</li>
<li><p>在内存申请方面，当数组达到初始的申请长度后，需要重新申请一个更大的数组然后把数据迁移过去才行。而链表只需要动态创建即可。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Vector-向量"><a href="#Vector-向量" class="headerlink" title="Vector 向量"></a>Vector 向量</h3><p>Vector非常类似ArrayList。<strong>Vector是同步的</strong>。当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p>
<h4 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h4><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。</p>
<h2 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a>Set子接口</h2><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。</p>
<h3 id="HashSet-散列集"><a href="#HashSet-散列集" class="headerlink" title="HashSet 散列集"></a>HashSet 散列集</h3><p>HashSet实现了Set接口，基于HashMap进行存储。遍历时不保证顺序，并且不保证下次遍历的顺序和之前一样。HashSet中允许null元素。</p>
<p>在初始化中，创建HashMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法调用的也是HashMap中的方法，key就是传入的元素，value是Object对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>意思就是HashSet的集合其实就是HashMap的key的集合，然后HashMap的val默认都是PRESENT。HashMap的定义即是key不重复的集合。使用HashMap实现，这样HashSet就不需要再实现一遍。</p>
<p>所以所有的add，remove等操作其实都是HashMap的add、remove操作。遍历操作其实就是HashMap的keySet的遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void clear() &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LinkedHashSet-链式散列集"><a href="#LinkedHashSet-链式散列集" class="headerlink" title="LinkedHashSet 链式散列集"></a>LinkedHashSet 链式散列集</h3><p>LinkedHashSet的核心概念相对于HashSet来说就是一个可以保持顺序的Set集合。HashSet是无序的，LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。这个顺序不是元素的大小顺序，而是可以保证2次遍历的顺序是一样的。</p>
<p>类似HashSet基于HashMap的源码实现，LinkedHashSet的数据结构是基于LinkedHashMap。</p>
<h3 id="TreeSet-树形集"><a href="#TreeSet-树形集" class="headerlink" title="TreeSet 树形集"></a>TreeSet 树形集</h3><p>TreeSet即是一组有次序的集合，如果没有指定排序规则Comparator，则会按照自然排序。（自然排序即e1.compareTo(e2) == 0作为比较）</p>
<p>TreeSet源码的算法即基于TreeMap，扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20190607103330622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。</p>
<ul>
<li><p><code>boolean add(E e)</code>：</p>
</li>
<li><p><code>boolean offer(E e)</code>：向队列添加一个元素</p>
</li>
<li><p><code>E poll()</code>：移除队列头部元素（队列为空返回null）</p>
</li>
<li><p><code>E remove()</code>：移除队列头部元素（队列为空抛出异常）</p>
</li>
<li><p><code>E element();</code>：获取头部元素</p>
</li>
<li><p><code>E peek();</code>：获取头部元素</p>
</li>
</ul>
<h3 id="Deque-双端队列-1"><a href="#Deque-双端队列-1" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h3><p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。</p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it &#x3D; collection.iterator(); &#x2F;&#x2F; 获得一个迭代子  </span><br><span class="line">while(it.hasNext()) &#123;  </span><br><span class="line">Object obj &#x3D; it.next(); &#x2F;&#x2F; 得到下一个元素  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638145a2ead2bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="这里写图片描述"></p>
<p>Map是图接口，存储键值对映射的容器类。Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。</p>
<ul>
<li>Map 是<strong>映射接口</strong>，Map中存储的内容是<strong>键值对</strong>(key-value)</li>
<li>AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。</li>
<li>SortedMap 是继承于Map的接口。SortedMap中的内容是<strong>排序的键值对</strong>，排序的方法是通过比较器(Comparator)</li>
<li>NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。 </li>
<li>TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“<strong>有序的键值对”</strong>！</li>
<li>HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“<strong>键值对，但不保证次序</strong>”！</li>
<li>Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“<strong>键值对，也不保证次序”</strong>。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。</li>
<li>WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，<strong>WeakHashMap的键是“弱键</strong>”。</li>
</ul>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    interface Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型&lt;K,V&gt;分别代表key和value的类型。这时候注意到还定义了一个内部接口Entry，其实每一个键值对都是一个Entry的实例关系对象，所以Map实际其实就是Entry的一个Collection，然后Entry里面包含key，value。再设定key不重复的规则，自然就演化成了Map。</p>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map集合提供3种遍历访问方法：</p>
<ul>
<li><p>Set keySet() 获得所有key的集合然后通过key访问value会返回所有key的Set集合，因为key不可以重复，所以返回的是Set格式，而不是List格式。（之后会说明Set，List区别。这里先告诉一点Set集合内元素是不可以重复的，而List内是可以重复的） 获取到所有key的Set集合后，由于Set是Collection类型的，所以可以通过Iterator去遍历所有的key，然后再通过get方法获取value。</p>
</li>
<li><p>Collection values() 获得value的集合。直接获取values的集合，无法再获取到key。所以如果只需要value的场景可以用这个方法。获取到后使用Iterator去遍历所有的value。</p>
</li>
<li><p>Set&lt; Map.Entry&lt; K, V&gt;&gt; entrySet() 获得key-value键值对的集合。</p>
</li>
</ul>
<p>通过以上3种遍历方式我们可以知道，如果你只想获取key，建议使用keySet。如果只想获取value，建议使用values。如果key value希望遍历，建议使用entrySet。</p>
<p>Map的访问顺序取决于Map的遍历访问方法的遍历顺序。 有的Map，比如TreeMap可以保证访问顺序，但是有的比如HashMap，无法保证访问顺序。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>常见的哈希函数：</p>
<ul>
<li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</li>
<li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</li>
<li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</li>
<li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li>
<li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li>
<li>伪随机数法：采用一个伪随机数当作哈希函数。</li>
</ul>
<p>哈希表是一种通过哈希函数将特定的键映射到特定值的一种数据结构，他维护者键和值之间一一对应关系。</p>
<ul>
<li>键(key)：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分。</li>
<li>桶(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将键(key)映射(map)到数据应该存放的槽(slot)所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的键映射到同一个索引的情况。</li>
</ul>
<p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p>
<p><strong>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</strong></p>
<h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>哈希冲突后，用链表去延展来解决。将所有关键字为同义词的记录存储在同一线性链表中。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190725082450961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="开地址法"><a href="#开地址法" class="headerlink" title="开地址法"></a>开地址法</h4><p>哈希冲突后，并不会在本身之外开拓新的空间，而是继续顺延下去某个位置来存放。</p>
<p>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)</p>
<p>其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。</p>
<p>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。</p>
<p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>就是同时构造多个不同的哈希函数：<br> Hi = RHi(key)   i= 1,2,3 … k;<br> 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h4 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h4><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。哈希表为解决冲突，采用了链地址法,简单来说，就是数组加链表的结合,当哈希冲突时，数组上的数据采用链表的方式把新数据插到链尾。</p>
<p>当出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当<strong>链表长度太长（默认超过8）时，链表就转换为红黑树</strong></p>
<p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>从结构实现来讲，HashMap是:<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210635_58179.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">		&#x2F;&#x2F;默认容量</span><br><span class="line">		static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">		&#x2F;&#x2F;最大容量</span><br><span class="line">		static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">		&#x2F;&#x2F;默认加载因子</span><br><span class="line">		static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">		&#x2F;&#x2F;链表转成红黑树的阈值</span><br><span class="line">		static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">		&#x2F;&#x2F;红黑树转为链表的阈值</span><br><span class="line">		static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">		&#x2F;&#x2F;哈希桶数组</span><br><span class="line">		transient Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 存放具体元素的集</span><br><span class="line">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存储方式由链表转成红黑树的容量的最小阈值</span><br><span class="line">		static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">		&#x2F;&#x2F;HashMap中存储的键值对的数量</span><br><span class="line">		transient int size;</span><br><span class="line">		&#x2F;&#x2F;扩容阈值，当size&gt;&#x3D;threshold时，就会扩容</span><br><span class="line">		int threshold;</span><br><span class="line">		&#x2F;&#x2F;HashMap的加载因子</span><br><span class="line">		final float loadFactor;</span><br><span class="line">		</span><br><span class="line">		public HashMap() &#123;</span><br><span class="line">        &#x2F;&#x2F;默认构造函数，赋值加载因子为默认的0.75f</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;指定初始化容量的构造函数</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;同时指定初始化容量 以及 加载因子， 用的很少，一般不会修改loadFactor</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;初始容量最大不能超过2的30次方</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F;显然加载因子不能为负数</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;新建一个哈希表，同时将另一个map m 里的所有元素加入表中</span><br><span class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">		static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue &#x3D; value;</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o &#x3D;&#x3D; this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;根据期望容量cap，返回2的n次方形式的 哈希桶的实际容量 length。 返回值一般会&gt;&#x3D;cap </span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    &#x2F;&#x2F;经过下面的 或 和位移 运算， n最终各位都是1。</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        &#x2F;&#x2F;判断n是否越界，返回 2的n次方作为 table（哈希桶）的阈值</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>一些重要的参数：</p>
<ul>
<li>初始容量（initialCapacity，默认为16）</li>
<li>如果initialCapacity不为2的幂值，HashMap会自动选择比initialCapacity大的下一个2的幂值作为初始容量。</li>
<li>负载系数（loadFactor，默认为0.75）</li>
<li>当HashMap.size()大于<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。</li>
</ul>
<h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123; &#x2F;&#x2F;jdk1.8 &amp; jdk1.7</span><br><span class="line"> int h;</span><br><span class="line"> &#x2F;&#x2F; h &#x3D; key.hashCode() 为第一步 取hashCode值</span><br><span class="line"> &#x2F;&#x2F; h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算</span><br><span class="line"> return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么所计算得到的Hash码值总是相同的。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210658_66827.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<h3 id="存储数据-put"><a href="#存储数据-put" class="headerlink" title="存储数据 put"></a>存储数据 put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先根据key，取得hash值。再插入节点</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        &#x2F;&#x2F;tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        &#x2F;&#x2F;如果当前哈希表是空的，代表是初始化，执行扩容</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        		&#x2F;&#x2F;扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        &#x2F;&#x2F;如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span><br><span class="line">        &#x2F;&#x2F;index 是利用 哈希值 &amp; 哈希桶的长度-1，替代模运算</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;&#x2F;&#x2F;发生了哈希冲突。</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            &#x2F;&#x2F;如果哈希值相等，key也相等，则是覆盖value操作</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F;将当前节点引用赋值给e</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)&#x2F;&#x2F;此处代表红黑树</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;&#x2F;&#x2F;此处代表链表</span><br><span class="line">	           		 &#x2F;&#x2F;遍历链表</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">		                    &#x2F;&#x2F;遍历到尾部，追加新节点到尾部</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        &#x2F;&#x2F;如果追加节点后，链表数量&gt;&#x3D;8，则转化为红黑树</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        &#x2F;&#x2F;treeifyBin首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，</span><br><span class="line">                        &#x2F;&#x2F;如果达到64，那么将冲突的存储结构为红黑树</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;如果找到了要覆盖的节点,结束遍历</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             &#x2F;&#x2F;如果e不是null，链表上有相同的key值，</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">		            &#x2F;&#x2F;则覆盖节点值，并返回原oldValue</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F;这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line">        &#x2F;&#x2F;修改modCount</span><br><span class="line">        ++modCount;</span><br><span class="line">    	  &#x2F;&#x2F;更新size，并判断是否需要扩容。</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        &#x2F;&#x2F;这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210713_35028.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ol>
<h3 id="获取数据-get"><a href="#获取数据-get" class="headerlink" title="获取数据 get"></a>获取数据 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F; 定位键值对所在桶的位置</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;直接命中</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            &#x2F;&#x2F; 桶中不止一个节点</span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果 first 是 TreeNode 类型，则调用黑红树查找方法</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">	                	&#x2F;&#x2F;对链表进行查找</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>get方法做了4件事：</p>
<ul>
<li>计算key的hash值；</li>
<li>找到key所在的桶及其第一个元素；</li>
<li>如果第一个元素的key等于待查找的key，直接返回；</li>
<li>如果第一个元素是树节点就按树的方式来查找，否则按链表方式查找；</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容(resize)就是重新计算容量，Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        &#x2F;&#x2F;oldTab 为当前表的哈希桶</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;当前哈希桶的容量 length</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        &#x2F;&#x2F;当前的阈值</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        &#x2F;&#x2F;初始化新的容量和阈值为0</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;如果当前容量大于0</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果当前容量已经到达上限</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                &#x2F;&#x2F;则设置阈值是2的31次方-1</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                &#x2F;&#x2F;同时返回当前的哈希桶，不再扩容</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;&#x2F;&#x2F;否则新的容量为旧的容量的两倍。 </span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)&#x2F;&#x2F;如果旧的容量大于等于默认初始容量16</span><br><span class="line">                &#x2F;&#x2F;那么新的阈值也等于旧的阈值的两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;&#x2F;&#x2F;如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;&#x2F;&#x2F;那么新表的容量就等于旧的阈值</span><br><span class="line">        else &#123;&#125;&#x2F;&#x2F;如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量&#x2F;阈值参数的情况               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;&#x2F;&#x2F;此时新表的容量为默认的容量 16</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&#x2F;&#x2F;新的阈值为默认容量16 * 默认加载因子0.75f &#x3D; 12</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		        &#x2F;&#x2F;根据新表容量 和 加载因子 求出新的阈值</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            &#x2F;&#x2F;进行越界修复</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新阈值 </span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        		&#x2F;&#x2F;根据新的容量 构建新的哈希桶</span><br><span class="line">            Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        &#x2F;&#x2F;更新哈希桶引用</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        &#x2F;&#x2F;如果以前的哈希桶中有元素</span><br><span class="line">        &#x2F;&#x2F;下面开始将当前哈希桶中的所有节点转移到新的哈希桶中</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历老的哈希桶</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                &#x2F;&#x2F;取出当前的节点 e</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                &#x2F;&#x2F;如果当前桶中有元素,则将链表赋值给e</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;将原哈希桶置空以便GC</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;如果当前链表中就一个元素，（没有发生哈希碰撞）</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        &#x2F;&#x2F;直接将这个元素放置在新的哈希桶里。</span><br><span class="line">                        &#x2F;&#x2F;注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    &#x2F;&#x2F;如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        &#x2F;&#x2F;新计算在新表的位置，并进行搬运</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;                   </span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;&#x2F;&#x2F;临时节点 存放e的下一个节点</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;&#x2F;这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                &#x2F;&#x2F;给头尾节点指针赋值</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;&#x2F;&#x2F;高位也是相同的逻辑</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;&#x2F;&#x2F;循环直到链表结束</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        &#x2F;&#x2F;将低位链表存放在原index处，</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F;将高位链表存放在新index处</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，根据hash值重新计算下角标（newTab[e.hash &amp; (newCap - 1)]），并把它们放置到合适的位置上去。</p>
<p>源码做了三件事：</p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。</p>
<p><strong>在并发的多线程使用场景中使用HashMap可能造成死循环。</strong></p>
<h3 id="重点及面试题"><a href="#重点及面试题" class="headerlink" title="重点及面试题"></a>重点及面试题</h3><ul>
<li>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；</li>
<li>HashMap的默认初始容量为16（1&lt;&lt;4），默认装载因子为0.75f，容量总是2的n次方；</li>
<li>HashMap扩容时每次容量变为原来的两倍；</li>
<li>当桶的数量小于64时不会进行树化，只会扩容；</li>
<li>当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；</li>
<li>当单个桶中元素数量小于6时，进行反树化；</li>
<li>HashMap查找添加元素的时间复杂度都为O(1)；</li>
<li>HashMap是非线程安全的容器</li>
<li>允许使用null值和null键(HashMap最多只允许一条记录的键为null，允许多条记录的值为null)。</li>
<li>HashMap中不允许出现重复的键（Key）</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。</p>
<p>添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。HashTable是<strong>同步</strong>方法，线程安全但是效率低。</p>
<p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashTable使用数组+单向列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class Hashtable&lt;K,V&gt;</span><br><span class="line">    extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    		</span><br><span class="line">        &#x2F;&#x2F; Hashtable保存key-value的数组。</span><br><span class="line">		    &#x2F;&#x2F; Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表</span><br><span class="line">        private transient HashtableEntry&lt;?,?&gt;[] table;</span><br><span class="line">		    &#x2F;&#x2F; Hashtable中元素的实际数量</span><br><span class="line">				private transient int count;</span><br><span class="line">				&#x2F;&#x2F; 阈值，用于判断是否需要调整Hashtable的容量（threshold &#x3D; 容量*加载因子）</span><br><span class="line">				private int threshold;</span><br><span class="line">				&#x2F;&#x2F; 加载因子</span><br><span class="line">				private float loadFactor;</span><br><span class="line">				</span><br><span class="line">		    &#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数</span><br><span class="line">				public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">        if (initialCapacity&#x3D;&#x3D;0)</span><br><span class="line">            initialCapacity &#x3D; 1;</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;创建对象时创建数组并非像HashMap那样懒加载</span><br><span class="line">        table &#x3D; new HashtableEntry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">        &#x2F;&#x2F; Android-changed: Ignore loadFactor when calculating threshold from initialCapacity</span><br><span class="line">        &#x2F;&#x2F; threshold &#x3D; (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        threshold &#x3D; (int)Math.min(initialCapacity, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 指定“容量大小”的构造函数</span><br><span class="line">     public Hashtable(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 默认构造函数。</span><br><span class="line">    public Hashtable() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认构造函数，指定的容量大小是11；加载因子是0.75</span><br><span class="line">        this(11, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</span><br><span class="line">        this(Math.max(2*t.size(), 11), 0.75f);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static class HashtableEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    		final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        HashtableEntry&lt;K,V&gt; next;</span><br><span class="line">    		</span><br><span class="line">    		 protected HashtableEntry(int hash, K key, V value, HashtableEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">    		 		&#x2F;**hash值*&#x2F;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">             &#x2F;**key表示键*&#x2F;</span><br><span class="line">            this.key &#x3D;  key;</span><br><span class="line">            &#x2F;**value表示值*&#x2F;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">             &#x2F;**节点下一个元素*&#x2F;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>put() 的作用是<strong>对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F; Make sure the value is not null</span><br><span class="line">        &#x2F;&#x2F; Hashtable中不能插入value为null的元素！！！</span><br><span class="line">        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F; Makes sure the key is not already in the hashtable.</span><br><span class="line">         &#x2F;&#x2F; 若“Hashtable中已存在键为key的键值对”，</span><br><span class="line">		    &#x2F;&#x2F; 则用“新的value”替换“旧的value”</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">        int hash &#x3D; key.hashCode();</span><br><span class="line">        int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        HashtableEntry&lt;K,V&gt; entry &#x3D; (HashtableEntry&lt;K,V&gt;)tab[index];</span><br><span class="line">        for(; entry !&#x3D; null ; entry &#x3D; entry.next) &#123;</span><br><span class="line">            if ((entry.hash &#x3D;&#x3D; hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old &#x3D; entry.value;</span><br><span class="line">                entry.value &#x3D; value;</span><br><span class="line">                return old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				&#x2F;&#x2F;“Hashtable中不存在键为key的键值对”，</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    		&#x2F;&#x2F;将“修改统计数”+1</span><br><span class="line">        modCount++;</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;若“Hashtable实际容量” &gt; “阈值”(阈值&#x3D;总的容量 * 加载因子)</span><br><span class="line">        if (count &gt;&#x3D; threshold) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rehash the table if the threshold is exceeded</span><br><span class="line">            &#x2F;&#x2F;则调整Hashtable的大小</span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab &#x3D; table;</span><br><span class="line">            hash &#x3D; key.hashCode();</span><br><span class="line">            index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Creates the new entry.</span><br><span class="line">        &#x2F;&#x2F;将“Hashtable中index”位置的Entry(链表)保存到e中</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        HashtableEntry&lt;K,V&gt; e &#x3D; (HashtableEntry&lt;K,V&gt;) tab[index];</span><br><span class="line">        &#x2F;&#x2F;创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。       </span><br><span class="line">        tab[index] &#x3D; new HashtableEntry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        &#x2F;&#x2F;将“Hashtable的实际容量”+1</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/ebdd7991f4634d4393568b0632d769ab.jpg" alt="img"></p>
<p>put方法执行流程：</p>
<ol>
<li>校验null值，value不允许null值。</li>
<li>计算出key的哈希值，用哈希值和数组的长度得到index下角标。</li>
<li>根据index找到节点。</li>
<li>如果节点中有元素则遍历链表如果找到则替换旧值并返回旧值。</li>
<li>如果没找到旧值则执行<code>addEntry</code>方法，创建节点并加入哈希桶中。<code>addEntry</code>方法：<ol>
<li>首先判断是否需要扩容</li>
<li>创建节点</li>
<li>添加哈希桶中</li>
</ol>
</li>
</ol>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">         &#x2F;&#x2F; 计算索引值，</span><br><span class="line">        int hash &#x3D; key.hashCode();</span><br><span class="line">        int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#x2F;&#x2F; 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span><br><span class="line">        for (HashtableEntry&lt;?,?&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">            if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                return (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据index直接找到节点，并进行比较，找到了就返回value，没找到返回null。</p>
<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/82a5ff28b5c14da29f3081db4cc2cd23.jpg" alt="img"></p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>remove() 的作用就是<strong>删除Hashtable中键为key的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#x2F;&#x2F; 找到“key对应的Entry(链表)”</span><br><span class="line">    &#x2F;&#x2F; 然后在链表中找出要删除的节点，并删除该节点。</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; tab[index], prev &#x3D; null ; e !&#x3D; null ; prev &#x3D; e, e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            &#x2F;&#x2F;重新排列链表</span><br><span class="line">            if (prev !&#x3D; null) &#123;</span><br><span class="line">                prev.next &#x3D; e.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/7486b49ac2f4410099b5764082a6d352.jpg" alt="img"></p>
<h4 id="rehash-扩容"><a href="#rehash-扩容" class="headerlink" title="rehash 扩容"></a>rehash 扩容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">				&#x2F;&#x2F;旧数组的长度</span><br><span class="line">        int oldCapacity &#x3D; table.length;</span><br><span class="line">        &#x2F;&#x2F;旧数组</span><br><span class="line">        HashtableEntry&lt;?,?&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;新数组的长度是&#x3D;将长度变成原来的(2倍+1)</span><br><span class="line">        int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">        &#x2F;&#x2F;是否超过可存储数量的最大值</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        		&#x2F;&#x2F;已经到了最大值直接返回，不允许扩容</span><br><span class="line">            if (oldCapacity &#x3D;&#x3D; MAX_ARRAY_SIZE)</span><br><span class="line">                &#x2F;&#x2F; Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">                return;</span><br><span class="line">            &#x2F;&#x2F;没有达到最大值，直接把新数组赋值到最大值</span><br><span class="line">            newCapacity &#x3D; MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建新的数组</span><br><span class="line">        HashtableEntry&lt;?,?&gt;[] newMap &#x3D; new HashtableEntry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        &#x2F;&#x2F;计算阀值 newCapacity * loadFactor 如果到达最大存储容量，以后都不会触法</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        table &#x3D; newMap;</span><br><span class="line">				&#x2F;&#x2F;循环获取获取所有节点</span><br><span class="line">        for (int i &#x3D; oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        		&#x2F;&#x2F;循环获取节点下的所有元素</span><br><span class="line">            for (HashtableEntry&lt;K,V&gt; old &#x3D; (HashtableEntry&lt;K,V&gt;)oldMap[i] ; old !&#x3D; null ; ) &#123;</span><br><span class="line">                HashtableEntry&lt;K,V&gt; e &#x3D; old;</span><br><span class="line">                old &#x3D; old.next;</span><br><span class="line">								&#x2F;&#x2F;获取元素新的index，并存入对应的哈希桶中</span><br><span class="line">                int index &#x3D; (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">                e.next &#x3D; (HashtableEntry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有操作数据的方法都是<code>synchronized</code>线程安全的，尽管，Hashtable 虽然是线程安全的，但是我们一般不推荐使用它，因为有比它更高效、更好的选择 ConcurrentHashMap，在后面我们也会讲到它。</p>
<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul>
<li>HashMap线程不安全；Hashtable线程安全。</li>
<li>因为线程安全的问题，HashMap 要比 HashTable 效率高一点。</li>
<li>HashMap使用时候初始化哈希桶；Hashtable创建对象时创建哈希桶。</li>
<li>HashMap扩容是原来的两倍；Hashtable扩容是原来的两倍+1。</li>
<li>HashMap的初始容量为16；Hashtable初始容量为11，两者的填充因子默认都是0.75</li>
<li>HashMap允许有null值；Hashtable不允许有null值。</li>
<li>HashMap数组+链表+红黑树；Hashtable数组+链表。</li>
</ul>
<h2 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h2><ul>
<li>HashMap实现Map接口；HashSet实现Set接口。</li>
<li>HashMap储存键值对；HashSet仅存储对象（<code>value</code>是空<code>Object</code>对象）。</li>
<li>HashSet基于HashMap，内部持有HashMap引用，核心方法调用都是HashMap。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap实现了Map接口。基本实现同HashMap一样，不同之处在于HashMap是无序的而LinkedHashMap保证了迭代的有序性。其内部维护了一个双向链表，解决了 HashMap不能随时保持遍历顺序和插入顺序一致的问题。</p>
<p><strong>默认情况下，LinkedHashMap的迭代顺序是按照插入节点的顺序。也可以通过改变accessOrder参数的值，使得其遍历顺序按照访问顺序输出。</strong></p>
<p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构。该结构由数组和链表或红黑树组成。本质上，HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。在LinkedHashMapMap中，所有put进来的Entry都保存在如下面第一个图所示的哈希表中，但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166327271293.jpg" alt="img"></p>
<p>LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。其结构可能如下图：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="img"></p>
<p>上图中，淡蓝色的箭头表示前驱引用，红色箭头表示后继引用。每当有新键值对节点插入，新节点最终会接在 tail 引用指向的节点后面。而 tail 引用则会移动到新的节点上，这样一个双向链表就建立起来了。</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line"></span><br><span class="line">		static class LinkedHashMapEntry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line">        LinkedHashMapEntry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     transient LinkedHashMapEntry&lt;K,V&gt; head;</span><br><span class="line">     </span><br><span class="line">     transient LinkedHashMapEntry&lt;K,V&gt; tail;</span><br><span class="line">     </span><br><span class="line">     final boolean accessOrder;</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F;默认初始容量 (16)和默认负载因子(0.75)的空 LinkedHashMap</span><br><span class="line">     public LinkedHashMap() &#123;</span><br><span class="line">     		&#x2F;&#x2F; 调用HashMap对应的构造函数</span><br><span class="line">        super();</span><br><span class="line">        &#x2F;&#x2F; 迭代顺序的默认值</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">        super(initialCapacity);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder &#x3D; accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header、tail</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p>
<p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。</p>
<p>Map 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。那么，LinkedHashMap 是怎样建立链表的呢？在展开说明之前，我们先看一下 LinkedHashMap 插入操作相关的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;...&#125;</span><br><span class="line">    &#x2F;&#x2F; 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#123;...&#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        else if (p instanceof TreeNode) &#123;...&#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历链表，并统计链表长度</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 未在单链表中找到要插入的节点，将新节点接在单链表的后面</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#123;...&#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 插入的节点已经存在于单链表中</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null) &#123;...&#125;</span><br><span class="line">            afterNodeAccess(e);    &#x2F;&#x2F; 回调方法，后续说明</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold) &#123;...&#125;</span><br><span class="line">    afterNodeInsertion(evict);    &#x2F;&#x2F; 回调方法，后续说明</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    &#x2F;&#x2F; 将 Entry 接在双向链表的尾部</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中实现</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail;</span><br><span class="line">    tail &#x3D; p;</span><br><span class="line">    &#x2F;&#x2F; last 为 null，表明链表还未建立</span><br><span class="line">    if (last &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; p;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新节点 p 接在链表尾部</span><br><span class="line">        p.before &#x3D; last;</span><br><span class="line">        last.after &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是 LinkedHashMap 插入相关的源码，这里省略了部分非关键的代码。我根据上面的代码，可以知道 LinkedHashMap 插入操作的调用过程。如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166881843975.jpg" alt="img"></p>
<p>newNode()这一步比较关键。LinkedHashMap 覆写了该方法。在这个方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。</p>
<p>HashMap中有三个回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>根据这三个方法的注释可以看出，这些方法的用途是在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的。上一节最后提到 HashMap 中三个回调方法运行 LinkedHashMap 对一些操作做出响应。所以，在删除及节点后，回调方法 <code>afterNodeRemoval</code> 会被调用。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。相关源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            node &#x3D; p;</span><br><span class="line">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">            if (p instanceof TreeNode) &#123;...&#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历单链表，寻找要删除的节点，并赋值给 node 变量</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                         (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node &#x3D; e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                             (value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode) &#123;...&#125;</span><br><span class="line">            &#x2F;&#x2F; 将要删除的节点从单链表中移除</span><br><span class="line">            else if (node &#x3D;&#x3D; p)</span><br><span class="line">                tab[index] &#x3D; node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next &#x3D; node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);    &#x2F;&#x2F; 调用删除回调方法进行后续操作</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">    &#x2F;&#x2F; 将 p 节点的前驱后后继引用置空</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; b 为 null，表明 p 是头节点</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    &#x2F;&#x2F; a 为 null，表明 p 是尾节点</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除的过程并不复杂，上面这么多代码其实就做了三件事：</p>
<ol>
<li>根据 hash 定位到桶位置</li>
<li>遍历链表或调用红黑树相关的删除方法</li>
<li>从 LinkedHashMap 维护的双链表中移除要删除的节点</li>
</ol>
<h3 id="访问顺序的维护过程"><a href="#访问顺序的维护过程" class="headerlink" title="访问顺序的维护过程"></a>访问顺序的维护过程</h3><p>默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。访问顺序的原理上并不复杂，当我们调用<code>get/getOrDefault/replace</code>等方法时，只需要将这些方法访问的节点移动到链表的尾部即可。相应的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    &#x2F;&#x2F; 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 如果 b 为 null，表明 p 为头节点</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">            </span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 这里存疑，父条件分支已经确保节点 e 不会是尾节点，</span><br><span class="line">         * 那么 e.after 必然不会为 null，不知道 else 分支有什么作用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">    </span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 将 p 接在链表的最后</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-LinkedHashMap-实现缓存"><a href="#基于-LinkedHashMap-实现缓存" class="headerlink" title="基于 LinkedHashMap 实现缓存"></a>基于 LinkedHashMap 实现缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    &#x2F;&#x2F; 根据条件判断是否移除最近最少被访问的节点</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是通过一些条件，判断是否移除最近最少被访问的节点。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写<code>removeEldestEntry</code>方法可以实现自定义策略的 LRU 缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等。本节所实现的缓存是基于判断节点数量是否超限的策略。在构造缓存对象时，传入最大节点数。当插入的节点数超过最大节点数时，移除最近最少被访问的节点。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_NODE_NUM &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    private int limit;</span><br><span class="line"></span><br><span class="line">    public SimpleCache() &#123;</span><br><span class="line">        this(MAX_NODE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SimpleCache(int limit) &#123;</span><br><span class="line">        super(limit, 0.75f, true);</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V save(K key, V val) &#123;</span><br><span class="line">        return put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V getOne(K key) &#123;</span><br><span class="line">        return get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean exists(K key) &#123;</span><br><span class="line">        return containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断节点数是否超限</span><br><span class="line">     * @param eldest</span><br><span class="line">     * @return 超限返回 true，否则返回 false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<p>举例：声明了两个Map对象，一个是HashMap，一个是WeakHashMap，同时向两个map中放入a、b两个对象，当HashMap remove掉a 并且将a、b都指向null时，WeakHashMap中的a将自动被回收掉。出现这个状况的原因是，对于a对象而言，当HashMap remove掉并且将a指向null后，除了WeakHashMap中还保存a外已经没有指向a的指针了，所以WeakHashMap会自动舍弃掉a，而对于b对象虽然指向了null，但HashMap中还有指向b的指针，所以WeakHashMap将会保留。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>内部红黑树实现</li>
<li>key-value不为空</li>
<li>TreeMap有序</li>
</ul>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;比较器，是自然排序，还是定制排序 ，使用final修饰，表明一旦赋值便不允许改变</span><br><span class="line">		private final Comparator&lt;? super K&gt; comparator;  </span><br><span class="line">		private transient Entry&lt;K,V&gt; root &#x3D; null;  &#x2F;&#x2F;红黑树的根节点</span><br><span class="line">		private transient int size &#x3D; 0;     &#x2F;&#x2F;TreeMap中存放的键值对的数量</span><br><span class="line">		private transient int modCount &#x3D; 0;   &#x2F;&#x2F;修改的次数</span><br><span class="line">    </span><br><span class="line">    private static final boolean RED   &#x3D; false;</span><br><span class="line">    private static final boolean BLACK &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;    &#x2F;&#x2F;键</span><br><span class="line">    V value;    &#x2F;&#x2F;值</span><br><span class="line">    Entry&lt;K,V&gt; left &#x3D; null;     &#x2F;&#x2F;左孩子节点</span><br><span class="line">    Entry&lt;K,V&gt; right &#x3D; null;    &#x2F;&#x2F;右孩子节点</span><br><span class="line">    Entry&lt;K,V&gt; parent;          &#x2F;&#x2F;父节点</span><br><span class="line">    boolean color &#x3D; BLACK;      &#x2F;&#x2F;节点的颜色，在红黑树种，只有两种颜色，红色和黑色</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造方法，用指定的key,value ,parent初始化，color默认为黑色</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;构造方法，comparator用键的顺序做比较</span><br><span class="line">		public TreeMap() &#123;</span><br><span class="line">		    comparator &#x3D; null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;构造方法，提供比较器，用指定比较器排序</span><br><span class="line">		public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">		    his.comparator &#x3D; comparator;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;将m中的元素转化daoTreeMap中，按照键的顺序做比较排序</span><br><span class="line">		public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">		    comparator &#x3D; null;</span><br><span class="line">		    putAll(m);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;构造方法，指定的参数为SortedMap</span><br><span class="line">		&#x2F;&#x2F;采用m的比较器排序</span><br><span class="line">		public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123;</span><br><span class="line">		    comparator &#x3D; m.comparator();</span><br><span class="line">		    try &#123;</span><br><span class="line">		        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</span><br><span class="line">		    &#125; catch (java.io.IOException cannotHappen) &#123;</span><br><span class="line">		    &#125; catch (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序.</p>
<ul>
<li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li>
<li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li>
</ul>
<h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">				&#x2F;&#x2F;&#x2F;&#x2F;红黑树的根节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; t &#x3D; root;</span><br><span class="line">        &#x2F;&#x2F;红黑树是否为空</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">            compare(key, key); &#x2F;&#x2F; type (and possibly null) check</span><br><span class="line">            &#x2F;&#x2F;构造根节点，因为根节点没有父节点，传入null值。</span><br><span class="line">            root &#x3D; new TreeMapEntry&lt;&gt;(key, value, null);</span><br><span class="line">            size &#x3D; 1;</span><br><span class="line">            modCount++;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp;</span><br><span class="line">         &#x2F;&#x2F;定义节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; parent;</span><br><span class="line">        &#x2F;&#x2F; split comparator and comparable paths</span><br><span class="line">        &#x2F;&#x2F;获取比较器</span><br><span class="line">        Comparator&lt;? super K&gt; cpr &#x3D; comparator;</span><br><span class="line">        &#x2F;&#x2F;如果定义了比较器，采用自定义比较器进行比较</span><br><span class="line">        if (cpr !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;do while 做循环排序 找到父节点</span><br><span class="line">            do &#123;</span><br><span class="line">             &#x2F;&#x2F;将红黑树根节点赋值给parent</span><br><span class="line">                parent &#x3D; t;</span><br><span class="line">                 &#x2F;&#x2F;比较key, 与根节点的大小</span><br><span class="line">                cmp &#x3D; cpr.compare(key, t.key);</span><br><span class="line">                &#x2F;&#x2F;如果key &lt; t.key , 指向左子树</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                &#x2F;&#x2F;t &#x3D; t.left  , t &#x3D;&#x3D; 它的左孩子节点</span><br><span class="line">                    t &#x3D; t.left;</span><br><span class="line">                else if (cmp &gt; 0)&#x2F;&#x2F;如果key &gt; t.key , 指向它的右孩子节点</span><br><span class="line">                    t &#x3D; t.right;</span><br><span class="line">                else &#x2F;&#x2F;如果它们相等，替换key的值</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;自然排序方式，没有指定比较器</span><br><span class="line">        		&#x2F;&#x2F;key &#x3D;&#x3D; null 抛出异常</span><br><span class="line">            if (key &#x3D;&#x3D; null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">            &#x2F;&#x2F;一样 循环排序 找到父节点</span><br><span class="line">                parent &#x3D; t;</span><br><span class="line">                cmp &#x3D; k.compareTo(t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t &#x3D; t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t &#x3D; t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建新节点，并制定父节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; e &#x3D; new TreeMapEntry&lt;&gt;(key, value, parent);</span><br><span class="line">       &#x2F;&#x2F;根据比较结果，决定新节点为父节点的左孩子或者右孩子</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            parent.left &#x3D; e;</span><br><span class="line">        else</span><br><span class="line">            parent.right &#x3D; e;</span><br><span class="line">        &#x2F;&#x2F;新插入节点后重新调整红黑树</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="compare方法-比较器"><a href="#compare方法-比较器" class="headerlink" title="compare方法 比较器"></a>compare方法 比较器</h4><p>比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final int compare(Object k1, Object k2) &#123;</span><br><span class="line">        return comparator&#x3D;&#x3D;null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</span><br><span class="line">            : comparator.compare((K)k1, (K)k2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fixAfterInsertion-重新调整红黑树"><a href="#fixAfterInsertion-重新调整红黑树" class="headerlink" title="fixAfterInsertion 重新调整红黑树"></a>fixAfterInsertion 重新调整红黑树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void fixAfterInsertion(TreeMapEntry&lt;K,V&gt; x) &#123;</span><br><span class="line">		    &#x2F;&#x2F;插入的节点默认的颜色为红色</span><br><span class="line">        x.color &#x3D; RED;</span><br><span class="line">				 &#x2F;&#x2F;情形1：新节点x 是树的根节点，没有父节点不需要任何操作</span><br><span class="line">		    &#x2F;&#x2F;情形2：新节点x 的父节点颜色是黑色的，也不需要任何操作</span><br><span class="line">        while (x !&#x3D; null &amp;&amp; x !&#x3D; root &amp;&amp; x.parent.color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">            &#x2F;&#x2F;情形3：新节点x的父节点颜色是红色的</span><br><span class="line">				    &#x2F;&#x2F;判断x的节点的父节点位置，是否属于左孩子</span><br><span class="line">            if (parentOf(x) &#x3D;&#x3D; leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">              &#x2F;&#x2F;获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y &#x3D; rightOf(parentOf(parentOf(x)));</span><br><span class="line">               &#x2F;&#x2F;判断是否x节点的父节点的兄弟节点为红色。</span><br><span class="line">                if (colorOf(y) &#x3D;&#x3D; RED) &#123;</span><br><span class="line">		                &#x2F;&#x2F; x节点的父节点设置为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    &#x2F;&#x2F; y节点的颜色设置为黑色</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    &#x2F;&#x2F; x.parent.parent设置为红色</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    &#x2F;&#x2F; x &#x3D;&#x3D; x.parent.parent ,进行遍历。</span><br><span class="line">                    x &#x3D; parentOf(parentOf(x));</span><br><span class="line">                &#125; else &#123;&#x2F;&#x2F;x的父节点的兄弟节点是黑色或者缺少的</span><br><span class="line">	                  &#x2F;&#x2F;判断x节点是否为父节点的右孩子</span><br><span class="line">                    if (x &#x3D;&#x3D; rightOf(parentOf(x))) &#123;</span><br><span class="line">                   		 &#x2F;&#x2F;x &#x3D;&#x3D; 父节点</span><br><span class="line">                        x &#x3D; parentOf(x);</span><br><span class="line">                        &#x2F;&#x2F;左旋转操作</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;x节点是其父的左孩子</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    &#x2F;&#x2F;进行右旋转</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">		             &#x2F;&#x2F;y 是x 节点的祖父节点的左孩子</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y &#x3D; leftOf(parentOf(parentOf(x)));</span><br><span class="line">                if (colorOf(y) &#x3D;&#x3D; RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x &#x3D; parentOf(parentOf(x));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (x &#x3D;&#x3D; leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x &#x3D; parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色</span><br><span class="line">        root.color &#x3D; BLACK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>红黑树是一个更高效的检索二叉树，有如下特点：</p>
<ul>
<li>每个节点只能是红色或者黑色</li>
<li>根节点永远是黑色的</li>
<li>所有的叶子的子节点都是空节点，并且都是黑色的</li>
<li>每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点）</li>
<li>从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同）</li>
</ul>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>TreeMap底层是红黑树结构，而红黑树本质是一颗二叉查找树，所以在获取节点方面，使用二分查找算法性能最高；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过key获取对应的value：</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取TreeMap中对应的节点：</span><br><span class="line">    java.util.TreeMap.Entry&lt;K,V&gt; p &#x3D; getEntry(key);</span><br><span class="line">    &#x2F;&#x2F;获取节点的值：</span><br><span class="line">    return (p&#x3D;&#x3D;null ? null : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过key获取Entry对象：</span><br><span class="line">final java.util.TreeMap.Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F;TreeMap自定义比较器不为空，使用自定义比较器对象来获取节点：</span><br><span class="line">    if (comparator !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F;获取节点：</span><br><span class="line">        return getEntryUsingComparator(key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果key为null，则抛出异常，TreeMap中不允许存在为null的key：</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将传入的key转换成Comparable类型，传入的key必须实现Comparable接口</span><br><span class="line">    Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key;</span><br><span class="line">    &#x2F;&#x2F;获取根节点：</span><br><span class="line">    java.util.TreeMap.Entry&lt;K,V&gt; p &#x3D; root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用二分查找方式，首先判断传入的key与根节点的key哪个大：</span><br><span class="line">    while (p !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;传入的key与p节点的key进行大小比较：</span><br><span class="line">        int cmp &#x3D; k.compareTo(p.key);</span><br><span class="line">        &#x2F;&#x2F;传入的key小于p节点的key,则从根的左子树中搜索：</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            &#x2F;&#x2F;左边</span><br><span class="line">            p &#x3D; p.left;</span><br><span class="line">        else if (cmp &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;传入的key大于p节点的key,则从根的右边子树中搜索：</span><br><span class="line">            &#x2F;&#x2F;右边</span><br><span class="line">            p &#x3D; p.right;</span><br><span class="line">        else</span><br><span class="line">            &#x2F;&#x2F;传入的key等于p节点的key,则直接返回当前节点：</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;以上循环没有找对对应的节点，则返回null：</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用自定义比较器进行元素比较，获取对节点：</span><br><span class="line">final java.util.TreeMap.Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;</span><br><span class="line">    K k &#x3D; (K) key;</span><br><span class="line">    Comparator&lt;? super K&gt; cpr &#x3D; comparator;</span><br><span class="line">    if (cpr !&#x3D; null) &#123;</span><br><span class="line">        java.util.TreeMap.Entry&lt;K,V&gt; p &#x3D; root;</span><br><span class="line">        while (p !&#x3D; null) &#123;</span><br><span class="line">            int cmp &#x3D; cpr.compare(k, p.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                p &#x3D; p.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                p &#x3D; p.right;</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Removes the mapping for this key from this TreeMap if present.</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Entry p &#x3D; getEntry(key);</span><br><span class="line">        if (p &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        V oldValue &#x3D; p.value;</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  通过这段代码可以看出，TreeMap的remove()方法中执行删除的真正方式是deleteEntry()方法。deleteEntry()代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Delete node p, and then rebalance the tree.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void deleteEntry(Entry p) &#123;</span><br><span class="line">        modCount++;&#x2F;&#x2F;修改次数 +1；</span><br><span class="line">        size--;&#x2F;&#x2F;元素个数 -1</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If strictly internal, copy successor&#39;s element to p and then make p</span><br><span class="line">        &#x2F;&#x2F; point to successor.</span><br><span class="line">		&#x2F;*</span><br><span class="line">         * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span><br><span class="line">         * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点</span><br><span class="line">         * ---------------------（1）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (p.left !&#x3D; null &amp;&amp; p.right !&#x3D; null) &#123;</span><br><span class="line">            Entry s &#x3D; successor (p);</span><br><span class="line">            p.key &#x3D; s.key;</span><br><span class="line">            p.value &#x3D; s.value;</span><br><span class="line">            p &#x3D; s;</span><br><span class="line">        &#125; &#x2F;&#x2F; p has 2 children</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start fixup at replacement node, if it exists.</span><br><span class="line">		&#x2F;&#x2F;replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代</span><br><span class="line">        Entry replacement &#x3D; (p.left !&#x3D; null ? p.left : p.right);</span><br><span class="line">		&#x2F;*</span><br><span class="line">         * 删除节点，分为上面提到的三种情况</span><br><span class="line">         * -----------------------（2）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;如果替代节点不为空</span><br><span class="line">        if (replacement !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; Link replacement to parent</span><br><span class="line">			&#x2F;&#x2F;replacement来替代P节点</span><br><span class="line">            replacement.parent &#x3D; p.parent;</span><br><span class="line">            if (p.parent &#x3D;&#x3D; null)</span><br><span class="line">                root &#x3D; replacement;</span><br><span class="line">            else if (p &#x3D;&#x3D; p.parent.left)</span><br><span class="line">                p.parent.left  &#x3D; replacement;</span><br><span class="line">            else</span><br><span class="line">                p.parent.right &#x3D; replacement;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Null out links so they are OK to use by fixAfterDeletion.</span><br><span class="line">            p.left &#x3D; p.right &#x3D; p.parent &#x3D; null;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Fix replacement</span><br><span class="line">            if (p.color &#x3D;&#x3D; BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br><span class="line">        &#125; else if (p.parent &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; return if we are the only node.</span><br><span class="line">            root &#x3D; null;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;  No children. Use self as phantom replacement and unlink.</span><br><span class="line">            if (p.color &#x3D;&#x3D; BLACK)</span><br><span class="line">                fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">            if (p.parent !&#x3D; null) &#123;</span><br><span class="line">                if (p &#x3D;&#x3D; p.parent.left)</span><br><span class="line">                    p.parent.left &#x3D; null;</span><br><span class="line">                else if (p &#x3D;&#x3D; p.parent.right)</span><br><span class="line">                    p.parent.right &#x3D; null;</span><br><span class="line">                p.parent &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/2019060710430212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li>
<li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。</li>
<li>要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</li>
<li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" itemprop="url">七大设计原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h1><h2 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则"></a>单一原则</h2><p>一个类做一件事情，避免职责过多。就一个类来说，应该只有一个引起它变化的原因（只负责担任一个职责）</p>
<blockquote>
<p>如果一个类承担的职责过多，即耦合性太高一个职责的变化可能会影响到其他的职责</p>
</blockquote>
<h3 id="问题由来："><a href="#问题由来：" class="headerlink" title="问题由来："></a>问题由来：</h3><p>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p>遵循单一职责原的优点有：</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭</p>
<blockquote>
<p>对于扩展是开放的，对于修改是封闭的。尽量做到面对需求的改变时，我们的代码能保持相对稳定，通过扩展的方式应对变化，而不是修改原有代码实现</p>
<p>符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</p>
</blockquote>
<h3 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h3><p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<h2 id="里氏代替原则"><a href="#里氏代替原则" class="headerlink" title="里氏代替原则"></a>里氏代替原则</h2><p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>定义1：</strong>如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p>
<p><strong>定义2：</strong>所有引用基类的地方必须能透明地使用其子类的对象。</p>
<h3 id="问题由来-1"><a href="#问题由来-1" class="headerlink" title="问题由来"></a>问题由来</h3><p>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>解决方案：</strong>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<h3 id="多态是不是违背了里氏替换原则？"><a href="#多态是不是违背了里氏替换原则？" class="headerlink" title="多态是不是违背了里氏替换原则？"></a>多态是不是违背了里氏替换原则？</h3><p>里氏替换原则是针对继承而言的，<strong>如果继承是为了实现代码重用</strong>，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</p>
<p> <strong>如果继承的目的是为了多态</strong>，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</p>
<p>不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p>
<p><strong>如何符合LSP？总结一句话</strong> <strong>——</strong> <strong>就是尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</strong></p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则的核心思想是<strong>面向接口编程，</strong></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</strong></p>
<h3 id="问题由来：-1"><a href="#问题由来：-1" class="headerlink" title="问题由来："></a>问题由来：</h3><p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Book&#123;</span><br><span class="line">	public String getContent()&#123;</span><br><span class="line">		return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Mother&#123;</span><br><span class="line">	public void narrate(Book book)&#123;</span><br><span class="line">		System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">		System.out.println(book.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Mother mother &#x3D; new Mother();</span><br><span class="line">		mother.narrate(new Book());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure>

<p>​    运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"林书豪38+7领导尼克斯击败湖人……"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"林书豪17+9助尼克斯击败老鹰……"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(IReader reader)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">		System.out.println(reader.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">		mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">		mother.narrate(<span class="keyword">new</span> Newspaper());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br><span class="line">妈妈开始讲故事</span><br><span class="line">林书豪17+9助尼克斯击败老鹰……</span><br></pre></td></tr></table></figure>

<p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。</li>
</ul>
<h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>依赖是一种关系，通俗来讲就是一种需要。  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-69e25239dbeb6ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">程序员需要电脑，因为没有电脑程序员就没有办法编写代码，所以说程序员<strong>依赖</strong>电脑，电脑被程序员依赖。  </p>
<h3 id="控制反转-Inversion-of-Control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转(Inversion of Control)"></a>控制反转(Inversion of Control)</h3><p><a href="https://cloud.tencent.com/developer/article/1383115这篇文章对依赖、依赖倒置、控制反转、依赖注入的解释。" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1383115这篇文章对依赖、依赖倒置、控制反转、依赖注入的解释。</a></p>
<p>IoC 是一种新的设计模式，它对上层模块与底层模块进行了更进一步的解耦。*<em>意思就是对于控制权的转移。它对上层模块与底层模块进行了更进一步的解耦。反转了上层模块对于底层模块的依赖控制。 *</em></p>
<p>应用程序本身不负责依赖对象的创建和维护，而是将它交给一个外部容器（比如Unity）来负责，这样控制权就由应用程序转移到了外部IoC 容器，即控制权实现了所谓的反转。例如在类型A中需要使用类型B的实例，而B 实例的创建并不由A 来负责，而是通过外部容器来创建。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>我们到餐厅去叫外卖，餐厅有专门送外卖的外卖员，他们的使命就是及时送达外卖食品。</p>
<p>依照<strong>依赖倒置原则</strong>，我们可以创建这样一个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WaimaiYuan &#123;</span><br><span class="line"></span><br><span class="line">    protected Food food;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public WaimaiYuan(Food food) &#123;</span><br><span class="line">        this.food &#x3D; food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void songWaiMai();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Xiaohuozi extends WaimaiYuan &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Xiaohuozi(Food food) &#123;</span><br><span class="line">        super(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void songWaiMai() &#123;</span><br><span class="line">        System.out.println(&quot;我是小伙子,为您送的外卖是：&quot;+food);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XiaoGuniang extends WaimaiYuan &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public XiaoGuniang(Food food) &#123;</span><br><span class="line">        super(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void songWaiMai() &#123;</span><br><span class="line">        System.out.println(&quot;我是小姑娘,为您送的外卖是：&quot;+food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WaimaiYuan 是抽象类，代表送外卖的，Xiaohuozi 和 XiaoGuniang 是它的继承者，说明他们都可以送外卖。WaimaiYuan 都依赖于 Food，但是它没有实例化 Food 的权力。</p>
<p>再编写食物类代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Food &#123;</span><br><span class="line">    protected String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PijiuYa extends Food &#123;</span><br><span class="line"></span><br><span class="line">    public PijiuYa() &#123;</span><br><span class="line">        name &#x3D; &quot;啤酒鸭&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DuojiaoYutou extends Food &#123;</span><br><span class="line"></span><br><span class="line">    public DuojiaoYutou() &#123;</span><br><span class="line">        name &#x3D; &quot;剁椒鱼头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Food 是抽象类，PijiuYa 和 DuojiaoYutou 都是实现细节。  </p>
<p>IoC 少不了 IoC 容器，也就是实例化抽象的地方。我们编写一个餐厅类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Restaurant &#123;</span><br><span class="line"></span><br><span class="line">    public static void peican(int orderid,int flowid) &#123;</span><br><span class="line">        WaimaiYuan person;</span><br><span class="line">        Food food;</span><br><span class="line"></span><br><span class="line">        if ( orderid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            food &#x3D; new PijiuYa();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            food &#x3D; new DuojiaoYutou();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ( flowid % 2 &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">            person &#x3D; new Xiaohuozi(food);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            person &#x3D; new XiaoGuniang(food);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        person.songWaiMai();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>orderid 代表菜品编号，0 是啤酒鸭，其它则是剁椒鱼头。  </p>
<p> flowid 是订单的流水号码。 餐厅根据流水编码的不同来指派小伙子或者小姑娘来送外卖，编写测试代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class IocTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Restaurant.peican(0, 0);</span><br><span class="line">        Restaurant.peican(0, 1);</span><br><span class="line">        Restaurant.peican(1, 2);</span><br><span class="line">        Restaurant.peican(0, 3);</span><br><span class="line">        Restaurant.peican(1, 4);</span><br><span class="line">        Restaurant.peican(1, 5);</span><br><span class="line">        Restaurant.peican(1, 6);</span><br><span class="line">        Restaurant.peican(0, 7);</span><br><span class="line">        Restaurant.peican(0, 8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>餐厅一次性送了 9 份外卖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我是小伙子,为您送的外卖是：啤酒鸭</span><br><span class="line">我是小姑娘,为您送的外卖是：啤酒鸭</span><br><span class="line">我是小伙子,为您送的外卖是：剁椒鱼头</span><br><span class="line">我是小姑娘,为您送的外卖是：啤酒鸭</span><br><span class="line">我是小伙子,为您送的外卖是：剁椒鱼头</span><br><span class="line">我是小姑娘,为您送的外卖是：剁椒鱼头</span><br><span class="line">我是小伙子,为您送的外卖是：剁椒鱼头</span><br><span class="line">我是小姑娘,为您送的外卖是：啤酒鸭</span><br><span class="line">我是小伙子,为您送的外卖是：啤酒鸭</span><br></pre></td></tr></table></figure>

<p>可以看到的是，因为有 Restaurant 这个 IoC 容器存在，大大地解放了外卖员的生产力，外卖员不再依赖具体的食物，具体的食物也不再依赖于特定的外卖员。也就是说，只要是食物外卖员就可以送，任何一种食物可以被任何一位外卖员送。  </p>
<p>大家细细体会这是怎么样一种灵活性。如果非要外卖员自己决定配送什么食物，人少则还行，人多的时候，订单多的时候肯定会乱成一锅粥。</p>
<p><strong>IoC 模式最核心的地方就是在于依赖方与被依赖方之间，也就是上文中说的上层模块与底层模块之间引入了第三方，这个第三方统称为 IoC 容器，因为 IoC 容器的介入，导致上层模块对于它的依赖的实例化控制权发生变化，也就是所谓的控制反转的意思。</strong></p>
<h3 id="依赖注入-Dependency-injection"><a href="#依赖注入-Dependency-injection" class="headerlink" title="依赖注入(Dependency injection)"></a>依赖注入(Dependency injection)</h3><p>依赖注入，被简称为 DI，它是一种实现 IoC 的手段。</p>
<p>实现依赖注入有 3 种方式：</p>
<ul>
<li>构造函数中注入</li>
<li>setter 方式注入</li>
<li>接口注入</li>
</ul>
<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public Person(Driveable driveable) &#123;</span><br><span class="line"></span><br><span class="line">        this.mDriveable &#x3D; driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void chumen() &#123;</span><br><span class="line">        System.out.println(&quot;出门了&quot;);</span><br><span class="line"></span><br><span class="line">        mDriveable.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：在 Person 一开始创建的时候就确定好了依赖。  </p>
</li>
<li><p>缺点：后期无法更改依赖。  </p>
</li>
</ul>
<h4 id="setter-方式注入"><a href="#setter-方式注入" class="headerlink" title="setter 方式注入"></a>setter 方式注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void chumen() &#123;</span><br><span class="line">        System.out.println(&quot;出门了&quot;);</span><br><span class="line"></span><br><span class="line">        mDriveable.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void setDriveable(Driveable mDriveable) &#123;</span><br><span class="line">        this.mDriveable &#x3D; mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：Person 对象在运行过程中可以灵活地更改依赖。 </p>
</li>
<li><p>缺点：Person 对象运行时，可能会存在依赖项为 null 的情况，所以需要检测依赖项的状态。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void chumen() &#123;</span><br><span class="line"></span><br><span class="line">    if ( mDriveable !&#x3D; null ) &#123;</span><br><span class="line">        System.out.println(&quot;出门了&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口方式注入"><a href="#接口方式注入" class="headerlink" title="接口方式注入"></a>接口方式注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface DepedencySetter &#123;</span><br><span class="line">    void set(Driveable driveable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person implements DepedencySetter&#123;</span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public void chumen() &#123;</span><br><span class="line"></span><br><span class="line">        if ( mDriveable !&#x3D; null ) &#123;</span><br><span class="line">            System.out.println(&quot;出门了&quot;);</span><br><span class="line">            mDriveable.drive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(Driveable driveable) &#123;</span><br><span class="line">        this.mDriveable &#x3D; mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式和 Setter 方式很相似。有很多同学可能有疑问那么加入一个接口是不是多此一举呢？</p>
<p>答案肯定是不是的，这涉及到一个角色的问题。还是以前面的餐厅为例，除了外卖员之外还有厨师和服务员，那么如果只有外卖员实现了一个送外卖的接口的话，那么餐厅配餐的时候就只会把外卖配置给外卖员。  </p>
<p><strong>接口的存在，表明了一种依赖配置的能力。</strong> </p>
<p>在软件框架中，读取 xml 配置文件，或者是利用反射技术读取注解，然后根据配置信息，框架动态将一些依赖配置给特定接口的类，<strong>我们也可以说 Injector 也依赖于接口，而不是特定的实现类</strong>，这样进一步提高了准确性与灵活性。 </p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>依赖倒置是面向对象开发领域中的软件设计原则，它倡导上层模块不依赖于底层模块，抽象不依赖细节。</li>
<li>依赖反转是遵守依赖倒置这个原则而提出来的一种设计模式，它引入了 IoC 容器的概念。</li>
<li>依赖注入是为了实现依赖反转的一种手段之一。</li>
<li>它们的本质是为了代码更加的<strong>“高内聚,低耦合”</strong>。   </li>
<li>Android 开发中很出名的依赖注入框架 Dagger2。  </li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><strong>定义：</strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p><strong>问题由来：</strong>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>
<p><strong>解决方案：</strong>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-798818b195d11913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">interface I &#123;</span><br><span class="line">	public void method1();</span><br><span class="line">	public void method2();</span><br><span class="line">	public void method3();</span><br><span class="line">	public void method4();</span><br><span class="line">	public void method5();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class A&#123;</span><br><span class="line">	public void depend1(I i)&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend2(I i)&#123;</span><br><span class="line">		i.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend3(I i)&#123;</span><br><span class="line">		i.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B implements I&#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;类B实现接口I的方法1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method2() &#123;</span><br><span class="line">		System.out.println(&quot;类B实现接口I的方法2&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method3() &#123;</span><br><span class="line">		System.out.println(&quot;类B实现接口I的方法3&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span><br><span class="line">	&#x2F;&#x2F;所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">	public void method4() &#123;&#125;</span><br><span class="line">	public void method5() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class C&#123;</span><br><span class="line">	public void depend1(I i)&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend2(I i)&#123;</span><br><span class="line">		i.method4();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend3(I i)&#123;</span><br><span class="line">		i.method5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class D implements I&#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;类D实现接口I的方法1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span><br><span class="line">	&#x2F;&#x2F;所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">	public void method2() &#123;&#125;</span><br><span class="line">	public void method3() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">	public void method4() &#123;</span><br><span class="line">		System.out.println(&quot;类D实现接口I的方法4&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method5() &#123;</span><br><span class="line">		System.out.println(&quot;类D实现接口I的方法5&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		A a &#x3D; new A();</span><br><span class="line">		a.depend1(new B());</span><br><span class="line">		a.depend2(new B());</span><br><span class="line">		a.depend3(new B());</span><br><span class="line">		</span><br><span class="line">		C c &#x3D; new C();</span><br><span class="line">		c.depend1(new D());</span><br><span class="line">		c.depend2(new D());</span><br><span class="line">		c.depend3(new D());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-798818b195d11913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">interface I1 &#123;</span><br><span class="line">	public void method1();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">interface I2 &#123;</span><br><span class="line">	public void method2();</span><br><span class="line">	public void method3();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">interface I3 &#123;</span><br><span class="line">	public void method4();</span><br><span class="line">	public void method5();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class A&#123;</span><br><span class="line">	public void depend1(I1 i)&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend2(I2 i)&#123;</span><br><span class="line">		i.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend3(I2 i)&#123;</span><br><span class="line">		i.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B implements I1, I2&#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;类B实现接口I1的方法1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method2() &#123;</span><br><span class="line">		System.out.println(&quot;类B实现接口I2的方法2&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method3() &#123;</span><br><span class="line">		System.out.println(&quot;类B实现接口I2的方法3&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class C&#123;</span><br><span class="line">	public void depend1(I1 i)&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend2(I3 i)&#123;</span><br><span class="line">		i.method4();</span><br><span class="line">	&#125;</span><br><span class="line">	public void depend3(I3 i)&#123;</span><br><span class="line">		i.method5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class D implements I1, I3&#123;</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;类D实现接口I1的方法1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method4() &#123;</span><br><span class="line">		System.out.println(&quot;类D实现接口I3的方法4&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void method5() &#123;</span><br><span class="line">		System.out.println(&quot;类D实现接口I3的方法5&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口隔离原则的含义是：</strong>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p> 采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>
<h2 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h2><p><strong>定义：</strong>一个对象应该对其他对象保持最少的了解。</p>
<p><strong>问题由来：</strong>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><strong>解决方案：</strong>尽量降低类与类之间的耦合。</p>
<p>迪米特法则又叫最少知道原则，就是一个类对自己依赖的类知道的越少越好。对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</p>
<p>迪米特法则还有一个更简单的定义：<strong>只与直接的朋友通信</strong>。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。<strong>耦合的方式很多，依赖、关联、组合、聚合等</strong>。其中，我们称<strong>出现成员变量、方法参数、方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类则不是直接的朋友</strong>。也就是说，<strong>陌生的类最好不要作为局部变量的形式出现在类的内部。</strong></p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//分公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubEmployee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">			SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line">			<span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">			emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			<span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">			emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		<span class="keyword">for</span>(SubEmployee e:list1)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		<span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		CompanyManager e = <span class="keyword">new</span> CompanyManager();</span><br><span class="line">		e.printAllEmployee(<span class="keyword">new</span> SubCompanyManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;</span><br><span class="line">	public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">		for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">			SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">			&#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">			emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	public void printEmployee()&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list &#x3D; this.getAllEmployee();</span><br><span class="line">		for(SubEmployee e:list)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class CompanyManager&#123;</span><br><span class="line">	public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">		List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">			Employee emp &#x3D; new Employee();</span><br><span class="line">			&#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">			emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">		sub.printEmployee();</span><br><span class="line">		List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">		for(Employee e:list2)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p>
<p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><strong>定义：</strong>尽量使用对象<strong>组合，而不是继承</strong>来达到复用的目的。</p>
<p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：<strong>复用时要尽量使用组合\聚合关系（关联关系），少用继承</strong>。</p>
<h3 id="实现复用的两种方式"><a href="#实现复用的两种方式" class="headerlink" title="实现复用的两种方式"></a>实现复用的两种方式</h3><p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即<strong>通过组合/聚合关系或通过继承</strong>，但<strong>首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少</strong>；其次才考虑继承，<strong>在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</strong></p>
<h4 id="组合聚合复用"><a href="#组合聚合复用" class="headerlink" title="组合聚合复用"></a>组合聚合复用</h4><ul>
<li>新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的。</li>
<li>这种复用支持包装。</li>
<li>这种复用所需要的依赖较少。</li>
<li>每一个新的类可以将焦点集中到一个任务上。</li>
<li>这种复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li>
</ul>
<p>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p>
<p><strong>缺点：</strong>组合复用建造的系统会有较多的对象需要管理。</p>
<h4 id="继承复用"><a href="#继承复用" class="headerlink" title="继承复用"></a>继承复用</h4><p>继承复用通过扩展一个已有对象的实现来得到新的功能，基类明显的捕获共同的属性和方法，而子类通过增加新的属性和方法来扩展超类的实现。</p>
<p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。</p>
<p><strong>优点：</strong></p>
<ul>
<li>新的实现比较容易，因为基类的大部分功能都可以通过继承自动的进入子类。</li>
<li>修改或扩展继承而来的实现较为容易。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>继承复用破坏了包装，因为继承超类的的实现细节暴露给子类。由于超类的内部细节常常对子类是透明的，因此这种复用是透明的复用，又称“白箱”复用。</li>
<li>如果超类的实现发生改变，那么子类的实现也不得不发生改变。因此，当一个基类发生改变时，这种改变就会像水中投入石子引起的水波一样，将变化一圈又一圈的传导到一级又一级的子类，使设计师不得不相应地改变这些子类，以适应超类的变化。</li>
<li>从超类继承而来的实现是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li>
</ul>
<h4 id="使用组合还是继承"><a href="#使用组合还是继承" class="headerlink" title="使用组合还是继承"></a>使用组合还是继承</h4><p>按照组合复用原则我们应该首选组合，然后才是继承，使用继承时应该严格的遵守里氏替换原则，必须满足“Is-A”的关系是才能使用继承，而组合却是一种“Has-A”的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把“Has-A”当成了“Is-A”。</p>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><ul>
<li>括单例模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构性设计模式是从程序的结构上解决模块之间的耦合问题。</p>
<ul>
<li>包括适配器模式</li>
<li>代理模式</li>
<li>装饰模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>主要处理类或对象如何交互及如何分配职责。</p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介模式</li>
<li>解析器模式</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Android/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Android/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="url">Android面试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Android/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Android/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android基础面试题详解"><a href="#Android基础面试题详解" class="headerlink" title="Android基础面试题详解"></a>Android基础面试题详解</h1><p><img src="https://img-blog.csdnimg.cn/2020041121370949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70#pic_center" alt="Android面试知识框架"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
