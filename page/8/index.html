<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/ActivityThread%E5%BC%80%E5%90%AFActivity(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/28/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/ActivityThread%E5%BC%80%E5%90%AFActivity(3)/" itemprop="url">ActivityThread开启Activity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-28T15:30:08+08:00">
                2020-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/" itemprop="url" rel="index">
                    <span itemprop="name">Activity</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/" itemprop="url" rel="index">
                    <span itemprop="name">startActivity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/28/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/ActivityThread%E5%BC%80%E5%90%AFActivity(3)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/28/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/ActivityThread%E5%BC%80%E5%90%AFActivity(3)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ActivityThread源码分析-3"><a href="#ActivityThread源码分析-3" class="headerlink" title="ActivityThread源码分析(3)"></a>ActivityThread源码分析(3)</h1><p>在Zygote进程中会创建新的子进程，然后通过反射调用<code>ActivityThread</code>中的Main方法.可以理解为这里是进程的入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F;初始化UserEnvironment内部类</span><br><span class="line">        Environment.initForCurrentUser();     </span><br><span class="line">				&#x2F;&#x2F;更改此进程的argv [0]参数。 这对于在诸如“ ps”命令之类的内容中显示更多描述性信息很有用。</span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">				&#x2F;&#x2F;开启主线程中loop</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">				&#x2F;&#x2F;创建    ActivityThread</span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line">				&#x2F;&#x2F;创建主线程Handler final H mH &#x3D; new H();</span><br><span class="line">        if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;主线程开始轮训</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread() &#123;</span><br><span class="line">        mResourcesManager &#x3D; ResourcesManager.getInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看名字应该是一个资源管理类</p>
<h3 id="attach"><a href="#attach" class="headerlink" title="attach()"></a><code>attach()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">				sCurrentActivityThread &#x3D; this;</span><br><span class="line">				&#x2F;&#x2F;从main中进入是false</span><br><span class="line">        mSystemThread &#x3D; system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">         ViewRootImpl.addFirstDrawHandler();</span><br><span class="line">      			 &#x2F;&#x2F;获取AMS</span><br><span class="line">        		final IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">            try &#123;</span><br><span class="line">            		&#x2F;&#x2F;调用AMS中的方法 mAppThread是ApplicationThread aidl实现类</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">                mInstrumentation.basicInit(this);</span><br><span class="line">                ContextImpl context &#x3D; ContextImpl.createAppContext(</span><br><span class="line">                this, getSystemContext().mPackageInfo);</span><br><span class="line">                mInitialApplication &#x3D; context.mPackageInfo.makeApplication(true, null);</span><br><span class="line">                mInitialApplication.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line"> ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><h3 id="attachApplication"><a href="#attachApplication" class="headerlink" title="attachApplication()"></a><code>attachApplication()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void attachApplication(IApplicationThread thread, long startSeq) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final int callingUid &#x3D; Binder.getCallingUid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">            &#x2F;&#x2F;恢复传入IPC的身份对当前线程回，是由&#123;@link #clearCallingIdentity&#125;返回先前的身份。</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="attachApplicationLocked"><a href="#attachApplicationLocked" class="headerlink" title="attachApplicationLocked()"></a><code>attachApplicationLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">    private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">						...</span><br><span class="line">						if (app.isolatedEntryPoint !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; This is an isolated process which should just call an entry point instead of</span><br><span class="line">                &#x2F;&#x2F; being bound to an application.</span><br><span class="line">                thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">            &#125; else if (app.instr !&#x3D; null) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                        null, null, null, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; See if the top visible activity is waiting to run in this process...</span><br><span class="line">            &#x2F;&#x2F;是不是有需要运行的Activity</span><br><span class="line">            if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要作两件事：</p>
<ul>
<li>创建Application：<code>thread.bindApplication</code></li>
<li>开启Activity：<code>mStackSupervisor.attachApplicationLocked(app)</code></li>
</ul>
<p>先来看看如何创建Application</p>
<h1 id="Application创建"><a href="#Application创建" class="headerlink" title="Application创建"></a>Application创建</h1><h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><h3 id="bindApplication"><a href="#bindApplication" class="headerlink" title="bindApplication()"></a>bindApplication()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">                IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">                IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">                boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">                boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">                String buildSerial, boolean autofillCompatibilityEnabled) &#123;</span><br><span class="line">                	...</span><br><span class="line">                	sendMessage(H.BIND_APPLICATION, data);                </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p> sendMessage发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mH.sendMessage(msg);</span><br></pre></td></tr></table></figure>

<p>所以找到mH的消息接受回调方法找对应的逻辑：</p>
<h3 id="mH-handlerMessage-BIND-APPLICATION"><a href="#mH-handlerMessage-BIND-APPLICATION" class="headerlink" title="mH.handlerMessage()===BIND_APPLICATION"></a><code>mH.handlerMessage()===BIND_APPLICATION</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (msg.what) &#123;</span><br><span class="line">               case BIND_APPLICATION:</span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                   AppBindData data &#x3D; (AppBindData)msg.obj;</span><br><span class="line">                   handleBindApplication(data);</span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                   break;</span><br></pre></td></tr></table></figure>

<h3 id="handleBindApplication"><a href="#handleBindApplication" class="headerlink" title="handleBindApplication()"></a><code>handleBindApplication()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">				...</span><br><span class="line">				updateDefaultDensity();</span><br><span class="line">				...</span><br><span class="line">				&#x2F;&#x2F;设置时区</span><br><span class="line">				...</span><br><span class="line">				&#x2F;&#x2F;设置代理</span><br><span class="line">				...</span><br><span class="line">				&#x2F;&#x2F;初始化 ContextImpl</span><br><span class="line">				final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info);</span><br><span class="line">				...</span><br><span class="line">				 &#x2F;&#x2F;获取其classLoader</span><br><span class="line">        final ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">        &#x2F;&#x2F;构建Instrumentation </span><br><span class="line">        mInstrumentation &#x3D; (Instrumentation)</span><br><span class="line">            cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">				...</span><br><span class="line">				&#x2F;&#x2F;创建Application</span><br><span class="line">				app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">				...</span><br><span class="line">				&#x2F;&#x2F;最后执行的是Application的onCreate方法</span><br><span class="line">				mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里创建了Application并调用onCreate方法</p>
<h3 id="makeApplication"><a href="#makeApplication" class="headerlink" title="makeApplication()"></a><code>makeApplication()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation) &#123;</span><br><span class="line">				if (mApplication !&#x3D; null) &#123;</span><br><span class="line">            return mApplication;</span><br><span class="line">        &#125;</span><br><span class="line">        String appClass &#x3D; mApplicationInfo.className;</span><br><span class="line">        if (forceDefaultAppClass || (appClass &#x3D;&#x3D; null)) &#123;</span><br><span class="line">            appClass &#x3D; &quot;android.app.Application&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; getClassLoader();</span><br><span class="line">            if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;获取上下文</span><br><span class="line">            ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">            &#x2F;&#x2F;创建Application</span><br><span class="line">            app &#x3D; mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看application如何创建的</p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h2><h3 id="newApplication"><a href="#newApplication" class="headerlink" title="newApplication()"></a><code>newApplication()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">            throws InstantiationException, IllegalAccessException, </span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        Application app &#x3D; getFactory(context.getPackageName())</span><br><span class="line">                .instantiateApplication(cl, className);</span><br><span class="line">        app.attach(context);</span><br><span class="line">        return app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建application</li>
<li>调用application的attach()方法</li>
</ol>
<h2 id="AppComponentFactory"><a href="#AppComponentFactory" class="headerlink" title="AppComponentFactory"></a><code>AppComponentFactory</code></h2><h3 id="instantiateApplication"><a href="#instantiateApplication" class="headerlink" title="instantiateApplication()"></a><code>instantiateApplication()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public @NonNull Application instantiateApplication(@NonNull ClassLoader cl,</span><br><span class="line">            @NonNull String className)</span><br><span class="line">            throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        return (Application) cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>利用反射去创建application，然后调用attach()方法，在执行onCreate方法</strong></p>
<h1 id="Activity如何开启"><a href="#Activity如何开启" class="headerlink" title="Activity如何开启"></a>Activity如何开启</h1><p>回到ActivityManagerService#attachApplicationLocked方法</p>
<h2 id="ActivityManagerService-1"><a href="#ActivityManagerService-1" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><h3 id="attachApplicationLocked-1"><a href="#attachApplicationLocked-1" class="headerlink" title="attachApplicationLocked()"></a><code>attachApplicationLocked()</code></h3><p>上面说到这个方法会启动Activity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; See if the top visible activity is waiting to run in this process...</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><h3 id="attachApplicationLocked-2"><a href="#attachApplicationLocked-2" class="headerlink" title="attachApplicationLocked()"></a><code>attachApplicationLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">				...</span><br><span class="line">				if (realStartActivityLocked(activity, app,top &#x3D;&#x3D; activity &#x2F;* andResume *&#x2F;, true &#x2F;* checkConfig *&#x2F;)) &#123;</span><br><span class="line">          didSomething &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        ...                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="realStartActivityLocked"><a href="#realStartActivityLocked" class="headerlink" title="realStartActivityLocked()"></a><code>realStartActivityLocked()</code></h3><p>这个方法很熟悉，去前面文章查查，有印象。</p>
<p>一分钟后。。。</p>
<p>在当前类中<code>startSpecificActivityLocked</code>方法下：</p>
<p>如果进程存在就走<code>realStartActivityLocked</code>如果没有进程则AMS创建一个进程<code>mService.startProcessLocked</code>。</p>
<p>上一篇文章说的是创建进程的流程，如果进程存在，直接创建Activity就好了。</p>
<p>开始分析<code>realStartActivityLocked</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">            boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">            &#x2F;&#x2F;Activity栈</span><br><span class="line">            final TaskRecord task &#x3D; r.getTask();</span><br><span class="line">       			final ActivityStack stack &#x3D; task.getStack();</span><br><span class="line">       			...</span><br><span class="line">       			&#x2F;&#x2F;创建activity启动事务。</span><br><span class="line">       			final ClientTransaction clientTransaction &#x3D; ClientTransaction.obtain(app.thread,</span><br><span class="line">                        r.appToken);</span><br><span class="line">                &#x2F;&#x2F;构建LaunchActivityItem对象,并传入clientTransaction中,用作callback</span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                        System.identityHashCode(r), r.info,</span><br><span class="line">                        &#x2F;&#x2F; TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                        &#x2F;&#x2F; and override configs.</span><br><span class="line">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                        profilerInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</code>添加回调的类型是<code>LaunchActivityItem类</code>。然后调用<code>mService.getLifecycleManager().scheduleTransaction(clientTransaction);</code></p>
<p>方法。mService是AMS</p>
<h2 id="ActivityManagerService-2"><a href="#ActivityManagerService-2" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><h3 id="getLifecycleManager"><a href="#getLifecycleManager" class="headerlink" title="getLifecycleManager()"></a><code>getLifecycleManager()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClientLifecycleManager getLifecycleManager() &#123;</span><br><span class="line">        return mLifecycleManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClientLifecycleManager"><a href="#ClientLifecycleManager" class="headerlink" title="ClientLifecycleManager"></a><code>ClientLifecycleManager</code></h2><h3 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction()"></a><code>scheduleTransaction()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">        final IApplicationThread client &#x3D; transaction.getClient();</span><br><span class="line">        transaction.schedule();</span><br><span class="line">        if (!(client instanceof Binder)) &#123;</span><br><span class="line">            &#x2F;&#x2F; If client is not an instance of Binder - it&#39;s a remote call and at this point it is</span><br><span class="line">            &#x2F;&#x2F; safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">            &#x2F;&#x2F; the transaction is executed on client in ActivityThread.</span><br><span class="line">            transaction.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClientTransaction"><a href="#ClientTransaction" class="headerlink" title="ClientTransaction"></a><code>ClientTransaction</code></h2><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a><code>schedule()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">        mClient.scheduleTransaction(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>mClient的类型是<code>private IApplicationThread mClient;</code>IApplicationThread的实现类是<code>ActivityThread</code>类</p>
<h2 id="ActivityThread-1"><a href="#ActivityThread-1" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationThread 是Aidl服务端实现类，夸进程通信。</p>
<h3 id="scheduleTransaction-1"><a href="#scheduleTransaction-1" class="headerlink" title="scheduleTransaction()"></a><code>scheduleTransaction()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">            ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityThread-this-scheduleTransaction"><a href="#ActivityThread-this-scheduleTransaction" class="headerlink" title="ActivityThread.this.scheduleTransaction()"></a><code>ActivityThread.this.scheduleTransaction()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">        transaction.preExecute(this);</span><br><span class="line">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用Handler发送<code>EXECUTE_TRANSACTION</code>类型,找到mH的回调。</p>
<h3 id="handleMessage"><a href="#handleMessage" class="headerlink" title="handleMessage()"></a><code>handleMessage()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case EXECUTE_TRANSACTION:</span><br><span class="line">                    final ClientTransaction transaction &#x3D; (ClientTransaction) msg.obj;</span><br><span class="line">                    mTransactionExecutor.execute(transaction);</span><br><span class="line">                    if (isSystem()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Client transactions inside system process are recycled on the client side</span><br><span class="line">                        &#x2F;&#x2F; instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">                        &#x2F;&#x2F; message is handled.</span><br><span class="line">                        transaction.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>

<h2 id="TransactionExecutor"><a href="#TransactionExecutor" class="headerlink" title="TransactionExecutor"></a><code>TransactionExecutor</code></h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a><code>execute()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">        final IBinder token &#x3D; transaction.getActivityToken();</span><br><span class="line">        log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line"></span><br><span class="line">        executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">        executeLifecycleState(transaction);</span><br><span class="line">        mPendingActions.clear();</span><br><span class="line">        log(&quot;End resolving transaction&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="executeCallbacks"><a href="#executeCallbacks" class="headerlink" title="executeCallbacks()"></a><code>executeCallbacks()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    public void executeCallbacks(ClientTransaction transaction) &#123;</span><br><span class="line">        ...</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; ++i) &#123;</span><br><span class="line">            final ClientTransactionItem item &#x3D; callbacks.get(i);</span><br><span class="line">           ...</span><br><span class="line">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">            item.postExecute(mTransactionHandler, token, mPendingActions);            </span><br><span class="line">            ...</span><br><span class="line">        	&#125;</span><br><span class="line">        	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的callback就是前面的<code>LaunchActivityItem</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LaunchActivityItem extends ClientTransactionItem &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上调用的是<code>LaunchActivityItem#execute()</code></p>
<h2 id="LaunchActivityItem"><a href="#LaunchActivityItem" class="headerlink" title="LaunchActivityItem"></a><code>LaunchActivityItem</code></h2><h3 id="execute-1"><a href="#execute-1" class="headerlink" title="execute()"></a><code>execute()</code></h3><h3 id="preExecute"><a href="#preExecute" class="headerlink" title="preExecute()"></a><code>preExecute()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void preExecute(ClientTransactionHandler client, IBinder token) &#123;</span><br><span class="line">        client.updateProcessState(mProcState, false);</span><br><span class="line">        client.updatePendingConfiguration(mCurConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">            PendingTransactionActions pendingActions) &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">        ActivityClientRecord r &#x3D; new ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">                mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">                mProfilerInfo, client);</span><br><span class="line">        client.handleLaunchActivity(r, pendingActions, null &#x2F;* customIntent *&#x2F;);</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>client</code>是一个<code>ClientTransactionHandler</code>类型是一个抽象类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ClientTransactionHandler &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的具体实现类是<code>ActivityThread</code></p>
<h2 id="ActivityThread-2"><a href="#ActivityThread-2" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityThread extends ClientTransactionHandler &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="handleLaunchActivity"><a href="#handleLaunchActivity" class="headerlink" title="handleLaunchActivity()"></a><code>handleLaunchActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Activity handleLaunchActivity(ActivityClientRecord r,PendingTransactionActions pendingActions, 			Intent customIntent) &#123;</span><br><span class="line">			...</span><br><span class="line">			if (a !&#x3D; null) &#123;</span><br><span class="line">            r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">            reportSizeConfigurations(r);</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; pendingActions !&#x3D; null) &#123;</span><br><span class="line">                pendingActions.setOldState(r.state);</span><br><span class="line">                pendingActions.setRestoreInstanceState(true);</span><br><span class="line">                pendingActions.setCallOnPostCreate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performLaunchActivity"><a href="#performLaunchActivity" class="headerlink" title="performLaunchActivity"></a><code>performLaunchActivity</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">			...</span><br><span class="line">			&#x2F;&#x2F;创建上下文</span><br><span class="line">			ContextImpl appContext &#x3D; createBaseContextForActivity(r);</span><br><span class="line">        Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F;获取类加载器</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; appContext.getClassLoader();</span><br><span class="line">            &#x2F;&#x2F;创建Activity</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;调用attach方法</span><br><span class="line">        activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;调用onCreate方法</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">        ...      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建Activity()</li>
<li>调用attach()</li>
<li>调用onCreate()</li>
</ul>
<h2 id="Instrumentation-1"><a href="#Instrumentation-1" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h2><h3 id="newActivity"><a href="#newActivity" class="headerlink" title="newActivity()"></a><code>newActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Activity newActivity(ClassLoader cl, String className,</span><br><span class="line">            Intent intent)</span><br><span class="line">            throws InstantiationException, IllegalAccessException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        String pkg &#x3D; intent !&#x3D; null &amp;&amp; intent.getComponent() !&#x3D; null</span><br><span class="line">                ? intent.getComponent().getPackageName() : null;</span><br><span class="line">        return getFactory(pkg).instantiateActivity(cl, className, intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="getFactory"><a href="#getFactory" class="headerlink" title="getFactory()"></a>getFactory()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private AppComponentFactory getFactory(String pkg) &#123;</span><br><span class="line">        if (pkg &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;No pkg specified, disabling AppComponentFactory&quot;);</span><br><span class="line">            return AppComponentFactory.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mThread &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Uninitialized ActivityThread, likely app-created Instrumentation,&quot;</span><br><span class="line">                    + &quot; disabling AppComponentFactory&quot;, new Throwable());</span><br><span class="line">            return AppComponentFactory.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        LoadedApk apk &#x3D; mThread.peekPackageInfo(pkg, true);</span><br><span class="line">        &#x2F;&#x2F; This is in the case of starting up &quot;android&quot;.</span><br><span class="line">        if (apk &#x3D;&#x3D; null) apk &#x3D; mThread.getSystemContext().mPackageInfo;</span><br><span class="line">        return apk.getAppFactory();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回<code>AppComponentFactory</code>类型。</p>
<h2 id="AppComponentFactory-1"><a href="#AppComponentFactory-1" class="headerlink" title="AppComponentFactory"></a><code>AppComponentFactory</code></h2><h3 id="getAppFactory"><a href="#getAppFactory" class="headerlink" title="getAppFactory()"></a><code>getAppFactory()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AppComponentFactory getAppFactory() &#123;</span><br><span class="line">        return mAppComponentFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="instantiateActivity"><a href="#instantiateActivity" class="headerlink" title="instantiateActivity()"></a><code>instantiateActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className,</span><br><span class="line">            @Nullable Intent intent)</span><br><span class="line">            throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        return (Activity) cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是通过反射创建出<code>Activity</code></p>
<h1 id="如何执行Activity-onCreate"><a href="#如何执行Activity-onCreate" class="headerlink" title="如何执行Activity#onCreate()"></a>如何执行Activity#onCreate()</h1><h2 id="ActivityThread-3"><a href="#ActivityThread-3" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><h3 id="performLaunchActivity-1"><a href="#performLaunchActivity-1" class="headerlink" title="performLaunchActivity"></a><code>performLaunchActivity</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用onCreate方法</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Instrumentation-2"><a href="#Instrumentation-2" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h2><h3 id="callActivityOnCreate"><a href="#callActivityOnCreate" class="headerlink" title="callActivityOnCreate()"></a><code>callActivityOnCreate()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a><code>Activity</code></h2><h3 id="performCreate"><a href="#performCreate" class="headerlink" title="performCreate()"></a><code>performCreate</code>()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">        mCanEnterPictureInPicture &#x3D; true;</span><br><span class="line">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">        if (persistentState !&#x3D; null) &#123;</span><br><span class="line">            onCreate(icicle, persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onCreate(icicle);</span><br><span class="line">        &#125;</span><br><span class="line">        writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">        mVisibleFromClient &#x3D; !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">                com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">        mFragments.dispatchActivityCreated();</span><br><span class="line">        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate(@Nullable Bundle savedInstanceState,</span><br><span class="line">            @Nullable PersistableBundle persistentState) &#123;</span><br><span class="line">        onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line"></span><br><span class="line">        if (mLastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">            mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mActivityInfo.parentActivityName !&#x3D; null) &#123;</span><br><span class="line">            if (mActionBar &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mEnableDefaultActionBarUp &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mActionBar.setDefaultDisplayHomeAsUpEnabled(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (savedInstanceState !&#x3D; null) &#123;</span><br><span class="line">            mAutoFillResetNeeded &#x3D; savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false);</span><br><span class="line">            mLastAutofillId &#x3D; savedInstanceState.getInt(LAST_AUTOFILL_ID,</span><br><span class="line">                    View.LAST_APP_AUTOFILL_ID);</span><br><span class="line"></span><br><span class="line">            if (mAutoFillResetNeeded) &#123;</span><br><span class="line">                getAutofillManager().onCreate(savedInstanceState);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Parcelable p &#x3D; savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">            mFragments.restoreAllState(p, mLastNonConfigurationInstances !&#x3D; null</span><br><span class="line">                    ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">        &#125;</span><br><span class="line">        mFragments.dispatchCreate();</span><br><span class="line">        getApplication().dispatchActivityCreated(this, savedInstanceState);</span><br><span class="line">        if (mVoiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            mVoiceInteractor.attachActivity(this);</span><br><span class="line">        &#125;</span><br><span class="line">        mRestoredFromBundle &#x3D; savedInstanceState !&#x3D; null;</span><br><span class="line">        mCalled &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TestSamplePictureActivity"><a href="#TestSamplePictureActivity" class="headerlink" title="TestSamplePictureActivity"></a>TestSamplePictureActivity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>到此一个Activity的开启已经分析完毕，很麻烦。这篇文章只是记录Activity的启动流程，中间好多类都没有分析到位，比如</p>
<ul>
<li>ActivityManagerService 知识流程经过</li>
<li>Instrumentation类</li>
<li>启动模式，任务栈相关</li>
<li>等等</li>
</ul>
<p>Activity的启动流程很少去看c++的代码，在AndroidStudio上就可以完成阅读，前提需要理解Binder机制。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://gityuan.com/images/activity/start_activity_process.jpg" alt="start_activity_process"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/Thread%E7%B1%BB%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/27/Thread%E7%B1%BB%E5%88%86%E6%9E%90/" itemprop="url">Thread类分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-27T14:53:16+08:00">
                2020-05-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/27/Thread%E7%B1%BB%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/27/Thread%E7%B1%BB%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Thead类"><a href="#Thead类" class="headerlink" title="Thead类"></a>Thead类</h1><p>写的不好 别看了，对注释的解释。</p>
<h2 id="Thread类-解释"><a href="#Thread类-解释" class="headerlink" title="Thread类 解释"></a>Thread类 解释</h2><p>线程是程序中的执行线程。 Java虚拟机允许应用程序具有多个并发运行的执行线程。</p>
<p>每个线程都有一个优先级。 具有较高优先级的线程<strong>优先</strong>于具有较低优先级的线程执行。 也可以把线程标记为守护线程。 在某个线程中运行的代码创建新的<code>&lt;code&gt; Thread &lt;/ code&gt;</code>对象时，新线程的优先级和创建线程的优先级相同。当且仅当创建线程是守护程序时，它才是守护程序线程。</p>
<p>当Java虚拟机启动时，通常只有一个非守护程序线程（通常调用某些指定类的名为<code>&lt;code&gt; main &lt;/ code&gt;</code>的方法）。Java虚拟机将继续执行线程，直到发生以下任何一种情况：</p>
<ul>
<li>已调用类<code>&lt;code&gt; Runtime &lt;/ code&gt;</code>的<code>&lt;code&gt; exit &lt;/ code&gt;</code>方法，并且安全管理器已允许进行退出操作。</li>
<li>所有的非守护线程都已死亡，要么通过从调用返回到<code>&lt;code&gt; run &lt;/ code&gt;</code>方法，要么抛出异常传播到<code> run <code>&lt;/ code&gt;</code>方法之外。</li>
</ul>
<p>有两种方法可以创建新的执行线程。 一种是将一个类声明为<code> Thread </ code>的子类。 该子类应重写类<code> Thread </ code>的<code> run </ code>方法。 然后可以分配并启动子类的实例。 例如，计算素数大于指定值的线程可以编写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PrimeThread extends Thread &#123;</span><br><span class="line"> *         long minPrime;</span><br><span class="line"> *         PrimeThread(long minPrime) &#123;</span><br><span class="line"> *             this.minPrime &#x3D; minPrime;</span><br><span class="line"> *         &#125;</span><br><span class="line"> *</span><br><span class="line"> *         public void run() &#123;</span><br><span class="line"> *             &#x2F;&#x2F; 计算大于minPrime的素数</span><br><span class="line"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span><br><span class="line"> *         &#125;</span><br><span class="line"> *     &#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码将创建一个线程并开始运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p &#x3D; new PrimeThread(143);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>

<p>创建线程的另一种方法是声明一个实现<code> Runnable </ code>接口的类。 然后，该类实现<code> run </ code>方法。 然后可以分配该类的实例，在创建<code> Thread </ code>时将其作为参数传递并启动。 其他样式的相同示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PrimeRun implements Runnable &#123;</span><br><span class="line"> *         long minPrime;</span><br><span class="line"> *         PrimeRun(long minPrime) &#123;</span><br><span class="line"> *             this.minPrime &#x3D; minPrime;</span><br><span class="line"> *         &#125;</span><br><span class="line"> *</span><br><span class="line"> *         public void run() &#123;</span><br><span class="line"> *             &#x2F;&#x2F; compute primes larger than minPrime</span><br><span class="line"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span><br><span class="line"> *         &#125;</span><br><span class="line"> *     &#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码将创建一个线程并开始运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p &#x3D; new PrimeRun(143);</span><br><span class="line">new Thread(p).start();</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个名称供识别。 一个以上的线程可能具有相同的名称。 如果在创建线程时未指定名称，则会为其生成一个新名称。</p>
<p>除非另有说明，否则将{@code null}参数传递给此类中的构造函数或方法将导致抛出{@link NullPointerException}。</p>
<h2 id="Thread-常量与属性"><a href="#Thread-常量与属性" class="headerlink" title="Thread 常量与属性"></a>Thread 常量与属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">&#x2F; *确保registerNatives是&lt;clinit&gt;要做的第一件事。 * &#x2F;</span><br><span class="line"></span><br><span class="line">		*负责此线程的join &#x2F; sleep &#x2F; park操作的同步对象。</span><br><span class="line">    private final Object lock &#x3D; new Object();</span><br><span class="line"> private volatile long nativePeer;</span><br><span class="line"></span><br><span class="line">    boolean started &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private volatile String name;</span><br><span class="line"></span><br><span class="line">    private int         priority;</span><br><span class="line">    private Thread      threadQ;</span><br><span class="line">    private long        eetop;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Whether or not to single_step this thread. *&#x2F;</span><br><span class="line">    &#x2F; *是否单步执行此线程。 * &#x2F;</span><br><span class="line">    private boolean     single_step;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Whether or not the thread is a daemon thread. *&#x2F;</span><br><span class="line">    &#x2F; *线程是否是守护程序线程。 * &#x2F;</span><br><span class="line">    private boolean     daemon &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;* JVM state *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;JVM 状态</span><br><span class="line">    private boolean     stillborn &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;* What will be run. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;将要被运行的内容</span><br><span class="line">    private Runnable target;</span><br><span class="line"></span><br><span class="line">    &#x2F;* The group of this thread *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;当前线程的组</span><br><span class="line">    private ThreadGroup group;</span><br><span class="line"></span><br><span class="line">    &#x2F;* The context ClassLoader for this thread *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;此线程的上下文ClassLoader</span><br><span class="line">    private ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">    &#x2F;* The inherited AccessControlContext of this thread *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;该线程的继承的AccessControlContext</span><br><span class="line">    private AccessControlContext inheritedAccessControlContext;</span><br><span class="line"></span><br><span class="line">    &#x2F;* For autonumbering anonymous threads. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;用于自动编号匿名线程。</span><br><span class="line">    private static int threadInitNumber;</span><br><span class="line">    </span><br><span class="line">    private static synchronized int nextThreadNum() &#123;</span><br><span class="line">        return threadInitNumber++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;与此线程有关的ThreadLocal值。 该映射由ThreadLocal类维护。 * &#x2F;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="line">     * maintained by the InheritableThreadLocal class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;与此线程有关的InheritableThreadLocal值。 该映射由InheritableThreadLocal类维护。</span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * The requested stack size for this thread, or 0 if the creator did</span><br><span class="line">     * not specify a stack size.  It is up to the VM to do whatever it</span><br><span class="line">     * likes with this number; some VMs will ignore it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;此线程请求的堆栈大小，如果创建者未指定堆栈大小，则为0。 由VM决定使用此编号执行任何操作。 一些虚拟机将忽略它。</span><br><span class="line">    private long stackSize;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * JVM-private state that persists after native thread termination.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;JVM私有状态在本地线程终止后仍然存在。</span><br><span class="line">    private long nativeParkEventPointer;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Thread ID</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private long tid;</span><br><span class="line"></span><br><span class="line">    &#x2F;* For generating thread ID *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;用于生成线程ID</span><br><span class="line">    private static long threadSeqNumber;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Java thread status for tools,</span><br><span class="line">     * initialized to indicate thread &#39;not yet started&#39;</span><br><span class="line">     *&#x2F;</span><br><span class="line">		&#x2F;&#x2F;Java线程状态，已初始化以指示线程“尚未启动”</span><br><span class="line">    private volatile int threadStatus &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * The argument supplied to the current call to</span><br><span class="line">     * java.util.concurrent.locks.LockSupport.park.</span><br><span class="line">     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker</span><br><span class="line">     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker</span><br><span class="line">     *&#x2F;</span><br><span class="line">    volatile Object parkBlocker;</span><br><span class="line">    </span><br><span class="line">    &#x2F; **</span><br><span class="line">      *线程可以具有的最低优先级。</span><br><span class="line">      * &#x2F;</span><br><span class="line">     public final static int MIN_PRIORITY &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F; **</span><br><span class="line">      *分配给线程的默认优先级。</span><br><span class="line">      * &#x2F;</span><br><span class="line">     public final static int NORM_PRIORITY &#x3D; 5;</span><br><span class="line"></span><br><span class="line">     &#x2F; **</span><br><span class="line">      *线程可以具有的最大优先级。</span><br><span class="line">      * &#x2F;</span><br><span class="line">     public final static int MAX_PRIORITY &#x3D; 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public Thread(Runnable target) &#123;</span><br><span class="line">        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public Thread(ThreadGroup group, Runnable target) &#123;</span><br><span class="line">        init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"> public Thread(String name) &#123;</span><br><span class="line">        init(null, null, name, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Thread(ThreadGroup group, String name) &#123;</span><br><span class="line">        init(group, null, name, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Thread(ThreadGroup group, String name, int priority, boolean daemon) &#123;</span><br><span class="line">        this.group &#x3D; group;</span><br><span class="line">        this.group.addUnstarted();</span><br><span class="line">        &#x2F;&#x2F; Must be tolerant of threads without a name.</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            name &#x3D; &quot;Thread-&quot; + nextThreadNum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; NOTE: Resist the temptation to call setName() here. This constructor is only called</span><br><span class="line">        &#x2F;&#x2F; by the runtime to construct peers for threads that have attached via JNI and it&#39;s</span><br><span class="line">        &#x2F;&#x2F; undesirable to clobber their natively set name.</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line"></span><br><span class="line">        this.priority &#x3D; priority;</span><br><span class="line">        this.daemon &#x3D; daemon;</span><br><span class="line">        init2(currentThread());</span><br><span class="line">        tid &#x3D; nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前面5个构造都会调用init方法，</p>
<h2 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Initializes a Thread.</span><br><span class="line">     * 创建Thread的公有构造函数，都调用的都是这个私有的init()方法。</span><br><span class="line">     * @param g the Thread group</span><br><span class="line">     * @param target the object whose run() method gets called</span><br><span class="line">     * @param name the name of the new Thread</span><br><span class="line">     * @param stackSize 指定占堆的大小</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123;</span><br><span class="line">				&#x2F;&#x2F; 获取当前正在运行的线程</span><br><span class="line">        &#x2F;&#x2F; 当前正在运行的线程就是该我们要创建的线程的父线程</span><br><span class="line">        &#x2F;&#x2F; 我们要创建的线程会从父线程那继承一些参数过来</span><br><span class="line">        &#x2F;&#x2F; 注意哦，此时仍然是在原来的线程，新线程此时还没有创建的哦！</span><br><span class="line">				Thread parent &#x3D; currentThread();</span><br><span class="line">        if (g &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果没有指定和父类一组</span><br><span class="line">            g &#x3D; parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">			 &#x2F;&#x2F;将ThreadGroup中的就绪线程计数器增加一。注意，此时线程还并没有被真正加入到ThreadGroup中。</span><br><span class="line">        g.addUnstarted();</span><br><span class="line">        &#x2F;&#x2F;将Thread实例的group赋值。从这里开始线程就拥有ThreadGroup了。</span><br><span class="line">        this.group &#x3D; g;</span><br><span class="line"></span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        &#x2F;&#x2F;和开启线程的优先级相同</span><br><span class="line">        this.priority &#x3D; parent.getPriority();</span><br><span class="line">        &#x2F;&#x2F;根据父线程是否是守护线程来确定Thread实例是否是守护线程。</span><br><span class="line">        this.daemon &#x3D; parent.isDaemon();</span><br><span class="line">        setName(name);</span><br><span class="line"></span><br><span class="line">        init2(parent);</span><br><span class="line"></span><br><span class="line">        &#x2F;* Stash the specified stack size in case the VM cares *&#x2F;</span><br><span class="line">        this.stackSize &#x3D; stackSize;</span><br><span class="line">        tid &#x3D; nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在Thread的init()方法中，比较重要的是会通过一个<code>currentThread()</code>这样的native函数通过底层从虚拟机中获取到当前运行的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native Thread currentThread();</span><br></pre></td></tr></table></figure>

<p>所以在Thread初始化的时候，仍然是在创建它的线程中。不难猜测出，其实Java层的Thread只是对底层的封装而已。</p>
<h2 id="init2"><a href="#init2" class="headerlink" title="init2()"></a>init2()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void init2(Thread parent) &#123;</span><br><span class="line">				&#x2F;&#x2F;设置ClassLoader成员变量</span><br><span class="line">        this.contextClassLoader &#x3D; parent.getContextClassLoader();</span><br><span class="line">        &#x2F;&#x2F;设置访问权限控制环境</span><br><span class="line">        this.inheritedAccessControlContext &#x3D; AccessController.getContext();      </span><br><span class="line">        if (parent.inheritableThreadLocals !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;创建Thread实例的ThreadLoacaleMap。需要用到父线程的ThreadLocaleMap，目的是为了将父线程中的变量副本拷贝一份到当前线程中。</span><br><span class="line">            &#x2F;&#x2F;ThreadLocaleMap是一个Entry型的数组，Thread实例会将变量副本保存在这里面。</span><br><span class="line">            this.inheritableThreadLocals &#x3D; ThreadLocal.createInheritedMap(</span><br><span class="line">                    parent.inheritableThreadLocals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的Thread就初始化完成了，Thread的几个重要成员变量都赋值了。</p>
<h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Causes this thread to begin execution; the Java Virtual Machine</span><br><span class="line"> * calls the &lt;code&gt;run&lt;&#x2F;code&gt; method of this thread.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The result is that two threads are running concurrently: the</span><br><span class="line"> * current thread (which returns from the call to the</span><br><span class="line"> * &lt;code&gt;start&lt;&#x2F;code&gt; method) and the other thread (which executes its</span><br><span class="line"> * &lt;code&gt;run&lt;&#x2F;code&gt; method).</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * It is never legal to start a thread more than once.</span><br><span class="line"> * In particular, a thread may not be restarted once it has completed</span><br><span class="line"> * execution.</span><br><span class="line"> *</span><br><span class="line"> * @exception  IllegalThreadStateException  if the thread was already</span><br><span class="line"> *               started.</span><br><span class="line"> * @see        #run()</span><br><span class="line"> * @see        #stop()</span><br><span class="line"> *&#x2F;</span><br><span class="line">public synchronized void start() &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">     * group threads created&#x2F;set up by the VM. Any new functionality added</span><br><span class="line">     * to this method in the future may have to also be added to the VM.</span><br><span class="line">     *</span><br><span class="line">     * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Android-changed: throw if &#39;started&#39; is true</span><br><span class="line">     &#x2F;&#x2F;检查线程状态是否为0，为0表示是一个新状态，即还没被start()过。不为0就抛出异常。</span><br><span class="line">    &#x2F;&#x2F;就是说，我们一个Thread实例，我们只能调用一次start()方法。</span><br><span class="line">    if (threadStatus !&#x3D; 0 || started)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    &#x2F;* Notify the group that this thread is about to be started</span><br><span class="line">     * so that it can be added to the group&#39;s list of threads</span><br><span class="line">     * and the group&#39;s unstarted count can be decremented. *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;从这里开始才真正的线程加入到ThreadGroup组里。再重复一次，前面只是把nUnstartedThreads这个计数器进行了增量，并没有添加线程。</span><br><span class="line">    &#x2F;&#x2F;同时，当线程启动了之后，nUnstartedThreads计数器会-1。因为就绪状态的线程少了一条啊！</span><br><span class="line">    group.add(this);</span><br><span class="line"></span><br><span class="line">    started &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;又是个Native方法。这里交由JVM处理，会调用Thread实例的run()方法。</span><br><span class="line">        nativeCreate(this, stackSize, daemon);</span><br><span class="line">        started &#x3D; true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!started) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有被启动成功，Thread将会被移除ThreadGroup，同时，nUnstartedThreads计数器又增量1了。</span><br><span class="line">                group.threadStartFailed(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignore) &#123;</span><br><span class="line">            &#x2F;* do nothing. If start0 threw a Throwable then</span><br><span class="line">              it will be passed up the call stack *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native static void nativeCreate(Thread t, long stackSize, boolean daemon);</span><br></pre></td></tr></table></figure>

<p>使该线程开始执行； Java虚拟机将调用此线程的<code> run </ code>方法。</p>
<p>如我们所见，这个方法是加了锁的。原因是避免开发者在其它线程调用同一个Thread实例的这个方法，从而尽量避免抛出异常。这个方法之所以能够执行我们传入的Runnable里的run()方法，是应为JVM调用了Thread实例的run()方法。</p>
<p>最精华的函数是<code>nativeCreate(this, stackSize, daemon)</code>，会去调用底层的JNI函数<code>Thread_nativeCreate()</code>，进一步的会调用底层的Thread类的<code>Thread::CreateNativeThread()</code>函数。</p>
<p><code>Thread::CreateNativeThread()</code>函数在<code>/art/runtime/thread.cc</code>文件中（注：CoorChice用的是6.0.0-r1的源码）。它会在去创建一个c/c++层的Thread对象，并且会关联Java层的Thread对象（其实就是保存一个Java层Thread对象的引用而已）。接着，会通过c/c++层的<code>pthread_create()</code>函数去创建并启动一个新线程。这条代码必须要看看了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_create_result = pthread_create(&amp;new_pthread, &amp;attr, </span><br><span class="line">    Thread::CreateCallback, child_thread);</span><br></pre></td></tr></table></figure>

<p>这里我们需要注意第三个参数位置的<code>Thread::CreateCallback</code>，它会返回一个Java层Thread类的run()方法指针，在Linux层的pthread线程创建成功后，将会调用这个run()方法。这就是为什么我们调用start()方法后，run()方法会被调用的原因。</p>
<p>从上面的分析我们可以知道，其实Java的线程Thread还是用的Linux那一套 <code>pthread</code> 的东西，并且一条线程真正创建并运行在虚拟机中时，是在调用start()方法之后。所以，如果你创建了一条线程，但是从没调用过它的start()方法，就不会有条新线程生成，此时的Thread对象和主线程里的一个普通对象没什么区别。如果你企图调用 <code>run()</code> 方法去试图启动你的线程，那真是大错特错了！这样不过相当于在主线程中调用了一个Java方法而已。</p>
<p>所以，Java中的线程在Android中实际上走的还是Linux的pthread那一套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;没错，就是这么简单！仅仅调用了Runnable类型的成员变量target的run()方法。至此，我们需要执行的代码就执行起来了。</span><br><span class="line">&#x2F;&#x2F;至于这个@Overrid的存在，完全是因为Thread本身也是一个Runnable！就是说，我们的Thread也可以作为一个Runnable来使用。</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">        if (target !&#x3D; null) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><h2 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h2><p>sleep使当前线程暂停，并没有释放锁，经过传入的time时间后自动继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">     * Causes the currently executing thread to sleep (temporarily cease</span><br><span class="line">     * execution) for the specified number of milliseconds, subject to</span><br><span class="line">     * the precision and accuracy of system timers and schedulers. The thread</span><br><span class="line">     * does not lose ownership of any monitors.</span><br><span class="line">     *</span><br><span class="line">     * @param  millis</span><br><span class="line">     *         the length of time to sleep in milliseconds</span><br><span class="line">     *</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line">     *</span><br><span class="line">     * @throws  InterruptedException</span><br><span class="line">     *          if any thread has interrupted the current thread. The</span><br><span class="line">     *          &lt;i&gt;interrupted status&lt;&#x2F;i&gt; of the current thread is</span><br><span class="line">     *          cleared when this exception is thrown.</span><br><span class="line">     如果任何线程中断了当前线程。 抛出此异常时，将清除当前线程的&lt;i&gt;中断状态&lt;&#x2F; i&gt;。</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;根据系统计时器和调度程序的精度和准确性，使当前正在执行的线程进入休眠状态（暂时停止执行）达指定的毫秒数。 该线程不会失去任何监视器的所有权。</span><br><span class="line">    public static void sleep(long millis) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(millis, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FastNative</span><br><span class="line">    private static native void sleep(Object lock, long millis, int nanos)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Causes the currently executing thread to sleep (temporarily cease</span><br><span class="line">     * execution) for the specified number of milliseconds plus the specified</span><br><span class="line">     * number of nanoseconds, subject to the precision and accuracy of system</span><br><span class="line">     * timers and schedulers. The thread does not lose ownership of any</span><br><span class="line">     * monitors.</span><br><span class="line">     *</span><br><span class="line">     * @param  millis</span><br><span class="line">     *         the length of time to sleep in milliseconds</span><br><span class="line">     *</span><br><span class="line">     * @param  nanos</span><br><span class="line">     *         &#123;@code 0-999999&#125; additional nanoseconds to sleep</span><br><span class="line">     *					额外的纳秒睡眠时间</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          if the value of &#123;@code millis&#125; is negative, or the value of</span><br><span class="line">     *          &#123;@code nanos&#125; is not in the range &#123;@code 0-999999&#125;</span><br><span class="line">     *</span><br><span class="line">     * @throws  InterruptedException</span><br><span class="line">     *          if any thread has interrupted the current thread. The</span><br><span class="line">     *          &lt;i&gt;interrupted status&lt;&#x2F;i&gt; of the current thread is</span><br><span class="line">     *          cleared when this exception is thrown.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void sleep(long millis, int nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;millis &lt; 0: &quot; + millis);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nanos &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;nanos &lt; 0: &quot; + nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nanos &gt; 999999) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;nanos &gt; 999999: &quot; + nanos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The JLS 3rd edition, section 17.9 says: &quot;...sleep for zero</span><br><span class="line">        &#x2F;&#x2F; time...need not have observable effects.&quot;</span><br><span class="line">        if (millis &#x3D;&#x3D; 0 &amp;&amp; nanos &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; ...but we still have to handle being interrupted.</span><br><span class="line">            &#x2F;&#x2F;当睡眠时间为0时，检测线程是否中断，并清除线程的中断状态标记。这是个Native的方法。</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果线程被设置了中断状态为true了(调用Thread.interrupt())。那么他将抛出异常。如果在catch住这个异常之后return线程，那么线程就停止了。  </span><br><span class="line">              throw new InterruptedException();</span><br><span class="line">           &#x2F;&#x2F;需要注意，在调用了Thread.sleep()之后，再调用isInterrupted()得到的结果永远是False。别忘了Thread.interrupted()在检测的同时还会清除标记位置哦！</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> &#x2F;&#x2F;类似System.currentTimeMillis()。但是获取的是纳秒，可能不准。</span><br><span class="line">        long start &#x3D; System.nanoTime();</span><br><span class="line">        long duration &#x3D; (millis * NANOS_PER_MILLI) + nanos;</span><br><span class="line">				 &#x2F;&#x2F;获得当前线程的锁。</span><br><span class="line">        Object lock &#x3D; currentThread().lock;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Wait may return early, so loop until sleep duration passes.</span><br><span class="line">&#x2F;&#x2F;        等待可能会提前返回，因此请循环直到睡眠持续时间过去。</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                sleep(lock, millis, nanos);</span><br><span class="line"></span><br><span class="line">                long now &#x3D; System.nanoTime();</span><br><span class="line">                long elapsed &#x3D; now - start;</span><br><span class="line">								&#x2F;&#x2F;&#x2F;&#x2F;如果当前睡眠时长，已经满足我们的需求，就退出循环，睡眠结束。</span><br><span class="line">                if (elapsed &gt;&#x3D; duration) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                duration -&#x3D; elapsed;</span><br><span class="line">                start &#x3D; now;</span><br><span class="line">                millis &#x3D; duration &#x2F; NANOS_PER_MILLI;</span><br><span class="line">                nanos &#x3D; (int) (duration % NANOS_PER_MILLI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Android为了确保休眠的准确性，在这里还使用了一个<code>while()</code>循环，在每次线程从底层被唤醒后，检查一下是否休眠够了足够的时长。如果不够就让它继续休眠。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>这个方法是Native的。调用这个方法可以提示cpu，当前线程将放弃目前cpu的使用权，和其它线程重新一起争夺新的cpu使用权限。当前线程可能再次获得执行，也可能没获得。</p>
<pre><code>/**
 * A hint to the scheduler that the current thread is willing to yield
 * its current use of a processor. The scheduler is free to ignore this
 * hint.
 *
 * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 * between threads that would otherwise over-utilise a CPU. Its use
 * should be combined with detailed profiling and benchmarking to
 * ensure that it actually has the desired effect.
 *
 * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 * for debugging or testing purposes, where it may help to reproduce
 * bugs due to race conditions. It may also be useful when designing
 * concurrency control constructs such as the ones in the
 * {@link java.util.concurrent.locks} package.
 */
public static native void yield();</code></pre><p>给调度程序的提示是当前线程愿意放弃当前使用的处理器。 调度程序可以随意忽略此提示。</p>
<p>Yield是一种启发式尝试，旨在提高线程之间的相对进程，否则将过度利用CPU。 应将其使用与详细的性能分析和基准测试结合起来，以确保它实际上具有所需的效果。</p>
<p>很少适合使用此方法。 对于调试或测试目的，它可能很有用，因为它可能有助于重现由于竞争条件而产生的错误。 在设计并发控制结构（例如@link java.util.concurrent.locks}包中的结构）时，它也可能很有用。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join方法是等待该线程执行，直到超时或者终止，可以作为线程通信的一种方式，A线程调用B线程的join（阻塞），等待B完成后再往下执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public final void join(long millis, int nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                                &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &gt;&#x3D; 500000 || (nanos !&#x3D; 0 &amp;&amp; millis &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        join(millis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final void join(long millis) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">               &#x2F;&#x2F;得到当前的系统给时间</span><br><span class="line">        long base &#x3D; System.currentTimeMillis();</span><br><span class="line">        long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           &#x2F;&#x2F; 如果millis &#x3D;&#x3D; 0 线程将一直等待下去</span><br><span class="line">           &#x2F;&#x2F;如果是活跃的的</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                lock.wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 指定了millis ，等待指定时间以后，会break当前线程</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay &#x3D; millis - now;</span><br><span class="line">                if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                 &#x2F;&#x2F;有限期的进行等待</span><br><span class="line">                lock.wait(delay);</span><br><span class="line">                now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a>interrupt()方法</h2><p>interrupt()方法是中断当前的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Interrupts this thread.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="line"> * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span><br><span class="line"> * of this thread is invoked, which may cause a &#123;@link</span><br><span class="line"> * SecurityException&#125; to be thrown.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span><br><span class="line"> * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span><br><span class="line"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span><br><span class="line"> * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span><br><span class="line"> * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span><br><span class="line"> * methods of this class, then its interrupt status will be cleared and it</span><br><span class="line"> * will receive an &#123;@link InterruptedException&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in an I&#x2F;O operation upon an &#123;@link</span><br><span class="line"> * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="line"> * then the channel will be closed, the thread&#39;s interrupt</span><br><span class="line"> * status will be set, and the thread will receive a &#123;@link</span><br><span class="line"> * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;</span><br><span class="line"> * then the thread&#39;s interrupt status will be set and it will return</span><br><span class="line"> * immediately from the selection operation, possibly with a non-zero</span><br><span class="line"> * value, just as if the selector&#39;s &#123;@link</span><br><span class="line"> * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt</span><br><span class="line"> * status will be set. &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="line"> *</span><br><span class="line"> * @throws  SecurityException</span><br><span class="line"> *          if the current thread cannot modify this thread</span><br><span class="line"> *</span><br><span class="line"> * @revised 6.0</span><br><span class="line"> * @spec JSR-51</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void interrupt() &#123;</span><br><span class="line">    if (this !&#x3D; Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    synchronized (blockerLock) &#123;</span><br><span class="line">        Interruptible b &#x3D; blocker;</span><br><span class="line">        if (b !&#x3D; null) &#123;</span><br><span class="line">            nativeInterrupt();</span><br><span class="line">            b.interrupt(this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nativeInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Tests whether the current thread has been interrupted.  The</span><br><span class="line"> * &lt;i&gt;interrupted status&lt;&#x2F;i&gt; of the thread is cleared by this method.  In</span><br><span class="line"> * other words, if this method were to be called twice in succession, the</span><br><span class="line"> * second call would return false (unless the current thread were</span><br><span class="line"> * interrupted again, after the first call had cleared its interrupted</span><br><span class="line"> * status and before the second call had examined it).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line"> * at the time of the interrupt will be reflected by this method</span><br><span class="line"> * returning false.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;code&gt;true&lt;&#x2F;code&gt; if the current thread has been interrupted;</span><br><span class="line"> *          &lt;code&gt;false&lt;&#x2F;code&gt; otherwise.</span><br><span class="line"> * @see #isInterrupted()</span><br><span class="line"> * @revised 6.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@FastNative</span><br><span class="line">public static native boolean interrupted();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><br><span class="line"> * status&lt;&#x2F;i&gt; of the thread is unaffected by this method.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line"> * at the time of the interrupt will be reflected by this method</span><br><span class="line"> * returning false.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;code&gt;true&lt;&#x2F;code&gt; if this thread has been interrupted;</span><br><span class="line"> *          &lt;code&gt;false&lt;&#x2F;code&gt; otherwise.</span><br><span class="line"> * @see     #interrupted()</span><br><span class="line"> * @revised 6.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@FastNative</span><br><span class="line">public native boolean isInterrupted();</span><br></pre></td></tr></table></figure>

<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block&#x2F;method or</span><br><span class="line">         * reenter a synchronized block&#x2F;method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         * &lt;&#x2F;ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         * &lt;&#x2F;ul&gt;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the state of this thread.</span><br><span class="line">     * This method is designed for use in monitoring of the system state,</span><br><span class="line">     * not for synchronization control.</span><br><span class="line">     *</span><br><span class="line">     * @return this thread&#39;s state.</span><br><span class="line">     * @since 1.5</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        &#x2F;&#x2F; get current thread state</span><br><span class="line">        return State.values()[nativeGetStatus(started)];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>NEW 线程刚刚创建，尚未启动</li>
<li>RUNNABLE 线程正在运行 </li>
<li>BLOCKED 线程堵塞状态，等待同步块的锁的释放，如果获得锁，就会自动进入运行状态</li>
<li>WAITING 线程处于等待状态，需要被其他线程唤醒（notify、notifyAll方法的调用）。线程在调用了join之后，也会进入等待状态，直到被join的线程执行结束才会被唤醒</li>
<li>TIMED_WAITING 有限时间的等待，一般出现在调用sleep(time),join(time),sleep(time)后</li>
<li>TERMINATED 线程运行结束</li>
</ul>
<h2 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait()"></a>Object.wait()</h2><p>根据文档的描述，wait()配合notify()和notifyAll()能够实现线程间通讯，即同步。在线程中调用wait()必须在同步代码块中调用，否则会抛出IllegalMonitorStateException异常。因为wait()函数需要释放相应对象的锁。当线程执行到wait()时，对象会把当前线程放入自己的线程池中，并且释放锁，然后阻塞在这个地方。直到该对象调用了notify()或者notifyAll()后，该线程才能重新获得，或者有可能获得对象的锁，然后继续执行后面的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">     * Causes the current thread to wait until another thread invokes the</span><br><span class="line">     * &#123;@link java.lang.Object#notify()&#125; method or the</span><br><span class="line">     * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or</span><br><span class="line">     * some other thread interrupts the current thread, or a certain</span><br><span class="line">     * amount of real time has elapsed.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This method is similar to the &#123;@code wait&#125; method of one</span><br><span class="line">     * argument, but it allows finer control over the amount of time to</span><br><span class="line">     * wait for a notification before giving up. The amount of real time,</span><br><span class="line">     * measured in nanoseconds, is given by:</span><br><span class="line">     * &lt;blockquote&gt;</span><br><span class="line">     * &lt;pre&gt;</span><br><span class="line">     * 1000000*timeout+nanos&lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * In all other respects, this method does the same thing as the</span><br><span class="line">     * method &#123;@link #wait(long)&#125; of one argument. In particular,</span><br><span class="line">     * &#123;@code wait(0, 0)&#125; means the same thing as &#123;@code wait(0)&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The current thread must own this object&#39;s monitor. The thread</span><br><span class="line">     * releases ownership of this monitor and waits until either of the</span><br><span class="line">     * following two conditions has occurred:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     * &lt;li&gt;Another thread notifies threads waiting on this object&#39;s monitor</span><br><span class="line">     *     to wake up either through a call to the &#123;@code notify&#125; method</span><br><span class="line">     *     or the &#123;@code notifyAll&#125; method.</span><br><span class="line">     * &lt;li&gt;The timeout period, specified by &#123;@code timeout&#125;</span><br><span class="line">     *     milliseconds plus &#123;@code nanos&#125; nanoseconds arguments, has</span><br><span class="line">     *     elapsed.</span><br><span class="line">     * &lt;&#x2F;ul&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The thread then waits until it can re-obtain ownership of the</span><br><span class="line">     * monitor and resumes execution.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * As in the one argument version, interrupts and spurious wakeups are</span><br><span class="line">     * possible, and this method should always be used in a loop:</span><br><span class="line">     * &lt;pre&gt;</span><br><span class="line">     *     synchronized (obj) &#123;</span><br><span class="line">     *         while (&lt;condition does not hold&gt;)</span><br><span class="line">     *             obj.wait(timeout, nanos);</span><br><span class="line">     *         ... &#x2F;&#x2F; Perform action appropriate to condition</span><br><span class="line">     *     &#125;</span><br><span class="line">     * &lt;&#x2F;pre&gt;</span><br><span class="line">     * This method should only be called by a thread that is the owner</span><br><span class="line">     * of this object&#39;s monitor. See the &#123;@code notify&#125; method for a</span><br><span class="line">     * description of the ways in which a thread can become the owner of</span><br><span class="line">     * a monitor.</span><br><span class="line">     *</span><br><span class="line">     * @param      millis   the maximum time to wait in milliseconds.</span><br><span class="line">     * @param      nanos      additional time, in nanoseconds range</span><br><span class="line">     *                       0-999999.</span><br><span class="line">     * @throws  IllegalArgumentException      if the value of timeout is</span><br><span class="line">     *                      negative or the value of nanos is</span><br><span class="line">     *                      not in the range 0-999999.</span><br><span class="line">     * @throws  IllegalMonitorStateException  if the current thread is not</span><br><span class="line">     *               the owner of this object&#39;s monitor.</span><br><span class="line">     * @throws  InterruptedException if any thread interrupted the</span><br><span class="line">     *             current thread before or while the current thread</span><br><span class="line">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span><br><span class="line">     *             status&lt;&#x2F;i&gt; of the current thread is cleared when</span><br><span class="line">     *             this exception is thrown.</span><br><span class="line">     *&#x2F;</span><br><span class="line">public final void wait(long millis) throws InterruptedException &#123;</span><br><span class="line">        wait(millis, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final native void wait(long millis, int nanos) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p>使当前线程等待，直到另一个线程为此对象调用{@link java.lang.Object＃notify（）}方法或{@link java.lang.Object＃notifyAll（）}方法，或其他一些线程中断 当前线程，或一定数量的实时时间已经过去。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/Android/Android%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/27/Android/Android%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/" itemprop="url">Android系统稳定性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-27T10:23:30+08:00">
                2020-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/27/Android/Android%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/27/Android/Android%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Android系统稳定性对于用户体验至关重要. 对于稳定性问题从表现来看有: 死机重启, 自动关机, 无法开机,冻屏,黑屏以及闪退, 无响应等情况; 从技术层面来划分无外乎两大类: 长时间无法执行完成(Timeout) 以及异常崩溃(crash). 主要分类如下:</p>
<p><img src="http://gityuan.com/images/stability/stability_summary.jpg" alt="stability_summary.jpg"></p>
<h3 id="1-1-Timeout"><a href="#1-1-Timeout" class="headerlink" title="1.1 Timeout"></a>1.1 Timeout</h3><p>长时间无法执行完成, 这只是描述性命题, 对于系统来说必须指定每一项操作超过指定阈值美誉执行完成, 则判定为超时(Timeout).</p>
<p>对于Android系统来说,比较常见的便是Service, Broadcast, provider以及input, 当普通app进程超过一定时间没有执行完, 则会弹出应用无响应(Application Not Responding, ANR)的对话框. 如果该app运行在system进程, 更准确的来说,应该是(System Not Responding, SNR). 虽然有ANR和SNR之分, 但习惯上大家都统称为ANR问题.</p>
<p><a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="noopener">理解Android ANR的触发原理</a>, 对于组件ANR问题, 有些是需要的执行时间比较长, 即便触发ANR, 只要再多给些时间还是可以正常运行的; 有些则是由于发生了死锁,即便给再长的时间都无法恢复的问题.</p>
<ul>
<li>Service Timeout:比如前台服务在20s内未执行完成；</li>
<li>broadcast Timeout：比如前台广播在10s内未执行完成</li>
<li>ContentProvider Timeout：内容提供者执行超时</li>
<li>InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件。</li>
</ul>
<p>除了ANR, 还有另一个类型那就是WatchDog.<a href="http://gityuan.com/2016/06/21/watchdog/" target="_blank" rel="noopener">WatchDog工作原理</a>, 最为常见的便是运行在system进程中的”watchdog”线程; 还有运行在各个app进程(包括system进程)的”FinalizerWatchdogDaemon”,该线程用于监控执行GC的过程中, 守护线程”FinalizerDaemon”回收某个对象时间过长的监视器; 当然不至于这些, 还有dex2oat, wifi等watchdog.</p>
<p>当发生ANR或许WatchDog后, 便需要收集系统相关信息,用于分析和修复异常, 见<a href="http://gityuan.com/2016/12/02/app-not-response/" target="_blank" rel="noopener">理解Android ANR的信息收集过程</a>. 整个过程中进程Trace的输出是最为核心的环节，另外该过程会清空/data/anr/traces.txt的老文件, 那么原来之前的traces信息一般地会先输出到dropbox, 有些情况就会丢失traces. Java和Native进程采用不同的策略，如下：</p>
<table>
<thead>
<tr>
<th>进程类型</th>
<th>trace命令</th>
<th>文章</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>kill -3 [pid]</td>
<td><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></td>
<td>不适用于Native进程</td>
</tr>
<tr>
<td>Native</td>
<td>debuggerd -b [pid]</td>
<td><a href="http://gityuan.com/2016/11/27/native-traces/" target="_blank" rel="noopener">Native进程之Trace原理</a></td>
<td>也适用于Java进程</td>
</tr>
</tbody></table>
<h3 id="1-2-Crash"><a href="#1-2-Crash" class="headerlink" title="1.2 Crash"></a>1.2 Crash</h3><p>异常崩溃(Crash)的问题, 毫无疑问这不是时间上能解决的问题, 而是出现了未知的异常. 一旦触发崩溃会出现相应的调用栈, 但不糊输出各个进程的traces.</p>
<p>对于Java层Crash, <a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="noopener">理解Java Crash处理流程</a>, 往往是抛出了一个未捕获的异常uncaughtException而导致的崩溃. 那是不是把所有的异常都catch住系统就没有问题呢, 这个是要分情况的,有时候的异常强制崩溃可能会留下更大的问题, 有些异常的抛出是需要深入分析Root Cause,从根源来解决问题, 而非简单粗糙的捕获住所有的异常.</p>
<p>对于Native层Crash, <a href="http://gityuan.com/2016/06/25/android-native-crash/" target="_blank" rel="noopener">理解Native Crash处理流程</a>, 则是由于进程收到signal信号而引发的崩溃.当进程收到信号,并会触发信号处理函数,通过socket发送信息到debuggerd进程, debuggerd进程收到事件后通过 ptrace attach到目标进程, 获取cpu/memory/traces等关键信息后dettach. Native crash情况比较多, 其中最为场景便是SIGSEGV段错误异常, 往往是内存出现异常,比如访问了权限不足的内存地址等.</p>
<p>对于Kernel层Crash, 这是比较难分析的一大类, 不少情况是跟硬件导致的,比较cpu问题, 硬件驱动问题等.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B(2)/" itemprop="url">Android进程创建流程(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-26T13:53:34+08:00">
                2020-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/" itemprop="url" rel="index">
                    <span itemprop="name">Activity</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/" itemprop="url" rel="index">
                    <span itemprop="name">startActivity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B(2)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B(2)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android进程创建流程"><a href="#Android进程创建流程" class="headerlink" title="Android进程创建流程"></a>Android进程创建流程</h1><h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">    - ZygoteInit.java</span><br><span class="line">    - ZygoteConnection.java</span><br><span class="line">    - RuntimeInit.java</span><br><span class="line">    - Zygote.java</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Process.java</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;com_android_internal_os_Zygote.cpp</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;App_main.cpp （内含AppRuntime类）</span><br><span class="line"></span><br><span class="line">&#x2F;bionic&#x2F;libc&#x2F;bionic&#x2F;fork.cpp</span><br><span class="line">&#x2F;bionic&#x2F;libc&#x2F;bionic&#x2F;pthread_atfork.cpp</span><br><span class="line"></span><br><span class="line">&#x2F;libcore&#x2F;dalvik&#x2F;src&#x2F;main&#x2F;java&#x2F;dalvik&#x2F;system&#x2F;ZygoteHooks.java</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;native&#x2F;dalvik_system_ZygoteHooks.cc</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;Runtime.cc</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;Thread.cc</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;signal_catcher.cc</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程：</strong>每个<code>App</code>在启动前必须先创建一个进程，该进程是由<code>Zygote</code> fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个<code>App</code>就运行在一个进程中，除非在AndroidManifest.xml中配置<code>Android:process</code>属性，或通过native代码fork进程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程：</strong>线程对应用开发者来说非常熟悉，比如每次<code>new Thread().start()</code>都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从Linux角度来说进程与线程都是一个task_struct结构体，除了是否共享资源外，并没有其他本质的区别。</p>
<p>在接下来的文章，会涉及到system_server进程和Zygote进程，下面简要这两个进程：</p>
<ul>
<li><code>system_server</code>进程：是用于管理整个Java framework层，包含ActivityManager，PowerManager等各种系统服务;</li>
<li><code>Zygote</code>进程：是Android系统的首个Java进程，Zygote是所有Java进程的父进程，包括 <code>system_server</code>进程以及所有的App进程都是Zygote的子进程，注意这里说的是子进程，而非子线程。</li>
</ul>
<p>如果想更进一步了解system_server进程和Zygote进程在整个Android系统所处的地位，可查看我的另一个文章<a href="http://gityuan.com/android" target="_blank" rel="noopener">Android系统-开篇</a>。</p>
<h2 id="进程创建图"><a href="#进程创建图" class="headerlink" title="进程创建图"></a>进程创建图</h2><p>对于大多数的应用开发者来说创建线程比较熟悉，而对于创建进程并没有太多的概念。对于系统工程师或者高级开发者，还是有很必要了解Android系统是如何一步步地创建出一个进程的。先来看一张进程创建过程的简要图：</p>
<p><img src="http://gityuan.com/images/android-process/start_app_process.jpg" alt="start_app_process"></p>
<p>图解：</p>
<ol>
<li><strong>App发起进程</strong>：当从桌面启动应用，则发起进程便是Launcher所在进程；当从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过binder发送消息给system_server进程；</li>
<li><strong>system_server进程</strong>：调用Process.start()方法，通过socket向zygote进程发送创建新进程的请求；</li>
<li><strong>zygote进程</strong>：在执行<code>ZygoteInit.main()</code>后便进入<code>runSelectLoop()</code>循环体内，当有客户端连接时便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程；</li>
<li><strong>新进程</strong>：执行handleChildProc方法，最后调用ActivityThread.main()方法。</li>
</ol>
<p>接下来，依次从<code>system_server进程发起请求</code>到<code>Zygote创建进程</code>，再到<code>新进程的运行</code>这3大块展开讲解进程创建是一个怎样的过程。</p>
<h2 id="system-server发起请求"><a href="#system-server发起请求" class="headerlink" title="system_server发起请求"></a>system_server发起请求</h2><h3 id="Process-start"><a href="#Process-start" class="headerlink" title="Process.start()"></a>Process.start()</h3><p>[-&gt; Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">         &#x2F;&#x2F;【见小节2】</span><br><span class="line">        return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startViaZygote"><a href="#startViaZygote" class="headerlink" title="startViaZygote()"></a>startViaZygote()</h3><p>[-&gt; Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    synchronized(Process.class) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">        argsForZygote.add(&quot;--setuid&#x3D;&quot; + uid);</span><br><span class="line">        argsForZygote.add(&quot;--setgid&#x3D;&quot; + gid);</span><br><span class="line">        argsForZygote.add(&quot;--target-sdk-version&#x3D;&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        if (niceName !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--nice-name&#x3D;&quot; + niceName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (appDataDir !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--app-data-dir&#x3D;&quot; + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        if (extraArgs !&#x3D; null) &#123;</span><br><span class="line">            for (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         &#x2F;&#x2F;【见小节3】</span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程主要工作是生成<code>argsForZygote</code>数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。</p>
<h3 id="zygoteSendArgsAndGetResult"><a href="#zygoteSendArgsAndGetResult" class="headerlink" title="zygoteSendArgsAndGetResult()"></a>zygoteSendArgsAndGetResult()</h3><p>[-&gt; Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;其中zygoteState 【见小节3.1】</span><br><span class="line">        final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">        final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        int sz &#x3D; args.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg &#x3D; args.get(i);</span><br><span class="line">            if (arg.indexOf(&#39;\n&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(</span><br><span class="line">                        &quot;embedded newlines not allowed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        ProcessStartResult result &#x3D; new ProcessStartResult();</span><br><span class="line">        &#x2F;&#x2F;等待socket服务端（即zygote）返回新创建的进程pid;</span><br><span class="line">        &#x2F;&#x2F;对于等待时长问题，Google正在考虑此处是否应该有一个timeout，但目前是没有的。</span><br><span class="line">        result.pid &#x3D; inputStream.readInt();</span><br><span class="line">        if (result.pid &lt; 0) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。</p>
<h3 id="openZygoteSocketIfNeeded"><a href="#openZygoteSocketIfNeeded" class="headerlink" title="openZygoteSocketIfNeeded()"></a>openZygoteSocketIfNeeded()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    if (primaryZygoteState &#x3D;&#x3D; null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;向主zygote发起connect()操作</span><br><span class="line">            primaryZygoteState &#x3D; ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState &#x3D;&#x3D; null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        &#x2F;&#x2F;当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span><br><span class="line">        secondaryZygoteState &#x3D; ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>openZygoteSocketIfNeeded(abi)</code>方法是根据当前的abi来选择与zygote还是zygote64来进行通信。</p>
<p>既然system_server进程的zygoteSendArgsAndGetResult()方法通过socket向Zygote进程发送消息，这时便会唤醒Zygote进程，来响应socket客户端的请求（即system_server端），接下来的操作便是在Zygote来创建进程【见小节4】</p>
<h2 id="Zygote创建进程"><a href="#Zygote创建进程" class="headerlink" title="Zygote创建进程"></a>Zygote创建进程</h2><p>文章<a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Android系统启动-zygote篇</a>已介绍，简单来说就是Zygote进程是由由init进程而创建的，进程启动之后调用ZygoteInit.main()方法，经过创建socket管道，预加载资源后，便进程runSelectLoop()方法。</p>
<h3 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        runSelectLoop(abiList); &#x2F;&#x2F;【见小节5】</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); &#x2F;&#x2F;【见小节16】</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续会讲到runSelectLoop()方法会抛出异常<code>MethodAndArgsCaller</code>，从而进入caller.run()方法。Android9.0版本不在需要抛出异常，改为手动调用run方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; We&#39;re in the child process and have exited the select loop. Proceed to execute the</span><br><span class="line">        &#x2F;&#x2F; command.</span><br><span class="line">        if (caller !&#x3D; null) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    &#x2F;&#x2F;sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">            pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">            pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">             &#x2F;&#x2F;处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span><br><span class="line">            Os.poll(pollFds, -1);</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；</span><br><span class="line">            &#x2F;&#x2F; 否则进入continue，跳出本次循环。</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；</span><br><span class="line">                &#x2F;&#x2F; 则创建ZygoteConnection对象,并添加到fds。&#x2F;&#x2F;【见小节5.1】</span><br><span class="line">                ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);&#x2F;&#x2F;内部执行accept方法</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor()); &#x2F;&#x2F;添加到fds.</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作【见小节6】</span><br><span class="line">                boolean done &#x3D; peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i); &#x2F;&#x2F;处理完则从fds中移除该文件描述符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要功能：</p>
<ul>
<li>客户端通过openZygoteSocketIfNeeded()来跟zygote进程建立连接。zygote进程收到客户端连接请求后执行accept()；然后再创建ZygoteConnection对象,并添加到fds数组列表；</li>
<li>建立连接之后，可以跟客户端通信，进入runOnce()方法来接收客户端数据，并执行进程创建工作。</li>
</ul>
<h3 id="acceptCommandPeer"><a href="#acceptCommandPeer" class="headerlink" title="acceptCommandPeer"></a>acceptCommandPeer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static ZygoteConnection acceptCommandPeer(String abiList) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return new ZygoteConnection(sServerSocket.accept(), abiList);</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收客户端发送过来的connect()操作，Zygote作为服务端执行accept()操作。 再后面客户端调用write()写数据，Zygote进程调用read()读数据。</p>
<p>没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒Zygote进程，创建Socket通道ZygoteConnection，然后执行ZygoteConnection的runOnce()方法。</p>
<h3 id="runOnce"><a href="#runOnce" class="headerlink" title="runOnce"></a>runOnce</h3><p>[-&gt; ZygoteConnection.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs &#x3D; null;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;读取socket客户端发送过来的参数列表</span><br><span class="line">        args &#x3D; readArgumentList();</span><br><span class="line">        descriptors &#x3D; mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        closeSocket();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintStream newStderr &#x3D; null;</span><br><span class="line">    if (descriptors !&#x3D; null &amp;&amp; descriptors.length &gt;&#x3D; 3) &#123;</span><br><span class="line">        newStderr &#x3D; new PrintStream(new FileOutputStream(descriptors[2]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pid &#x3D; -1;</span><br><span class="line">    FileDescriptor childPipeFd &#x3D; null;</span><br><span class="line">    FileDescriptor serverPipeFd &#x3D; null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;将binder客户端传递过来的参数，解析成Arguments对象格式</span><br><span class="line">        parsedArgs &#x3D; new Arguments(args);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        int [] fdsToClose &#x3D; &#123; -1, -1 &#125;;</span><br><span class="line">        FileDescriptor fd &#x3D; mSocket.getFileDescriptor();</span><br><span class="line">        if (fd !&#x3D; null) &#123;</span><br><span class="line">            fdsToClose[0] &#x3D; fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd &#x3D; ZygoteInit.getServerSocketFileDescriptor();</span><br><span class="line">        if (fd !&#x3D; null) &#123;</span><br><span class="line">            fdsToClose[1] &#x3D; fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line">        fd &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;【见小节7】</span><br><span class="line">        pid &#x3D; Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;子进程执行</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;【见小节13】</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 不应到达此处，子进程预期的是抛出异常ZygoteInit.MethodAndArgsCaller或者执行exec().</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;父进程执行</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd &#x3D; null;</span><br><span class="line">            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forkAndSpecialize"><a href="#forkAndSpecialize" class="headerlink" title="forkAndSpecialize"></a>forkAndSpecialize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, String instructionSet, String appDataDir) &#123;</span><br><span class="line">    VM_HOOKS.preFork(); &#x2F;&#x2F;【见小节8】</span><br><span class="line">    int pid &#x3D; nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir); &#x2F;&#x2F;【见小节9】</span><br><span class="line">    ...</span><br><span class="line">    VM_HOOKS.postForkCommon(); &#x2F;&#x2F;【见小节11】</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS是Zygote对象的静态成员变量：VM_HOOKS = new ZygoteHooks();</p>
<h3 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h3><p>先说说Zygote进程，如下图：</p>
<p><img src="http://gityuan.com/images/android-process/zygote_sub_thread.png" alt="zygote_sub_thread"></p>
<p>从图中可知Zygote进程有4个Daemon子线程分别是ReferenceQueueDaemon，FinalizerDaemon，FinalizerWatchdogDaemon，HeapTaskDaemon。图中线程名显示的并不完整是由于底层的进程结构体<code>task_struct</code>是由长度为16的char型数组保存，超过15个字符便会截断。</p>
<p>可能有人会问zygote64进程不是还有system_server，com.android.phone等子线程，怎么会只有4个呢？那是因为这些并不是Zygote子线程，而是Zygote的子进程。在图中用红色圈起来的是进程的<a href="http://gityuan.com/2015/10/11/ps-command/" target="_blank" rel="noopener">VSIZE，virtual size)</a>，代表的是进程虚拟地址空间大小。线程与进程的最为本质的区别便是是否共享内存空间，图中VSIZE和Zygote进程相同的才是Zygote的子线程，否则就是Zygote的子进程。</p>
<h3 id="preFork"><a href="#preFork" class="headerlink" title="preFork"></a>preFork</h3><p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public void preFork() &#123;</span><br><span class="line">    Daemons.stop(); &#x2F;&#x2F;停止4个Daemon子线程【见小节8.1】</span><br><span class="line">    waitUntilAllThreadsStopped(); &#x2F;&#x2F;等待所有子线程结束【见小节8.2】</span><br><span class="line">    token &#x3D; nativePreFork(); &#x2F;&#x2F;完成gc堆的初始化工作【见小节8.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daemons-stop"><a href="#Daemons-stop" class="headerlink" title="Daemons.stop"></a>Daemons.stop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void stop() &#123;</span><br><span class="line">    HeapTaskDaemon.INSTANCE.stop(); &#x2F;&#x2F;Java堆整理线程</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.stop(); &#x2F;&#x2F;引用队列线程</span><br><span class="line">    FinalizerDaemon.INSTANCE.stop(); &#x2F;&#x2F;析构线程</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.stop(); &#x2F;&#x2F;析构监控线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处守护线程Stop方式是先调用目标线程interrrupt()方法，然后再调用目标线程join()方法，等待线程执行完成。</p>
<h3 id="waitUntilAllThreadsStopped"><a href="#waitUntilAllThreadsStopped" class="headerlink" title="waitUntilAllThreadsStopped"></a>waitUntilAllThreadsStopped</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void waitUntilAllThreadsStopped() &#123;</span><br><span class="line">    File tasks &#x3D; new File(&quot;&#x2F;proc&#x2F;self&#x2F;task&quot;);</span><br><span class="line">    &#x2F;&#x2F; 当&#x2F;proc中线程数大于1，就出让CPU直到只有一个线程，才退出循环</span><br><span class="line">    while (tasks.list().length &gt; 1) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativePreFork"><a href="#nativePreFork" class="headerlink" title="nativePreFork"></a>nativePreFork</h3><p>nativePreFork通过JNI最终调用如下方法：</p>
<p>[-&gt; dalvik_system_ZygoteHooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</span><br><span class="line">    Runtime* runtime &#x3D; Runtime::Current();</span><br><span class="line">    runtime-&gt;PreZygoteFork(); &#x2F;&#x2F; 见下文</span><br><span class="line">    if (Trace::GetMethodTracingMode() !&#x3D; TracingMode::kTracingInactive) &#123;</span><br><span class="line">      Trace::Pause();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将线程转换为long型并保存到token，该过程是非安全的</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于runtime-&gt;PreZygoteFork的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::PreZygoteFork() &#123;</span><br><span class="line">    &#x2F;&#x2F; 堆的初始化工作。这里就不继续再往下追art虚拟机</span><br><span class="line">    heap_-&gt;PreZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS.preFork()的主要功能便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），并等待这些线程的停止，初始化gc堆的工作, 并将线程转换为long型并保存到token</p>
<h3 id="nativeForkAndSpecialize"><a href="#nativeForkAndSpecialize" class="headerlink" title="nativeForkAndSpecialize"></a>nativeForkAndSpecialize</h3><p>nativeForkAndSpecialize()通过JNI最终调用调用如下方法：</p>
<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(</span><br><span class="line">    JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span><br><span class="line">    jint debug_flags, jobjectArray rlimits,</span><br><span class="line">    jint mount_external, jstring se_info, jstring se_name,</span><br><span class="line">    jintArray fdsToClose, jstring instructionSet, jstring appDataDir) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将CAP_WAKE_ALARM赋予蓝牙进程</span><br><span class="line">    jlong capabilities &#x3D; 0;</span><br><span class="line">    if (uid &#x3D;&#x3D; AID_BLUETOOTH) &#123;</span><br><span class="line">        capabilities |&#x3D; (1LL &lt;&lt; CAP_WAKE_ALARM);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见流程10】</span><br><span class="line">    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, false, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForkAndSpecializeCommon"><a href="#ForkAndSpecializeCommon" class="headerlink" title="ForkAndSpecializeCommon"></a>ForkAndSpecializeCommon</h3><p>[-&gt; com_android_internal_os_Zygote.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置子进程的signal信号处理函数</span><br><span class="line">  SetSigChldHandler();</span><br><span class="line">  &#x2F;&#x2F;fork子进程 【见流程10.1】</span><br><span class="line">  pid_t pid &#x3D; fork();</span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程</span><br><span class="line">    DetachDescriptors(env, fdsToClose); &#x2F;&#x2F;关闭并清除文件描述符</span><br><span class="line"></span><br><span class="line">    if (!is_system_server) &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非system_server子进程，则创建进程组</span><br><span class="line">        int rc &#x3D; createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); &#x2F;&#x2F;设置设置group</span><br><span class="line">    SetRLimits(env, javaRlimits); &#x2F;&#x2F;设置资源limit</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; setresgid(gid, gid, gid);</span><br><span class="line">    rc &#x3D; setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); &#x2F;&#x2F;设置调度策略</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;selinux上下文</span><br><span class="line">    rc &#x3D; selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    if (se_info_c_str &#x3D;&#x3D; NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str &#x3D; &quot;system_server&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (se_info_c_str !&#x3D; NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); &#x2F;&#x2F;设置线程名为system_server，方便调试</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为</span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line">    &#x2F;&#x2F;等价于调用zygote.callPostForkChildHooks() 【见流程10.2】</span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入父进程，即Zygote进程</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。</p>
<ul>
<li>父进程中，fork返回新创建的子进程的pid;</li>
<li>子进程中，fork返回0；</li>
<li>当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</li>
</ul>
<p>fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote进程是所有Android进程的母体，包括system_server和各个App进程。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。其中下图中Zygote进程的libc、vm、preloaded classes、preloaded resources是如何生成的，可查看另一个文章<a href="http://gityuan.com/2016/02/13/android-zygote/#preload" target="_blank" rel="noopener">Android系统启动-zygote篇</a>，见下图：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_fork.jpg" alt="zygote_fork"></p>
<p>copy-on-write过程：当父子进程任一方修改内存数据时（这是on-write时机），才发生缺页中断，从而分配新的物理内存（这是copy操作）。</p>
<p>copy-on-write原理：写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork过程只拷贝父进程的页表，并标记这些页表是只读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常(page fault)，Linux收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。</p>
<h5 id="fork-cpp"><a href="#fork-cpp" class="headerlink" title="fork.cpp"></a>fork.cpp</h5><p>[-&gt; bionic/fork.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define FORK_FLAGS (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD)</span><br><span class="line">int fork() &#123;</span><br><span class="line">  __bionic_atfork_run_prepare(); &#x2F;&#x2F;[见小节2.1.1]</span><br><span class="line"></span><br><span class="line">  pthread_internal_t* self &#x3D; __get_thread();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;fork期间，获取父进程pid，并使其缓存值无效</span><br><span class="line">  pid_t parent_pid &#x3D; self-&gt;invalidate_cached_pid();</span><br><span class="line">  &#x2F;&#x2F;系统调用【见小节2.2】</span><br><span class="line">  int result &#x3D; syscall(__NR_clone, FORK_FLAGS, NULL, NULL, NULL, &amp;(self-&gt;tid));</span><br><span class="line">  if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    self-&gt;set_cached_pid(gettid());</span><br><span class="line">    __bionic_atfork_run_child(); &#x2F;&#x2F;fork完成执行子进程回调方法[见小节2.1.1]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    self-&gt;set_cached_pid(parent_pid);</span><br><span class="line">    __bionic_atfork_run_parent(); &#x2F;&#x2F;fork完成执行父进程回调方法</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能说明：在执行syscall的前后都有相应的回调方法。</p>
<ul>
<li>__bionic_atfork_run_prepare： fork完成前，父进程回调方法</li>
<li>__bionic_atfork_run_child： fork完成后，子进程回调方法</li>
<li>__bionic_atfork_run_paren： fork完成后，父进程回调方法</li>
</ul>
<p>以上3个方法的实现都位于bionic/pthread_atfork.cpp。如果有需要，可以扩展该回调方法，添加相关的业务需求。</p>
<h5 id="Zygote-callPostForkChildHooks"><a href="#Zygote-callPostForkChildHooks" class="headerlink" title="Zygote.callPostForkChildHooks"></a>Zygote.callPostForkChildHooks</h5><p>[-&gt; Zygote.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用ZygoteHooks.postForkChild()</span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void postForkChild(int debugFlags, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;【见流程10.3】</span><br><span class="line">    nativePostForkChild(token, debugFlags, instructionSet);</span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。</p>
<h5 id="nativePostForkChild"><a href="#nativePostForkChild" class="headerlink" title="nativePostForkChild"></a>nativePostForkChild</h5><p>nativePostForkChild通过JNI最终调用调用如下方法：</p>
<p>[-&gt; dalvik_system_ZygoteHooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处token是由[小节8.3]创建的，记录着当前线程</span><br><span class="line">    Thread* thread &#x3D; reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">    &#x2F;&#x2F;设置新进程的主线程id</span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    ..</span><br><span class="line">    if (instruction_set !&#x3D; nullptr) &#123;</span><br><span class="line">      ScopedUtfChars isa_string(env, instruction_set);</span><br><span class="line">      InstructionSet isa &#x3D; GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">      Runtime::NativeBridgeAction action &#x3D; Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">      if (isa !&#x3D; kNone &amp;&amp; isa !&#x3D; kRuntimeISA) &#123;</span><br><span class="line">        action &#x3D; Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;【见流程10.4】</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="DidForkFromZygote"><a href="#DidForkFromZygote" class="headerlink" title="DidForkFromZygote"></a>DidForkFromZygote</h5><p>[-&gt; Runtime.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) &#123;</span><br><span class="line">  is_zygote_ &#x3D; false;</span><br><span class="line">  if (is_native_bridge_loaded_) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">      case NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge(); &#x2F;&#x2F;卸载用于跨平台的桥连库</span><br><span class="line">        is_native_bridge_loaded_ &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      case NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);&#x2F;&#x2F;初始化用于跨平台的桥连库</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建Java堆处理的线程池</span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  &#x2F;&#x2F;重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line">  if (jit_.get() &#x3D;&#x3D; nullptr &amp;&amp; jit_options_-&gt;UseJIT()) &#123;</span><br><span class="line">    &#x2F;&#x2F;当flag被设置，并且还没有创建JIT时，则创建JIT</span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;设置信号处理函数</span><br><span class="line">  StartSignalCatcher();</span><br><span class="line">  &#x2F;&#x2F;启动JDWP线程，当命令debuger的flags指定&quot;suspend&#x3D;y&quot;时，则暂停runtime</span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于信号处理过程，其代码位于signal_catcher.cc文件中，后续会单独讲解。</p>
<h3 id="postForkCommon"><a href="#postForkCommon" class="headerlink" title="postForkCommon"></a>postForkCommon</h3><p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void postForkCommon() &#123;</span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void start() &#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS.postForkCommon的主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。</p>
<h3 id="forkAndSpecialize小结"><a href="#forkAndSpecialize小结" class="headerlink" title="forkAndSpecialize小结"></a>forkAndSpecialize小结</h3><p>该方法主要功能：</p>
<ul>
<li>preFork： 停止Zygote的4个Daemon子线程的运行，初始化gc堆；</li>
<li>nativeForkAndSpecialize：调用<code>fork()</code>创建新进程，设置新进程的主线程id，重置gc性能数据，设置信号处理函数等功能。</li>
<li>postForkCommon：启动4个Deamon子线程。</li>
</ul>
<p>其调用关系链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Zygote.forkAndSpecialize</span><br><span class="line">    ZygoteHooks.preFork</span><br><span class="line">        Daemons.stop</span><br><span class="line">        ZygoteHooks.nativePreFork</span><br><span class="line">            dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork</span><br><span class="line">                Runtime::PreZygoteFork</span><br><span class="line">                    heap_-&gt;PreZygoteFork()</span><br><span class="line">    Zygote.nativeForkAndSpecialize</span><br><span class="line">        com_android_internal_os_Zygote.ForkAndSpecializeCommon</span><br><span class="line">            fork()</span><br><span class="line">            Zygote.callPostForkChildHooks</span><br><span class="line">                ZygoteHooks.postForkChild</span><br><span class="line">                    dalvik_system_ZygoteHooks.nativePostForkChild</span><br><span class="line">                        Runtime::DidForkFromZygote</span><br><span class="line">    ZygoteHooks.postForkCommon</span><br><span class="line">        Daemons.start</span><br></pre></td></tr></table></figure>

<p><strong>时序图：</strong> 点击查看<a href="http://gityuan.com/images/android-process/fork_and_specialize.jpg" target="_blank" rel="noopener">大图</a></p>
<p><img src="http://gityuan.com/images/android-process/fork_and_specialize.jpg" alt="fork_and_specialize"></p>
<p>到此App进程已完成了创建的所有工作，接下来开始新创建的App进程的工作。在前面ZygoteConnection.runOnce方法中，zygote进程执行完<code>forkAndSpecialize()</code>后，新创建的App进程便进入<code>handleChildProc()</code>方法，下面的操作运行在App进程。</p>
<h2 id="新进程运行"><a href="#新进程运行" class="headerlink" title="新进程运行"></a>新进程运行</h2><p>在前面[流程6]runOnce()过程中调用forkAndSpecialize()创建完新进程后，返回值pid=0(即运行在子进程)继续开始执行handleChildProc()方法。</p>
<h3 id="handleChildProc"><a href="#handleChildProc" class="headerlink" title="handleChildProc"></a>handleChildProc</h3><p>[-&gt; ZygoteConnection.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;关闭Zygote的socket两端的连接</span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line"></span><br><span class="line">    if (descriptors !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Os.dup2(descriptors[0], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[1], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[2], STDERR_FILENO);</span><br><span class="line">            for (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr &#x3D; System.err;</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Error reopening stdio&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;设置进程名</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;据说这是用于检测进程内存泄露或溢出时场景而设计，后续还需要进一步分析。</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;执行目标类的main()方法 【见流程14】</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zygoteInit"><a href="#zygoteInit" class="headerlink" title="zygoteInit"></a>zygoteInit</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    redirectLogStreams(); &#x2F;&#x2F;重定向log输出</span><br><span class="line"></span><br><span class="line">    commonInit(); &#x2F;&#x2F; 通用的一些初始化【见流程14.1】</span><br><span class="line">    nativeZygoteInit(); &#x2F;&#x2F; zygote初始化 【见流程14.2】</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); &#x2F;&#x2F; 应用初始化【见流程14.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commonInit"><a href="#commonInit" class="headerlink" title="commonInit"></a>commonInit</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置市区，中国时区为&quot;Asia&#x2F;Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent &#x3D; getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的HTTP User-agent格式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Dalvik&#x2F;1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build&#x2F;LMY47V)&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="nativeZygoteInit"><a href="#nativeZygoteInit" class="headerlink" title="nativeZygoteInit"></a>nativeZygoteInit</h3><p>nativeZygoteInit()所对应的jni方法如下：</p>
<p>[–&gt;AndroidRuntime.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onZygoteInit"><a href="#onZygoteInit" class="headerlink" title="onZygoteInit"></a>onZygoteInit</h4><p>[–&gt;app_main.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit() &#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ProcessState::self():主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver().</li>
<li>startThreadPool(): 启动Binder线程池, 详见<a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">进程的Binder线程池工作过程</a></li>
</ul>
<h3 id="applicationInit"><a href="#applicationInit" class="headerlink" title="applicationInit"></a>applicationInit</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    &#x2F;&#x2F;true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span><br><span class="line">    nativeSetExitWithoutCleanup(true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args &#x3D; new Arguments(argv); &#x2F;&#x2F;解析参数</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用startClass的static方法 main() 【见流程15】</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处args.startClass为”android.app.ActivityThread”。</p>
<h3 id="invokeStaticMain"><a href="#invokeStaticMain" class="headerlink" title="invokeStaticMain"></a>invokeStaticMain</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line"></span><br><span class="line">    Method m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line"></span><br><span class="line">    int modifiers &#x3D; m.getModifiers();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。【见流程16】</span><br><span class="line">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeStaticMain()方法中抛出的异常<code>MethodAndArgsCaller</code> caller，该方法的参数<code>m</code>是指main()方法, <code>argv</code>是指ActivityThread. 根据前面的【流程4】中可知，下一步进入caller.run()方法，也就是MethodAndArgsCaller.run()。</p>
<h3 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h3><p>[–&gt;ZygoteInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static class MethodAndArgsCaller extends Exception implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;根据传递过来的参数，此处反射调用ActivityThread.main()方法【见流程17】</span><br><span class="line">            mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause &#x3D; ex.getCause();</span><br><span class="line">            if (cause instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) cause;</span><br><span class="line">            &#125; else if (cause instanceof Error) &#123;</span><br><span class="line">                throw (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，总算是进入到了ActivityThread类的main()方法。</p>
<h3 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main"></a>ActivityThread.main</h3><p>[–&gt; ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建主线程looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    &#x2F;&#x2F;attach到系统进程</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程进入循环状态</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Process.start()方法是阻塞操作，等待直到进程创建完成并返回相应的新进程pid，才完成该方法。</p>
<p>当App第一次启动时或者启动远程Service，即AndroidManifest.xml文件中定义了process:remote属性时，都需要创建进程。比如当用户点击桌面的某个App图标，桌面本身是一个app（即Launcher App），那么Launcher所在进程便是这次创建新进程的发起进程，该通过binder发送消息给system_server进程，该进程承载着整个java framework的核心服务。system_server进程从Process.start开始，执行创建进程，流程图（以进程的视角）如下：</p>
<p>点击查看<a href="http://gityuan.com/images/android-process/process-create.jpg" target="_blank" rel="noopener">大图</a></p>
<p><img src="http://gityuan.com/images/android-process/process-create.jpg" alt="process-create"></p>
<p>上图中，<code>system_server</code>进程通过socket IPC通道向<code>zygote</code>进程通信，<code>zygote</code>在fork出新进程后由于fork<strong>调用一次，返回两次</strong>，即在zygote进程中调用一次，在zygote进程和子进程中各返回一次，从而能进入子进程来执行代码。该调用流程图的过程：</p>
<ol>
<li><strong>system_server进程</strong>（<code>即流程1~3</code>）：通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；</li>
<li>zygote进程（即流程4~12）：接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节（详见流程6），其具体工作是依次执行下面的3个方法：<ul>
<li>preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；</li>
<li>nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；</li>
<li>postForkCommon()：在启动之前被暂停的4个Daemon子线程。</li>
</ul>
</li>
<li><strong>新进程</strong>（<code>即流程13~15</code>）：进入handleChildProc()方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即Activity.main()方法。</li>
</ol>
<p>再之后的流程，如果是startActivity则将要进入Activity的onCreate/onStart/onResume等生命周期；如果是startService则将要进入Service的onCreate等生命周期。</p>
<p>system_server进程等待zygote返回进程创建完成(ZygoteConnection.handleParentProc), 一旦Zygote.forkAndSpecialize()方法执行完成, 那么分道扬镳, zygote告知system_server进程进程已创建, 而子进程继续执行后续的handleChildProc操作.</p>
<p>Tips: [小节11]RuntimeInit.java的方法nativeZygoteInit()会调用到onZygoteInit()，这个过程中有startThreadPool()创建Binder线程池。也就是说每个进程无论是否包含任何activity等组件，一定至少会包含一个Binder线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/" itemprop="url">Android系统启动概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T23:48:17+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-292fb596c9a68b24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h1><p>按下电源之后，首先加载引导程序 BootLoader 到 RAM（运行内存）；然后，执行引导程序 BootLoader 以把系统 OS 拉起来；Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程，该进程是所有用户空间的鼻祖,init进程会启动servicemanager(binder服务管家), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程，下图是这几个系统重量级进程之间的层级关系。</p>
<p><img src="http://gityuan.com/images/android-arch/android-booting.jpg" alt="android-booting"></p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><p><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">init</a>是Linux系统中用户空间的第一个进程(pid=1), Kerner启动后会调用/system/core/init/Init.cpp的main()方法.</p>
<h3 id="init-main"><a href="#init-main" class="headerlink" title="init.main()"></a>init.main()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    ...</span><br><span class="line">    klog_init();  &#x2F;&#x2F;初始化kernel log</span><br><span class="line">    property_init(); &#x2F;&#x2F;创建一块共享的内存空间，用于属性服务</span><br><span class="line">    signal_handler_init();  &#x2F;&#x2F;初始化子进程退出的信号处理过程</span><br><span class="line"></span><br><span class="line">    property_load_boot_defaults(); &#x2F;&#x2F;加载&#x2F;default.prop文件</span><br><span class="line">    start_property_service();   &#x2F;&#x2F;启动属性服务器(通过socket通信)</span><br><span class="line">    init_parse_config_file(&quot;&#x2F;init.rc&quot;); &#x2F;&#x2F;解析init.rc文件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为 on early-init的语句</span><br><span class="line">    action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);</span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为 on init的语句</span><br><span class="line">    action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);</span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为 on late-init的语句</span><br><span class="line">    action_for_each_trigger(&quot;late-init&quot;, action_add_queue_tail);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (!waiting_for_exec) &#123;</span><br><span class="line">            execute_one_command();</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        int timeout &#x3D; -1;</span><br><span class="line">        if (process_needs_restart) &#123;</span><br><span class="line">            timeout &#x3D; (process_needs_restart - gettime()) * 1000;</span><br><span class="line">            if (timeout &lt; 0)</span><br><span class="line">                timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!action_queue_empty() || cur_action) &#123;</span><br><span class="line">            timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        &#x2F;&#x2F;循环 等待事件发生</span><br><span class="line">        int nr &#x3D; TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">        if (nr &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        &#125; else if (nr &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init进程的主要功能点:</p>
<ul>
<li>分析和运行所有的init.rc文件;</li>
<li>生成设备驱动节点; （通过rc文件创建）</li>
<li>处理子进程的终止(signal方式);</li>
<li>提供属性服务property service。</li>
</ul>
<h3 id="Zygote自动重启机制"><a href="#Zygote自动重启机制" class="headerlink" title="Zygote自动重启机制"></a>Zygote自动重启机制</h3><p>当init解析到下面这条语句,便会启动Zygote进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main                             &#x2F;&#x2F;伴随着main class的启动而启动</span><br><span class="line">    socket zygote stream 660 root system   &#x2F;&#x2F;创建socket</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart media              &#x2F;&#x2F;当zygote重启时,则会重启media</span><br><span class="line">    onrestart restart netd               &#x2F;&#x2F; 当zygote重启时,则会重启netd</span><br></pre></td></tr></table></figure>

<p>当init子进程(Zygote)退出时，会产生SIGCHLD信号，并发送给init进程，通过socket套接字传递数据，调用到wait_for_one_process()方法，根据是否是oneshot，来决定是重启子进程，还是放弃启动。由于缺省模式oneshot=false,因此Zygote一旦被杀便会再次由init进程拉起.</p>
<p><img src="http://gityuan.com/images/boot/init/init_oneshot.jpg" alt="init_oneshot"></p>
<h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r5/cmds/app_process/app_main.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r5/cmds/app_process/app_main.cpp</a></p>
<p>当<a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Zygote</a>进程启动后, 便会执行到frameworks/base/cmds/app_process/App_main.cpp文件的main()方法. 整个调用流程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">App_main.main</span><br><span class="line">    AndroidRuntime.start</span><br><span class="line">        AndroidRuntime.startVm</span><br><span class="line">        AndroidRuntime.startReg</span><br><span class="line">        ZygoteInit.main (首次进入Java世界)</span><br><span class="line">            registerZygoteSocket</span><br><span class="line">            preload</span><br><span class="line">            startSystemServer</span><br><span class="line">            runSelectLoop</span><br></pre></td></tr></table></figure>

<h3 id="App-main-main"><a href="#App-main-main" class="headerlink" title="App_main.main"></a>App_main.main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    while (i &lt; argc) &#123;</span><br><span class="line">        ...&#x2F;&#x2F;参数解析</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置进程名</span><br><span class="line">    if (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        &#x2F;&#x2F; 启动AppRuntime，见小节[3.2]</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在app_process进程启动过程，有两个分支：</p>
<ul>
<li>当zygote为true时，则执行ZygoteInit.main()</li>
<li>当zygote为false时，则执行RuntimeInit.main()</li>
</ul>
<h3 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime::start"></a>AndroidRuntime::start</h3><p>[-&gt; AndroidRuntime.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 虚拟机创建</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env, zygote) !&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; JNI方法注册</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用ZygoteInit.main()方法[见小节3.3]</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-main–Java"><a href="#ZygoteInit-main–Java" class="headerlink" title="ZygoteInit.main–Java"></a>ZygoteInit.main–Java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        registerZygoteSocket(socketName); &#x2F;&#x2F;为Zygote注册socket</span><br><span class="line">        preload(); &#x2F;&#x2F; 预加载类和资源[见小节3.4]</span><br><span class="line">        ...</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);&#x2F;&#x2F;启动system_server[见小节3.5]</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</span><br><span class="line">        runSelectLoop(abiList); &#x2F;&#x2F;进入循环模式[见小节3.6]</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); &#x2F;&#x2F;启动system_server中会讲到。</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-preload"><a href="#ZygoteInit-preload" class="headerlink" title="ZygoteInit.preload"></a>ZygoteInit.preload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void preload() &#123;</span><br><span class="line">    Log.d(TAG, &quot;begin preload&quot;);</span><br><span class="line">    preloadClasses();</span><br><span class="line">    preloadResources();</span><br><span class="line">    preloadOpenGL();</span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">    Log.d(TAG, &quot;end preload&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-startSystemServer"><a href="#ZygoteInit-startSystemServer" class="headerlink" title="ZygoteInit.startSystemServer"></a>ZygoteInit.startSystemServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">        throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fork子进程system_server</span><br><span class="line">    pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">            parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">            parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags,</span><br><span class="line">            null,</span><br><span class="line">            parsedArgs.permittedCapabilities,</span><br><span class="line">            parsedArgs.effectiveCapabilities);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;进入system_server进程[见小节4.1]</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-runSelectLoop"><a href="#ZygoteInit-runSelectLoop" class="headerlink" title="ZygoteInit.runSelectLoop"></a>ZygoteInit.runSelectLoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;sServerSocket是socket通信中的服务端，即zygote进程</span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">            pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">            pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        Os.poll(pollFds, -1);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当客户端发出 连接请求或者数据处理请求时，则执行continue</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;创建客户端连接</span><br><span class="line">                ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;处理客户端数据事务</span><br><span class="line">                boolean done &#x3D; peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote进程创建Java虚拟机,并注册JNI方法， 真正成为Java进程的母体，用于孵化Java进程. 在创建完system_server进程后,zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</p>
<h2 id="system-server"><a href="#system-server" class="headerlink" title="system_server"></a>system_server</h2><p>Zygote通过fork后创建system_server进程，在小节[3.5]执行完startSystemServer()方法后，进入到了handleSystemServerProcess()方法，如下所示。</p>
<h3 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess"></a>handleSystemServerProcess</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;设置当前进程名为&quot;system_server&quot;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String systemServerClasspath &#x3D; Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">    if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行dex优化操作,比如services.jar</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ClassLoader cl &#x3D; null;</span><br><span class="line">        if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">            cl &#x3D; new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;[见小节4.2]</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>system_server进程创建PathClassLoader类加载器.</p>
<h3 id="RuntimeInit-zygoteInit"><a href="#RuntimeInit-zygoteInit" class="headerlink" title="RuntimeInit.zygoteInit"></a>RuntimeInit.zygoteInit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</span><br><span class="line">    redirectLogStreams(); &#x2F;&#x2F;重定向log输出</span><br><span class="line"></span><br><span class="line">    commonInit(); &#x2F;&#x2F; 通用的一些初始化</span><br><span class="line">    nativeZygoteInit(); &#x2F;&#x2F; zygote初始化</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); &#x2F;&#x2F; [见小节3.4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder线程池启动"><a href="#Binder线程池启动" class="headerlink" title="Binder线程池启动"></a>Binder线程池启动</h2><p>nativeZygoteInit()方法经过层层调用,会进入app_main.cpp中的onZygoteInit()方法, Binder线程池的创建也是在这个过程,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit() &#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程池</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获特殊异常"><a href="#捕获特殊异常" class="headerlink" title="捕获特殊异常"></a>捕获特殊异常</h2><p>applicationInit()方法经过层层调用,会抛出异常ZygoteInit.MethodAndArgsCaller(m, argv), 具体过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv,</span><br><span class="line">        ClassLoader classLoader) &#123;</span><br><span class="line">    ...</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    final Arguments args &#x3D; new Arguments(argv);</span><br><span class="line">    &#x2F;&#x2F;找到目标类的静态main()方法</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    &#x2F;&#x2F;此处的className等于SystemServer</span><br><span class="line">    Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">    Method  m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#x2F;&#x2F;抛出异常Runnable对象</span><br><span class="line">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h3><p>[–&gt;ZygoteInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        startSystemServer(abiList, socketName); &#x2F;&#x2F;抛出MethodAndArgsCaller异常</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); &#x2F;&#x2F;此处通过反射,会调用SystemServer.main()方法 [见小节4.4]</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MethodAndArgsCaller implements Runnable &#123;</span><br><span class="line">    private final Method mMethod;</span><br><span class="line">    private final String[] mArgs;</span><br><span class="line"></span><br><span class="line">    public MethodAndArgsCaller(Method method, String[] args) &#123;</span><br><span class="line">        mMethod &#x3D; method;</span><br><span class="line">        mArgs &#x3D; args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;执行SystemServer.main()</span><br><span class="line">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用抛出异常的方式,用于栈帧清空,提供利用率, 以至于现在大家看到的每个Java进程的调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">at com.android.server.SystemServer.main(SystemServer.java:175)</span><br><span class="line">at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)</span><br></pre></td></tr></table></figure>

<h3 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main"></a>SystemServer.main</h3><p>[–&gt;SystemServer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class SystemServer &#123;</span><br><span class="line">    ...</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先初始化SystemServer对象，再调用对象的run()方法</span><br><span class="line">        new SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h3><p>[–&gt;SystemServer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void run() &#123;</span><br><span class="line">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</span><br><span class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</span><br><span class="line">    Looper.prepareMainLooper();&#x2F;&#x2F; 准备主线程looper</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;加载android_servers.so库，该库包含的源码在frameworks&#x2F;base&#x2F;services&#x2F;目录下</span><br><span class="line">    System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测上次关机过程是否失败，该方法可能不会返回</span><br><span class="line">    performPendingShutdown();</span><br><span class="line">    createSystemContext(); &#x2F;&#x2F;初始化系统上下文</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建系统服务管理</span><br><span class="line">    mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动各种系统服务</span><br><span class="line">    try &#123;</span><br><span class="line">        startBootstrapServices(); &#x2F;&#x2F; 启动引导服务</span><br><span class="line">        startCoreServices();      &#x2F;&#x2F; 启动核心服务</span><br><span class="line">        startOtherServices();     &#x2F;&#x2F; 启动其他服务[见小节4.6]</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;一直循环执行</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class SystemServer &#123;</span><br><span class="line">    private void startBootstrapServices() &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#x2F;&#x2F;phase100</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void startOtherServices() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;phase480 和phase500</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;[见小节4.7]</span><br><span class="line">        mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               &#x2F;&#x2F;phase550</span><br><span class="line">               mSystemServiceManager.startBootPhase(</span><br><span class="line">                       SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;phase600</span><br><span class="line">               mSystemServiceManager.startBootPhase(</span><br><span class="line">                       SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>start: 创建AMS, PMS, LightsService, DMS.</li>
<li>phase100: 进入Phase100, 创建PKMS, WMS, IMS, DBMS, LockSettingsService, JobSchedulerService, MmsService等服务;</li>
<li>phase480 &amp;&amp; 500: 进入Phase480, 调用WMS, PMS, PKMS, DisplayManagerService这4个服务的systemReady();</li>
<li>Phase550: 进入phase550, 执行AMS.systemReady(), 启动SystemUI, WebViewFactory, Watchdog.</li>
<li>Phase600: 进入phase600, 执行AMS.systemReady(), 执行各种服务的systemRunning().</li>
<li>Phase1000: 进入1000, 执行finishBooting, 启动启动on-hold进程.</li>
</ul>
<h3 id="AMS-systemReady"><a href="#AMS-systemReady" class="headerlink" title="AMS.systemReady"></a>AMS.systemReady</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line"></span><br><span class="line">    public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ... &#x2F;&#x2F;update相关</span><br><span class="line">        mSystemReady &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;杀掉所有非persistent进程</span><br><span class="line">        removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">        mProcessesReady &#x3D; true;</span><br><span class="line"></span><br><span class="line">        goingCallback.run();  &#x2F;&#x2F;[见小节1.6.2]</span><br><span class="line"></span><br><span class="line">        addAppLocked(info, false, null); &#x2F;&#x2F;启动所有的persistent进程</span><br><span class="line">        mBooting &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动home</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line">        &#x2F;&#x2F;恢复栈顶的Activity</span><br><span class="line">        mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System_server主线程的启动工作,总算完成, 进入Looper.loop()状态,等待其他线程通过handler发送消息再处理.</p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>对于普通的app进程,跟system_server进程的启动过程有些类似.不同的是app进程是向发消息给system_server进程, 由system_server向zygote发出创建进程的请求.</p>
<p><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a>, 可知进程创建后 接下来会进入ActivityThread.main()过程。</p>
<h3 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main"></a>ActivityThread.main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建主线程looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false); &#x2F;&#x2F;attach到系统进程</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程进入循环状态</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用栈对比"><a href="#调用栈对比" class="headerlink" title="调用栈对比"></a>调用栈对比</h3><p>App进程的主线程调用栈的栈底如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:5442)</span><br><span class="line">    at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)</span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)</span><br></pre></td></tr></table></figure>

<p>跟前面介绍的system_server进程调用栈对比:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">at com.android.server.SystemServer.main(SystemServer.java:175)</span><br><span class="line">at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)</span><br></pre></td></tr></table></figure>

<h2 id="启动日志分析"><a href="#启动日志分析" class="headerlink" title="启动日志分析"></a>启动日志分析</h2><p>以下列举启动部分重要进程以及关键节点会打印出的log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;system&#x2F;bin&#x2F;vold: 383</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;lmkd: 432</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;surfaceflinger: 434</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;debuggerd64: 537</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;mediaserver: 540</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;installd: 541</span><br><span class="line">&#x2F;system&#x2F;vendor&#x2F;bin&#x2F;thermal-engine: 552</span><br><span class="line"></span><br><span class="line">zygote64: 557</span><br><span class="line">zygote: 558</span><br><span class="line">system_server: 1274</span><br></pre></td></tr></table></figure>

<h3 id="before-zygote日志"><a href="#before-zygote日志" class="headerlink" title="before zygote日志"></a>before zygote日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动vold, 再列举当前系统所支持的文件系统.  执行到system&#x2F;vold&#x2F;main.cpp的main()</span><br><span class="line">11-23 14:36:47.474   383   383 I vold    : Vold 3.0 (the awakening) firing up  </span><br><span class="line">11-23 14:36:47.475   383   383 V vold    : Detected support for: ext4 vfat   </span><br><span class="line">&#x2F;&#x2F;使用内核的lmk策略</span><br><span class="line">11-23 14:36:47.927   432   432 I lowmemorykiller: Using in-kernel low memory killer interface</span><br><span class="line">&#x2F;&#x2F;启动SurfaceFlinger</span><br><span class="line">11-23 14:36:48.041   434   434 I SurfaceFlinger: SurfaceFlinger is starting</span><br><span class="line">11-23 14:36:48.042   434   434 I SurfaceFlinger: SurfaceFlinger&#39;s main thread ready to run. Initializing graphics H&#x2F;W...</span><br><span class="line">&#x2F;&#x2F; 开机动画</span><br><span class="line">11-23 14:36:48.583   508   508 I BootAnimation: bootanimation launching ...</span><br><span class="line">&#x2F;&#x2F; debuggerd</span><br><span class="line">11-23 14:36:50.306   537   537 I         : debuggerd: starting</span><br><span class="line">&#x2F;&#x2F; installd启动</span><br><span class="line">11-23 14:36:50.311   541   541 I installd: installd firing up</span><br><span class="line">&#x2F;&#x2F; thermal守护进程</span><br><span class="line">11-23 14:36:50.369   552   552 I ThermalEngine: Thermal daemon started</span><br></pre></td></tr></table></figure>

<h3 id="zygote日志"><a href="#zygote日志" class="headerlink" title="zygote日志"></a>zygote日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Zygote64进程(Zygote):  AndroidRuntime::start</span><br><span class="line">11-23 14:36:51.260   557   557 D AndroidRuntime: &gt;&gt;&gt;&gt;&gt;&gt; START com.android.internal.os.ZygoteInit uid 0 &lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">&#x2F;&#x2F; Zygote64进程:  AndroidRuntime::startVm</span><br><span class="line">11-23 14:36:51.304   557   557 D AndroidRuntime: CheckJNI is OFF</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preload()</span><br><span class="line">11-23 14:36:52.134   557   557 D Zygote  : begin preload</span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preloadClasses(), 预加载3860个classes, 花费时长746ms</span><br><span class="line">11-23 14:36:52.134   557   557 I Zygote  : Preloading classes...</span><br><span class="line">11-23 14:36:52.881   557   557 I Zygote  : ...preloaded 3860 classes in 746ms.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preloadClasses(), 预加载86组资源, 花费时长179ms</span><br><span class="line">11-23 14:36:53.114   557   557 I Zygote  : Preloading resources...</span><br><span class="line">11-23 14:36:53.293   557   557 I Zygote  : ...preloaded 86 resources in 179ms.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preloadSharedLibraries()</span><br><span class="line">11-23 14:36:53.494   557   557 I Zygote  : Preloading shared libraries...</span><br><span class="line">11-23 14:36:53.503   557   557 D Zygote  : end preload</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行com_android_internal_os_Zygote_nativeForkSystemServer(),成功fork出system_server进程</span><br><span class="line">11-23 14:36:53.544   557   557 I Zygote  : System server process 1274 has been created</span><br><span class="line">&#x2F;&#x2F; Zygote开始进入runSelectLoop()</span><br><span class="line">11-23 14:36:53.546   557   557 I Zygote  : Accepting command socket connections</span><br></pre></td></tr></table></figure>

<h3 id="system-server日志"><a href="#system-server日志" class="headerlink" title="system_server日志"></a>system_server日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进入system_server, 建立跟Zygote进程的socket通道</span><br><span class="line">11-23 14:36:53.586  1274  1274 I Zygote  : Process: zygote socket opened, supported ABIS: armeabi-v7a,armeabi</span><br><span class="line">&#x2F;&#x2F; 执行SystemServer.run()</span><br><span class="line">11-23 14:36:53.618  1274  1274 I SystemServer: Entered the Android system server!   &lt;&#x3D;&#x3D;&#x3D;&gt; boot_progress_system_run</span><br><span class="line">&#x2F;&#x2F; 等待installd准备就绪</span><br><span class="line">11-23 14:36:53.707  1274  1274 I Installer: Waiting for installd to be ready.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务启动</span><br><span class="line">11-23 14:36:53.732  1274  1274 I ActivityManager: Memory class: 192</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;phase100</span><br><span class="line">11-23 14:36:53.883  1274  1274 I SystemServiceManager: Starting phase 100</span><br><span class="line">11-23 14:36:53.902  1274  1274 I SystemServer: Package Manager</span><br><span class="line">11-23 14:37:03.816  1274  1274 I SystemServer: User Service</span><br><span class="line">...</span><br><span class="line">11-23 14:37:03.940  1274  1274 I SystemServer: Init Watchdog</span><br><span class="line">11-23 14:37:03.941  1274  1274 I SystemServer: Input Manager</span><br><span class="line">11-23 14:37:03.946  1274  1274 I SystemServer: Window Manager</span><br><span class="line">...</span><br><span class="line">11-23 14:37:04.081  1274  1274 I SystemServiceManager: Starting com.android.server.MountService$Lifecycle</span><br><span class="line">11-23 14:37:04.088  1274  2717 D MountService: Thinking about reset, mSystemReady&#x3D;false, mDaemonConnected&#x3D;true</span><br><span class="line">11-23 14:37:04.088  1274  1274 I SystemServiceManager: Starting com.android.server.UiModeManagerService</span><br><span class="line">11-23 14:37:04.520  1274  1274 I SystemServer: NetworkTimeUpdateService</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;phase480 &amp;&amp; 500</span><br><span class="line">11-23 14:37:05.056  1274  1274 I SystemServiceManager: Starting phase 480</span><br><span class="line">11-23 14:37:05.061  1274  1274 I SystemServiceManager: Starting phase 500</span><br><span class="line">11-23 14:37:05.231  1274  1274 I ActivityManager: System now ready  &lt;&#x3D;&#x3D;&gt; boot_progress_ams_ready</span><br><span class="line">11-23 14:37:05.234  1274  1274 I SystemServer: Making services ready</span><br><span class="line">11-23 14:37:05.243  1274  1274 I SystemServer: WebViewFactory preparation</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;phase550</span><br><span class="line">11-23 14:37:05.234  1274  1274 I SystemServiceManager: Starting phase 550</span><br><span class="line">11-23 14:37:05.237  1274  1288 I ActivityManager: Force stopping com.android.providers.media appid&#x3D;10010 user&#x3D;-1: vold reset</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Phase600</span><br><span class="line">11-23 14:37:06.066  1274  1274 I SystemServiceManager: Starting phase 600</span><br><span class="line">11-23 14:37:06.236  1274  1274 D MountService: onStartUser 0</span><br></pre></td></tr></table></figure>

<h3 id="logcat小技巧"><a href="#logcat小技巧" class="headerlink" title="logcat小技巧"></a>logcat小技巧</h3><p>通过adb bugreport抓取log信息.先看zygote是否起来, 再看system_server主线程的运行情况,再看ActivityManager情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -s Zygote</span><br><span class="line">adb logcat -s SystemServer</span><br><span class="line">adb logcat -s SystemServiceManager</span><br><span class="line">adb logcat | grep &quot;1359 1359&quot; &#x2F;&#x2F;system_server情况</span><br><span class="line">adb logcat -s ActivityManager</span><br></pre></td></tr></table></figure>

<p>现场调试命令</p>
<ol>
<li>cat proc/[pid]/stack ==&gt; 查看kernel调用栈</li>
<li>debuggerd -b [pid] ==&gt; 也不可以不带参数-b, 则直接输出到/data/tombstones/目录</li>
<li>kill -3 [pid] ==&gt; 生成/data/anr/traces.txt文件</li>
<li>lsof [pid] ==&gt; 查看进程所打开的文件</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各大核心进程启动后，都会进入各种对象所相应的main()方法，如下</p>
<h3 id="进程main方法"><a href="#进程main方法" class="headerlink" title="进程main方法"></a>进程main方法</h3><table>
<thead>
<tr>
<th align="left">进程</th>
<th align="left">主方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">init进程</td>
<td align="left">Init.main()</td>
</tr>
<tr>
<td align="left">zygote进程</td>
<td align="left">ZygoteInit.main()</td>
</tr>
<tr>
<td align="left">app_process进程</td>
<td align="left">RuntimeInit.main()</td>
</tr>
<tr>
<td align="left">system_server进程</td>
<td align="left">SystemServer.main()</td>
</tr>
<tr>
<td align="left">app进程</td>
<td align="left">ActivityThread.main()</td>
</tr>
</tbody></table>
<p>注意app_process进程是指通过/system/bin/app_process启动的进程，且后面跟的参数不带–zygote，即并非启动zygote进程。 比如常见的有通过adb shell方式来执行am,pm等命令，便是这种方式。</p>
<h3 id="重启相关进程"><a href="#重启相关进程" class="headerlink" title="重启相关进程"></a>重启相关进程</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>关于重要进程重启的过程，会触发哪些关联进程重启名单：</p>
<ul>
<li>zygote：触发media、netd以及子进程(包括system_server进程)重启；</li>
<li>system_server: 触发zygote重启;</li>
<li>surfaceflinger：触发zygote重启;</li>
<li>servicemanager: 触发zygote、healthd、media、surfaceflinger、drm重启</li>
</ul>
<p>所以，surfaceflinger,servicemanager,zygote自身以及system_server进程被杀都会触发Zygote重启。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/" itemprop="url">为什么Android要采用Binder作为IPC机制？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T21:59:55+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p>Android 另起炉灶开发了 Binder 驱动，而没有采用已有的方案，而 D-Bus 这样的方案也可以实现 Binder 的功能，是出于什么原因和什么考虑？安全性？性能？</p>
<h1 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h1><p><strong>在开始回答 前，先简单概括性地说说Linux现有的所有进程间IPC方式：</strong></p>
<ul>
<li><strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li><strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li><strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li><strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不同机器或跨网络的通信；</li>
<li><strong>信号量</strong>：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>信号</strong>: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ul>
<p><strong>Android的内核也是基于Linux内核，为何不直接采用Linux现有的进程IPC方案呢，难道Linux社区那么多优秀人员都没有考虑到有Binder这样一个更优秀的方案，是google太过于牛B吗？事实是真相并非如此，请细细往下看，您就明白了。</strong></p>
<p><strong>接下来正面回答这个问题，从5个角度来展开对Binder的分析：</strong></p>
<ul>
<li><p><strong>从性能的角度</strong> <strong>数据拷贝次数：</strong></p>
<p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</p>
</li>
<li><p><strong>从稳定性的角度</strong></p>
<p>Binder是基于C/S架构的，简单解释下C/S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。</p>
</li>
</ul>
<p>仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制，那么更重要的原因是：</p>
<ul>
<li><p><strong>从安全的角度</strong></p>
<p>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。 </p>
<p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，<strong>Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行</strong>。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。</p>
<p>针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但<strong>同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。</strong>对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。</p>
<p>Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：<br><a href="https://www.zhihu.com/question/41003297/answer/89328987?from=profile_answer_card" target="_blank" rel="noopener">Android源码的Binder权限是如何控制？ -Gityuan的回答</a></p>
<p><strong>传统IPC</strong>只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p>
<p><strong>说到这，可能有人要反驳</strong>，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在<strong>Google举办的Android Bootcamp 2016</strong>大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。 </p>
<p>话题扯远了，继续说Binder。</p>
</li>
<li><p><strong>从语言层面的角度</strong></p>
<p>大家多知道Linux是基于C语言(面向过程的语言)，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。</p>
<p><strong>另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。</strong>也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在<strong>Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制</strong>，Android中的<strong>Kill Process采用的signal（信号）机制</strong>等等。而<strong>Binder更多则用在system_server进程与上层App层的IPC交互</strong>。</p>
</li>
<li><p><strong>从公司战略的角度</strong></p>
<p>总所周知，Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。 </p>
<p>而Android 之父 Andy Rubin对于GPL显然是不能接受的，为此，Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性，仍有较大争议，但至少目前缓解Android，让GPL止步于内核空间，这是Google在GPL Linux下 开源与商业化共存的一个成功典范。</p>
</li>
</ul>
<p><strong>有了这些铺垫，我们再说说Binder的今世前缘</strong></p>
<p>Binder是基于开源的 <a href="https://link.zhihu.com/?target=http%3A//www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html">OpenBinder</a>实现的，OpenBinder是一个开源的系统IPC机制,最初是由 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Be_Inc.">Be Inc.</a> 开发，接着由<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Palm%2C_Inc.">Palm, Inc.</a>公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择。</p>
<p>另外，再说一点关于OpenBinder，在2015年OpenBinder以及合入到Linux Kernel主线 3.19版本，这也算是Google对Linux的一点回馈吧。</p>
<p><strong>综合上述5点，可知Binder是Android系统上层进程间通信的不二选择。</strong></p>
<p><strong>接着，回答楼主提到的</strong>D-Bus</p>
<p>作者：Gityuan<br>链接：<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">https://www.zhihu.com/question/39440766/answer/89210950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>也采用C/S架构的IPC机制，<strong><a href="https://link.zhihu.com/?target=https%3A//www.freedesktop.org/wiki/Software/dbus/">D-Bus</a></strong>是在用户空间实现的方法，效率低，消息拷贝次数和上下文切换次数都明显多过于Binder。针对D-Bus这些缺陷，于是就产生了<strong>kdbus</strong>，这是D-Bus在内核实现版，效率得到提升，与Binder一样在内核作为字符设计，通过open()打开设备，mmap()映射内存。</p>
<p>（1）kdbus在进程间通信过程，Client端将消息在内存的消息队列，可以存储大量的消息，Server端不断从消息队里中取消息，大小只受限内存；<br>（2）Binder的机制是每次通信，会通信的进程或线程中的todo队里中增加binder事务，并且每个进程所允许Binder线程数，google提供的默认最大线程数为16个，受限于CPU，由于线程数太多，增加系统负载，并且每个进程默认分配的（1M-8K）大小的内存。</p>
<p>而kdbus对于内存消耗较大，同时也适合传输大量数据和大量消息的系统。Binder对CPU和内存的需求比较低，效率比较高，从而进一步说明Binder适合于移动系统Android，但是，也有一定缺点，就是不同利用Binder输出大数据，比如利用Binder传输几M大小的图片，便会出现异常，虽然有厂商会增加Binder内存，但是也不可能比系统默认内存大很多，否则整个系统的可用内存大幅度降低。</p>
<p><strong>最后，简单讲讲Android Binder架构</strong></p>
<p>Binder在Android系统中江湖地位非常之高。在Zygote孵化出system_server进程后，在system_server进程中出初始化支持整个Android framework的各种各样的Service，而这些Service从大的方向来划分，分为Java层Framework和Native Framework层(C++)的Service，几乎都是基于BInder IPC机制。</p>
<ol>
<li><strong>Java framework：作为Server端继承(或间接继承)于Binder类，Client端继承(或间接继承)于BinderProxy类。</strong>例如 ActivityManagerService(用于控制Activity、Service、进程等) 这个服务作为Server端，间接继承Binder类，而相应的ActivityManager作为Client端，间接继承于BinderProxy类。 当然还有PackageManagerService、WindowManagerService等等很多系统服务都是采用C/S架构；</li>
<li><strong>Native Framework层：这是C++层，作为Server端继承(或间接继承)于BBinder类，Client端继承(或间接继承)于BpBinder。</strong>例如MediaPlayService(用于多媒体相关)作为Server端，继承于BBinder类，而相应的MediaPlay作为Client端，间接继承于BpBinder类。</li>
</ol>
<p><strong>总之，一句话”无Binder不Android”。</strong></p>
<p>本来想从Binder源码技术的角度，分析Binder如何做到的，发现不知不觉就写了这么多，对于实现原理有兴趣，查看我的个人博客。通过<strong>Google搜索关键字 “Binder系列”</strong>，第一个出现的便是我的博客 老域名(域名已经释放了，听读者被重定向带色的网站了)，上一张 Google搜索结果的截图：</p>
<p><img src="https://pic4.zhimg.com/50/c986b0f037f7f1aaec0ba485253dba25_hd.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/c986b0f037f7f1aaec0ba485253dba25_1440w.jpg" alt="img"></p>
<blockquote>
<p>为了便于传播与记忆，刚刚申请了新域名gityuan(与我的微博、知乎ID同名)，个人博客由xxx(匿了)迁<strong>移到新域名 <a href="https://link.zhihu.com/?target=http%3A//Gityuan.com">http://Gityuan.com</a></strong>，由于不擅长SEO，网站的google权重降低，更新时间 2016.03.27。</p>
</blockquote>
<p>有网友建议，放上Binder系列的连接：<a href="https://link.zhihu.com/?target=http%3A//gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a>。 更新时间2016.04.09</p>
<p>最后的最后：</p>
<blockquote>
<p><strong>朋友推荐来知乎这边回答网友的问题，涨涨人气，我也是拼了，第一次这么长篇大论的回答知乎的问题，感觉没说清楚，修订了一遍又一遍，如果大家觉得我回答得还行，还请大家随手 点赞、关注、收藏，如果觉得说得不好的，还往评论指正。 若能得到大家的肯定，那也不枉费花时间敲打这么多文字，在这里 Gityuan先谢谢大家。</strong></p>
</blockquote>
<p>==========&gt;      <strong>我的微博：<a href="https://link.zhihu.com/?target=http%3A//weibo.com/gityuan">Gityuan</a></strong><br>==========&gt; <strong>我微信公众号： Gityuan</strong></p>
<p>之前一直在埋头做技术，最近刚刚开通微信、微博，后面会有更多的干货分享，欢迎大家关注，谢谢！！</p>
<p>-—————————————————————————————————————————————–</p>
<blockquote>
<p>关于我是如何学习Android，可以查看我的另一篇知乎文章： <a href="http://zhuanlan.zhihu.com/p/20708611" target="_blank" rel="noopener">如何自学Android</a>？</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/" itemprop="url">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T21:08:24+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p>app程序入口中为主线程准备好了消息队列</p>
<p><img src="https://pic1.zhimg.com/ce97597327ffe00c04ce76fc2f41030c_b.png" alt="img"></p>
<p>而根据Looper.loop()源码可知里面是一个死循环在遍历消息队列取消息</p>
<p><img src="https://pic3.zhimg.com/10df1f7c70d0d9382f5c8a4b2b6d66a6_b.png" alt="img"></p>
<p>而且并也没看见哪里有相关代码为这个死循环准备了一个新线程去运转，但是主线程却并不会因为Looper.loop()中的这个死循环卡死，为什么呢？</p>
<p>举个例子，像Activity的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？</p>
<h1 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h1><p>要完全彻底理解这个问题，需要准备以下4方面的知识：Process/Thread，Android Binder IPC，Handler/Looper/MessageQueue消息机制，Linux pipe/epoll机制。</p>
<p><strong>总结一下楼主主要有3个疑惑：</strong></p>
<p>1.Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ </p>
<p>2.没看见哪里有相关代码为这个死循环准备了一个新线程去运转？ </p>
<p>3.Activity的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？</p>
<p><strong>(1) Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</strong></p>
<p>这里涉及线程，先说说说进程/线程</p>
<p><strong>进程：</strong>每个app运行时前首先创建一个进程，该进程是由Zygote fork出来的，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。</p>
<p><strong>线程：</strong>线程对应用来说非常常见，比如每次new Thread().start都会创建一个新的线程。该线程与App所在进程之间资源共享，从Linux角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个task_struct结构体<strong>，在CPU看来进程或线程无非就是一段可执行的代码，CPU采用CFS调度算法，保证每个task都尽可能公平的享有CPU时间片</strong>。</p>
<p>有了这么准备，再说说死循环问题：</p>
<p>对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？<strong>简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，</strong>例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。</p>
<p>真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。</p>
<p><strong>(2) 没看见哪里有相关代码为这个死循环准备了一个新线程去运转？</strong></p>
<p>事实上，会在进入死循环之前便创建了新binder线程，在代码ActivityThread.main()中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Looper和MessageQueue对象，用于处理主线程的消息</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建ActivityThread对象</span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread(); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;建立Binder通道 (创建新线程)</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        Looper.loop(); &#x2F;&#x2F;消息循环运行</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>thread.attach(false)；便会创建一个Binder线程（具体是指ApplicationThread，Binder的服务端，用于接收系统服务AMS发送来的事件），该Binder线程通过Handler将Message发送给主线程</strong>，具体过程可查看 <a href="https://link.zhihu.com/?target=http%3A//gityuan.com/2016/03/06/start-service/">startService流程分析</a>，这里不展开说，简单说Binder用于进程间通信，采用C/S架构。关于binder感兴趣的朋友，可查看我回答的另一个知乎问题：<br><a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？ - Gityuan的回答</a></p>
<p>另外，<strong>ActivityThread实际上并非线程</strong>，不像HandlerThread类，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，该人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。</p>
<p><strong>主线程的死循环一直运行是不是特别消耗CPU资源呢？</strong> 其实不然，这里就涉及到<strong>Linux pipe/epoll机制</strong>，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见<a href="https://link.zhihu.com/?target=http%3A//www.yuanhh.com/2015/12/26/handler-message-framework/%23next">Android消息机制1-Handler(Java层)</a>，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 <strong>所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</strong></p>
<p><strong>(3) Activity的生命周期是怎么实现在死循环体外能够执行起来的？</strong></p>
<p>ActivityThread的内部类H继承于Handler，通过handler消息机制，简单说Handler机制用于同一个进程的线程间通信。</p>
<p><strong>Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施：</strong><br>在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。</p>
<p>比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法；</p>
<p>再比如收到msg=H.PAUSE_ACTIVITY，则调用ActivityThread.handlePauseActivity()方法，最终会执行Activity.onPause()等方法。 上述过程，我只挑核心逻辑讲，真正该过程远比这复杂。</p>
<p><strong>主线程的消息又是哪来的呢？</strong>当然是App进程中的其他线程通过Handler发送给主线程，请看接下来的内容：</p>
<p><strong>最后，从进程与线程间通信的角度，</strong>通过一张图加深大家对App运行过程的理解</p>
<p><img src="https://pic4.zhimg.com/50/7fb8728164975ac86a2b0b886de2b872_hd.jpg" alt="img"></p>
<p><strong>system_server进程是系统进程</strong>，java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。</p>
<p><strong>App进程则是我们常说的应用程序</strong>，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），除了图中画的线程，其中还有很多线程，比如signal catcher线程等，这里就不一一列举。</p>
<p>Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事务，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息。</p>
<p><strong>结合图说说Activity生命周期，比如暂停Activity，流程如下：</strong></p>
<ol>
<li>线程1的AMS中调用线程2的ATP；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题）</li>
<li>线程2通过binder传输到App进程的线程4；</li>
<li>线程4通过handler消息机制，将暂停Activity的消息发送给主线程；</li>
<li>主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的调用，最后便会调用到Activity.onPause()，当onPause()处理完后，继续循环loop下去。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/" itemprop="url">Handler（Java层）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T16:03:39+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android消息机制1-Handler-Java层"><a href="#Android消息机制1-Handler-Java层" class="headerlink" title="Android消息机制1-Handler(Java层)"></a>Android消息机制1-Handler(Java层)</h1><blockquote>
<p>本文基于Android 6.0的源代码，来分析Java层的handler消息处理机制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;andorid&#x2F;os&#x2F;</span><br><span class="line">  - Handler.java</span><br><span class="line">  - Looper.java</span><br><span class="line">  - Message.java</span><br><span class="line">  - MessageQueue.java</span><br></pre></td></tr></table></figure>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，，另一个便是消息机制(由Handler/Looper/MessageQueue等构成的)。关于Binder在<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列</a>中详细讲解过，有兴趣看看。</p>
<p>Android有大量的消息驱动方式来进行交互，比如Android的四剑客<code>Activity</code>, <code>Service</code>, <code>Broadcast</code>, <code>ContentProvider</code>的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。消息机制涉及MessageQueue/Message/Looper/Handler这4个类。</p>
<h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><p>消息机制主要包含：</p>
<ul>
<li><strong>Message</strong>：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li>
<li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li>
<li><strong>Looper</strong>：不断循环执行(<code>Looper.loop</code>)，按分发机制将消息分发给目标处理者。</li>
</ul>
<h3 id="1-2-架构图"><a href="#1-2-架构图" class="headerlink" title="1.2 架构图"></a>1.2 架构图</h3><p><img src="http://gityuan.com/images/handler/Main.jpg" alt="handler_java"></p>
<ul>
<li><strong>Looper</strong>有一个MessageQueue消息队列；</li>
<li><strong>MessageQueue</strong>有一组待处理的Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的Handler；</li>
<li><strong>Handler</strong>中有Looper和MessageQueue。</li>
</ul>
<h3 id="1-3-典型实例"><a href="#1-3-典型实例" class="headerlink" title="1.3 典型实例"></a>1.3 典型实例</h3><p>先展示一个典型的关于Handler/Looper的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();   &#x2F;&#x2F;【见 2.1】</span><br><span class="line"></span><br><span class="line">        mHandler &#x3D; new Handler() &#123;  &#x2F;&#x2F;【见 3.1】</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                &#x2F;&#x2F;TODO 定义消息处理逻辑. 【见 3.2】</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();  &#x2F;&#x2F;【见 2.2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，围绕着这个实例展开详细分析。</p>
<h2 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h2><h3 id="2-1-prepare"><a href="#2-1-prepare" class="headerlink" title="2.1 prepare()"></a>2.1 prepare()</h3><p>对于无参的情况，默认调用<code>prepare(true)</code>，表示的是这个Looper允许退出，而对于false的情况则表示当前Looper不允许退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>sThreadLocal</code>是ThreadLocal类型，下面，先说说ThreadLocal。</p>
<p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p>
<ul>
<li><code>ThreadLocal.set(T value)</code>：将value存储到当前线程的TLS区域，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存数据value到当前线程this</span></span><br><span class="line">    values.put(<span class="keyword">this</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal.get()</code>：获取当前线程TLS区域的数据，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] table = values.table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; values.mask;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) table[index + <span class="number">1</span>]; <span class="comment">//返回当前线程储存区中的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>); <span class="comment">//从目标线程存储区没有查询是则返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的<code>sThreadLocal</code>变量，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;()</span><br></pre></td></tr></table></figure>

<p>可见<code>sThreadLocal</code>的get()和set()操作的类型都是<code>Looper</code>类型。</p>
<p><strong>Looper.prepare()</strong></p>
<p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p>
<p>对于Looper类型的构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue &#x3D; new MessageQueue(quitAllowed);  &#x2F;&#x2F;创建MessageQueue对象. 【见4.1】</span><br><span class="line">    mThread &#x3D; Thread.currentThread();  &#x2F;&#x2F;记录当前线程.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，与prepare()相近功能的，还有一个<code>prepareMainLooper()</code>方法，该方法主要在ActivityThread类中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false); &#x2F;&#x2F;设置不允许退出的Looper</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        &#x2F;&#x2F;将当前的Looper保存为主Looper，每个线程只允许执行一次。</span><br><span class="line">        if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper &#x3D; myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-loop"><a href="#2-2-loop" class="headerlink" title="2.2 loop()"></a>2.2 loop()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me &#x3D; myLooper();  &#x2F;&#x2F;获取TLS存储的Looper对象 【见2.4】</span><br><span class="line">    final MessageQueue queue &#x3D; me.mQueue;  &#x2F;&#x2F;获取Looper对象中的消息队列</span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    &#x2F;&#x2F;确保在权限检查时基于本地进程，而不是调用进程。</span><br><span class="line">    final long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F;进入loop的主循环方法</span><br><span class="line">        Message msg &#x3D; queue.next(); &#x2F;&#x2F;可能会阻塞 【见4.2】</span><br><span class="line">        if (msg &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;没有消息，则退出循环</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span><br><span class="line">        Printer logging &#x3D; me.mLogging;  </span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg); &#x2F;&#x2F;用于分发Message 【见3.2】</span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;恢复调用者信息</span><br><span class="line">        final long newIdent &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        msg.recycleUnchecked();  &#x2F;&#x2F;将Message放入消息池 【见5.2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p>
<ul>
<li>读取MessageQueue的下一条Message；</li>
<li>把Message分发给相应的target；</li>
<li>再把分发后的Message回收到消息池，以便重复利用。</li>
</ul>
<p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下<code>logging == null</code>，通过设置setMessageLogging()用来开启debug工作。</p>
<h3 id="2-3-quit"><a href="#2-3-quit" class="headerlink" title="2.3 quit()"></a>2.3 quit()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void quit() &#123;</span><br><span class="line">    mQueue.quit(false); &#x2F;&#x2F;消息移除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true); &#x2F;&#x2F;安全地消息移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法</p>
<p><strong>MessageQueue.quit()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常</span><br><span class="line">        if (!mQuitAllowed) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123; &#x2F;&#x2F;防止多次执行退出操作</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting &#x3D; true;</span><br><span class="line">            if (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked(); &#x2F;&#x2F;移除尚未触发的所有消息</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                removeAllMessagesLocked(); &#x2F;&#x2F;移除所有的消息</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;mQuitting&#x3D;false，那么认定为 mPtr !&#x3D; 0</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消息退出的方式：</p>
<ul>
<li>当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；</li>
<li>当safe =flase时，移除所有的消息</li>
</ul>
<h3 id="2-4-常用方法"><a href="#2-4-常用方法" class="headerlink" title="2.4 常用方法"></a>2.4 常用方法</h3><h4 id="2-4-1-myLooper"><a href="#2-4-1-myLooper" class="headerlink" title="2.4.1 myLooper"></a>2.4.1 myLooper</h4><p>用于获取TLS存储的Looper对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-post"><a href="#2-4-2-post" class="headerlink" title="2.4.2 post"></a>2.4.2 post</h4><p>发送消息，并设置消息的callback，用于处理消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h2><h3 id="3-1-创建Handler"><a href="#3-1-创建Handler" class="headerlink" title="3.1 创建Handler"></a>3.1 创建Handler</h3><h4 id="3-1-1-无参构造"><a href="#3-1-1-无参构造" class="headerlink" title="3.1.1 无参构造"></a>3.1.1 无参构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">    &#x2F;&#x2F;匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span><br><span class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        final Class&lt;? extends Handler&gt; klass &#x3D; getClass();</span><br><span class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span><br><span class="line">    mLooper &#x3D; Looper.myLooper();  &#x2F;&#x2F;从当前线程的TLS中获取Looper对象【见2.1】</span><br><span class="line">    if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue &#x3D; mLooper.mQueue; &#x2F;&#x2F;消息队列，来自Looper对象</span><br><span class="line">    mCallback &#x3D; callback;  &#x2F;&#x2F;回调方法</span><br><span class="line">    mAsynchronous &#x3D; async; &#x2F;&#x2F;设置消息是否为异步处理方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p>
<h4 id="3-1-2-有参构造"><a href="#3-1-2-有参构造" class="headerlink" title="3.1.2 有参构造"></a>3.1.2 有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p>
<h3 id="3-2-消息分发机制"><a href="#3-2-消息分发机制" class="headerlink" title="3.2 消息分发机制"></a>3.2 消息分发机制</h3><p>在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;当Message存在回调方法，回调msg.callback.run()方法；</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;当Handler存在Callback成员变量时，回调方法handleMessage()；</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;Handler自身的回调方法handleMessage()</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分发消息流程：</strong></p>
<ol>
<li>当<code>Message</code>的回调方法不为空时，则回调方法<code>msg.callback.run()</code>，其中callBack数据类型为Runnable,否则进入步骤2；</li>
<li>当<code>Handler</code>的<code>mCallback</code>成员变量不为空时，则回调方法<code>mCallback.handleMessage(msg)</code>,否则进入步骤3；</li>
<li>调用<code>Handler</code>自身的回调方法<code>handleMessage()</code>，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。</li>
</ol>
<p>对于很多情况下，消息分发后的处理方法是第3种情况，即Handler.handleMessage()，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p>
<h3 id="3-3-消息发送"><a href="#3-3-消息发送" class="headerlink" title="3.3 消息发送"></a>3.3 消息发送</h3><p>发送消息调用链：</p>
<p><img src="http://gityuan.com/images/handler/java_sendmessage.png" alt="java_sendmessage"></p>
<p>从上图，可以发现所有的发消息方式，最终都是调用<code>MessageQueue.enqueueMessage()</code>;</p>
<h4 id="3-3-1-sendEmptyMessage"><a href="#3-3-1-sendEmptyMessage" class="headerlink" title="3.3.1 sendEmptyMessage"></a>3.3.1 sendEmptyMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendEmptyMessage(int what) &#123;</span><br><span class="line">    return sendEmptyMessageDelayed(what, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-sendEmptyMessageDelayed"><a href="#3-3-2-sendEmptyMessageDelayed" class="headerlink" title="3.3.2 sendEmptyMessageDelayed"></a>3.3.2 sendEmptyMessageDelayed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class="line">    Message msg &#x3D; Message.obtain();</span><br><span class="line">    msg.what &#x3D; what;</span><br><span class="line">    return sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-sendMessageDelayed"><a href="#3-3-3-sendMessageDelayed" class="headerlink" title="3.3.3 sendMessageDelayed"></a>3.3.3 sendMessageDelayed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-sendMessageAtTime"><a href="#3-3-4-sendMessageAtTime" class="headerlink" title="3.3.4 sendMessageAtTime"></a>3.3.4 sendMessageAtTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-sendMessageAtFrontOfQueue"><a href="#3-3-5-sendMessageAtFrontOfQueue" class="headerlink" title="3.3.5 sendMessageAtFrontOfQueue"></a>3.3.5 sendMessageAtFrontOfQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageAtFrontOfQueue(Message msg) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法通过设置消息的触发时间为0，从而使Message加入到消息队列的队头。</p>
<h4 id="3-3-6-post"><a href="#3-3-6-post" class="headerlink" title="3.3.6 post"></a>3.3.6 post</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-7-postAtFrontOfQueue"><a href="#3-3-7-postAtFrontOfQueue" class="headerlink" title="3.3.7 postAtFrontOfQueue"></a>3.3.7 postAtFrontOfQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean postAtFrontOfQueue(Runnable r) &#123;</span><br><span class="line">    return sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-8-enqueueMessage"><a href="#3-3-8-enqueueMessage" class="headerlink" title="3.3.8 enqueueMessage"></a>3.3.8 enqueueMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis); 【见4.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p><code>Handler.sendEmptyMessage()</code>等系列方法最终调用<code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code>，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p>
<h3 id="3-4-Handler其他方法"><a href="#3-4-Handler其他方法" class="headerlink" title="3.4 Handler其他方法"></a>3.4 Handler其他方法</h3><h4 id="3-4-1-obtainMessage"><a href="#3-4-1-obtainMessage" class="headerlink" title="3.4.1 obtainMessage"></a>3.4.1 obtainMessage</h4><p>获取消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final Message obtainMessage() &#123;</span><br><span class="line">    return Message.obtain(this); 【见5.2】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler.obtainMessage()</code>方法，最终调用<code>Message.obtainMessage(this)</code>，其中this为当前的Handler对象。</p>
<h4 id="3-4-2-removeMessages"><a href="#3-4-2-removeMessages" class="headerlink" title="3.4.2 removeMessages"></a>3.4.2 removeMessages</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void removeMessages(int what) &#123;</span><br><span class="line">    mQueue.removeMessages(this, what, null); 【见 4.5】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler</code>是消息机制中非常重要的辅助类，更多的实现都是<code>MessageQueue</code>, <code>Message</code>中的方法，Handler的目的是为了更加方便的使用消息机制。</p>
<h2 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h2><p>MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private native static long nativeInit();</span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br><span class="line">private native void nativePollOnce(long ptr, int timeoutMillis);</span><br><span class="line">private native static void nativeWake(long ptr);</span><br><span class="line">private native static boolean nativeIsPolling(long ptr);</span><br><span class="line">private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);</span><br></pre></td></tr></table></figure>

<p>关于这些native方法的介绍，见<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<h3 id="4-1-创建MessageQueue"><a href="#4-1-创建MessageQueue" class="headerlink" title="4.1 创建MessageQueue"></a>4.1 创建MessageQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed &#x3D; quitAllowed;</span><br><span class="line">    &#x2F;&#x2F;通过native方法初始化消息队列，其中mPtr是供native代码使用</span><br><span class="line">    mPtr &#x3D; nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-next"><a href="#4-2-next" class="headerlink" title="4.2 next()"></a>4.2 next()</h3><p>提取下一条message</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    final long ptr &#x3D; mPtr;</span><br><span class="line">    if (ptr &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;当消息循环已经退出，则直接返回</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; 循环迭代的首次为-1</span><br><span class="line">    int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis !&#x3D; 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg &#x3D; null;</span><br><span class="line">            Message msg &#x3D; mMessages;</span><br><span class="line">            &#x2F;&#x2F;当消息的Handler为空时，则查询异步消息</span><br><span class="line">            if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;当查询到异步消息，则立刻退出循环</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg &#x3D; msg;</span><br><span class="line">                    msg &#x3D; msg.next;</span><br><span class="line">                &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg !&#x3D; null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    &#x2F;&#x2F;当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取一条消息，并返回</span><br><span class="line">                    mBlocked &#x3D; false;</span><br><span class="line">                    if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                        prevMsg.next &#x3D; msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages &#x3D; msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;设置消息的使用状态，即flags |&#x3D; FLAG_IN_USE</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;   &#x2F;&#x2F;成功地获取MessageQueue中的下一条即将要执行的消息</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有消息</span><br><span class="line">                nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;消息正在退出，返回null</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当消息队列为空，或者是消息队列的第一个消息时</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages &#x3D;&#x3D; null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount &#x3D; mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;没有idle handlers 需要运行，则循环并等待。</span><br><span class="line">                mBlocked &#x3D; true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPendingIdleHandlers &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mPendingIdleHandlers &#x3D; new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers &#x3D; mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler &#x3D; mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] &#x3D; null; &#x2F;&#x2F;去掉handler的引用</span><br><span class="line">            boolean keep &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep &#x3D; idler.queueIdle();  &#x2F;&#x2F;idle时执行的方法</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;重置idle handler个数为0，以保证不会再次重复运行</span><br><span class="line">        pendingIdleHandlerCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span><br><span class="line">        nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nativePollOnce</code>是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p>
<p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当nativePollOnce()返回后，next()从<code>mMessages</code>中提取一个消息。</p>
<p><code>nativePollOnce()</code>在native做了大量的工作，想进一步了解可查看 <a href="http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<h3 id="4-3-enqueueMessage"><a href="#4-3-enqueueMessage" class="headerlink" title="4.3 enqueueMessage"></a>4.3 enqueueMessage</h3><p>添加一条消息到消息队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MessageQueue</code>是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<h3 id="4-4-removeMessages"><a href="#4-4-removeMessages" class="headerlink" title="4.4 removeMessages"></a>4.4 removeMessages</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">//从消息队列的头部开始，移除所有符合条件的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除剩余的符合要求的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked();</span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个移除消息的方法，采用了两个while循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h3 id="4-5-postSyncBarrier"><a href="#4-5-postSyncBarrier" class="headerlink" title="4.5 postSyncBarrier"></a>4.5 postSyncBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面小节[4.3]已说明每一个普通Message必须有一个target，对于特殊的message是没有target，即同步barrier token。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒Looper.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         Message prev = <span class="keyword">null</span>;</span><br><span class="line">         Message p = mMessages;</span><br><span class="line">         <span class="comment">//从消息队列找到 target为空,并且token相等的Message</span></span><br><span class="line">         <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">             prev = p;</span><br><span class="line">             p = p.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">             prev.next = p.next;</span><br><span class="line">             needWake = <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             mMessages = p.next;</span><br><span class="line">             needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">             nativeWake(mPtr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>postSyncBarrier只对同步消息产生影响，对于异步消息没有任何差别。</p>
<h2 id="五、-Message"><a href="#五、-Message" class="headerlink" title="五、 Message"></a>五、 Message</h2><h3 id="5-1-消息对象"><a href="#5-1-消息对象" class="headerlink" title="5.1 消息对象"></a>5.1 消息对象</h3><p>每个消息用<code>Message</code>表示，<code>Message</code>主要包含以下内容：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">成员变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">what</td>
<td align="left">消息类别</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">when</td>
<td align="left">消息触发时间</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg1</td>
<td align="left">参数1</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg2</td>
<td align="left">参数2</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">obj</td>
<td align="left">消息内容</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="left">target</td>
<td align="left">消息响应方</td>
</tr>
<tr>
<td align="left">Runnable</td>
<td align="left">callback</td>
<td align="left">回调方法</td>
</tr>
</tbody></table>
<p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p>
<h3 id="5-2-消息池"><a href="#5-2-消息池" class="headerlink" title="5.2 消息池"></a>5.2 消息池</h3><p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p>
<p>静态变量<code>sPool</code>的数据类型为Message，通过next成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。</p>
<p>消息池常用的操作方法是obtain()和recycle()。</p>
<h4 id="5-2-1-obtain"><a href="#5-2-1-obtain" class="headerlink" title="5.2.1 obtain"></a>5.2.1 obtain</h4><p>从消息池中获取消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool !&#x3D; null) &#123;</span><br><span class="line">            Message m &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; m.next;</span><br><span class="line">            m.next &#x3D; null; &#x2F;&#x2F;从sPool中取出一个Message对象，并消息链表断开</span><br><span class="line">            m.flags &#x3D; 0; &#x2F;&#x2F; 清除in-use flag</span><br><span class="line">            sPoolSize--; &#x2F;&#x2F;消息池的可用大小进行减1操作</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message(); &#x2F;&#x2F; 当消息池为空时，直接创建Message对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p>
<h4 id="5-2-2-recycle"><a href="#5-2-2-recycle" class="headerlink" title="5.2.2 recycle"></a>5.2.2 recycle</h4><p>把不再使用的消息加入消息池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123; &#x2F;&#x2F;判断消息是否正在使用</span><br><span class="line">        if (gCheckRecycle) &#123; &#x2F;&#x2F;Android 5.0以后的版本默认为true,之前的版本默认为false.</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于不再使用的消息，加入到消息池</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    &#x2F;&#x2F;将消息标示位置为IN_USE，并清空消息所有的参数。</span><br><span class="line">    flags &#x3D; FLAG_IN_USE;</span><br><span class="line">    what &#x3D; 0;</span><br><span class="line">    arg1 &#x3D; 0;</span><br><span class="line">    arg2 &#x3D; 0;</span><br><span class="line">    obj &#x3D; null;</span><br><span class="line">    replyTo &#x3D; null;</span><br><span class="line">    sendingUid &#x3D; -1;</span><br><span class="line">    when &#x3D; 0;</span><br><span class="line">    target &#x3D; null;</span><br><span class="line">    callback &#x3D; null;</span><br><span class="line">    data &#x3D; null;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123; &#x2F;&#x2F;当消息池没有满时，将Message对象加入消息池</span><br><span class="line">            next &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; this;</span><br><span class="line">            sPoolSize++; &#x2F;&#x2F;消息池的可用大小进行加1操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最后用一张图，来表示整个消息机制</p>
<p><img src="http://gityuan.com/images/handler/handler_java.jpg" alt="handler_java"></p>
<p><strong>图解：</strong></p>
<ul>
<li>Handler通过sendMessage()发送Message到MessageQueue队列；</li>
<li>Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；</li>
<li>经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。</li>
<li>将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。</li>
</ul>
<p><strong>消息分发的优先级：</strong></p>
<ol>
<li>Message的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，优先级仅次于1；</li>
<li>Handler的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<p><strong>消息缓存：</strong></p>
<p>为了提供效率，提供了一个大小为50的Message缓存队列，减少对象不断创建与销毁的过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" itemprop="url">Android系统架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T12:52:49+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://gityuan.com/android/" target="_blank" rel="noopener">文章出处</a></p>
<h1 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h1><p>Android大致可以分为四层架构：<strong>Linux内核层、系统运行库层、应用框架层和应用层</strong>。</p>
<p>本文作为Android系统架构的开篇，起到提纲挈领的作用，从系统整体架构角度概要讲解Android系统的核心技术点，带领大家初探Android系统全貌以及内部运作机制。虽然Android系统非常庞大且错综复杂，需要具备全面的技术栈，但整体架构设计清晰。Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-a8c2d9d3a1a3a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>Linux内核层</p>
<p>Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。</p>
</li>
<li><p>系统运行库层</p>
<p>这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGl|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。</p>
<p>同样这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用。另外，Android运行库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机示例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。</p>
</li>
<li><p>应用框架层</p>
<p>这一层主要提供了构建应用程序时可能用到的各种API,Andorid自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。</p>
</li>
<li><p>应用层</p>
<p>所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play上下载的小游戏，当然还包括你自己开发的程序。</p>
</li>
</ul>
<h1 id="系统启动架构"><a href="#系统启动架构" class="headerlink" title="系统启动架构"></a>系统启动架构</h1><p>Google提供的5层架构图很经典，但为了更进一步透视Android系统架构，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌，阐述Android内部的环环相扣的内在联系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-68a5968ed562a20e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>图解：</strong> Android系统启动过程由上图从下往上的一个过程是由Boot Loader引导开机，然后依次进入 -&gt; <code>Kernel</code> -&gt; <code>Native</code> -&gt; <code>Framework</code> -&gt; <code>App</code>，接来下简要说说每个过程：</p>
<h2 id="Loader层"><a href="#Loader层" class="headerlink" title="Loader层"></a>Loader层</h2><ul>
<li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在<code>ROM</code>里的预设代码开始执行，然后加载引导程序到<code>RAM</code>；</li>
<li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。</li>
</ul>
<h2 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h2><p>Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。 </p>
<ul>
<li>启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；</li>
<li>启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。<code>kthreadd进程是所有内核进程的鼻祖</code>。</li>
</ul>
<h2 id="硬件抽象层-HAL"><a href="#硬件抽象层-HAL" class="headerlink" title="硬件抽象层 (HAL)"></a>硬件抽象层 (HAL)</h2><p>硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p>
<h2 id="Android-Runtime-amp-系统库"><a href="#Android-Runtime-amp-系统库" class="headerlink" title="Android Runtime &amp; 系统库"></a>Android Runtime &amp; 系统库</h2><p>每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。</p>
<p>这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，<strong>init进程是所有用户进程的鼻祖</strong>。</p>
<ul>
<li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li>
<li>init进程还启动<code>servicemanager</code>(binder服务管家)、<code>bootanim</code>(开机动画)等重要服务</li>
<li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code>Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li>
</ul>
<h2 id="Framework层"><a href="#Framework层" class="headerlink" title="Framework层"></a>Framework层</h2><ul>
<li><p>Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含： </p>
<ul>
<li>加载ZygoteInit类，注册Zygote Socket服务端套接字</li>
<li>加载虚拟机</li>
<li>提前加载类preloadClasses</li>
<li>提前加载资源preloadResouces</li>
</ul>
</li>
<li><p>System Server进程，是由Zygote进程fork而来，<strong>System Server是Zygote孵化的第一个进程</strong>，System Server负责启动和管理整个Java framework，包含<strong>ActivityManager，WindowManager，PackageManager，PowerManager等服务</strong>。</p>
</li>
<li><p>Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含<strong>AudioFlinger，Camera Service等服务。</strong></p>
</li>
</ul>
<h2 id="Syscall-amp-amp-JNI"><a href="#Syscall-amp-amp-JNI" class="headerlink" title="Syscall &amp;&amp; JNI"></a>Syscall &amp;&amp; JNI</h2><ul>
<li>Native与Kernel之间有一层系统调用(SysCall)层，见<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">Linux系统调用(Syscall)原理</a>;</li>
<li>Java层与Native(C/C++)层之间的纽带JNI，见<a href="http://gityuan.com/2016/05/28/android-jni/" target="_blank" rel="noopener">Android JNI原理分析</a>。</li>
</ul>
<h2 id="App层"><a href="#App层" class="headerlink" title="App层"></a>App层</h2><ul>
<li>Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</li>
<li>Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。</li>
<li>所有的App进程都是由Zygote进程fork生成的。</li>
</ul>
<h1 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h1><p>无论是Android系统，还是各种Linux衍生系统，各个组件、模块往往运行在各种不同的进程和线程内，这里就必然涉及进程/线程之间的通信。对于IPC(Inter-Process Communication, 进程间通信)，Linux现有管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制，Android额外还有Binder IPC机制，Android OS中的Zygote进程的IPC采用的是Socket机制，在上层system server、media server以及上层App之间更多的是采用Binder IPC方式来完成跨进程间的通信。对于Android上层架构中，很多时候是在同一个进程的线程之间需要相互通信，例如同一个进程的主线程与工作线程之间的通信，往往采用的Handler消息机制。</p>
<p>想深入理解Android内核层架构，必须先深入理解Linux现有的IPC机制；对于Android上层架构，则最常用的通信方式是Binder、Socket、Handler，当然也有少量其他的IPC方式，比如杀进程Process.killProcess()采用的是signal方式。下面说说Binder、Socket、Handler：</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder作为Android系统提供的一种IPC机制，无论从系统开发还是应用开发，都是Android系统中最重要的组成，也是最难理解的一块知识点，想了解<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a> 可查看我在知乎上的回答。深入了解Binder机制，最好的方法便是阅读源码，借用Linux鼻祖Linus Torvalds曾说过的一句话：Read The Fucking Source Code。下面简要说说Binder IPC原理。</p>
<h3 id="Binder-IPC原理"><a href="#Binder-IPC原理" class="headerlink" title="Binder IPC原理"></a>Binder IPC原理</h3><p>Binder通信采用c/s架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。</p>
<p><img src="http://gityuan.com/images/android-arch/IPC-Binder.jpg" alt="ServiceManager"></p>
<ul>
<li>想进一步了解Binder，可查看<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a>，Binder系列花费了13篇文章的篇幅，从源码角度出发来讲述Driver、Native、Framework、App四个层面的整个完整流程。根据有些读者反馈这个系列还是不好理解，这个binder涉及的层次跨度比较大，知识量比较广，建议大家先知道binder是用于进程间通信，有个大致概念就可以先去学习系统基本知识，等后面有一定功力再进一步深入研究Binder机制。</li>
</ul>
<p><strong>Binder原理篇</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left"><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></td>
<td align="left">Binder概述</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">Binder系列3—启动Service Manager</a></td>
<td align="left">ServiceManager守护进程 注册和查询服务</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">Binder系列4—获取Service Manager</a></td>
<td align="left">获取代理对象BpServiceManager</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">Binder系列5—注册服务(addService)</a></td>
<td align="left">注册Media服务</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2015/11/15/binder-get-service/" target="_blank" rel="noopener">Binder系列6—获取服务(getService)</a></td>
<td align="left">获取Media代理，以及DeathRecipient</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Binder系列7—framework层分析</a></td>
<td align="left">framework层服务注册和查询，Binder注册</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">理解Binder线程池的管理</a></td>
<td align="left">Binder的startThreadPool过程</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a></td>
<td align="left">startService为主线</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2015/11/28/binder-summary/" target="_blank" rel="noopener">Binder系列10—总结</a></td>
<td align="left">Binder的简单总结</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/03/05/binder-clearCallingIdentity/" target="_blank" rel="noopener">Binder IPC的权限控制</a></td>
<td align="left">clearCallingIdentity/restoreCallingIdentity</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2016/10/03/binder_linktodeath/" target="_blank" rel="noopener">Binder死亡通知机制之linkToDeath</a></td>
<td align="left">Binder死亡通知机制</td>
</tr>
</tbody></table>
<p><strong>Binder驱动篇:</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder系列1—Binder Driver初探</a></th>
<th>驱动open/mmap/ioctl，以及binder结构体</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><a href="http://gityuan.com/2015/11/02/binder-driver-2/" target="_blank" rel="noopener">Binder系列2—Binder Driver再探</a></td>
<td>Binder通信协议，内存机制</td>
</tr>
</tbody></table>
<p><strong>Binder使用篇:</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">Binder系列8—如何使用Binder</a></th>
<th>Native层、Framwrok层自定义Binder服务</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><a href="http://gityuan.com/2015/11/23/binder-aidl/" target="_blank" rel="noopener">Binder系列9—如何使用AIDL</a></td>
<td>App层自定义Binder服务</td>
</tr>
</tbody></table>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket通信方式也是C/S架构，比Binder简单很多。在Android系统中采用Socket通信方式的主要有：</p>
<ul>
<li>zygote：用于孵化进程，system_server创建进程是通过socket向zygote进程发起请求；</li>
<li>installd：用于安装App的守护进程，上层PackageManagerService很多实现最终都是交给它来完成；</li>
<li>lmkd：lowmemorykiller的守护进程，Java层的LowMemoryKiller最终都是由lmkd来完成；</li>
<li>adbd：这个也不用说，用于服务adb；</li>
<li>logcatd:这个不用说，用于服务logcat；</li>
<li>vold：即volume Daemon，是存储类的守护进程，用于负责如USB、Sdcard等存储设备的事件处理。</li>
</ul>
<p>等等还有很多，这里不一一列举，Socket方式更多的用于Android framework层与native层之间的通信。Socket通信方式相对于binder比较简单，这里省略。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><strong>Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信</strong>，Handler消息机制是由一组MessageQueue、Message、Looper、Handler共同组成的，为了方便且称之为Handler消息机制。</p>
<p>有人可能会疑惑，为何Binder/Socket用于进程间通信，能否用于线程间通信呢？答案是肯定，对于两个具有独立地址空间的进程通信都可以，当然也能用于共享内存空间的两个线程间通信，这就好比杀鸡用牛刀。接着可能还有人会疑惑，那handler消息机制能否用于进程间通信？答案是不能，Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。很多时候，Handler是工作线程向UI主线程发送消息，即App应用中只有主线程能更新UI，其他工作线程往往是完成相应工作后，通过Handler告知主线程需要做出相应地UI更新操作，Handler分发相应的消息给UI主线程去完成，如下图：</p>
<p><img src="http://gityuan.com/images/android-arch/handler_thread_commun.jpg" alt="handler_communication"></p>
<p>由于工作线程与主线程共享地址空间，即Handler实例对象mHandler位于线程间共享的内存堆上，工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。工作线程通过mHandler向其成员变量MessageQueue中添加新Message，主线程一直处于loop()方法内，当收到新的Message时按照一定规则分发给相应的handleMessage()方法来处理。所以说，Handler消息机制用于同进程的线程间通信，其核心是线程间共享内存空间，而不同进程拥有不同的地址空间，也就不能用handler来实现进程间通信。</p>
<p>上图只是Handler消息机制的一种处理流程，是不是只能工作线程向UI主线程发消息呢，其实不然，可以是UI线程向工作线程发送消息，也可以是多个工作线程之间通过handler发送消息。更多关于Handler消息机制文章：</p>
<ul>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制-Handler(framework篇)</a></li>
<li><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制-Handler(native篇)</a></li>
<li><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></li>
</ul>
<p>要理解framework层源码，掌握这3种基本的进程/线程间通信方式是非常有必要，当然Linux还有不少其他的IPC机制，比如共享内存、信号、信号量，在源码中也有体现，如果想全面彻底地掌握Android系统，还是需要对每一种IPC机制都有所了解。</p>
<h1 id="核心提纲"><a href="#核心提纲" class="headerlink" title="核心提纲"></a>核心提纲</h1><p>博主对于Android从系统底层一路到上层都有自己的理解和沉淀，通过前面对系统启动的介绍，相信大家对Android系统有了一个整体观。接下来需抓核心、理思路，争取各个击破。后续将持续更新和完善整个大纲，不限于进程、内存、IO、系统服务架构以及分析实战等文章。</p>
<p>当然本站有一些文章没来得及进一步加工，有时间根据大家的反馈，不断修正和完善所有文章，争取给文章，再进一步精简非核心代码，增加可视化图表以及文字的结论性分析。基于<strong>Android 6.0的源码</strong>，专注于分享Android系统原理、架构分析的原创文章。</p>
<p><strong>建议阅读群体</strong>： 适合于正从事或者有兴趣研究Android系统的工程师或者技术爱好者，也适合Android App高级工程师；对于尚未入门或者刚入门的App工程师阅读可能会有点困难，建议先阅读更基础的资料，再来阅读本站博客。</p>
<p>看到Android整个系统架构是如此庞大的, 该问如何学习Android系统, 以下是我自己的Android的学习和研究论，仅供参考<a href="http://gityuan.com/2016/04/24/how-to-study-android/" target="_blank" rel="noopener">如何自学Android</a>。</p>
<p>从整理上来列举一下Android系统的核心知识点概览：</p>
<p><img src="http://gityuan.com/images/android-arch/android_os.png" alt="Android_os"></p>
<h4 id="系统启动系列"><a href="#系统启动系列" class="headerlink" title="系统启动系列"></a>系统启动系列</h4><p><img src="http://gityuan.com/images/android-arch/android-booting.jpg" alt="android-booting"></p>
<p><a href="http://gityuan.com/2016/02/01/android-booting/" target="_blank" rel="noopener">Android系统启动-概述</a>: Android系统中极其重要进程：init, zygote, system_server, servicemanager 进程:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">进程启动</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">init进程</a></td>
<td align="left">Linux系统中用户空间的第一个进程, Init.main</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">zygote进程</a></td>
<td align="left">所有Ａpp进程的父进程, ZygoteInit.main</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/02/14/android-system-server/" target="_blank" rel="noopener">system_server进程(上篇)</a></td>
<td align="left">系统各大服务的载体, forkSystemServer过程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/02/20/android-system-server-2/" target="_blank" rel="noopener">system_server进程(下篇)</a></td>
<td align="left">系统各大服务的载体, SystemServer.main</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">servicemanager进程</a></td>
<td align="left">binder服务的大管家, 守护进程循环运行在binder_loop</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">app进程</a></td>
<td align="left">通过Process.start启动App进程, ActivityThread.main</td>
</tr>
</tbody></table>
<p>再来看看守护进程(也就是进程名一般以d为后缀，比如logd，此处d是指daemon的简称), 下面介绍部分守护进程：</p>
<ul>
<li><a href="http://gityuan.com/2016/06/15/android-debuggerd/" target="_blank" rel="noopener">debuggerd</a></li>
<li><a href="http://gityuan.com/2016/11/13/android-installd" target="_blank" rel="noopener">installd</a></li>
<li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">lmkd</a></li>
<li><a href="http://gityuan.com/2018/01/27/android-log/" target="_blank" rel="noopener">logd</a></li>
</ul>
<h4 id="系统稳定性系列"><a href="#系统稳定性系列" class="headerlink" title="系统稳定性系列"></a>系统稳定性系列</h4><p><a href="http://gityuan.com/2016/06/19/stability_summary/" target="_blank" rel="noopener">Android系统稳定性</a>主要是异常崩溃(crash)和执行超时(timeout),:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="noopener">理解Android ANR的触发原理</a></td>
<td align="left">触发ANR的场景以及机理</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">Input系统—ANR原理分析</a></td>
<td align="left">input触发ANR的原理</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/12/02/app-not-response/" target="_blank" rel="noopener">理解Android ANR的信息收集过程</a></td>
<td align="left">AMS.appNotResponding过程分析,收集traces</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></td>
<td align="left">kill -3 信息收集过程</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/11/27/native-traces/" target="_blank" rel="noopener">Native进程之Trace原理</a></td>
<td align="left">debuggerd -b 信息收集过程</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/06/21/watchdog/" target="_blank" rel="noopener">WatchDog工作原理</a></td>
<td align="left">WatchDog触发机制</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="noopener">理解Java Crash处理流程</a></td>
<td align="left">AMS.handleApplicationCrash过程分析</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/06/25/android-native-crash/" target="_blank" rel="noopener">理解Native Crash处理流程</a></td>
<td align="left">debuggerd守护进程</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2019/01/19/global_ref/" target="_blank" rel="noopener">global reference限制策略</a></td>
<td align="left">global reference</td>
</tr>
</tbody></table>
<h4 id="Android进程系列"><a href="#Android进程系列" class="headerlink" title="Android进程系列"></a>Android进程系列</h4><p>进程/线程是操作系统的魂，各种服务、组件、子系统都是依附于具体的进程实体。深入理解进程机制对于掌握Android系统整体架构和运转机制是非常有必要的，是系统工程师的基本功，下面列举进程相关的文章：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a></td>
<td align="left">Process.start过程分析</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/04/16/kill-signal/" target="_blank" rel="noopener">理解杀进程的实现原理</a></td>
<td align="left">Process.killProcess过程分析</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/10/09/app-process-create-2/" target="_blank" rel="noopener">Android四大组件与进程启动的关系</a></td>
<td align="left">AMS.startProcessLocked过程分析组件与进程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/10/22/force-stop/" target="_blank" rel="noopener">Android进程绝杀技–forceStop</a></td>
<td align="left">force-stop过程分析彻底移除组件与杀进程</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/09/24/android-thread/" target="_blank" rel="noopener">理解Android线程创建流程</a></td>
<td align="left">3种不同线程的创建过程</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a></td>
<td align="left">以start-service为线,阐述进程间通信机理</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">理解Binder线程池的管理</a></td>
<td align="left">Zygote fork的进程都默认开启binder线程池</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2015/10/01/process-lifecycle/" target="_blank" rel="noopener">Android进程生命周期与ADJ</a></td>
<td align="left">进程adj, processState以及lmk</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></td>
<td align="left">lmk原理分析</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2015/10/01/process-priority/" target="_blank" rel="noopener">进程优先级</a></td>
<td align="left">进程nice,thread priority以及scheduler</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a></td>
<td align="left">updateOomAdjLocked过程</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2015/12/19/android-process-category/" target="_blank" rel="noopener">Android进程整理</a></td>
<td align="left">整理系统的所有进程/线程</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="http://gityuan.com/2018/05/19/android-process-adj/" target="_blank" rel="noopener">解读Android进程优先级ADJ算法</a></td>
<td align="left">Android进程ADJ优先级</td>
</tr>
</tbody></table>
<h4 id="四大组件系列"><a href="#四大组件系列" class="headerlink" title="四大组件系列"></a>四大组件系列</h4><p>对于App来说，Android应用的四大组件Activity，Service，Broadcast Receiver， Content Provider最为核心，接下分别展开介绍：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/03/18/start-activity-cycle/" target="_blank" rel="noopener">简述Activity生命周期</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService启动过程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/05/01/bind-service/" target="_blank" rel="noopener">bindService启动过程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">以Binder视角来看Service启动</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/06/04/broadcast-receiver/" target="_blank" rel="noopener">Android Broadcast广播机制分析</a></td>
<td align="left">Broadcast</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="noopener">理解ContentProvider原理</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/05/03/content_provider_release/" target="_blank" rel="noopener">ContentProvider引用计数</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2015/05/31/android-lifecycle/" target="_blank" rel="noopener">Activity与Service生命周期</a></td>
<td align="left">Activity&amp;&amp;Service</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2017/04/16/activity-with-window/" target="_blank" rel="noopener">简述Activity与Window关系</a></td>
<td align="left">Activity&amp;&amp;Window</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2017/05/19/ams-abstract/" target="_blank" rel="noopener">四大组件之综述</a></td>
<td align="left">AMS</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2017/05/25/service_record/" target="_blank" rel="noopener">四大组件之ServiceRecord</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="http://gityuan.com/2017/06/03/broadcast_record/" target="_blank" rel="noopener">四大组件之BroadcastRecord</a></td>
<td align="left">Broadcast</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="http://gityuan.com/2017/06/04/content_provider_record/" target="_blank" rel="noopener">四大组件之ContentProviderRecord</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="http://gityuan.com/2017/04/09/android_context/" target="_blank" rel="noopener">理解Android Context</a></td>
<td align="left">Context</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="http://gityuan.com/2017/04/02/android-application/" target="_blank" rel="noopener">理解Application创建过程</a></td>
<td align="left">Application</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="http://gityuan.com/2016/05/02/unbind-service/" target="_blank" rel="noopener">unbindService流程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="http://gityuan.com/2017/06/11/activity_record/" target="_blank" rel="noopener">四大组件之ActivityRecord</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="http://gityuan.com/2017/06/25/ams_summary_1/" target="_blank" rel="noopener">AMS总结(一)</a></td>
<td align="left">AMS</td>
</tr>
</tbody></table>
<h4 id="图形系统系列"><a href="#图形系统系列" class="headerlink" title="图形系统系列"></a>图形系统系列</h4><p>图形也是整个系统非常复杂且重要的一个系列，涉及WindowManager,SurfaceFlinger服务。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2017/01/08/windowmanger/" target="_blank" rel="noopener">WindowManager启动篇</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2017/01/15/wms_starting_window/" target="_blank" rel="noopener">WMS之启动窗口篇</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2017/01/22/start-activity-wms/" target="_blank" rel="noopener">以Window视角来看startActivity</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">Android图形系统概述</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2017/02/11/surface_flinger/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">SurfaceFlinger绘图篇</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">Choreographer原理</a></td>
<td align="left">Choreographer</td>
</tr>
</tbody></table>
<h4 id="系统服务篇"><a href="#系统服务篇" class="headerlink" title="系统服务篇"></a>系统服务篇</h4><p>再则就是在整个架构中有大量的服务，都是基于<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder</a>来交互的，<a href="http://gityuan.com/2016/10/01/system_service_common/" target="_blank" rel="noopener">Android系统服务的注册过程</a>也是在此之上的构建的。计划针对部分核心服务来重点分析：</p>
<ul>
<li>AMS服务<ul>
<li><a href="http://gityuan.com/2016/02/21/activity-manager-service/" target="_blank" rel="noopener">AMS启动过程（一）</a></li>
<li>更多组件篇[见小节4.3]</li>
</ul>
</li>
<li>Input系统<ul>
<li><a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">Input系统—启动篇</a></li>
<li><a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">Input系统—InputReader线程</a></li>
<li><a href="http://gityuan.com/2016/12/17/input-dispatcher/" target="_blank" rel="noopener">Input系统—InputDispatcher线程</a></li>
<li><a href="http://gityuan.com/2016/12/24/input-ui/" target="_blank" rel="noopener">Input系统—UI线程</a></li>
<li><a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">Input系统—进程交互</a></li>
<li><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">Input系统—ANR原理分析</a></li>
</ul>
</li>
<li>PKMS服务<ul>
<li><a href="http://gityuan.com/2016/11/06/packagemanager" target="_blank" rel="noopener">PackageManager启动篇</a></li>
<li><a href="http://gityuan.com/2016/11/13/android-installd" target="_blank" rel="noopener">Installd守护进程</a></li>
</ul>
</li>
<li>Alarm服务<ul>
<li><a href="http://gityuan.com/2017/03/12/alarm_manager_service/" target="_blank" rel="noopener">理解AlarmManager机制</a></li>
</ul>
</li>
<li>JobScheduler服务<ul>
<li><a href="http://gityuan.com/2017/03/10/job_scheduler_service/" target="_blank" rel="noopener">理解JobScheduler机制</a></li>
</ul>
</li>
<li>BatteryService<ul>
<li><a href="http://gityuan.com/2016/01/10/power_rank/" target="_blank" rel="noopener">Android耗电统计算法</a></li>
</ul>
</li>
<li>PMS服务</li>
<li>DropBox服务<ul>
<li><a href="http://gityuan.com/2016/06/12/DropBoxManagerService/" target="_blank" rel="noopener">DropBoxManager启动篇</a></li>
</ul>
</li>
<li>UserManagerService<ul>
<li><a href="http://gityuan.com/2016/11/20/user_manager/" target="_blank" rel="noopener">多用户管理UserManager</a></li>
</ul>
</li>
<li>更多系统服务</li>
</ul>
<h4 id="内存-amp-amp-存储篇"><a href="#内存-amp-amp-存储篇" class="headerlink" title="内存&amp;&amp;存储篇"></a>内存&amp;&amp;存储篇</h4><ul>
<li>内存篇<ul>
<li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></li>
<li><a href="http://gityuan.com/2015/10/30/kernel-memory/" target="_blank" rel="noopener">Linux内存管理</a></li>
<li><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">Android内存分析命令</a></li>
</ul>
</li>
<li>存储篇<ul>
<li><a href="http://gityuan.com/2016/07/17/android-io/" target="_blank" rel="noopener">Android存储系统之源码篇</a></li>
<li><a href="http://gityuan.com/2016/07/23/android-io-arch" target="_blank" rel="noopener">Android存储系统之架构篇</a></li>
</ul>
</li>
<li>Linux驱动篇</li>
<li>dalvik/art<ul>
<li><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></li>
</ul>
</li>
</ul>
<h4 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h4><p>再来说说Android相关的一些常用命令和工具以及调试手段.</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/19/android-build/" target="_blank" rel="noopener">理解Android编译命令</a></td>
<td align="left">build</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2018/06/02/android-bp/" target="_blank" rel="noopener">理解Android.bp</a></td>
<td align="left">build</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">性能工具Systrace</a></td>
<td align="left">systrace</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">Android内存分析命令</a></td>
<td align="left">Memory</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2015/10/11/ps-command/" target="_blank" rel="noopener">ps进程命令</a></td>
<td align="left">Process</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/02/27/am-command/" target="_blank" rel="noopener">Am命令用法</a></td>
<td align="left">Am</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/02/28/pm-command/" target="_blank" rel="noopener">Pm命令用法</a></td>
<td align="left">Pm</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/06/10/bugreport/" target="_blank" rel="noopener">调试系列1：bugreport源码篇</a></td>
<td align="left">bugreport</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/06/11/bugreport-2/" target="_blank" rel="noopener">调试系列2：bugreport实战篇</a></td>
<td align="left">bugreport</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/05/14/dumpsys-command/" target="_blank" rel="noopener">dumpsys命令用法</a></td>
<td align="left">dumpsys</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2018/01/27/android-log/" target="_blank" rel="noopener">Android logd日志原理</a></td>
<td align="left">logd</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2017/09/09/gdb/" target="_blank" rel="noopener">介绍gdb调试工具</a></td>
<td align="left">gdb</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2017/09/02/addr2line/" target="_blank" rel="noopener">介绍addr2line调试命令</a></td>
<td align="left">addr2line</td>
</tr>
</tbody></table>
<h4 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h4><p>下面列举处理过的部分较为典型的案例，供大家参考</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2018/05/12/binder-driver-bug/" target="_blank" rel="noopener">Binder Driver缺陷导致定屏的案例</a></td>
<td align="left">binder</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2019/01/13/arraymap/" target="_blank" rel="noopener">深度解读ArrayMap优势与缺陷</a></td>
<td align="left">ArrayMap</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2018/02/10/reboot-locked-method/" target="_blank" rel="noopener">数组越界导致系统重启的案例</a></td>
<td align="left">数组越界</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2018/02/03/log-fc/" target="_blank" rel="noopener">一行Log引发多线程并发问题的案例</a></td>
<td align="left">多线程并发</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2018/02/17/monkey-deadlock/" target="_blank" rel="noopener">跑monkey压力测试过程的冻屏案例</a></td>
<td align="left">monkey冻屏</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2018/02/24/process-keep-forever/" target="_blank" rel="noopener">深度剖析APP保活案例</a></td>
<td align="left">保活</td>
</tr>
</tbody></table>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Android系统之博大精深，包括Linux内核、Native、虚拟机、Framework，通过系统调用连通内核与用户空间，通过JNI打通用户空间的Java层和Native层，通过Binder、Socket、Handler等打通跨进程、跨线程的信息交换。只有真正阅读并理解系统核心架构的设计，解决问题和设计方案才能做到心中无剑胜有剑，才能做到知其然知其所以然。当修炼到此，恭喜你对系统有了更高一个层次的理解，正如太极剑法，忘记了所有招式，也就练成了太极剑法。</p>
<p>再回过头去看看那些API，看到的将不再是一行行代码、一个个接口的调用，而是各种信息的传递与交互工作，而是背后成千上万个小蝌蚪的动态执行流。记得《侠客行》里面的龙木二岛主终其一生也无法参透太玄经，石破天却短短数日练成绝世神功，究其根源是龙木二岛主以静态视角去解读太玄经，而石破天把墙壁的图案想象成无数游动的蝌蚪，最终成就绝世神功。一言以蔽之，程序代码是死的，系统运转是活的，要以动态视角去理解系统架构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/" itemprop="url">使用AIDL实现一个多进程消息推送(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-22T00:19:00+08:00">
                2020-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>像图片选择这样的多进程需求，可能并不需要我们额外编写进程通讯的代码，使用四大组件传输Bundle就行了，但是像推送服务这种需求，进程与进程之间需要高度的交互，此时就绕不过进程通讯这一步了。</p>
<p>下面我们就用即时聊天软件为例，手动去实现一个多进程的推送例子，具体需求如下：</p>
<ol>
<li>UI和消息推送的Service分两个进程；</li>
<li>UI进程用于展示具体的消息数据，把用户发送的消息，传递到消息Service，然后发送到远程服务器；</li>
<li>Service负责收发消息，并和远程服务器保持长连接，UI进程可通过Service发送消息到远程服务器，Service收到远程服务器消息通知UI进程；</li>
<li>即使UI进程退出了，Service仍需要保持运行，收取服务器消息。</li>
</ol>
<p><strong>实现思路</strong></p>
<ol>
<li><p>创建UI进程（下文统称为客户端）；</p>
</li>
<li><p>创建消息Service（下文统称为服务端）；</p>
</li>
<li><p>把服务端配置到独立的进程(AndroidManifest.xml中指定process标签)；</p>
</li>
<li><p>客户端和服务端进行绑定（bindService）；</p>
</li>
<li><p>让客户端和服务端具备交互的能力。(AIDL使用)</p>
</li>
</ol>
<h1 id="例子具体实现"><a href="#例子具体实现" class="headerlink" title="例子具体实现"></a>例子具体实现</h1><h2 id="AIDL调用流程概览"><a href="#AIDL调用流程概览" class="headerlink" title="AIDL调用流程概览"></a>AIDL调用流程概览</h2><p>开始之前，我们先来概括一下使用AIDL进行多进程调用的整个流程：</p>
<ol>
<li>客户端使用bindService方法绑定服务端；</li>
<li>服务端在onBind方法返回Binder对象；</li>
<li>客户端拿到服务端返回的Binder对象进行跨进程方法调用；</li>
</ol>
<p><img src="http://jsh180.net/blog_aidl_img_flow_1.jpg" alt="AIDL调用过程"></p>
<p><strong>整个AIDL调用过程概括起来就以上3个步骤，下文中我们使用上面描述的例子，来逐步分解这些步骤，并讲述其中的细节。</strong></p>
<h2 id="客户端使用bindService方法绑定服务端"><a href="#客户端使用bindService方法绑定服务端" class="headerlink" title="客户端使用bindService方法绑定服务端"></a>客户端使用bindService方法绑定服务端</h2><h3 id="创建客户端和服务端，把服务端配置到另外的进程"><a href="#创建客户端和服务端，把服务端配置到另外的进程" class="headerlink" title="创建客户端和服务端，把服务端配置到另外的进程"></a>创建客户端和服务端，把服务端配置到另外的进程</h3><ol>
<li>创建客户端 -&gt; MainActivity；</li>
<li>创建服务端 -&gt; MessageService;</li>
<li>把服务端配置到另外的进程 -&gt; android:process=”:remote”</li>
</ol>
<p>上面描述的客户端、服务端、以及把服务端配置到另外进程，体现在AndroidManifest.xml中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;application ...&gt;</span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.test.test_aidl.TestAidlMessageActivity&quot; &#x2F;&gt;</span><br><span class="line">        &lt;service</span><br><span class="line">            android:name&#x3D;&quot;.test.test_aidl.MessageService&quot;</span><br><span class="line">            android:enabled&#x3D;&quot;true&quot;</span><br><span class="line">            android:exported&#x3D;&quot;true&quot;</span><br><span class="line">            android:process&#x3D;&quot;:remote&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>

<p>开启多进程的方法很简单，只需要给四大组件指定android:process标签。</p>
<h3 id="绑定MessageService到MainActivity"><a href="#绑定MessageService到MainActivity" class="headerlink" title="绑定MessageService到MainActivity"></a>绑定MessageService到MainActivity</h3><p><strong>创建MessageService</strong></p>
<p>此时的MessageService就是刚创建的模样，onBind中返回了null，下一步中我们将返回一个可操作的对象给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line">    </span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端MainActivity调用bindService方法绑定MessageService</strong></p>
<p>这一步其实是属于Service组件相关的知识，在这里就比较简单地说一下，启动服务可以通过以下两种方式：</p>
<ul>
<li>使用bindService方法 -&gt; bindService(Intent service, ServiceConnection conn, int flags)；</li>
<li>使用startService方法 -&gt; startService(Intent service);</li>
</ul>
<p><strong>bindService &amp; startService区别：</strong></p>
<p>使用bindService方式，多个Client可以同时bind一个Service，但是当所有Client unbind后，Service会退出，通常情况下，如果希望和Service交互，一般使用bindService方法，使用onServiceConnected中的IBinder对象可以和Service进行交互，不需要和Service交互的情况下，使用startService方法即可。</p>
<p>正如上面所说，我们是要和Service交互的，所以我们需要使用bindService方法，<strong>但是我们希望unbind后Service仍保持运行，这样的情况下，可以同时调用bindService和startService</strong>（比如像本例子中的消息服务，退出UI进程，Service仍需要接收到消息），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端在onBind方法返回Binder对象"><a href="#服务端在onBind方法返回Binder对象" class="headerlink" title="服务端在onBind方法返回Binder对象"></a>服务端在onBind方法返回Binder对象</h2><h3 id="首先，什么是Binder"><a href="#首先，什么是Binder" class="headerlink" title="首先，什么是Binder?"></a>首先，什么是Binder?</h3><p>要说Binder，首先要说一下IBinder这个接口，IBinder是远程对象的基础接口，轻量级的远程过程调用机制的核心部分，该接口描述了与远程对象交互的抽象协议，而Binder实现了IBinder接口，简单说，Binder就是Android SDK中内置的一个多进程通讯实现类，在使用的时候，我们不用也不要去实现IBinder，而是继承Binder这个类即可实现多进程通讯。</p>
<h3 id="其次，这个需要在onBind方法返回的Binder对象从何而来？"><a href="#其次，这个需要在onBind方法返回的Binder对象从何而来？" class="headerlink" title="其次，这个需要在onBind方法返回的Binder对象从何而来？"></a>其次，这个需要在onBind方法返回的Binder对象从何而来？</h3><p><strong>在这里就要引出本文中的主题了——AIDL</strong></p>
<p>多进程中使用的Binder对象，一般通过我们定义好的 .adil 接口文件自动生成，当然你可以走野路子，直接手动编写这个跨进程通讯所需的Binder类，其本质无非就是一个继承了Binder的类，鉴于野路子走起来麻烦，而且都是重复步骤的工作，Google提供了 AIDL 接口来帮我们自动生成Binder这条正路，下文中我们围绕 AIDL 这条正路继续展开讨论</p>
<h3 id="定义AIDL接口"><a href="#定义AIDL接口" class="headerlink" title="定义AIDL接口"></a>定义AIDL接口</h3><p>很明显，接下来我们需要搞一波上面说的Binder，让客户端可以调用到服务端的方法，而这个Binder又是通过AIDL接口自动生成，那我们就先从AIDL搞起，搞之前先看看注意事项，以免出事故：</p>
<p>AIDL支持的数据类型：</p>
<ul>
<li>Java 编程语言中的所有基本数据类型（如 int、long、char、boolean 等等）</li>
<li>String和CharSequence</li>
<li>Parcelable：实现了Parcelable接口的对象</li>
<li>List：其中的元素需要被AIDL支持，另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口</li>
<li>Map：其中的元素需要被AIDL支持，包括 key 和 value，另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接口</li>
</ul>
<p>其他注意事项：</p>
<ul>
<li>在AIDL中传递的对象，必须实现Parcelable序列化接口；</li>
<li>在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类；</li>
<li>跟普通接口的区别：只能声明方法，不能声明变量；</li>
<li>所有非基础数据类型参数都需要标出数据走向的方向标记。可以是 in、out 或 inout，基础数据类型默认只能是 in，不能是其他方向。</li>
</ul>
<h3 id="创建一个AIDL接口"><a href="#创建一个AIDL接口" class="headerlink" title="创建一个AIDL接口"></a>创建一个AIDL接口</h3><p>接口中提供发送消息的方法（Android Studio创建AIDL：项目右键 -&gt; New -&gt; AIDL -&gt; AIDL File），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageSender.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface MessageSender &#123;</span><br><span class="line">    void sendMessage(in MessageModel messageModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被“in”标记的参数，就是接收实际数据的参数，这个跟我们普通参数传递一样的含义。在AIDL中，“out” 指定了一个仅用于输出的参数，换而言之，这个参数不关心调用方传递了什么数据过来，但是这个参数的值可以在方法被调用后填充（无论调用方传递了什么值过来，在方法执行的时候，这个参数的初始值总是空的），这就是“out”的含义，仅用于输出。而“inout”显然就是“in”和“out”的合体了，输入和输出的参数。区分“in”、“out”有什么用？这是非常重要的，因为每个参数的内容必须编组（序列化，传输，接收和反序列化）。in/out标签允许Binder跳过编组步骤以获得更好的性能。</p>
</blockquote>
<p>上述的MessageModel为消息的实体类，该类在AIDL中传递，实现了Parcelable序列化接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.model;</span><br><span class="line"></span><br><span class="line">import android.os.Parcel;</span><br><span class="line">import android.os.Parcelable;</span><br><span class="line"></span><br><span class="line">public class MessageModel implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    private String from;</span><br><span class="line">    private String to;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public MessageModel() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MessageModel(String from, String to, String content) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected MessageModel(Parcel in) &#123;</span><br><span class="line">        from &#x3D; in.readString();</span><br><span class="line">        to &#x3D; in.readString();</span><br><span class="line">        content &#x3D; in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;MessageModel&gt; CREATOR &#x3D; new Creator&lt;MessageModel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public MessageModel createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new MessageModel(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public MessageModel[] newArray(int size) &#123;</span><br><span class="line">            return new MessageModel[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public String getFrom() &#123;</span><br><span class="line">        return from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFrom(String from) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTo() &#123;</span><br><span class="line">        return to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTo(String to) &#123;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MessageModel&#123;&quot; +</span><br><span class="line">                &quot;from&#x3D;&#39;&quot; + from + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, to&#x3D;&#39;&quot; + to + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(from);</span><br><span class="line">        dest.writeString(to);</span><br><span class="line">        dest.writeString(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完MessageModel这个实体类，别忘了还有一件事要做：”在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类“。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageModel.aidl</span><br><span class="line">package com.zhyen.android.model;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">parcelable MessageModel;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>MessageSender.aidl -&gt; 定义了发送消息的方法，会自动生成名为MessageSender.Stub的Binder类，在服务端实现，返回给客户端调用</li>
<li>MessageModel.java -&gt; 消息实体类，由客户端传递到服务端，实现了Parcelable序列化</li>
<li>MessageModel.aidl -&gt; 声明了MessageModel可在AIDL中传递，放在跟MessageModel.java相同的包路径下</li>
</ul>
<h3 id="服务端MessageService"><a href="#服务端MessageService" class="headerlink" title="服务端MessageService"></a>服务端MessageService</h3><p>在服务端创建MessageSender.aidl这个AIDL接口自动生成的Binder对象，并返回给客户端调用，服务端MessageService代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MessageService&quot;;</span><br><span class="line"></span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageSender.Stub是Android Studio根据我们MessageSender.aidl文件自动生成的Binder对象（至于是怎样生成的，下文会有答案），我们需要把这个Binder对象返回给客户端。</p>
<h2 id="客户端拿到Binder对象后调用远程方法"><a href="#客户端拿到Binder对象后调用远程方法" class="headerlink" title="客户端拿到Binder对象后调用远程方法"></a>客户端拿到Binder对象后调用远程方法</h2><p>调用步骤如下：</p>
<ol>
<li>在客户端的onServiceConnected方法中，拿到服务端返回的Binder对象；</li>
<li>使用MessageSender.Stub.asInterface方法，取得MessageSender.aidl对应的操作接口；</li>
<li>取得MessageSender对象后，像普通接口一样调用方法即可。</li>
</ol>
<p>此时客户端代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中我们调用了MessageSender的sendMessage方法，向服务端发送了一条消息，并把生成的MessageModel对象作为参数传递到了服务端，最终服务端打印的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 10:53:25.747 22509-22545&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两点要说：</p>
<ul>
<li>服务端已经接收到客户端发送过来的消息，并正确打印；</li>
<li>服务端和客户端区分两个进程，PID不一样，进程名也不一样；</li>
</ul>
<h1 id="分析Binder上层机制"><a href="#分析Binder上层机制" class="headerlink" title="分析Binder上层机制"></a>分析Binder上层机制</h1><p>我们通过上述的调用流程，看看从客户端到服务端，都经历了些什么事，看看Binder的上层是如何工作的，至于Binder的底层，这是一个非常复杂的话题，本文不深究。（如果看到这里你又想问什么是Binder的话，请手动倒带往上看…）</p>
<p>我们先来回顾一下从客户端发起的调用流程：</p>
<ul>
<li>MessageSender messageSender = MessageSender.Stub.asInterface(service);</li>
<li>messageSender.sendMessage(messageModel);</li>
</ul>
<p>抛开其它无关代码，客户端调跨进程方法就这两个步骤，而这两个步骤都封装在 MessageSender.aidl 最终生成的 MessageSender.java 源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> *&#x2F;</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">public interface MessageSender extends android.os.IInterface &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.zhyen.android.MessageSender &#123;</span><br><span class="line">		    &#x2F;&#x2F;描述符，该值为全类名</span><br><span class="line">        private static final java.lang.String DESCRIPTOR &#x3D; &quot;com.zhyen.android.MessageSender&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         根据AIDL的使用流程，Server会在onBind的时候返回一个Stub实例，</span><br><span class="line">         调用了Stub的构造器内部调用Binder的attachInterface方法将当前实例以及描述符存到Binder实例中</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 把IBinder对象转换为MessageSender 接口</span><br><span class="line">         * 判断IBinder是否处于相同进程，相同进程返回Stub实现的MessageSender接口</span><br><span class="line">         * 不同进程，则返回Stub.Proxy实现的MessageSender接口</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static com.zhyen.android.MessageSender asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin !&#x3D; null) &amp;&amp; (iin instanceof com.zhyen.android.MessageSender))) &#123;</span><br><span class="line">                return ((com.zhyen.android.MessageSender) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.zhyen.android.MessageSender.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 同一进程时，不会触发</span><br><span class="line">         *</span><br><span class="line">         * 不同进程时，asInterface会返回Stub.Proxy，客户端调用 messageSender.sendMessage(messageModel)</span><br><span class="line">         * 实质是调用了 Stub.Proxy 的 sendMessage 方法，从而触发跨进程数据传递，</span><br><span class="line">         * 最终Binder底层将处理好的数据回调到此方法，并调用我们真正的sendMessage方法</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">            java.lang.String descriptor &#x3D; DESCRIPTOR;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_sendMessage: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.zhyen.android.model.MessageModel _arg0;</span><br><span class="line">                    if ((0 !&#x3D; data.readInt())) &#123;</span><br><span class="line">                        _arg0 &#x3D; com.zhyen.android.model.MessageModel.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _arg0 &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.sendMessage(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    return super.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.zhyen.android.MessageSender &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote &#x3D; remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * Proxy中的sendMessage方法，并不是直接调用我们定义的sendMessage方法，而是经过一顿的Parcel读写，</span><br><span class="line">             * 然后调用mRemote.transact方法，把数据交给Binder处理，transact处理完毕后会调用上方的onTransact方法，</span><br><span class="line">             * onTransact拿到最终得到的参数数据，调用由我们真正的sendMessage方法</span><br><span class="line">             *&#x2F;</span><br><span class="line">            @Override</span><br><span class="line">            public void sendMessage(com.zhyen.android.model.MessageModel messageModel) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    if ((messageModel !&#x3D; null)) &#123;</span><br><span class="line">                        _data.writeInt(1);</span><br><span class="line">                        messageModel.writeToParcel(_data, 0);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _data.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;调用Binder的transact方法进行多进程数据传输，处理完毕后调用上方的onTransact方法</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_sendMessage, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_sendMessage &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(com.zhyen.android.model.MessageModel messageModel) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只看代码的话，可能会有点懵逼，相信结合代码再看下方的流程图会更好理解：</p>
<p><img src="http://jsh180.net/image/jpg/blog_aidl_flowchart.jpg" alt="flow chart"></p>
<p>从客户端的sendMessage开始，整个AIDL的调用过程如上图所示，asInterface方法，将会判断onBind方法返回的Binder是否存处于同一进程，在同一进程中，则进行常规的方法调用，若处于不同进程，整个数据传递的过程则需要通过Binder底层去进行编组（序列化，传输，接收和反序列化），得到最终的数据后再进行常规的方法调用。</p>
<p><strong>对象跨进程传输的本质就是 序列化，传输，接收和反序列化 这样一个过程，这也是为什么跨进程传输的对象必须实现Parcelable接口</strong></p>
<h1 id="跨进程的回调接口"><a href="#跨进程的回调接口" class="headerlink" title="跨进程的回调接口"></a>跨进程的回调接口</h1><p>在上面我们已经实现了从客户端发送消息到跨进程服务端的功能，接下来我们还需要将服务端接收到的远程服务器消息，传递到客户端。有同学估计会说：“这不就是一个回调接口的事情嘛”，设置回调接口思路是对的，但是在这里使用的回调接口有点不一样，在AIDL中传递的接口，不能是普通的接口，只能是AIDL接口，所以我们需要新建一个AIDL接口传到服务端，作为回调接口。</p>
<p>新建消息收取的AIDL接口MessageReceiver.aidl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageReceiver.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line">&#x2F;&#x2F;消息回调接口</span><br><span class="line">interface MessageReceiver &#123;</span><br><span class="line">    void onMessageReceived(in MessageModel receivedMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们把回调接口注册到服务端去，修改我们的MessageSender.aidl:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageSender.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface MessageSender &#123;</span><br><span class="line">    void sendMessage(in MessageModel messageModel);</span><br><span class="line"></span><br><span class="line">    void registerReceiveListener(MessageReceiver messageReceiver);</span><br><span class="line"></span><br><span class="line">    void unregisterReceiveListener(MessageReceiver messageReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我们最终修改好的aidl接口，接下来我们需要做出对应的变更：</p>
<ul>
<li><p>在服务端中增加MessageSender的注册和反注册接口的方法；</p>
</li>
<li><p>在客户端中实现MessageReceiver接口，并通过MessageSender注册到服务端。</p>
</li>
</ul>
<p>客户端变更，修改MainActivity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_register).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (connected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.registerReceiveListener(messageReceiver);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消息监听回调接口</span><br><span class="line">    private MessageReceiver.Stub messageReceiver &#x3D; new MessageReceiver.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;onMessageReceived: &quot; + receivedMessage.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;解除消息监听接口</span><br><span class="line">        if (messageSender !&#x3D; null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                messageSender.unregisterReceiveListener(messageReceiver);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端主要有3个变更：</p>
<ol>
<li>增加了messageReceiver对象，用于监听服务端的消息通知；</li>
<li>onServiceConnected方法中，把messageReceiver注册到Service中去；</li>
<li>onDestroy时候解除messageReceiver的注册。</li>
</ol>
<p><strong>下面对服务端MessageServie进行变更：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteCallbackList;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MessageService&quot;;</span><br><span class="line">    private AtomicBoolean serviceStop &#x3D; new AtomicBoolean();</span><br><span class="line">    &#x2F;&#x2F;RemoteCallbackList专门用来管理多进程回调接口</span><br><span class="line">    private RemoteCallbackList&lt;MessageReceiver&gt; listenerList &#x3D; new RemoteCallbackList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.register(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.unregister(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        new Thread(new FakeTCPTask()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        serviceStop.set(true);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;模拟长连接，通知客户端有新消息到达</span><br><span class="line">    private class FakeTCPTask implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!serviceStop.get()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;Service&quot;);</span><br><span class="line">                messageModel.setTo(&quot;Client&quot;);</span><br><span class="line">                messageModel.setContent(String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * RemoteCallbackList的遍历方式</span><br><span class="line">                 * beginBroadcast和finishBroadcast一定要配对使用</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                final int listenerCount &#x3D; listenerList.beginBroadcast();</span><br><span class="line">                Log.d(TAG, &quot;listenerCount &#x3D;&#x3D; &quot; + listenerCount);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; listenerCount; i++) &#123;</span><br><span class="line">                    MessageReceiver messageReceiver &#x3D; listenerList.getBroadcastItem(i);</span><br><span class="line">                    if (messageReceiver !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            messageReceiver.onMessageReceived(messageModel);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                listenerList.finishBroadcast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端主要变更：</p>
<ol>
<li>MessageSender.Stub实现了注册和反注册回调接口的方法；</li>
<li>增加了RemoteCallbackList来管理AIDL远程接口；</li>
<li>FakeTCPTask模拟了长连接通知客户端有新消息到达。</li>
</ol>
<p>这里还有一个需要讲一下的，就是RemoteCallbackList，为什么要用RemoteCallbackList，普通ArrayList不行吗？当然不行，不然干嘛又整一个RemoteCallbackList 🙃，registerReceiveListener 和 unregisterReceiveListener在客户端传输过来的对象，经过Binder处理，在服务端接收到的时候其实是一个新的对象，这样导致在 unregisterReceiveListener 的时候，普通的ArrayList是无法找到在 registerReceiveListener 时候添加到List的那个对象的，但是它们底层使用的Binder对象是同一个，RemoteCallbackList利用这个特性做到了可以找到同一个对象，这样我们就可以顺利反注册客户端传递过来的接口对象了。RemoteCallbackList在客户端进程终止后，它能自动移除客户端所注册的listener，它内部还实现了线程同步，所以我们在注册和反注册都不需要考虑线程同步，的确是个666的类。（至于使用ArrayList的幺蛾子现象，大家可以自己试试，篇幅问题，这里就不演示了）</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>客户端结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 12:15:07.405 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120907403&#39;&#125;</span><br><span class="line">2020-05-22 12:15:10.408 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120910406&#39;&#125;</span><br><span class="line">2020-05-22 12:15:13.409 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120913408&#39;&#125;</span><br><span class="line">2020-05-22 12:15:16.411 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120916410&#39;&#125;</span><br><span class="line">2020-05-22 12:15:19.413 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120919412&#39;&#125;</span><br><span class="line">2020-05-22 12:15:22.415 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120922414&#39;&#125;</span><br><span class="line">2020-05-22 12:15:25.419 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120925417&#39;&#125;</span><br><span class="line">2020-05-22 12:15:28.422 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120928420&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>服务端结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 12:14:37.395 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:39.397 32152-32152&#x2F;com.zhyen.android:remote D&#x2F;AwareBitmapCacher: handleInit disable com.zhyen.android:remote</span><br><span class="line">2020-05-22 12:14:40.395 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:43.397 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:46.398 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:49.399 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:52.400 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:55.400 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:56.750 32152-32191&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br><span class="line">2020-05-22 12:14:56.751 32152-32191&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br><span class="line">2020-05-22 12:14:58.401 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:01.402 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:04.402 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:07.403 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br><span class="line">2020-05-22 12:15:10.407 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br><span class="line">2020-05-22 12:15:13.408 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure>

<h1 id="DeathRecipient"><a href="#DeathRecipient" class="headerlink" title="DeathRecipient"></a>DeathRecipient</h1><p>不知道你有没有感觉到，两个进程交互总是觉得缺乏那么一点安全感…比如说服务端进程Crash了，而客户端进程想要调用服务端方法，这样就调用不到了。此时我们可以给Binder设置一个DeathRecipient对象，当Binder意外挂了的时候，我们可以在DeathRecipient接口的回调方法中收到通知，并作出相应的操作，比如重连服务等等。</p>
<p>DeathRecipient的使用如下：</p>
<ul>
<li>声明DeathRecipient对象，实现其binderDied方法，当binder死亡时，会回调binderDied方法；</li>
<li>给Binder对象设置DeathRecipient对象。</li>
</ul>
<p>在客户端MainActivity声明DeathRecipient：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Binder;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_register).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.registerReceiveListener(messageReceiver);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Binder可能会意外死忙（比如Service Crash），Client监听到Binder死忙后可以进行重连服务等操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Binder.DeathRecipient deathRecipient &#x3D; new IBinder.DeathRecipient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void binderDied() &#123;</span><br><span class="line">            Log.d(TAG, &quot;binderDied: &quot;);</span><br><span class="line">            if (messageSender !&#x3D; null) &#123;</span><br><span class="line">                messageSender.asBinder().unlinkToDeath(this, 0);</span><br><span class="line">                messageSender &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;重连服务或其他操作</span><br><span class="line">            setupService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消息监听回调接口</span><br><span class="line">    private MessageReceiver.Stub messageReceiver &#x3D; new MessageReceiver.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;onMessageReceived: &quot; + receivedMessage.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">            &#x2F;&#x2F;设置Binder死亡监听</span><br><span class="line">            try &#123;</span><br><span class="line">                messageReceiver.asBinder().linkToDeath(deathRecipient, 0);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;解除消息监听接口</span><br><span class="line">        if (messageSender !&#x3D; null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                messageSender.unregisterReceiveListener(messageReceiver);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Binder中两个重要方法：</p>
<ol>
<li>linkToDeath -&gt; 设置死亡代理 DeathRecipient 对象；</li>
<li>unlinkToDeath -&gt; Binder死亡的情况下，解除该代理。</li>
</ol>
<p>此外，Binder中的isBinderAlive也可以判断Binder是否死亡。</p>
<h1 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h1><p>就算是公交车，上车也得嘀卡对不，如果希望我们的服务进程不想像公交车一样谁想上就上，那么我们可以加入权限验证。</p>
<p>介绍两种常用验证方法：</p>
<ul>
<li>在服务端的onBind中校验自定义permission，如果通过了我们的校验，正常返回Binder对象，校验不通过返回null，返回null的情况下客户端无法绑定到我们的服务；</li>
<li>在服务端的onTransact方法校验客户端包名，不通过校验直接return false，校验通过执行正常的流程。</li>
</ul>
<p>自定义permission，在Androidmanifest.xml中增加自定义的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission</span><br><span class="line">        android:name&#x3D;&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot;</span><br><span class="line">        android:protectionLevel&#x3D;&quot;normal&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>服务端检查权限的方法：</p>
<ul>
<li>校验权限的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F;自定义permission方式检查权限</span><br><span class="line">        if (checkCallingOrSelfPermission(&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot;) &#x3D;&#x3D; PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onBind: 没有设置权限&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断包名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.register(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.unregister(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 包名验证方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            String packageName &#x3D; null;</span><br><span class="line">            String[] packages &#x3D; getPackageManager().getPackagesForUid(getCallingUid());</span><br><span class="line">            if (packages !&#x3D; null &amp;&amp; packages.length &gt; 0) &#123;</span><br><span class="line">                packageName &#x3D; packages[0];</span><br><span class="line">            &#125;</span><br><span class="line">            if (packageName &#x3D;&#x3D; null || !packageName.startsWith(&quot;com.zhyen.android&quot;)) &#123;</span><br><span class="line">                Log.d(&quot;onTransact&quot;, &quot;拒绝调用：&quot; + packageName);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="根据不同进程，做不同的初始化工作"><a href="#根据不同进程，做不同的初始化工作" class="headerlink" title="根据不同进程，做不同的初始化工作"></a>根据不同进程，做不同的初始化工作</h1><p>相信前一两年很多朋友还在使用Android-Universal-Image-Loader来加载图片，它是需要在Application类进行初始化的。打个比如，我们用它来加载图片，而且还有一个图片选择进程，那么我们希望分配更多的缓存给图片选择进程，又或者是一些其他的初始化工作，不需要在图片选择进程初始化怎么办？</p>
<p>这里提供一个简单粗暴的方法，博主也是这么干的…直接拿到进程名判断，作出相应操作即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android;</span><br><span class="line"></span><br><span class="line">import android.app.ActivityManager;</span><br><span class="line">import android.app.Application;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.nfc.Tag;</span><br><span class="line">import android.os.Process;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ZhyenApplication extends Application &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;ZhyenApplication&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.d(TAG, getProcessName(getApplicationContext()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得进程名</span><br><span class="line">    public static String getProcessName(Context context) &#123;</span><br><span class="line">        ActivityManager am &#x3D; (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps &#x3D; am.getRunningAppProcesses();</span><br><span class="line">        if (runningApps &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123;</span><br><span class="line">            if (procInfo.pid &#x3D;&#x3D; Process.myPid()) &#123;</span><br><span class="line">                return procInfo.processName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个进程创建，都会调用Application的onCreate方法，这是一个需要注意的地方，我们也可以根据当前进程的pid，拿到当前进程的名字去做判断，然后做一些我们需要的逻辑，我们这个例子，拿到的两个进程名分别是：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 13:54:17.090 16347-16347&#x2F;com.zhyen.android:remote D&#x2F;ZhyenApplication: com.zhyen.android:remote</span><br><span class="line"></span><br><span class="line">2020-05-22 13:54:08.698 16280-16280&#x2F;? D&#x2F;ZhyenApplication: com.zhyen.android</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/9/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
