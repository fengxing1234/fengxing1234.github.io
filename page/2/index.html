<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/" itemprop="url">使用AIDL实现一个多进程消息推送(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-22T00:19:00+08:00">
                2020-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>像图片选择这样的多进程需求，可能并不需要我们额外编写进程通讯的代码，使用四大组件传输Bundle就行了，但是像推送服务这种需求，进程与进程之间需要高度的交互，此时就绕不过进程通讯这一步了。</p>
<p>下面我们就用即时聊天软件为例，手动去实现一个多进程的推送例子，具体需求如下：</p>
<ol>
<li>UI和消息推送的Service分两个进程；</li>
<li>UI进程用于展示具体的消息数据，把用户发送的消息，传递到消息Service，然后发送到远程服务器；</li>
<li>Service负责收发消息，并和远程服务器保持长连接，UI进程可通过Service发送消息到远程服务器，Service收到远程服务器消息通知UI进程；</li>
<li>即使UI进程退出了，Service仍需要保持运行，收取服务器消息。</li>
</ol>
<p><strong>实现思路</strong></p>
<ol>
<li><p>创建UI进程（下文统称为客户端）；</p>
</li>
<li><p>创建消息Service（下文统称为服务端）；</p>
</li>
<li><p>把服务端配置到独立的进程(AndroidManifest.xml中指定process标签)；</p>
</li>
<li><p>客户端和服务端进行绑定（bindService）；</p>
</li>
<li><p>让客户端和服务端具备交互的能力。(AIDL使用)</p>
</li>
</ol>
<h1 id="例子具体实现"><a href="#例子具体实现" class="headerlink" title="例子具体实现"></a>例子具体实现</h1><h2 id="AIDL调用流程概览"><a href="#AIDL调用流程概览" class="headerlink" title="AIDL调用流程概览"></a>AIDL调用流程概览</h2><p>开始之前，我们先来概括一下使用AIDL进行多进程调用的整个流程：</p>
<ol>
<li>客户端使用bindService方法绑定服务端；</li>
<li>服务端在onBind方法返回Binder对象；</li>
<li>客户端拿到服务端返回的Binder对象进行跨进程方法调用；</li>
</ol>
<p><img src="http://jsh180.net/blog_aidl_img_flow_1.jpg" alt="AIDL调用过程"></p>
<p><strong>整个AIDL调用过程概括起来就以上3个步骤，下文中我们使用上面描述的例子，来逐步分解这些步骤，并讲述其中的细节。</strong></p>
<h2 id="客户端使用bindService方法绑定服务端"><a href="#客户端使用bindService方法绑定服务端" class="headerlink" title="客户端使用bindService方法绑定服务端"></a>客户端使用bindService方法绑定服务端</h2><h3 id="创建客户端和服务端，把服务端配置到另外的进程"><a href="#创建客户端和服务端，把服务端配置到另外的进程" class="headerlink" title="创建客户端和服务端，把服务端配置到另外的进程"></a>创建客户端和服务端，把服务端配置到另外的进程</h3><ol>
<li>创建客户端 -&gt; MainActivity；</li>
<li>创建服务端 -&gt; MessageService;</li>
<li>把服务端配置到另外的进程 -&gt; android:process=”:remote”</li>
</ol>
<p>上面描述的客户端、服务端、以及把服务端配置到另外进程，体现在AndroidManifest.xml中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;application ...&gt;</span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.test.test_aidl.TestAidlMessageActivity&quot; &#x2F;&gt;</span><br><span class="line">        &lt;service</span><br><span class="line">            android:name&#x3D;&quot;.test.test_aidl.MessageService&quot;</span><br><span class="line">            android:enabled&#x3D;&quot;true&quot;</span><br><span class="line">            android:exported&#x3D;&quot;true&quot;</span><br><span class="line">            android:process&#x3D;&quot;:remote&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>

<p>开启多进程的方法很简单，只需要给四大组件指定android:process标签。</p>
<h3 id="绑定MessageService到MainActivity"><a href="#绑定MessageService到MainActivity" class="headerlink" title="绑定MessageService到MainActivity"></a>绑定MessageService到MainActivity</h3><p><strong>创建MessageService</strong></p>
<p>此时的MessageService就是刚创建的模样，onBind中返回了null，下一步中我们将返回一个可操作的对象给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line">    </span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端MainActivity调用bindService方法绑定MessageService</strong></p>
<p>这一步其实是属于Service组件相关的知识，在这里就比较简单地说一下，启动服务可以通过以下两种方式：</p>
<ul>
<li>使用bindService方法 -&gt; bindService(Intent service, ServiceConnection conn, int flags)；</li>
<li>使用startService方法 -&gt; startService(Intent service);</li>
</ul>
<p><strong>bindService &amp; startService区别：</strong></p>
<p>使用bindService方式，多个Client可以同时bind一个Service，但是当所有Client unbind后，Service会退出，通常情况下，如果希望和Service交互，一般使用bindService方法，使用onServiceConnected中的IBinder对象可以和Service进行交互，不需要和Service交互的情况下，使用startService方法即可。</p>
<p>正如上面所说，我们是要和Service交互的，所以我们需要使用bindService方法，<strong>但是我们希望unbind后Service仍保持运行，这样的情况下，可以同时调用bindService和startService</strong>（比如像本例子中的消息服务，退出UI进程，Service仍需要接收到消息），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端在onBind方法返回Binder对象"><a href="#服务端在onBind方法返回Binder对象" class="headerlink" title="服务端在onBind方法返回Binder对象"></a>服务端在onBind方法返回Binder对象</h2><h3 id="首先，什么是Binder"><a href="#首先，什么是Binder" class="headerlink" title="首先，什么是Binder?"></a>首先，什么是Binder?</h3><p>要说Binder，首先要说一下IBinder这个接口，IBinder是远程对象的基础接口，轻量级的远程过程调用机制的核心部分，该接口描述了与远程对象交互的抽象协议，而Binder实现了IBinder接口，简单说，Binder就是Android SDK中内置的一个多进程通讯实现类，在使用的时候，我们不用也不要去实现IBinder，而是继承Binder这个类即可实现多进程通讯。</p>
<h3 id="其次，这个需要在onBind方法返回的Binder对象从何而来？"><a href="#其次，这个需要在onBind方法返回的Binder对象从何而来？" class="headerlink" title="其次，这个需要在onBind方法返回的Binder对象从何而来？"></a>其次，这个需要在onBind方法返回的Binder对象从何而来？</h3><p><strong>在这里就要引出本文中的主题了——AIDL</strong></p>
<p>多进程中使用的Binder对象，一般通过我们定义好的 .adil 接口文件自动生成，当然你可以走野路子，直接手动编写这个跨进程通讯所需的Binder类，其本质无非就是一个继承了Binder的类，鉴于野路子走起来麻烦，而且都是重复步骤的工作，Google提供了 AIDL 接口来帮我们自动生成Binder这条正路，下文中我们围绕 AIDL 这条正路继续展开讨论</p>
<h3 id="定义AIDL接口"><a href="#定义AIDL接口" class="headerlink" title="定义AIDL接口"></a>定义AIDL接口</h3><p>很明显，接下来我们需要搞一波上面说的Binder，让客户端可以调用到服务端的方法，而这个Binder又是通过AIDL接口自动生成，那我们就先从AIDL搞起，搞之前先看看注意事项，以免出事故：</p>
<p>AIDL支持的数据类型：</p>
<ul>
<li>Java 编程语言中的所有基本数据类型（如 int、long、char、boolean 等等）</li>
<li>String和CharSequence</li>
<li>Parcelable：实现了Parcelable接口的对象</li>
<li>List：其中的元素需要被AIDL支持，另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口</li>
<li>Map：其中的元素需要被AIDL支持，包括 key 和 value，另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接口</li>
</ul>
<p>其他注意事项：</p>
<ul>
<li>在AIDL中传递的对象，必须实现Parcelable序列化接口；</li>
<li>在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类；</li>
<li>跟普通接口的区别：只能声明方法，不能声明变量；</li>
<li>所有非基础数据类型参数都需要标出数据走向的方向标记。可以是 in、out 或 inout，基础数据类型默认只能是 in，不能是其他方向。</li>
</ul>
<h3 id="创建一个AIDL接口"><a href="#创建一个AIDL接口" class="headerlink" title="创建一个AIDL接口"></a>创建一个AIDL接口</h3><p>接口中提供发送消息的方法（Android Studio创建AIDL：项目右键 -&gt; New -&gt; AIDL -&gt; AIDL File），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageSender.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface MessageSender &#123;</span><br><span class="line">    void sendMessage(in MessageModel messageModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被“in”标记的参数，就是接收实际数据的参数，这个跟我们普通参数传递一样的含义。在AIDL中，“out” 指定了一个仅用于输出的参数，换而言之，这个参数不关心调用方传递了什么数据过来，但是这个参数的值可以在方法被调用后填充（无论调用方传递了什么值过来，在方法执行的时候，这个参数的初始值总是空的），这就是“out”的含义，仅用于输出。而“inout”显然就是“in”和“out”的合体了，输入和输出的参数。区分“in”、“out”有什么用？这是非常重要的，因为每个参数的内容必须编组（序列化，传输，接收和反序列化）。in/out标签允许Binder跳过编组步骤以获得更好的性能。</p>
</blockquote>
<p>上述的MessageModel为消息的实体类，该类在AIDL中传递，实现了Parcelable序列化接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.model;</span><br><span class="line"></span><br><span class="line">import android.os.Parcel;</span><br><span class="line">import android.os.Parcelable;</span><br><span class="line"></span><br><span class="line">public class MessageModel implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    private String from;</span><br><span class="line">    private String to;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public MessageModel() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MessageModel(String from, String to, String content) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected MessageModel(Parcel in) &#123;</span><br><span class="line">        from &#x3D; in.readString();</span><br><span class="line">        to &#x3D; in.readString();</span><br><span class="line">        content &#x3D; in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;MessageModel&gt; CREATOR &#x3D; new Creator&lt;MessageModel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public MessageModel createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new MessageModel(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public MessageModel[] newArray(int size) &#123;</span><br><span class="line">            return new MessageModel[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public String getFrom() &#123;</span><br><span class="line">        return from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFrom(String from) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTo() &#123;</span><br><span class="line">        return to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTo(String to) &#123;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MessageModel&#123;&quot; +</span><br><span class="line">                &quot;from&#x3D;&#39;&quot; + from + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, to&#x3D;&#39;&quot; + to + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(from);</span><br><span class="line">        dest.writeString(to);</span><br><span class="line">        dest.writeString(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完MessageModel这个实体类，别忘了还有一件事要做：”在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类“。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageModel.aidl</span><br><span class="line">package com.zhyen.android.model;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">parcelable MessageModel;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>MessageSender.aidl -&gt; 定义了发送消息的方法，会自动生成名为MessageSender.Stub的Binder类，在服务端实现，返回给客户端调用</li>
<li>MessageModel.java -&gt; 消息实体类，由客户端传递到服务端，实现了Parcelable序列化</li>
<li>MessageModel.aidl -&gt; 声明了MessageModel可在AIDL中传递，放在跟MessageModel.java相同的包路径下</li>
</ul>
<h3 id="服务端MessageService"><a href="#服务端MessageService" class="headerlink" title="服务端MessageService"></a>服务端MessageService</h3><p>在服务端创建MessageSender.aidl这个AIDL接口自动生成的Binder对象，并返回给客户端调用，服务端MessageService代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MessageService&quot;;</span><br><span class="line"></span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageSender.Stub是Android Studio根据我们MessageSender.aidl文件自动生成的Binder对象（至于是怎样生成的，下文会有答案），我们需要把这个Binder对象返回给客户端。</p>
<h2 id="客户端拿到Binder对象后调用远程方法"><a href="#客户端拿到Binder对象后调用远程方法" class="headerlink" title="客户端拿到Binder对象后调用远程方法"></a>客户端拿到Binder对象后调用远程方法</h2><p>调用步骤如下：</p>
<ol>
<li>在客户端的onServiceConnected方法中，拿到服务端返回的Binder对象；</li>
<li>使用MessageSender.Stub.asInterface方法，取得MessageSender.aidl对应的操作接口；</li>
<li>取得MessageSender对象后，像普通接口一样调用方法即可。</li>
</ol>
<p>此时客户端代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中我们调用了MessageSender的sendMessage方法，向服务端发送了一条消息，并把生成的MessageModel对象作为参数传递到了服务端，最终服务端打印的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 10:53:25.747 22509-22545&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两点要说：</p>
<ul>
<li>服务端已经接收到客户端发送过来的消息，并正确打印；</li>
<li>服务端和客户端区分两个进程，PID不一样，进程名也不一样；</li>
</ul>
<h1 id="分析Binder上层机制"><a href="#分析Binder上层机制" class="headerlink" title="分析Binder上层机制"></a>分析Binder上层机制</h1><p>我们通过上述的调用流程，看看从客户端到服务端，都经历了些什么事，看看Binder的上层是如何工作的，至于Binder的底层，这是一个非常复杂的话题，本文不深究。（如果看到这里你又想问什么是Binder的话，请手动倒带往上看…）</p>
<p>我们先来回顾一下从客户端发起的调用流程：</p>
<ul>
<li>MessageSender messageSender = MessageSender.Stub.asInterface(service);</li>
<li>messageSender.sendMessage(messageModel);</li>
</ul>
<p>抛开其它无关代码，客户端调跨进程方法就这两个步骤，而这两个步骤都封装在 MessageSender.aidl 最终生成的 MessageSender.java 源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> *&#x2F;</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">public interface MessageSender extends android.os.IInterface &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.zhyen.android.MessageSender &#123;</span><br><span class="line">		    &#x2F;&#x2F;描述符，该值为全类名</span><br><span class="line">        private static final java.lang.String DESCRIPTOR &#x3D; &quot;com.zhyen.android.MessageSender&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         根据AIDL的使用流程，Server会在onBind的时候返回一个Stub实例，</span><br><span class="line">         调用了Stub的构造器内部调用Binder的attachInterface方法将当前实例以及描述符存到Binder实例中</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 把IBinder对象转换为MessageSender 接口</span><br><span class="line">         * 判断IBinder是否处于相同进程，相同进程返回Stub实现的MessageSender接口</span><br><span class="line">         * 不同进程，则返回Stub.Proxy实现的MessageSender接口</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static com.zhyen.android.MessageSender asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin !&#x3D; null) &amp;&amp; (iin instanceof com.zhyen.android.MessageSender))) &#123;</span><br><span class="line">                return ((com.zhyen.android.MessageSender) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.zhyen.android.MessageSender.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 同一进程时，不会触发</span><br><span class="line">         *</span><br><span class="line">         * 不同进程时，asInterface会返回Stub.Proxy，客户端调用 messageSender.sendMessage(messageModel)</span><br><span class="line">         * 实质是调用了 Stub.Proxy 的 sendMessage 方法，从而触发跨进程数据传递，</span><br><span class="line">         * 最终Binder底层将处理好的数据回调到此方法，并调用我们真正的sendMessage方法</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">            java.lang.String descriptor &#x3D; DESCRIPTOR;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_sendMessage: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.zhyen.android.model.MessageModel _arg0;</span><br><span class="line">                    if ((0 !&#x3D; data.readInt())) &#123;</span><br><span class="line">                        _arg0 &#x3D; com.zhyen.android.model.MessageModel.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _arg0 &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.sendMessage(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    return super.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.zhyen.android.MessageSender &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote &#x3D; remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * Proxy中的sendMessage方法，并不是直接调用我们定义的sendMessage方法，而是经过一顿的Parcel读写，</span><br><span class="line">             * 然后调用mRemote.transact方法，把数据交给Binder处理，transact处理完毕后会调用上方的onTransact方法，</span><br><span class="line">             * onTransact拿到最终得到的参数数据，调用由我们真正的sendMessage方法</span><br><span class="line">             *&#x2F;</span><br><span class="line">            @Override</span><br><span class="line">            public void sendMessage(com.zhyen.android.model.MessageModel messageModel) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    if ((messageModel !&#x3D; null)) &#123;</span><br><span class="line">                        _data.writeInt(1);</span><br><span class="line">                        messageModel.writeToParcel(_data, 0);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _data.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;调用Binder的transact方法进行多进程数据传输，处理完毕后调用上方的onTransact方法</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_sendMessage, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_sendMessage &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(com.zhyen.android.model.MessageModel messageModel) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只看代码的话，可能会有点懵逼，相信结合代码再看下方的流程图会更好理解：</p>
<p><img src="http://jsh180.net/image/jpg/blog_aidl_flowchart.jpg" alt="flow chart"></p>
<p>从客户端的sendMessage开始，整个AIDL的调用过程如上图所示，asInterface方法，将会判断onBind方法返回的Binder是否存处于同一进程，在同一进程中，则进行常规的方法调用，若处于不同进程，整个数据传递的过程则需要通过Binder底层去进行编组（序列化，传输，接收和反序列化），得到最终的数据后再进行常规的方法调用。</p>
<p><strong>对象跨进程传输的本质就是 序列化，传输，接收和反序列化 这样一个过程，这也是为什么跨进程传输的对象必须实现Parcelable接口</strong></p>
<h1 id="跨进程的回调接口"><a href="#跨进程的回调接口" class="headerlink" title="跨进程的回调接口"></a>跨进程的回调接口</h1><p>在上面我们已经实现了从客户端发送消息到跨进程服务端的功能，接下来我们还需要将服务端接收到的远程服务器消息，传递到客户端。有同学估计会说：“这不就是一个回调接口的事情嘛”，设置回调接口思路是对的，但是在这里使用的回调接口有点不一样，在AIDL中传递的接口，不能是普通的接口，只能是AIDL接口，所以我们需要新建一个AIDL接口传到服务端，作为回调接口。</p>
<p>新建消息收取的AIDL接口MessageReceiver.aidl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageReceiver.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line">&#x2F;&#x2F;消息回调接口</span><br><span class="line">interface MessageReceiver &#123;</span><br><span class="line">    void onMessageReceived(in MessageModel receivedMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们把回调接口注册到服务端去，修改我们的MessageSender.aidl:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageSender.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface MessageSender &#123;</span><br><span class="line">    void sendMessage(in MessageModel messageModel);</span><br><span class="line"></span><br><span class="line">    void registerReceiveListener(MessageReceiver messageReceiver);</span><br><span class="line"></span><br><span class="line">    void unregisterReceiveListener(MessageReceiver messageReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我们最终修改好的aidl接口，接下来我们需要做出对应的变更：</p>
<ul>
<li><p>在服务端中增加MessageSender的注册和反注册接口的方法；</p>
</li>
<li><p>在客户端中实现MessageReceiver接口，并通过MessageSender注册到服务端。</p>
</li>
</ul>
<p>客户端变更，修改MainActivity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_register).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (connected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.registerReceiveListener(messageReceiver);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消息监听回调接口</span><br><span class="line">    private MessageReceiver.Stub messageReceiver &#x3D; new MessageReceiver.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;onMessageReceived: &quot; + receivedMessage.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;解除消息监听接口</span><br><span class="line">        if (messageSender !&#x3D; null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                messageSender.unregisterReceiveListener(messageReceiver);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端主要有3个变更：</p>
<ol>
<li>增加了messageReceiver对象，用于监听服务端的消息通知；</li>
<li>onServiceConnected方法中，把messageReceiver注册到Service中去；</li>
<li>onDestroy时候解除messageReceiver的注册。</li>
</ol>
<p><strong>下面对服务端MessageServie进行变更：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteCallbackList;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MessageService&quot;;</span><br><span class="line">    private AtomicBoolean serviceStop &#x3D; new AtomicBoolean();</span><br><span class="line">    &#x2F;&#x2F;RemoteCallbackList专门用来管理多进程回调接口</span><br><span class="line">    private RemoteCallbackList&lt;MessageReceiver&gt; listenerList &#x3D; new RemoteCallbackList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.register(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.unregister(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        new Thread(new FakeTCPTask()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        serviceStop.set(true);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;模拟长连接，通知客户端有新消息到达</span><br><span class="line">    private class FakeTCPTask implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!serviceStop.get()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;Service&quot;);</span><br><span class="line">                messageModel.setTo(&quot;Client&quot;);</span><br><span class="line">                messageModel.setContent(String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * RemoteCallbackList的遍历方式</span><br><span class="line">                 * beginBroadcast和finishBroadcast一定要配对使用</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                final int listenerCount &#x3D; listenerList.beginBroadcast();</span><br><span class="line">                Log.d(TAG, &quot;listenerCount &#x3D;&#x3D; &quot; + listenerCount);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; listenerCount; i++) &#123;</span><br><span class="line">                    MessageReceiver messageReceiver &#x3D; listenerList.getBroadcastItem(i);</span><br><span class="line">                    if (messageReceiver !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            messageReceiver.onMessageReceived(messageModel);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                listenerList.finishBroadcast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端主要变更：</p>
<ol>
<li>MessageSender.Stub实现了注册和反注册回调接口的方法；</li>
<li>增加了RemoteCallbackList来管理AIDL远程接口；</li>
<li>FakeTCPTask模拟了长连接通知客户端有新消息到达。</li>
</ol>
<p>这里还有一个需要讲一下的，就是RemoteCallbackList，为什么要用RemoteCallbackList，普通ArrayList不行吗？当然不行，不然干嘛又整一个RemoteCallbackList 🙃，registerReceiveListener 和 unregisterReceiveListener在客户端传输过来的对象，经过Binder处理，在服务端接收到的时候其实是一个新的对象，这样导致在 unregisterReceiveListener 的时候，普通的ArrayList是无法找到在 registerReceiveListener 时候添加到List的那个对象的，但是它们底层使用的Binder对象是同一个，RemoteCallbackList利用这个特性做到了可以找到同一个对象，这样我们就可以顺利反注册客户端传递过来的接口对象了。RemoteCallbackList在客户端进程终止后，它能自动移除客户端所注册的listener，它内部还实现了线程同步，所以我们在注册和反注册都不需要考虑线程同步，的确是个666的类。（至于使用ArrayList的幺蛾子现象，大家可以自己试试，篇幅问题，这里就不演示了）</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>客户端结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 12:15:07.405 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120907403&#39;&#125;</span><br><span class="line">2020-05-22 12:15:10.408 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120910406&#39;&#125;</span><br><span class="line">2020-05-22 12:15:13.409 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120913408&#39;&#125;</span><br><span class="line">2020-05-22 12:15:16.411 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120916410&#39;&#125;</span><br><span class="line">2020-05-22 12:15:19.413 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120919412&#39;&#125;</span><br><span class="line">2020-05-22 12:15:22.415 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120922414&#39;&#125;</span><br><span class="line">2020-05-22 12:15:25.419 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120925417&#39;&#125;</span><br><span class="line">2020-05-22 12:15:28.422 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120928420&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>服务端结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 12:14:37.395 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:39.397 32152-32152&#x2F;com.zhyen.android:remote D&#x2F;AwareBitmapCacher: handleInit disable com.zhyen.android:remote</span><br><span class="line">2020-05-22 12:14:40.395 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:43.397 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:46.398 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:49.399 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:52.400 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:55.400 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:56.750 32152-32191&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br><span class="line">2020-05-22 12:14:56.751 32152-32191&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br><span class="line">2020-05-22 12:14:58.401 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:01.402 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:04.402 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:07.403 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br><span class="line">2020-05-22 12:15:10.407 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br><span class="line">2020-05-22 12:15:13.408 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure>

<h1 id="DeathRecipient"><a href="#DeathRecipient" class="headerlink" title="DeathRecipient"></a>DeathRecipient</h1><p>不知道你有没有感觉到，两个进程交互总是觉得缺乏那么一点安全感…比如说服务端进程Crash了，而客户端进程想要调用服务端方法，这样就调用不到了。此时我们可以给Binder设置一个DeathRecipient对象，当Binder意外挂了的时候，我们可以在DeathRecipient接口的回调方法中收到通知，并作出相应的操作，比如重连服务等等。</p>
<p>DeathRecipient的使用如下：</p>
<ul>
<li>声明DeathRecipient对象，实现其binderDied方法，当binder死亡时，会回调binderDied方法；</li>
<li>给Binder对象设置DeathRecipient对象。</li>
</ul>
<p>在客户端MainActivity声明DeathRecipient：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Binder;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_register).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.registerReceiveListener(messageReceiver);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Binder可能会意外死忙（比如Service Crash），Client监听到Binder死忙后可以进行重连服务等操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Binder.DeathRecipient deathRecipient &#x3D; new IBinder.DeathRecipient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void binderDied() &#123;</span><br><span class="line">            Log.d(TAG, &quot;binderDied: &quot;);</span><br><span class="line">            if (messageSender !&#x3D; null) &#123;</span><br><span class="line">                messageSender.asBinder().unlinkToDeath(this, 0);</span><br><span class="line">                messageSender &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;重连服务或其他操作</span><br><span class="line">            setupService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消息监听回调接口</span><br><span class="line">    private MessageReceiver.Stub messageReceiver &#x3D; new MessageReceiver.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;onMessageReceived: &quot; + receivedMessage.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">            &#x2F;&#x2F;设置Binder死亡监听</span><br><span class="line">            try &#123;</span><br><span class="line">                messageReceiver.asBinder().linkToDeath(deathRecipient, 0);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;解除消息监听接口</span><br><span class="line">        if (messageSender !&#x3D; null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                messageSender.unregisterReceiveListener(messageReceiver);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Binder中两个重要方法：</p>
<ol>
<li>linkToDeath -&gt; 设置死亡代理 DeathRecipient 对象；</li>
<li>unlinkToDeath -&gt; Binder死亡的情况下，解除该代理。</li>
</ol>
<p>此外，Binder中的isBinderAlive也可以判断Binder是否死亡。</p>
<h1 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h1><p>就算是公交车，上车也得嘀卡对不，如果希望我们的服务进程不想像公交车一样谁想上就上，那么我们可以加入权限验证。</p>
<p>介绍两种常用验证方法：</p>
<ul>
<li>在服务端的onBind中校验自定义permission，如果通过了我们的校验，正常返回Binder对象，校验不通过返回null，返回null的情况下客户端无法绑定到我们的服务；</li>
<li>在服务端的onTransact方法校验客户端包名，不通过校验直接return false，校验通过执行正常的流程。</li>
</ul>
<p>自定义permission，在Androidmanifest.xml中增加自定义的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission</span><br><span class="line">        android:name&#x3D;&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot;</span><br><span class="line">        android:protectionLevel&#x3D;&quot;normal&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>服务端检查权限的方法：</p>
<ul>
<li>校验权限的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F;自定义permission方式检查权限</span><br><span class="line">        if (checkCallingOrSelfPermission(&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot;) &#x3D;&#x3D; PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onBind: 没有设置权限&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断包名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.register(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.unregister(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 包名验证方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            String packageName &#x3D; null;</span><br><span class="line">            String[] packages &#x3D; getPackageManager().getPackagesForUid(getCallingUid());</span><br><span class="line">            if (packages !&#x3D; null &amp;&amp; packages.length &gt; 0) &#123;</span><br><span class="line">                packageName &#x3D; packages[0];</span><br><span class="line">            &#125;</span><br><span class="line">            if (packageName &#x3D;&#x3D; null || !packageName.startsWith(&quot;com.zhyen.android&quot;)) &#123;</span><br><span class="line">                Log.d(&quot;onTransact&quot;, &quot;拒绝调用：&quot; + packageName);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="根据不同进程，做不同的初始化工作"><a href="#根据不同进程，做不同的初始化工作" class="headerlink" title="根据不同进程，做不同的初始化工作"></a>根据不同进程，做不同的初始化工作</h1><p>相信前一两年很多朋友还在使用Android-Universal-Image-Loader来加载图片，它是需要在Application类进行初始化的。打个比如，我们用它来加载图片，而且还有一个图片选择进程，那么我们希望分配更多的缓存给图片选择进程，又或者是一些其他的初始化工作，不需要在图片选择进程初始化怎么办？</p>
<p>这里提供一个简单粗暴的方法，博主也是这么干的…直接拿到进程名判断，作出相应操作即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android;</span><br><span class="line"></span><br><span class="line">import android.app.ActivityManager;</span><br><span class="line">import android.app.Application;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.nfc.Tag;</span><br><span class="line">import android.os.Process;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ZhyenApplication extends Application &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;ZhyenApplication&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.d(TAG, getProcessName(getApplicationContext()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得进程名</span><br><span class="line">    public static String getProcessName(Context context) &#123;</span><br><span class="line">        ActivityManager am &#x3D; (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps &#x3D; am.getRunningAppProcesses();</span><br><span class="line">        if (runningApps &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123;</span><br><span class="line">            if (procInfo.pid &#x3D;&#x3D; Process.myPid()) &#123;</span><br><span class="line">                return procInfo.processName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个进程创建，都会调用Application的onCreate方法，这是一个需要注意的地方，我们也可以根据当前进程的pid，拿到当前进程的名字去做判断，然后做一些我们需要的逻辑，我们这个例子，拿到的两个进程名分别是：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 13:54:17.090 16347-16347&#x2F;com.zhyen.android:remote D&#x2F;ZhyenApplication: com.zhyen.android:remote</span><br><span class="line"></span><br><span class="line">2020-05-22 13:54:08.698 16280-16280&#x2F;? D&#x2F;ZhyenApplication: com.zhyen.android</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="url">adb常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T21:21:56+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><p><a href="https://www.wanandroid.com/blog/show/2310" target="_blank" rel="noopener">ADB命令大全</a></p>
<p><a href="https://developer.android.com/studio/command-line/adb.html#test_harness" target="_blank" rel="noopener">Android官方</a></p>
<h2 id="ADB简介"><a href="#ADB简介" class="headerlink" title="ADB简介"></a>ADB简介</h2><p>ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 sdk/platform-tools 目录下。虽然现在 Android Studio 已经将大部分 ADB 命令以图形化的形式实现了，但是了解一下还是有必要的。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><strong>启动ADB</strong>的2种方式：</p>
<ul>
<li>直接进入<strong>sdk/platform-tools</strong>目录：然后在命令行中输入<strong>adb devices</strong>来验证设备是否连接。<ul>
<li>缺点：每次进入platform-tools目录很麻烦。</li>
</ul>
</li>
<li>将adb地址写入环境变量**（即配置adb为环境变量）</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看当前连接设备："><a href="#查看当前连接设备：" class="headerlink" title="查看当前连接设备："></a>查看当前连接设备：</h3><ul>
<li>查看当前连接设备：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<ul>
<li>如果发现多个设备：</li>
</ul>
<figure class="highlight plain"><figcaption><span>-s 设备号 其他指令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s 设备号 其他指令</span><br></pre></td></tr></table></figure>

<h3 id="事件输入"><a href="#事件输入" class="headerlink" title="事件输入"></a>事件输入</h3><ol>
<li>使用<strong>adb shell input</strong>命令向屏幕输入一些信息，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input text &quot;insert%stext%shere&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：%s表示空格。</strong></p>
<ol start="2">
<li>使用<strong>adb shell input tap</strong>命令来模拟屏幕点击事件，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input tap 500 1450</span><br></pre></td></tr></table></figure>

<p>表示在屏幕上（500，1450）的坐标点上进行一次点击。 </p>
<ol start="3">
<li>使用<strong>adb shell input swipe</strong>命令来模拟手势滑动事件，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 100 500 100 1450 100</span><br></pre></td></tr></table></figure>

<p>表示从屏幕坐标（100，500）开始，滑动到(100,1450)结束，整个过程耗时100ms.</p>
<ol start="4">
<li>使用上面的命令还可以模拟”<strong>长按（long press）</strong>操作，也就是2个坐标点相同，耗时超过500ms.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 100 500 100 500 500</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用<strong>adb shell input keyevent</strong>命令来模拟点按实体按钮的命令，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure>

<p>该命令表示调低音量。数字25是在AOSP源码中的<strong>KeyEvent类</strong>里定义的一个事件常量。该类定义了将近300个事件常量。</p>
<h3 id="查看顶部Activity"><a href="#查看顶部Activity" class="headerlink" title="查看顶部Activity"></a>查看顶部Activity</h3><ul>
<li>windows环境下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Linux、Mac环境下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</span><br></pre></td></tr></table></figure>

<h3 id="查看日志："><a href="#查看日志：" class="headerlink" title="查看日志："></a>查看日志：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat</span><br></pre></td></tr></table></figure>

<h3 id="安装apk文件："><a href="#安装apk文件：" class="headerlink" title="安装apk文件："></a>安装apk文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install xxx.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>此安装方式，如果已经存在，无法安装；<br>推荐使用<strong>覆盖安装：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r xxx.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>比分直接RUN出来的包是test-onlu的无法安装，推荐使用<strong>-t</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r -t xxx.apk</span><br></pre></td></tr></table></figure>

<h3 id="卸载App"><a href="#卸载App" class="headerlink" title="卸载App:"></a>卸载App:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.zhy.app</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想要保留数据，则：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall -k com.zhy.app</span><br></pre></td></tr></table></figure>

<h3 id="传递文件："><a href="#传递文件：" class="headerlink" title="传递文件："></a>传递文件：</h3><ul>
<li>电脑往手机SDCard传递文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 文件名 手机端SDCard路径</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 帅照.jpg &#x2F;sdcard&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>从手机端拉取文件到电脑：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;sdcard&#x2F;xxx.txt</span><br></pre></td></tr></table></figure>

<h3 id="查看手机端安装的所有app包名"><a href="#查看手机端安装的所有app包名" class="headerlink" title="查看手机端安装的所有app包名:"></a>查看手机端安装的所有app包名:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<h3 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity:"></a>启动Activity:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start 包名&#x2F;完整Activity路径</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">adb shell am start com.zhyen.android&#x2F;com.zhyen.android.MainActivity</span><br></pre></td></tr></table></figure>

<p>如果需要携带参数(携带一个Intent,Key 为name):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start com.zhyen.android&#x2F;com.zhyen.android.MainActivity -e name zhy</span><br></pre></td></tr></table></figure>

<p>启动一个隐式的Intent:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a &quot;android.intent.action,VIEW&quot; -d &quot;https:&#x2F;&#x2F;www.google.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="发送广播："><a href="#发送广播：" class="headerlink" title="发送广播："></a>发送广播：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a &quot;broadcastactionfilter&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要携带参数（携带一个Intent,key为name）:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a &quot;broadcastactionfilter&quot; -e name zhy</span><br></pre></td></tr></table></figure>

<h3 id="启动服务："><a href="#启动服务：" class="headerlink" title="启动服务："></a>启动服务：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice &quot;com.zhy.aaa&#x2F;com.zhy.aaa.MyService&quot;</span><br></pre></td></tr></table></figure>

<h3 id="屏幕截图："><a href="#屏幕截图：" class="headerlink" title="屏幕截图："></a>屏幕截图：</h3><ul>
<li>可以使用screencap命令来进行手机屏幕截图，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap &#x2F;sdcard&#x2F;screen.png</span><br></pre></td></tr></table></figure>

<h3 id="录制视频："><a href="#录制视频：" class="headerlink" title="录制视频："></a>录制视频：</h3><p>可以使用screenrecord[options] filename命令来录制屏幕视频，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord &#x2F;sdcard&#x2F;demo.mp4</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/" itemprop="url">多进程(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T19:56:56+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按照操作系统中的描述。线程是 CPU 调度的最小单元，同时线程也是一种有限的资源。而进程一般指一个执行单元，在 PC 和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程。对于 Android 来说，它是一种基于 Linux 内核的移动操作系统，它的进程和线程有着其特有的性质。我们这篇文章就来聊聊关于 Android 中的进程和线程，我们需要了解的知识。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>我们都知道Android系统是基于Linux改造而来的，进程系统也是一脉相承，进程，其实就是程序的具体实现。当程序第一次启动，Android会启动一个Linux进程（具体由Zygote fork出来）以及一个主线程，默认的情况下，所有组件都将运行在该进程内。同一个应用由系统分配一个独立的Linux账户，该应用的产生的所有进程，都会是这同一个Linux账户。</p>
<h2 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h2><p>在开发中，我们通常会使用修改清单文件的<code>android:process</code>来使用多进程。<code>activity</code>、<code>service</code>、<code>receiver</code> 和 <code>provider</code>均支持<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。如果<code>android:process</code>的value值以冒号<code>:</code>开头的话，那么该进程就是私有进程，如果是以其他字符开头，那么就是公有进程，拥有相同 ShareUID 的不同应用可以跑在同一进程里。另外，我们还可以通过设置<code>application</code>的<code>android:process</code>属性，来设置所有组件的默认进程。</p>
<p><strong>私有进程</strong></p>
<p>如果<code>android:process</code>的值以冒号开头的话，那么该进程就是<strong>私有进程</strong>，如下：</p>
<p><code>&lt;service android:name=&quot;.ProcessTestService&quot; android:process=&quot;:remote&quot;/&gt;</code>   </p>
<p>这种设置形式表示该进程为当前应用的私有进程，<strong>其他应用的组件不可以和它跑在同一个进程中</strong>。</p>
<p><strong>公有进程</strong></p>
<p>进程名称不以“:”开头的进程都可以叫公有进程，如</p>
<p><code>&lt;service android:name=&quot;.ProcessTestService&quot; android:process=&quot;remote&quot;/&gt;</code>   </p>
<p>以小写字母开头，表示运行在一个以这个名字命名的全局进程中，<strong>其他应用通过设置相同的ShareUID可以和它跑在同一个进程</strong>。</p>
<p><strong>ShareUID</strong></p>
<p>ShareUserId，在Android里面每个app都有一个唯一的linux user ID，则这样权限就被设置成该应用程序的文件只对该用户可见，只对该应用程序自身可见，而我们可以使他们对其他的应用程序可见，这会使我们用到SharedUserId，也就是让两个apk使用相同的userID，这样它们就可以看到对方的文件。为了节省资源，具有相同ID的apk也可以在相同的linux进程中进行(注意，并不是一定要在一个进程里面运行)，共享一个虚拟机。<br>ShareUserId的作用，数据共享、调用其他程序资源。</p>
<h2 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h2><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入 “重要性层次结构” 中。必要时，系统会首先消除重要性最低的进程，然后是重要性相对较高的进程，以此类推，以回收进程。</p>
<h3 id="前台进程-—-Foreground-process"><a href="#前台进程-—-Foreground-process" class="headerlink" title="前台进程 — Foreground process"></a>前台进程 — Foreground process</h3><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即是为前台进程：</p>
<ul>
<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>
<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>托管正在 “前台” 运行的 Service（服务已调用 startForeground()）</li>
<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>托管正执行其 onReceive() 方法的 BroadcastRecevier</li>
</ul>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支撑他们同时运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>
<h3 id="可见进程-—-Visible-process"><a href="#可见进程-—-Visible-process" class="headerlink" title="可见进程 — Visible process"></a>可见进程 — Visible process</h3><p> 没有任何前台组件、但仍会影响用户在屏幕上所见内存的进程</p>
<ul>
<li><p>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）例如，如果前台 <code>Activity</code> 启动了一个对话框，允许在其后显示上一 <code>Activity</code>，则有可能会发生这种情况。</p>
</li>
<li><p>托管绑定到可见（或前台）Activity 的 Service</p>
</li>
</ul>
<p>可见进程被视为极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
<h3 id="服务进程-—-Service-process"><a href="#服务进程-—-Service-process" class="headerlink" title="服务进程 — Service process"></a>服务进程 — Service process</h3><p>​        正在运行已使用 startService() 方法启动的服务且不属于和上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但它们通常在「执行一些用户关心的操作」（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维护所有前台进程和可见进程同时运行，否则会让服务进程保持运行状态。</p>
<h3 id="后台进程-—-Background-process"><a href="#后台进程-—-Background-process" class="headerlink" title="后台进程 — Background process"></a>后台进程 — Background process</h3><p>​        包含目前对用户不可见的 <code>Activity</code> 的进程（已调用 <code>Activity</code> 的 <code>onStop()</code> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 <code>Activity</code> 的进程最后一个被终止。如果某个 <code>Activity</code> 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 <code>Activity</code> 时，<code>Activity</code> 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 <code>Activity</code>文档。</p>
<h3 id="空进程-—-Empty-process"><a href="#空进程-—-Empty-process" class="headerlink" title="空进程 — Empty process"></a>空进程 — Empty process</h3><p>​        不含任意活动应用组件的进程。保留这种进程的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>进程按照状态分完重要性之后，就要开始杀进程了。Android的Low Memory Killer基于Linux的OOM机制，在Linux中，内存是以页面(page)为单位，当申请页面分配不足的时候，系统会通过Low Memory Killer来杀掉bad进程，释放内存。Low Memory Killer会根据进程的adj级别以及所占的内存，来决定是否杀掉该进程，adj越大，占用内存越多，进程越容易被杀掉。</p>
<h4 id="adj分级："><a href="#adj分级：" class="headerlink" title="adj分级："></a>adj分级：</h4><ul>
<li>UNKNOWN_ADJ = 16<br>级别最低级的进程，通常是被缓存的进程，但是系统也不清楚缓存的内容。</li>
<li>CACHED_APP_MAX_ADJ = 15<br>这是一个只托管不可见的活动的进程，因此可以在没有任何中断的情况下被杀死。</li>
<li>CACHED_APP_MIN_ADJ = 9<br>缓存进程，没有英文解释。</li>
<li>SERVICE_B_ADJ = 8<br>不活跃的服务，不想adj=5的服务那么活跃。<br>PS:这里说一句，在root以后，有的系统优化大师，会把所有服务统一调成adj=8这个级别，来达到内存优化的目的。</li>
<li>PREVIOUS_APP_ADJ = 7<br>被切换的进程，一般是用户前一个使用的进程。两个应用来回切换，那么前一个应用一般adj设置为7。</li>
<li>HOME_APP_ADJ = 6<br>与主应用程序有交互的进程。</li>
<li>SERVICE_ADJ = 5<br>活跃的服务进程。</li>
<li>HEAVY_WEIGHT_APP_ADJ = 4<br>高权重进程</li>
<li>BACKUP_APP_ADJ = 3<br>正在备份的进程</li>
<li>PERCEPTIBLE_APP_ADJ = 2<br>可感知进程（通常是前台Service进程）</li>
<li>VISIBLE_APP_ADJ = 1<br>可见进程</li>
<li>FOREGROUND_APP_ADJ = 0<br>前台进程</li>
</ul>
<p>剩下的就是adj值为负数的进程，基本上都是系统集成，不在本文的讨论范围内。负数进程是不会被lmk杀掉的。</p>
<h4 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h4><p>首先通过 adb shell ps 指令查找对应进程的pid</p>
<p>然后通过 adb shell cat /proc/${pid}/oom_adj（设备需要root）返回对应进程的adj值。</p>
<p>还可以把oom_adj替换成oom_score或者oom_score_adj来查看这两项的数值，当oom_adj相同时，LowMemoryKiller会根据oom_score_adj和RSS内存大小来杀掉对应的进程。</p>
<h2 id="整个app都在一个进程有什么弊端？"><a href="#整个app都在一个进程有什么弊端？" class="headerlink" title="整个app都在一个进程有什么弊端？"></a>整个app都在一个进程有什么弊端？</h2><p>在Android中，虚拟机分配给各个进程的运行内存是有限制值的（这个值可以是32M，48M，64M等，根据机型而定），试想一下，如果在app中，增加了一个很常用的图片选择模块用于上传图片或者头像，加载大量Bitmap会使app的内存占用迅速增加，如果你还把查看过的图片缓存在了内存中，那么OOM的风险将会大大增加，如果此时还需要使用WebView加载一波网页，我就问你怕不怕！</p>
<p><strong>微信，微博等主流app是如何解决这些问题的？</strong></p>
<p>微信移动开发团队在 <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=400656149&idx=1&sn=122b4f4965fafebf78ec0b4fce2ef62a&mpshare=1&scene=1&srcid=0501f6p8yRsM5qj6OBKEVY1T&key=16e063fbfd27c52cdf5c92791e0542126da55aeb373dcd13df6aa6c417ec61127af2618384b2201ffa7c918e4bbe6780b4d20d3e2ec989af4e2ec3adfda18308cac9706ac4f970ae73fb86211c44b7c2&ascene=0&uin=ODExMTkxNjU%3D&devicetype=iMac+MacBookPro11%2C2+OSX+OSX+10.12.3+build&version=12020510&nettype=WIFI&fontScale=100&pass_ticket=AxhG0QxjCX8weF512sU8ttFb%2B7z%2B8JxvShlgh7diOtM%3D" target="_blank" rel="noopener">《Android内存优化杂谈》</a> 一文中就说到：“对于webview，图库等，由于存在内存系统泄露或者占用内存过多的问题，我们可以采用单独的进程。微信当前也会把它们放在单独的tools进程中”。</p>
<p><img src="http://jsh180.net/image/jpg/ps.png" alt="img"></p>
<p><strong>进入adb shell后，使用 “ps | grep 条目名称” 可以过滤出想要查看的进程。</strong></p>
<p>可以看到，微信的确有一个tools进程，而新浪微博也有image相关的进程，而且它们当中还有好些其它的进程，比如微信的push进程，微博的remote进程等，这里可以看出，他们不单单只是把上述的WebView、图库等放到单独的进程，还有推送服务等也是运行在独立的进程中的。一个消息推送服务，为了保证稳定性，可能需要和UI进程分离，分离后即使UI进程退出、Crash或者出现内存消耗过高等情况，仍不影响消息推送服务。</p>
<p><strong>可见，合理使用多进程不仅仅是有多大好处的问题，我个人认为而且是很有必要的。</strong></p>
<h2 id="为什么需要“跨进程通讯”？"><a href="#为什么需要“跨进程通讯”？" class="headerlink" title="为什么需要“跨进程通讯”？"></a>为什么需要“跨进程通讯”？</h2><p>Android的进程与进程之间通讯，有些不需要我们额外编写通讯代码，例如：把选择图片模块放到独立的进程，我们仍可以使用startActivityForResult方法，将选中的图片放到Bundle中，使用Intent传递即可。（看到这里，你还不打算把你项目的图片选择弄到独立进程么？）</p>
<p>但是对于把“消息推送Service”放到独立的进程，这个业务就稍微复杂点了，这个时候可能会发生Activity跟Service传递对象，调用Service方法等一系列复杂操作。</p>
<p>由于各个进程运行在相对独立的内存空间，所以它们是不能直接通讯的，因为程序里的变量、对象等初始化后都是具有内存地址的，举个简单的例子，读取一个变量的值，本质是找到变量的内存地址，取出存放的值。不同的进程，运行在相互独立的内存（其实就可以理解为两个不同的应用程序），显然不能直接得知对方变量、对象的内存地址，这样的话也自然不能访问对方的变量，对象等。此时两个进程进行交互，就需要使用跨进程通讯的方式去实现。简单说，跨进程通讯就是一种让进程与进程之间可以进行交互的技术。</p>
<h3 id="跨进程通讯的方式有哪些？"><a href="#跨进程通讯的方式有哪些？" class="headerlink" title="跨进程通讯的方式有哪些？"></a>跨进程通讯的方式有哪些？</h3><ol>
<li>四大组件间传递Bundle;</li>
<li>使用文件共享方式，多进程读写一个相同的文件，获取文件内容进行交互；</li>
<li>使用Messenger，一种轻量级的跨进程通讯方案，底层使用AIDL实现；</li>
<li>使用AIDL(Android Interface Definition Language)，Android接口定义语言，用于定义跨进程通讯的接口；</li>
<li>使用ContentProvider，常用于多进程共享数据，比如系统的相册，音乐等，我们也可以通过ContentProvider访问到；</li>
<li>使用Socket传输数据。</li>
</ol>
<h2 id="多进程的应用场景"><a href="#多进程的应用场景" class="headerlink" title="多进程的应用场景"></a>多进程的应用场景</h2><h3 id="常驻后台任务应用"><a href="#常驻后台任务应用" class="headerlink" title="常驻后台任务应用"></a>常驻后台任务应用</h3><p>类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。</p>
<p>现在要做一款音乐播放器，现在有以下几种方案：</p>
<p>A. 在Activity中直接播放音乐。<br>B. 启动后台Service，播放音乐。<br>C. 启动前台Service，播放音乐。<br>D. 在新的进程中，启动后台Service，播放音乐。<br>E. 在新的进程中，启动前台Service，播放音乐。</p>
<h4 id="分析A方案"><a href="#分析A方案" class="headerlink" title="分析A方案"></a>分析A方案</h4><p>在A中，我们的播放器是直接在activity中启动的。首先这么做肯定是不对的，我们需要在后台播放音乐，所以当activity退出后就播不了了，之所以给出这个例子是为了控制变量作对比。</p>
<p>音乐播放器无非是 <strong>打开app，选歌，播放，退到桌面，切其他应用</strong>。我们选取了三个场景，<strong>打开、按home切换其他应用、按back退回桌面</strong>。让我们看一下<strong>A</strong>的相对应的 <strong>oom_adj、oom_score、oom_score_adj</strong> 的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHcyc5RrvgkqdibQvj7lPkn7Vf2tAOYACeM1MbAokOdyUkibB8nOmeHzzA/640?wx_fmt=jpeg" alt="打开状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHf14icAA7Qic83Op12RtibFnmniaicjjDicYT23UIPAeib35wtu2smUo7nU4sg/640?wx_fmt=jpeg" alt="按了Home键被切换状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHL8wZicbIN8h3FMkmeiapWQ3S25xXJqc3sVAmzAFPvfwrn6mGkFWnK2WQ/640?wx_fmt=jpeg" alt="按了Back键被退出状态"></p>
<p>当我们应用在前台的时候，无论 adj 还是 score 还是 score_adj，他们的值都非常的小，基本不会被LMK所杀掉，但是当我们<strong>按了Home</strong>之后，进程的 adj 就会急剧增大，变为 <strong>7</strong>，相应的 score 和 score_adj 也会增大。</p>
<p>在上篇文章中我们得知，<strong>adj=7</strong> 即为 <strong>被切换的进程</strong>，两个进程来回切换，上一个进程就会被设为7。当我们<strong>按Back键</strong>的时候，adj 就会被设为 <strong>9</strong>，也就是<strong>缓存进程</strong>，优先级比较低，有很大的几率被杀掉。</p>
<h4 id="接着我们分析B"><a href="#接着我们分析B" class="headerlink" title="接着我们分析B"></a>接着我们分析B</h4><p><strong>启动后台Service，播放音乐</strong></p>
<p>B是直接启动一个后台service并且播放音乐，这个处理看起来比A好了很多，那么实际上，B的各个场景的优先级和A又有什么不同呢？让我们来看下B的对应的 打开、切换、退出相应 的 adj、score、score_adj 的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHVr6pjKo7ykhEl2ANGvlRvVE89Kf6jDAqdx0uSfrGxqAtyvGJjfYugg/640?wx_fmt=jpeg" alt="打开状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHQlEtnyG5aHpF3OG98c0e6R6s1V54eJrhEkSrDT9hbCSOXxzE9qad5w/640?wx_fmt=jpeg" alt="按了Home键被切换状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHc8Kq3VtWdIrTTWqBHyXDgOEXZRZKEMn14mk4Kzauo48dmBNTBt371g/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>B的情况其实是与A类似的，三种状态的 adj、score_adj 的值都是一样的，只有 score 有一点出入，其实分析源码得知，LMK杀进程的时候，score 的左右其实并不大，所以我们暂时忽略它。所以，与A相比，他们的 adj 和 score_adj 的值都相同，如果遇到内存不足的情况下，这两个应用谁占得内存更大，谁就会被杀掉。不过鉴于A实在 activity 中播放音乐，所以B还是比A略好的方案。</p>
<p>这里有朋友肯定要问了，为什么切到后台后，adj的值是<strong>7</strong>而不是<strong>5</strong>，后台不是还有service在跑吗？</p>
<p>我们通过查看源码可以找出来，当切换Home的时候，会调用 ActivityStack.java 的 finishCurrentActivityLocked 函数，然后调用到了 ActivityManagerService.java的computeOomAdjLocked 函数，在这里，对进程的 ADJ 值进行重新计算。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGH1ibiaP5BqV16uxkib5bIRAqDrsFGFYzjZGfo1HicSicploZCuicxCZ9axylQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h4 id="接下来分析C"><a href="#接下来分析C" class="headerlink" title="接下来分析C"></a>接下来分析C</h4><p><strong>启动前台Service，播放音乐</strong></p>
<p><strong>C</strong>的话是启动一个前台Service来播放音乐。让我们来看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHiaUkuJPHFYESPevxKQlolnqM0zTnbWHRTibCMABdIuAIdUkgiayjAEl7A/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHnJvlKYnSibkVfEj8v2HgZLb526NnhLTskqarPwQ380VWt483ueh9mrA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHuPkF4v4L1Q141L9K4v6SF0jqqd0GGels6UOhces082CnXJMTuibbqYg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>在前台的时候，和AB是一样的，adj 都是 0，当切到后台，或者back结束时，C对应的 adj 就是 2，也就是可感知进程。adj=2 可以说是很高优先级了，非root手机，非系统应用已经没有办法将其杀掉了。具体可参见 ActivityManagerService：</p>
<blockquote>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java</a></p>
</blockquote>
<p>中的 <strong>killBackgroundProcesses</strong> 方法以及 <strong>killPackageProcessesLocked</strong> 方法。<strong>adj&lt;5</strong> 的应用不会被杀掉。</p>
<p>总的来说，C方案比B优秀，拥有 前台Service 的C更不容易被系统或者其他应用所杀掉了，进程的优先级一下子提高到了2，相对于B来说更稳定，用户体验更好。不过有一点不足是必须启动一个前台service。不过现在大部分的音乐类软件都会提供一个前台service，也就不是什么缺点了。其实也是有灰色方法可以启动一个不显示通知的前台service，这里就不过多介绍了。</p>
<p>那么还有可改进的余地吗？答案当然是肯定的。</p>
<h4 id="让我们来看看D"><a href="#让我们来看看D" class="headerlink" title="让我们来看看D"></a>让我们来看看D</h4><p><strong>在新的进程中，启动后台Service，播放音乐</strong></p>
<p><strong>D</strong>把应用进行了拆分，把用于播放音乐的service放到了新的进程内，让我们看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHKI1mzbia2qcfdjgnw5Ojaxdwn2lfayRoFXDg7Bk22OLx3SRbV3n3NEg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHLnzrJmOnE4L8TIuAOCerxTR6icwsavwtlBThXom8YeNN6bAB0L6Iiagg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHFEQn5QfE2aXWj3a4KynNjQibkU73icPrl3Z9uxwAiaASAcmKcpghRZPKQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>上面三张图对应的是<strong>D</strong>应用主进程的ADJ相关值，我们可以看出来，跟<strong>A</strong>类似，adj都是0，7，9。由于少了service部分，内存使用变少，最后计算出的 oom_score_adj 也更低了，意味着主进程部分也更不容易被杀死。</p>
<p>下面我们看下拆分出的service的相关值</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHmZzGib1icZjK3wicCSFEBs4KJSYq3RFJy1gxBAp3tBGONgdSssjjL9n7w/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>因为是service进程，所以不受打开，关闭，切换所影响，这里就放了一张图。</p>
<p>我们可以看到，service的 adj 值一直是 5，也就是活跃的服务进程，相比于B来说，优先级高了不少。不过对于C来说，其实这个方案反倒不如C的 adj=2 的前台进程更稳定。但是D可以自主释放主进程，使D实际所占用的内存很小，从而不容易被杀掉。那么到底C和D谁是更优秀的设计？我个人认为，在ABCDE这5个设计中，D是最具智慧的设计，具体是为什么？先卖个关子，等我们说完了E，再作总结。</p>
<p><strong>那就赶紧分析E吧</strong></p>
<p><strong>在新的进程中，启动前台Service，播放音乐</strong></p>
<p><strong>E</strong>也是使用了多进程，并且在新进程中，使用了前台service，先来看下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHnIjZc1LThH8XPFUYSVRU5tNC9InsObWXhR1UcDF5qU5ppu145whL8A/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHJbdbhWIbCdagxpPZBIfJiaZT4HgZw7gEibAVTdyL80jsanBLchUC1rXg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHgqicd37ychiax3l4fL0FyjwqzB2kSibPUSyvvia38N0AbkZGqU6OA8RcNA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>这个不多解释，和ABD基本差不多，都是0，7，9。我们看下拆分出来的进程的值。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHN6Fu6BWgh59ShhVXpKgm0gkycurmTHUEdO2dqt1w5BVJUDV6JicKDSA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>我们可以看到，这个进程的值是 <strong>2</strong>，像<strong>C</strong>方案，非常小，非常稳定，而且，我们还可以在系统进入后台后，手动杀掉主进程，使整个应用的内存消耗降到最低，内存低，优先级又高。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ABCDE，5种方案都已经分析完了。显然，<strong>E是最稳定的方案</strong>，不过，我刚才说过，我个人最倾向于<strong>D</strong>方案，并且认为<strong>D是最智慧的方案</strong>，这是为什么呢？</p>
<p>景点平常没人的时候还好，谁拿票都能进，当人逐渐拥挤的时候，保安就开始根据票的等级，往外轰人。E方案就是一个拿着普通票的妈妈，带着一个VIP的孩子去参观，D方案就是一个拿着普通票的妈妈，带着一个拿着中等票的孩子参观。当内存不够的时候，保安会先把两个妈妈轰出去，孩子们在里面看，再不够了，就会把D孩子给轰出去。这么看来，显然E的效果更好一些，不过由于Android系统对于VIP票的发放没有节制，大家都可以领VIP票，那也就是相当于没有VIP票了。所以如果E方案是一种精明，那么D才是真正的智慧。将调度权还给系统，做好自己，维护好整个Android生态。</p>
<h3 id="可以获得更多内存"><a href="#可以获得更多内存" class="headerlink" title="可以获得更多内存"></a>可以获得更多内存</h3><p>可以获得更多内存。进程是系统分配资源和调度的基本单位，进程越多得到的资源就越多。Android对内存的限制是针对于进程的。设置为多个进程就可以获取更多的资源。</p>
<h3 id="分散内存的占用"><a href="#分散内存的占用" class="headerlink" title="分散内存的占用"></a>分散内存的占用</h3><p>我们知道Android系统对每个应用进程的内存占用是有限制的，而且占用内存越大的进程，通常被系统杀死的可能性越大。让一个组件运行在单独的进程中，可以减少主进程所占用的内存，避免OOM问题，降低被系统杀死的概率，</p>
<h3 id="实现多模块"><a href="#实现多模块" class="headerlink" title="实现多模块"></a>实现多模块</h3><p>比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。</p>
<blockquote>
<p>当我们的应用开发越来越大，模块越来越多，团队规模也越来越大，协作开发也是个很麻烦的事情。项目解耦，模块化，是这阶段的目标。通过模块解耦，开辟新的进程，独立的JVM，来达到数据解耦目的。模块之间互不干预，团队并行开发，责任分工也明确。</p>
</blockquote>
<h3 id="单一进程崩溃并不影响整体应用的使用"><a href="#单一进程崩溃并不影响整体应用的使用" class="headerlink" title="单一进程崩溃并不影响整体应用的使用"></a>单一进程崩溃并不影响整体应用的使用</h3><p>多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap 申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。</p>
<h3 id="主进程退出，子进程可以继续工作"><a href="#主进程退出，子进程可以继续工作" class="headerlink" title="主进程退出，子进程可以继续工作"></a>主进程退出，子进程可以继续工作</h3><p>主进程退出，子进程可以继续工作，这个最常见的的情况是，主进程启动了推送服务，在主进程结束之后，用户仍然能一直收到推送服务</p>
<h2 id="多进程的问题"><a href="#多进程的问题" class="headerlink" title="多进程的问题"></a>多进程的问题</h2><h3 id="进程之间的内存空间是相互不可见的"><a href="#进程之间的内存空间是相互不可见的" class="headerlink" title="进程之间的内存空间是相互不可见的"></a>进程之间的内存空间是相互不可见的</h3><h3 id="Application的多次重建"><a href="#Application的多次重建" class="headerlink" title="Application的多次重建"></a>Application的多次重建</h3><p>不同进程跑在不同虚拟机上，每个虚拟机上会创建自己的Application 所以在Application中的只存放尽可能少的逻辑，有些sdk要求一定在Application中，此时可以判断当前是否在主进程中，只有主进程中才启动相应逻辑。</p>
<p><strong>思路：判断是否为主进程，只有主进程的时候才执行初始化的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String getProcessName() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;&quot; + android.os.Process.myPid() + &quot;&#x2F;&quot; + &quot;cmdline&quot;);</span><br><span class="line">        BufferedReader mBufferedReader &#x3D; new BufferedReader(new FileReader(file));</span><br><span class="line">        String processName &#x3D; mBufferedReader.readLine().trim();</span><br><span class="line">        mBufferedReader.close();</span><br><span class="line">        return processName;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例-静态变量的失效"><a href="#单例-静态变量的失效" class="headerlink" title="单例/静态变量的失效"></a>单例/静态变量的失效</h3><p>每个进程中保持有独立的一份单例，单例退化为某进程中的单例，而不是整个app运行期间的单例 静态变量相对于类仍然只有一份，但是不同进程中同一个类会加载两次，所以一个类中的静态变量每个进程都独立有一个值，之间没有任何关联</p>
<h3 id="文件共享问题"><a href="#文件共享问题" class="headerlink" title="文件共享问题"></a>文件共享问题</h3><p>多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等。在多线程的情况下我们有锁机制控制资源的共享，但是在多进程中比较难，虽然有文件锁、排队等机制，但是在Android里很难实现。解决办法就是多进程的时候不并发访问同一个文件，比如子进程涉及到操作数据库，就可以考虑调用主进程进行数据库的操作。</p>
<h3 id="线程同步机制可能失效"><a href="#线程同步机制可能失效" class="headerlink" title="线程同步机制可能失效"></a>线程同步机制可能失效</h3><p>例如原本一个线程池中我们最多只希望有2个线程在运行，如果这个线程池同时在两个进程中均存在，那么就可以有4个线程同时运行</p>
<h3 id="ObjectBox"><a href="#ObjectBox" class="headerlink" title="ObjectBox"></a>ObjectBox</h3><p>objectbox在多进程中使用时有坑，项目在单进程时运行很稳定，但配置成多进程之后。Buggly上存在很多Objectbox上报的crash，我们不知道其中错误的细节，但是坑是肯定存在的。</p>
<h3 id="SqlLite"><a href="#SqlLite" class="headerlink" title="SqlLite"></a>SqlLite</h3><p>android API 26 Platform中包含sqllite。一下是一段关于Sqllite的官网介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQLite是一个很快的数据库，但&quot;快&quot;这个词本身是一个主观的和模糊不清的词。坦白地讲，对于有些事情，SQLite比其他数据库做得快，也有些事情比不上其他数据库。利用SQLite提供的配置参数，SQLite是足够快速和高效的。与大多数数据库一样，SQLite使用B-tree做索引，使用B+-tree处理表。因此，在对单表进行查询时，平均而言，SQLite与其他数据库一样快（至少不慢于）。简单的SELECT、INSERT和UPDATE语句是相当快速的--几乎与内存（如果是内存数据库）或者磁盘同速。SQLite通常要快于其他数据库，因为它在处理一个事务开始，或者一个查询计划的产生方面开销较小，并且没有调用服务器的网络或认证以及权限协商的开销。它的简单性使它更快。</span><br><span class="line"></span><br><span class="line">但是随着查询变大变复杂，查询时间使得网络调用或者事务处理开销相形见绌，SQLite将会与其他数据库一样。这时一些大型的设计复杂的数据库开始发挥作用了。虽然SQLite也能处理复杂的查询，但是它没有精密的优化器或者查询计划器。SQLite知道如何使用索引，但是它没有保存详细的表统计信息。假如执行17路join，SQLite也会连接表并给您结果，并不像您在Oracle或者PostgreSQL中期望的那样，SQLite没有通过计算各种替代查询计划并选择最快的候选计划来尝试判断优化路径。因此，假如您在大型数据集合上运行复杂的查询，SQLite与那些有复杂设计的查询计划器的数据库运行一样快的机会是非常小的。</span><br><span class="line"></span><br><span class="line">一些情况下，SQLite可能不如大型数据库快，但大多数的这些情况是预期的。SQLite是为中小规模的应用程序设计的一个嵌入式的数据库，这些限制是设计目的预见到的。许多新用户错误地认为使用SQLite可以代替大型关系数据库。事实是有时可以这样做，有时不行，这完全取决于您准备用SQLite来做什么。</span><br><span class="line"></span><br><span class="line">一般情况下，SQLite的局限性主要有以下两方面：</span><br><span class="line"></span><br><span class="line">并发。SQLite的锁机制是粗粒度的，它允许多个读，但是一次只允许一个写。写锁会在写期间排他地锁定数据库，其他人在此期间不能访问数据库。SQLite已经采取措施以最小化排它锁所占用的时间。通常来讲，SQLite中的锁只保持几毫秒。但是按照一般经验，如果您的应用程序有很高的写并发（许多连接竞争向同一数据库写），并且是时间关键型，您可能需要其他数据库。需要实际测试您的应用程序才能知道能获得怎样的性能。作者曾见过一个简单的网络应用程序中，SQLite用100个并发连接每秒处理500多个事务。您的事务所修改的记录数以及查询所涉及的复杂性可能有所不同。什么样的并发性是可接受的，这取决于具体的应用程序，只能通过直接测试来判断。总之，对任何数据库都是真理：直到您做了实际测试才能知道应用程序能获得怎样的性能。</span><br><span class="line"></span><br><span class="line">网络。虽然SQLite数据库可以通过网络文件系统共享，但是与这种文件系统相关的潜在延时会导致性能受损。更糟的是，网络文件系统实现中的一些缺陷也使得打开和修改远程文件--SQLite或其他--很容易出错。如果文件系统的锁实现不当，可能允许两个客户端同时修改同一个数据库文件，这样必然会导致数据库出错。实际上，并不是因为SQLite的实现导致SQLite不能在网络文件系统上工作。相反，SQLite在底层文件系统和有线协议下工作，但是这些技术有时并不完善。例如，许多NFS使用有缺陷的fcntl()，这意味着锁可能并不像设想的那样工作。一些较新版本的NFS，如Solaris NFSV4就可以工作正常，SQLite需要的锁机制也是相当可靠的。然而，SQLite开发者既没有时间，也没有资源去验证任何给定的网络文件系统在所有的情况下都可以无缺陷工作。</span><br><span class="line"></span><br><span class="line">再次申明，绝大部分限制是有意设计的--它们是SQLite设计的结果。例如，支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。同样，作为嵌入式数据库，SQLite是有意不支持网络的。这一点并不奇怪。总之，SQLite不能做的都是它所能做的直接结果。它开始的设计就是一款模块化、简单、紧凑的以及易于使用的嵌入式关系数据库，它的基础代码都在使用它的程序员的掌握范围内。从多方面看，它能完成许多其他数据库不能做的事情，例如，运行在电力消耗实际上是一项制约因素的嵌入式环境中。</span><br></pre></td></tr></table></figure>

<p>当Android系统中存在多个进程时，会有多个SQLiteDatabase对象被创建出来，每个对象都去试图连接同一个数据文件，这个没有什么问题。我们的项目中使用的是“一写多读”的模式，一个进程写，多个进程读取，这个是OK的。</p>
<p>但是如果同时有多个进程进行写操作。个人认为大概率会存在问题，多进程中每个SQLiteDatabase中的锁必然是相互独立，彼此不关联的，那么这个锁必然拦截不住多个进程同时写同一张表的情况。</p>
<h4 id="其他DB"><a href="#其他DB" class="headerlink" title="其他DB"></a>其他DB</h4><p>总体来说，db在多进程间使用时，需要遵照一写多读的方式，并且这个db中没有缓存机制的情况下，还是可用的。但是如果像greendao或者其他本身包含缓存机制的db，那么多进程间即使使用一写多读的工作模式，同样存在风险，因为此时还存在内存与db文件之间不一致的风险</p>
<h3 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h3><p>使用文件同使用数据库本质上一样，全读 / 一写多读没有问题，但是存在多个写时，如何对多个写操作之间进行同步，这个是个大问题。目前看，没有找到什么工具内部处理好了这件事情，都需要业务层自己来做好互斥、管理。</p>
<h3 id="Broadcaster"><a href="#Broadcaster" class="headerlink" title="Broadcaster"></a>Broadcaster</h3><p>以上均是多进程之间对于持久化信息之间的共享，Android上多进程之间非持久化通信莫过于Broadcaster了。可以基于Broadcaster来封装一个好用一点的通信组件。</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>这个方式比较原始。相对于前面所有提到的通信方式，它最大的优点是：不需要context。看起来这不算什么有用的优点。不过特殊情况下，比如我们项目中，由于历史原因获取不到能够支持Service的Context，这个反而成了唯一的选项</p>
<h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>Messenger是基于AIDL实现的，服务端（被动方）提供一个Service来处理客户端（主动方）连接，维护一个Handler来创建Messenger，在onBind时返回Messenger的binder。</p>
<p>双方用Messenger来发送数据，用Handler来处理数据。Messenger处理数据依靠Handler，所以是串行的，也就是说，Handler接到多个message时，就要排队依次处理。</p>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>AIDL通过定义服务端暴露的接口，以提供给客户端来调用，AIDL使服务器可以并行处理，而Messenger封装了AIDL之后只能串行运行</p>
<h3 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h3><p>参考下面的后续看看： <a href="https://www.jianshu.com/p/875d13458538" target="_blank" rel="noopener">https://www.jianshu.com/p/875d13458538</a> <a href="https://juejin.im/entry/590833711b69e60058eb34b9" target="_blank" rel="noopener">https://juejin.im/entry/590833711b69e60058eb34b9</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>进程间的通信在实际场景中频次一般有限，总体来说，先想明白业务的需求。在确定通信需求不是很大的情况下，使用普通db + broadcast基本能满足需求了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/" itemprop="url">如何使用Aidl</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T11:58:35+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Aidl是什么"><a href="#Aidl是什么" class="headerlink" title="Aidl是什么"></a>Aidl是什么</h1><p>它全称是Android Interface Definition Language，即Android接口定义语言，为了使其他的进程也可以访问本进程提供的服务，Android使用AIDL来公开服务的接口，它里面定义了本进程可以为其他进程提供什么服务，即定义了一些方法，其他进程就可以通过RPC（远程调用）来调用这些方法，从而获得服务，其中提供服务的进程称为服务端，获取服务的进程称为客户端。</p>
<p><img src="http://gityuan.com/images/binder/prepare/binder_interprocess_communication.png" alt="binder_interprocess_communication"></p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>AIDL的语法十分简单，与Java语言基本保持一致，需要记住的规则有以下几点：</p>
<ol>
<li>AIDL文件以 <strong>.aidl</strong> 为后缀名</li>
<li>AIDL支持的数据类型分为如下几种： <ul>
<li>八种基本数据类型：byte、char、short、int、long、float、double、boolean</li>
<li>String，CharSequence</li>
<li>实现了Parcelable接口的数据类型</li>
<li>List 类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象</li>
<li>Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象</li>
</ul>
</li>
<li>AIDL文件可以分为两类。一类用来声明实现了Parcelable接口的数据类型，以供其他AIDL文件使用那些非默认支持的数据类型。还有一类是用来定义接口方法，声明要暴露哪些接口给客户端调用，定向Tag就是用来标注这些方法的参数值</li>
<li>定向Tag。定向Tag表示在跨进程通信中数据的流向，用于标注方法的参数值，分为 in、out、inout 三种。其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。此外，如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。</li>
<li>明确导包。在AIDL文件中需要明确标明引用到的数据类型所在的包名，即使两个文件处在同个包名下。</li>
</ol>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>客户端绑定服务端的service调用服务端的方法，实现应用数据共享</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>创建aidl接口定义外暴露方法，以及需要的传递的实体。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-5aeb537d22344755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对外接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TestAidl.aidl</span><br><span class="line">package com.zhyen.test;</span><br><span class="line">import com.zhyen.test.Book;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface TestAidl &#123;</span><br><span class="line">       List&lt;Book&gt; getBookList();</span><br><span class="line"></span><br><span class="line">       void addBookInOut(inout Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Book改为声明Parcelable数据类型的AIDL文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Book.aidl</span><br><span class="line">package com.zhyen.test;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>

<p>java类型实体类，注意包的结构相同。此处都是<code>com.zhyen.test</code></p>
<p>自定义数据类型，用于进程间通信的话，必须实现Parcelable接口，Parcelable是类似于Java中的Serializable，Android中定义了Parcelable，用于进程间数据传递，对传输数据进行分解，编组的工作，相对于Serializable，他对于进程间通信更加高效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.test;</span><br><span class="line"></span><br><span class="line">import android.os.Parcel;</span><br><span class="line">import android.os.Parcelable;</span><br><span class="line"></span><br><span class="line">public class Book implements Parcelable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Book(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;book name：&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readFromParcel(Parcel dest) &#123;</span><br><span class="line">        name &#x3D; dest.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Book(Parcel in) &#123;</span><br><span class="line">        this.name &#x3D; in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;Book&gt; CREATOR &#x3D; new Creator&lt;Book&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Book createFromParcel(Parcel source) &#123;</span><br><span class="line">            return new Book(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Book[] newArray(int size) &#123;</span><br><span class="line">            return new Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写服务端service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.test;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class AidlBookService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;AidlService&quot;;</span><br><span class="line">    private List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        books &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        Book book1 &#x3D; new Book(&quot;活着&quot;);</span><br><span class="line">        Book book2 &#x3D; new Book(&quot;或者&quot;);</span><br><span class="line">        Book book3 &#x3D; new Book(&quot;叶应是叶&quot;);</span><br><span class="line">        Book book4 &#x3D; new Book(&quot;https:&#x2F;&#x2F;github.com&#x2F;leavesC&quot;);</span><br><span class="line">        Book book5 &#x3D; new Book(&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9df45b87cfdf&quot;);</span><br><span class="line">        Book book6 &#x3D; new Book(&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;new_one_object&quot;);</span><br><span class="line">        books.add(book1);</span><br><span class="line">        books.add(book2);</span><br><span class="line">        books.add(book3);</span><br><span class="line">        books.add(book4);</span><br><span class="line">        books.add(book5);</span><br><span class="line">        books.add(book6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TestAidl.Stub stub &#x3D; new TestAidl.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public List&lt;Book&gt; getBookList() throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;getBookList: &quot;);</span><br><span class="line">            return books;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void addBookInOut(Book book) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;addBookInOut: &quot; + book);</span><br><span class="line">            books.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">            android:name&#x3D;&quot;.AidlBookService&quot;</span><br><span class="line">            android:enabled&#x3D;&quot;true&quot;</span><br><span class="line">            android:exported&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;com.zhyen.test.action&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure>

<p>服务端已经做好了</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-f2595f3330c66dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>客户端连带着aidl目录全都复制到main目录下，负责java类Book，注意包的结构。</p>
<p>编写客户端代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.base.IMyService;</span><br><span class="line">import com.zhyen.base.Student;</span><br><span class="line">import com.zhyen.test.Book;</span><br><span class="line">import com.zhyen.test.TestAidl;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestAIDLActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAIDLActivity&quot;;</span><br><span class="line">    private boolean bookConnected;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    private ServiceConnection connectionBook &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: &quot; + name);</span><br><span class="line">            bookConnected &#x3D; true;</span><br><span class="line">            testAidl &#x3D; TestAidl.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            bookConnected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private TestAidl testAidl;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_activity);</span><br><span class="line">        findViewById(R.id.btn_add_book).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (!bookConnected) return;</span><br><span class="line">                    testAidl.addBookInOut(new Book(&quot;呵呵哒&quot;));</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_book_list).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!bookConnected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    List&lt;Book&gt; bookList &#x3D; testAidl.getBookList();</span><br><span class="line">                    for (Book book : bookList) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;onClick: &quot; + book.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bindServiceBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bindServiceBook() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent();</span><br><span class="line">        intent.setPackage(&quot;com.zhyen.test&quot;);</span><br><span class="line">        intent.setAction(&quot;com.zhyen.test.action&quot;);</span><br><span class="line">        bindService(intent, connectionBook, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unbindService(connectionBook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 活着</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 或者</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 叶应是叶</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: https:&#x2F;&#x2F;github.com&#x2F;leavesC</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9df45b87cfdf</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: http:&#x2F;&#x2F;blog.csdn.net&#x2F;new_one_object</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 呵呵哒</span><br><span class="line">2020-05-21 18:33:13.679 31931-31931&#x2F;com.zhyen.android I&#x2F;chatty: uid&#x3D;10206(com.zhyen.android) identical 6 lines</span><br><span class="line">2020-05-21 18:33:13.679 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 呵呵哒</span><br></pre></td></tr></table></figure>

<h2 id="aidl编译后的样子"><a href="#aidl编译后的样子" class="headerlink" title="aidl编译后的样子"></a>aidl编译后的样子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> *&#x2F;</span><br><span class="line">package com.zhyen.test;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">public interface TestAidl extends android.os.IInterface &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.zhyen.test.TestAidl &#123;</span><br><span class="line">        private static final java.lang.String DESCRIPTOR &#x3D; &quot;com.zhyen.test.TestAidl&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Cast an IBinder object into an com.zhyen.test.TestAidl interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static com.zhyen.test.TestAidl asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin !&#x3D; null) &amp;&amp; (iin instanceof com.zhyen.test.TestAidl))) &#123;</span><br><span class="line">                return ((com.zhyen.test.TestAidl) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.zhyen.test.TestAidl.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">            java.lang.String descriptor &#x3D; DESCRIPTOR;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;com.zhyen.test.Book&gt; _result &#x3D; this.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_addBookInOut: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.zhyen.test.Book _arg0;</span><br><span class="line">                    if ((0 !&#x3D; data.readInt())) &#123;</span><br><span class="line">                        _arg0 &#x3D; com.zhyen.test.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _arg0 &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.addBookInOut(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    if ((_arg0 !&#x3D; null)) &#123;</span><br><span class="line">                        reply.writeInt(1);</span><br><span class="line">                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reply.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    return super.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.zhyen.test.TestAidl &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote &#x3D; remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public java.util.List&lt;com.zhyen.test.Book&gt; getBookList() throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.zhyen.test.Book&gt; _result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result &#x3D; _reply.createTypedArrayList(com.zhyen.test.Book.CREATOR);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addBookInOut(com.zhyen.test.Book book) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    if ((book !&#x3D; null)) &#123;</span><br><span class="line">                        _data.writeInt(1);</span><br><span class="line">                        book.writeToParcel(_data, 0);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _data.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBookInOut, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    if ((0 !&#x3D; _reply.readInt())) &#123;</span><br><span class="line">                        book.readFromParcel(_reply);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_getBookList &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">        static final int TRANSACTION_addBookInOut &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.util.List&lt;com.zhyen.test.Book&gt; getBookList() throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    public void addBookInOut(com.zhyen.test.Book book) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://gityuan.com/images/binder/AIDL/MyServer_java_binder.jpg" alt="aidl image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/" itemprop="url">自定义binder架构的C/S组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T17:46:25+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Native层Binder"><a href="#Native层Binder" class="headerlink" title="Native层Binder"></a>Native层Binder</h1><p>源码结构：</p>
<ul>
<li>ClientDemo.cpp: 客户端程序</li>
<li>ServerDemo.cpp：服务端程序</li>
<li>IMyService.h：自定义的MyService服务的头文件</li>
<li>IMyService.cpp：自定义的MyService服务</li>
<li>Android.mk：源码build文件</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取service manager引用</span><br><span class="line">    sp &lt; IServiceManager &gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">    &#x2F;&#x2F;注册名为&quot;service.myservice&quot;的服务到service manager</span><br><span class="line">    sm-&gt;addService(String16(&quot;service.myservice&quot;), new BnMyService());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool(); &#x2F;&#x2F;启动线程池</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool(); &#x2F;&#x2F;把主线程加入线程池</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将名为”service.myservice”的BnMyService服务添加到ServiceManager，并启动服务</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取service manager引用</span><br><span class="line">    sp &lt; IServiceManager &gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">    &#x2F;&#x2F;获取名为&quot;service.myservice&quot;的binder接口</span><br><span class="line">    sp &lt; IBinder &gt; binder &#x3D; sm-&gt;getService(String16(&quot;service.myservice&quot;));</span><br><span class="line">    &#x2F;&#x2F;将biner对象转换为强引用类型的IMyService</span><br><span class="line">    sp&lt;IMyService&gt; cs &#x3D; interface_cast &lt; IMyService &gt; (binder);</span><br><span class="line">    &#x2F;&#x2F;利用binder引用调用远程sayHello()方法</span><br><span class="line">    cs-&gt;sayHello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取名为”service.myservice”的服务，再进行类型，最后调用远程方法<code>sayHello()</code></p>
<h2 id="创建MyService"><a href="#创建MyService" class="headerlink" title="创建MyService"></a>创建MyService</h2><p><strong>IMyService.h</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">namespace android</span><br><span class="line">&#123;</span><br><span class="line">    class IMyService : public IInterface</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        DECLARE_META_INTERFACE(MyService); &#x2F;&#x2F;使用宏，申明MyService</span><br><span class="line">        virtual void sayHello()&#x3D;0; &#x2F;&#x2F;定义方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义命令字段</span><br><span class="line">    enum</span><br><span class="line">    &#123;</span><br><span class="line">        HELLO &#x3D; 1,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;申明客户端BpMyService</span><br><span class="line">    class BpMyService: public BpInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        BpMyService(const sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">        virtual void sayHello();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;申明服务端BnMyService</span><br><span class="line">    class BnMyService: public BnInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags &#x3D; 0);</span><br><span class="line">        virtual void sayHello();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能：</p>
<ul>
<li>申明IMyService</li>
<li>申明BpMyService（Binder客户端）</li>
<li>申明BnMyService（Binder的服务端）</li>
</ul>
<p><strong>IMyService.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">namespace android</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;使用宏，完成MyService定义</span><br><span class="line">    IMPLEMENT_META_INTERFACE(MyService, &quot;android.demo.IMyService&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;客户端</span><br><span class="line">    BpMyService::BpMyService(const sp&lt;IBinder&gt;&amp; impl) :</span><br><span class="line">            BpInterface&lt;IMyService&gt;(impl) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现客户端sayHello方法</span><br><span class="line">    void BpMyService::sayHello() &#123;</span><br><span class="line">        printf(&quot;BpMyService::sayHello\n&quot;);</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMyService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(HELLO, data, &amp;reply);</span><br><span class="line">        printf(&quot;get num from BnMyService: %d\n&quot;, reply.readInt32());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;服务端，接收远程消息，处理onTransact方法</span><br><span class="line">    status_t BnMyService::onTransact(uint_t code, const Parcel&amp; data,</span><br><span class="line">            Parcel* reply, uint32_t flags) &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case HELLO: &#123;    &#x2F;&#x2F;收到HELLO命令的处理流程</span><br><span class="line">            printf(&quot;BnMyService:: got the client hello\n&quot;);</span><br><span class="line">            CHECK_INTERFACE(IMyService, data, reply);</span><br><span class="line">            sayHello();</span><br><span class="line">            reply-&gt;writeInt32(2015);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现服务端sayHello方法</span><br><span class="line">    void BnMyService::sayHello() &#123;</span><br><span class="line">        printf(&quot;BnMyService::sayHello\n&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://gityuan.com/images/binder/binderSimple/native_binder_demo.jpg" alt="native_binder"></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><strong>编译生成</strong> 利用Android.mk编译上述代码，在Android的源码中，通过mm编译后，可生成两个可执行文件ServerDemo，ClientDemo。</p>
<p><strong>执行</strong></p>
<p>首先将这两个ServerDemo，ClientDemo可执行文件push到手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push ServerDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ClientDemo &#x2F;system&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>如果push不成功，那么先执行<code>adb remount</code>，再执行上面的指令；如果还不成功，可能就是权限不够。</p>
<p>如果上述开启成功，通过开启两个窗口运行（一个运行client端，另一个运行server端）</p>
<p><strong>结果</strong></p>
<p>服务端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/native_server.png" alt="native_server"></p>
<p>客户端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/native_client.png" alt="native_client"></p>
<h1 id="Framework层Binder"><a href="#Framework层Binder" class="headerlink" title="Framework层Binder"></a>Framework层Binder</h1><p>源码结构：</p>
<p>Server端</p>
<ol>
<li>ServerDemo.java：可执行程序</li>
<li>IMyService.java: 定义IMyService接口</li>
<li>MyService.java：定义MyService</li>
</ol>
<p>Client端</p>
<ol>
<li>ClientDemo.java：可执行程序</li>
<li>IMyService.java: 与Server端完全一致</li>
<li>MyServiceProxy.java：定义MyServiceProxy</li>
</ol>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><p><strong>ServerDemo.java</strong></p>
<p>可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;MyService Start&quot;);</span><br><span class="line">        &#x2F;&#x2F;准备Looper循环执行</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        &#x2F;&#x2F;设置为前台优先级</span><br><span class="line">        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        &#x2F;&#x2F;注册服务</span><br><span class="line">        ServiceManager.addService(&quot;MyService&quot;, new MyService());</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMyService.java</strong></p>
<p>定义sayHello()方法，DESCRIPTOR属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyService extends IInterface &#123;</span><br><span class="line">    static final java.lang.String DESCRIPTOR &#x3D; &quot;com.gityuan.frameworkBinder.MyServer&quot;;</span><br><span class="line">    public void sayHello(String str) throws RemoteException ;</span><br><span class="line">    static final int TRANSACTION_say &#x3D; android.os.IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyService.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Binder implements IMyService&#123;</span><br><span class="line"></span><br><span class="line">    public MyService() &#123;</span><br><span class="line">        this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 将MyService转换为IMyService接口 **&#x2F;</span><br><span class="line">    public static com.gityuan.frameworkBinder.IMyService asInterface( android.os.IBinder obj) &#123;</span><br><span class="line">        if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iInterface &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (((iInterface !&#x3D; null)&amp;&amp;(iInterface instanceof com.gityuan.frameworkBinder.IMyService)))&#123;</span><br><span class="line">            return ((com.gityuan.frameworkBinder.IMyService) iInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 服务端，接收远程消息，处理onTransact方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_say: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            String str &#x3D; data.readString();</span><br><span class="line">            sayHello(str);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 自定义sayHello()方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        System.out.println(&quot;MyService:: Hello, &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><p><strong>ClientDemo.java</strong></p>
<p>可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Client start&quot;);</span><br><span class="line">        IBinder binder &#x3D; ServiceManager.getService(&quot;MyService&quot;); &#x2F;&#x2F;获取名为&quot;MyService&quot;的服务</span><br><span class="line">        IMyService myService &#x3D; new MyServiceProxy(binder); &#x2F;&#x2F;创建MyServiceProxy对象</span><br><span class="line">        myService.sayHello(&quot;binder&quot;); &#x2F;&#x2F;通过MyServiceProxy对象调用接口的方法</span><br><span class="line">        System.out.println(&quot;Client end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMyService.java</strong></p>
<p>与Server端的IMyService是一致，基本都是拷贝一份过来。</p>
<p><strong>MyServiceProxy.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyServiceProxy implements IMyService &#123;</span><br><span class="line">    private android.os.IBinder mRemote;  &#x2F;&#x2F;代表BpBinder</span><br><span class="line"></span><br><span class="line">    public MyServiceProxy(android.os.IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">        return DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 自定义的sayHello()方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) throws RemoteException &#123;</span><br><span class="line">        android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(str);</span><br><span class="line">            mRemote.transact(TRANSACTION_say, _data, _reply, 0);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://gityuan.com/images/binder/binderSimple/MyServer_framework_binder.jpg" alt="framework_binder"></p>
<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>首先将ServerDemo，ClientDemo可执行文件，以及ServerDemo.jar，ClientDemo.jar都push到手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push ServerDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ClientDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ServerDemo.jar &#x2F;system&#x2F;framework</span><br><span class="line">adb push ClientDemo.jar &#x2F;system&#x2F;framework</span><br></pre></td></tr></table></figure>

<p>如果push不成功，那么先执行<code>adb remount</code>，再执行上面的指令；如果还不成功，可能就是权限不够。</p>
<p>如果上述开启成功，通过开启两个窗口运行（一个运行client端，另一个运行server端）</p>
<p><strong>结果</strong></p>
<p>服务端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/framework_server.png" alt="framework_server"></p>
<p>客户端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/framework_client.png" alt="framework_client"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/" itemprop="url">Binder机制framework层分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T13:42:10+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><p>基于6.0.0_r1地址<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r1/core/java/android/os/" target="_blank" rel="noopener">源码地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">  - IInterface.java</span><br><span class="line">  - IServiceManager.java</span><br><span class="line">  - ServiceManager.java</span><br><span class="line">  - ServiceManagerNative.java(内含ServiceManagerProxy类)</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">  - IBinder.java</span><br><span class="line">  - Binder.java(内含BinderProxy类)</span><br><span class="line">  - Parcel.java</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">  - BinderInternal.java</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;jni&#x2F;</span><br><span class="line">  - AndroidRuntime.cpp</span><br><span class="line">  - android_os_Parcel.cpp</span><br><span class="line">  - android_util_Binder.cpp</span><br></pre></td></tr></table></figure>

<p><strong>IInterface</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Base class for Binder interfaces.  When defining a new interface,</span><br><span class="line"> * you must derive it from IInterface.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve the Binder object associated with this interface.</span><br><span class="line">     * You must use this instead of a plain cast, so that proxy objects</span><br><span class="line">     * can return the correct result.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IServiceManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Basic interface for finding and publishing system services.</span><br><span class="line"> * </span><br><span class="line"> * An implementation of this interface is usually published as the</span><br><span class="line"> * global context object, which can be retrieved via</span><br><span class="line"> * BinderNative.getContextObject().  An easy way to retrieve this</span><br><span class="line"> * is with the static method BnServiceManager.getDefault().</span><br><span class="line"> * </span><br><span class="line"> * @hide</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IServiceManager extends IInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Blocks for a few seconds waiting for it to be</span><br><span class="line">     * published if it does not already exist.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder getService(String name) throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Non-blocking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder checkService(String name) throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">                throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return a list of all currently running services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String[] listServices() throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Assign a permission controller to the service manager.  After set, this</span><br><span class="line">     * interface is checked before any services are added.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    static final String descriptor &#x3D; &quot;android.os.IServiceManager&quot;;</span><br><span class="line">    int GET_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">    int CHECK_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+1;</span><br><span class="line">    int ADD_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+2;</span><br><span class="line">    int LIST_SERVICES_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+3;</span><br><span class="line">    int CHECK_SERVICES_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+4;</span><br><span class="line">    int SET_PERMISSION_CONTROLLER_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ServiceManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** @hide *&#x2F;</span><br><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;ServiceManager&quot;;</span><br><span class="line">    private static IServiceManager sServiceManager;</span><br><span class="line">    private static HashMap&lt;String, IBinder&gt; sCache &#x3D; new HashMap&lt;String, IBinder&gt;();</span><br><span class="line">    private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a reference to a service with the given name.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the service to get</span><br><span class="line">     * @return a reference to the service, or &lt;code&gt;null&lt;&#x2F;code&gt; if the service doesn&#39;t exist</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the new service</span><br><span class="line">     * @param service the service object</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the new service</span><br><span class="line">     * @param service the service object</span><br><span class="line">     * @param allowIsolated set to true to allow isolated sandboxed processes</span><br><span class="line">     * to access this service</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void addService(String name, IBinder service, boolean allowIsolated) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Non-blocking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder checkService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().checkService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in checkService&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return a list of all currently running services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String[] listServices() throws RemoteException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return getIServiceManager().listServices();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in listServices&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This is only intended to be called when the process is first being brought</span><br><span class="line">     * up and bound by the activity manager. There is only one thread in the process</span><br><span class="line">     * at that time, so no locking is done.</span><br><span class="line">     * </span><br><span class="line">     * @param cache the cache of service references</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void initServiceCache(Map&lt;String, IBinder&gt; cache) &#123;</span><br><span class="line">        if (sCache.size() !&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;setServiceCache may only be called once&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sCache.putAll(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceManagerNative</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Native implementation of the service manager.  Most clients will only</span><br><span class="line"> * care about getDefault() and possibly asInterface().</span><br><span class="line"> * @hide</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class ServiceManagerNative extends Binder implements IServiceManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Cast a Binder object into a service manager interface, generating</span><br><span class="line">     * a proxy if needed.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ServiceManagerNative()</span><br><span class="line">    &#123;</span><br><span class="line">        attachInterface(this, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">            case IServiceManager.GET_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; getService(name);</span><br><span class="line">                reply.writeStrongBinder(service);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.CHECK_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; checkService(name);</span><br><span class="line">                reply.writeStrongBinder(service);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; data.readStrongBinder();</span><br><span class="line">                boolean allowIsolated &#x3D; data.readInt() !&#x3D; 0;</span><br><span class="line">                addService(name, service, allowIsolated);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.LIST_SERVICES_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String[] list &#x3D; listServices();</span><br><span class="line">                reply.writeStringArray(list);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            case IServiceManager.SET_PERMISSION_CONTROLLER_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                IPermissionController controller</span><br><span class="line">                        &#x3D; IPermissionController.Stub.asInterface(</span><br><span class="line">                                data.readStrongBinder());</span><br><span class="line">                setPermissionController(controller);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder asBinder()</span><br><span class="line">    &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder checkService(String name) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(CHECK_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String[] listServices() throws RemoteException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; services &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">            Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">            data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">            data.writeInt(n);</span><br><span class="line">            n++;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean res &#x3D; mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);</span><br><span class="line">                if (!res) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; The result code that is returned by the C++ code can</span><br><span class="line">                &#x2F;&#x2F; cause the call to throw an exception back instead of</span><br><span class="line">                &#x2F;&#x2F; returning a nice result...  so eat it here and go on.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            services.add(reply.readString());</span><br><span class="line">            reply.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        String[] array &#x3D; new String[services.size()];</span><br><span class="line">        services.toArray(array);</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(controller.asBinder());</span><br><span class="line">        mRemote.transact(SET_PERMISSION_CONTROLLER_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    private IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IBinder</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">public interface IBinder &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The first transaction code available for user commands.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int FIRST_CALL_TRANSACTION  &#x3D; 0x00000001;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The last transaction code available for user commands.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int LAST_CALL_TRANSACTION   &#x3D; 0x00ffffff;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: pingBinder().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int PING_TRANSACTION        &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;P&#39;&lt;&lt;16)|(&#39;N&#39;&lt;&lt;8)|&#39;G&#39;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: dump internal state.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int DUMP_TRANSACTION        &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;D&#39;&lt;&lt;16)|(&#39;M&#39;&lt;&lt;8)|&#39;P&#39;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: interrogate the recipient side</span><br><span class="line">     * of the transaction for its canonical interface descriptor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int INTERFACE_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;N&#39;&lt;&lt;16)|(&#39;T&#39;&lt;&lt;8)|&#39;F&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: send a tweet to the target</span><br><span class="line">     * object.  The data in the parcel is intended to be delivered to</span><br><span class="line">     * a shared messaging service associated with the object; it can be</span><br><span class="line">     * anything, as long as it is not more than 130 UTF-8 characters to</span><br><span class="line">     * conservatively fit within common messaging services.  As part of</span><br><span class="line">     * &#123;@link Build.VERSION_CODES#HONEYCOMB_MR2&#125;, all Binder objects are</span><br><span class="line">     * expected to support this protocol for fully integrated tweeting</span><br><span class="line">     * across the platform.  To support older code, the default implementation</span><br><span class="line">     * logs the tweet to the main log as a simple emulation of broadcasting</span><br><span class="line">     * it publicly over the Internet.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;Also, upon completing the dispatch, the object must make a cup</span><br><span class="line">     * of tea, return it to the caller, and exclaim &quot;jolly good message</span><br><span class="line">     * old boy!&quot;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int TWEET_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;T&#39;&lt;&lt;16)|(&#39;W&#39;&lt;&lt;8)|&#39;T&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: tell an app asynchronously that the</span><br><span class="line">     * caller likes it.  The app is responsible for incrementing and maintaining</span><br><span class="line">     * its own like counter, and may display this value to the user to indicate the</span><br><span class="line">     * quality of the app.  This is an optional command that applications do not</span><br><span class="line">     * need to handle, so the default implementation is to do nothing.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;There is no response returned and nothing about the</span><br><span class="line">     * system will be functionally affected by it, but it will improve the</span><br><span class="line">     * app&#39;s self-esteem.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int LIKE_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;L&#39;&lt;&lt;16)|(&#39;I&#39;&lt;&lt;8)|&#39;K&#39;;</span><br><span class="line">    &#x2F;** @hide *&#x2F;</span><br><span class="line">    int SYSPROPS_TRANSACTION &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;S&#39;&lt;&lt;16)|(&#39;P&#39;&lt;&lt;8)|&#39;R&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Flag to &#123;@link #transact&#125;: this is a one-way call, meaning that the</span><br><span class="line">     * caller returns immediately, without waiting for a result from the</span><br><span class="line">     * callee. Applies only if the caller and callee are in different</span><br><span class="line">     * processes.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int FLAG_ONEWAY             &#x3D; 0x00000001;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Limit that should be placed on IPC sizes to keep them safely under the</span><br><span class="line">     * transaction buffer limit.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final int MAX_IPC_SIZE &#x3D; 64 * 1024;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the canonical name of the interface supported by this binder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check to see if the object still exists.</span><br><span class="line">     * </span><br><span class="line">     * @return Returns false if the</span><br><span class="line">     * hosting process is gone, otherwise the result (always by default</span><br><span class="line">     * true) returned by the pingBinder() implementation on the other</span><br><span class="line">     * side.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean pingBinder();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check to see if the process that the binder is in is still alive.</span><br><span class="line">     *</span><br><span class="line">     * @return false if the process is not alive.  Note that if it returns</span><br><span class="line">     * true, the process may have died while the call is returning.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isBinderAlive();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempt to retrieve a local implementation of an interface</span><br><span class="line">     * for this Binder object.  If null is returned, you will need</span><br><span class="line">     * to instantiate a proxy class to marshall calls through</span><br><span class="line">     * the transact() method.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Print the object&#39;s state into the given stream.</span><br><span class="line">     * </span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Like &#123;@link #dump(FileDescriptor, String[])&#125; but always executes</span><br><span class="line">     * asynchronously.  If the object is local, a new thread is created</span><br><span class="line">     * to perform the dump.</span><br><span class="line">     *</span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Perform a generic operation with the object.</span><br><span class="line">     * </span><br><span class="line">     * @param code The action to perform.  This should</span><br><span class="line">     * be a number between &#123;@link #FIRST_CALL_TRANSACTION&#125; and</span><br><span class="line">     * &#123;@link #LAST_CALL_TRANSACTION&#125;.</span><br><span class="line">     * @param data Marshalled data to send to the target.  Must not be null.</span><br><span class="line">     * If you are not sending any data, you must create an empty Parcel</span><br><span class="line">     * that is given here.</span><br><span class="line">     * @param reply Marshalled data to be received from the target.  May be</span><br><span class="line">     * null if you are not interested in the return value.</span><br><span class="line">     * @param flags Additional operation flags.  Either 0 for a normal</span><br><span class="line">     * RPC, or &#123;@link #FLAG_ONEWAY&#125; for a one-way RPC.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">        throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Interface for receiving a callback when the process hosting an IBinder</span><br><span class="line">     * has gone away.</span><br><span class="line">     * </span><br><span class="line">     * @see #linkToDeath</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public interface DeathRecipient &#123;</span><br><span class="line">        public void binderDied();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Register the recipient for a notification if this binder</span><br><span class="line">     * goes away.  If this binder object unexpectedly goes away</span><br><span class="line">     * (typically because its hosting process has been killed),</span><br><span class="line">     * then the given &#123;@link DeathRecipient&#125;&#39;s</span><br><span class="line">     * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method</span><br><span class="line">     * will be called.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;You will only receive death notifications for remote binders,</span><br><span class="line">     * as local binders by definition can&#39;t die without you dying as well.</span><br><span class="line">     * </span><br><span class="line">     * @throws RemoteException if the target IBinder&#39;s</span><br><span class="line">     * process has already died.</span><br><span class="line">     * </span><br><span class="line">     * @see #unlinkToDeath</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void linkToDeath(DeathRecipient recipient, int flags)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove a previously registered death notification.</span><br><span class="line">     * The recipient will no longer be called if this object</span><br><span class="line">     * dies.</span><br><span class="line">     * </span><br><span class="line">     * @return &#123;@code true&#125; if the &lt;var&gt;recipient&lt;&#x2F;var&gt; is successfully</span><br><span class="line">     * unlinked, assuring you that its</span><br><span class="line">     * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method</span><br><span class="line">     * will not be called;  &#123;@code false&#125; if the target IBinder has already</span><br><span class="line">     * died, meaning the method has been (or soon will be) called.</span><br><span class="line">     * </span><br><span class="line">     * @throws java.util.NoSuchElementException if the given</span><br><span class="line">     * &lt;var&gt;recipient&lt;&#x2F;var&gt; has not been registered with the IBinder, and</span><br><span class="line">     * the IBinder is still alive.  Note that if the &lt;var&gt;recipient&lt;&#x2F;var&gt;</span><br><span class="line">     * was never registered, but the IBinder has already died, then this</span><br><span class="line">     * exception will &lt;em&gt;not&lt;&#x2F;em&gt; be thrown, and you will receive a false</span><br><span class="line">     * return value instead.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Binder</strong></p>
<p>BinderProxy是Binder的内部类实现IBinder接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Set this flag to true to detect anonymous, local or member classes</span><br><span class="line">     * that extend this Binder class and that are not static. These kind</span><br><span class="line">     * of classes can potentially create leaks.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final boolean FIND_POTENTIAL_LEAKS &#x3D; false;</span><br><span class="line">    private static final boolean CHECK_PARCEL_SIZE &#x3D; false;</span><br><span class="line">    static final String TAG &#x3D; &quot;Binder&quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Control whether dump() calls are allowed.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String sDumpDisabled &#x3D; null;</span><br><span class="line">    &#x2F;* mObject is used by native code, do not remove or rename *&#x2F;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private IInterface mOwner;</span><br><span class="line">    private String mDescriptor;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the ID of the process that sent you the current transaction</span><br><span class="line">     * that is being processed.  This pid can be used with higher-level</span><br><span class="line">     * system services to determine its identity and check permissions.</span><br><span class="line">     * If the current thread is not currently executing an incoming transaction,</span><br><span class="line">     * then its own pid is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getCallingPid();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the Linux uid assigned to the process that sent you the</span><br><span class="line">     * current transaction that is being processed.  This uid can be used with</span><br><span class="line">     * higher-level system services to determine its identity and check</span><br><span class="line">     * permissions.  If the current thread is not currently executing an</span><br><span class="line">     * incoming transaction, then its own uid is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getCallingUid();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the UserHandle assigned to the process that sent you the</span><br><span class="line">     * current transaction that is being processed.  This is the user</span><br><span class="line">     * of the caller.  It is distinct from &#123;@link #getCallingUid()&#125; in that a</span><br><span class="line">     * particular user will have multiple distinct apps running under it each</span><br><span class="line">     * with their own uid.  If the current thread is not currently executing an</span><br><span class="line">     * incoming transaction, then its own UserHandle is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final UserHandle getCallingUserHandle() &#123;</span><br><span class="line">        return new UserHandle(UserHandle.getUserId(getCallingUid()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reset the identity of the incoming IPC on the current thread.  This can</span><br><span class="line">     * be useful if, while handling an incoming call, you will be calling</span><br><span class="line">     * on interfaces of other objects that may be local to your process and</span><br><span class="line">     * need to do permission checks on the calls coming into them (so they</span><br><span class="line">     * will check the permission of your own local process, and not whatever</span><br><span class="line">     * process originally called you).</span><br><span class="line">     *</span><br><span class="line">     * @return Returns an opaque token that can be used to restore the</span><br><span class="line">     * original calling identity by passing it to</span><br><span class="line">     * &#123;@link #restoreCallingIdentity(long)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #getCallingPid()</span><br><span class="line">     * @see #getCallingUid()</span><br><span class="line">     * @see #restoreCallingIdentity(long)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native long clearCallingIdentity();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Restore the identity of the incoming IPC on the current thread</span><br><span class="line">     * back to a previously identity that was returned by &#123;@link</span><br><span class="line">     * #clearCallingIdentity&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param token The opaque token that was previously returned by</span><br><span class="line">     * &#123;@link #clearCallingIdentity&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #clearCallingIdentity</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void restoreCallingIdentity(long token);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets the native thread-local StrictMode policy mask.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The StrictMode settings are kept in two places: a Java-level</span><br><span class="line">     * threadlocal for libcore&#x2F;Dalvik, and a native threadlocal (set</span><br><span class="line">     * here) for propagation via Binder calls.  This is a little</span><br><span class="line">     * unfortunate, but necessary to break otherwise more unfortunate</span><br><span class="line">     * dependencies either of Dalvik on Android, or Android</span><br><span class="line">     * native-only code on Dalvik.</span><br><span class="line">     *</span><br><span class="line">     * @see StrictMode</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void setThreadStrictModePolicy(int policyMask);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets the current native thread-local StrictMode policy mask.</span><br><span class="line">     *</span><br><span class="line">     * @see #setThreadStrictModePolicy</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getThreadStrictModePolicy();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Flush any Binder commands pending in the current thread to the kernel</span><br><span class="line">     * driver.  This can be</span><br><span class="line">     * useful to call before performing an operation that may block for a long</span><br><span class="line">     * time, to ensure that any pending object references have been released</span><br><span class="line">     * in order to prevent the process from holding on to objects longer than</span><br><span class="line">     * it needs to.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void flushPendingCommands();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Add the calling thread to the IPC thread pool.  This function does</span><br><span class="line">     * not return until the current process is exiting.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void joinThreadPool();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns true if the specified interface is a proxy.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final boolean isProxy(IInterface iface) &#123;</span><br><span class="line">        return iface.asBinder() !&#x3D; iface;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Call blocks until the number of executing binder threads is less</span><br><span class="line">     * than the maximum number of binder threads allowed for this process.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void blockUntilThreadAvailable();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default constructor initializes the object.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Binder() &#123;</span><br><span class="line">        init();</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Binder&gt; klass &#x3D; getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Binder class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Convenience method for associating a specific interface with the Binder.</span><br><span class="line">     * After calling, queryLocalInterface() will be implemented for you</span><br><span class="line">     * to return the given owner IInterface when the corresponding</span><br><span class="line">     * descriptor is requested.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void attachInterface(IInterface owner, String descriptor) &#123;</span><br><span class="line">        mOwner &#x3D; owner;</span><br><span class="line">        mDescriptor &#x3D; descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation returns an empty interface name.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getInterfaceDescriptor() &#123;</span><br><span class="line">        return mDescriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation always returns true -- if you got here,</span><br><span class="line">     * the object is alive.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean pingBinder() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *</span><br><span class="line">     * Note that if you&#39;re calling on a local binder, this always returns true</span><br><span class="line">     * because your process is alive if you&#39;re calling it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isBinderAlive() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Use information supplied to attachInterface() to return the</span><br><span class="line">     * associated IInterface if it matches the requested</span><br><span class="line">     * descriptor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        if (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">            return mOwner;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Control disabling of dump calls in this process.  This is used by the system</span><br><span class="line">     * process watchdog to disable incoming dump calls while it has detecting the system</span><br><span class="line">     * is hung and is reporting that back to the activity controller.  This is to</span><br><span class="line">     * prevent the controller from getting hung up on bug reports at this point.</span><br><span class="line">     * @hide</span><br><span class="line">     *</span><br><span class="line">     * @param msg The message to show instead of the dump; if null, dumps are</span><br><span class="line">     * re-enabled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setDumpDisabled(String msg) &#123;</span><br><span class="line">        synchronized (Binder.class) &#123;</span><br><span class="line">            sDumpDisabled &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation is a stub that returns false.  You will want</span><br><span class="line">     * to override this to do the appropriate unmarshalling of transactions.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If you want to call this, call transact().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (code &#x3D;&#x3D; INTERFACE_TRANSACTION) &#123;</span><br><span class="line">            reply.writeString(getInterfaceDescriptor());</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (code &#x3D;&#x3D; DUMP_TRANSACTION) &#123;</span><br><span class="line">            ParcelFileDescriptor fd &#x3D; data.readFileDescriptor();</span><br><span class="line">            String[] args &#x3D; data.readStringArray();</span><br><span class="line">            if (fd !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd.getFileDescriptor(), args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        fd.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; swallowed, not propagated back to the caller</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Write the StrictMode header.</span><br><span class="line">            if (reply !&#x3D; null) &#123;</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StrictMode.clearGatheredViolations();</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Implemented to call the more convenient version</span><br><span class="line">     * &#123;@link #dump(FileDescriptor, PrintWriter, String[])&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) &#123;</span><br><span class="line">        FileOutputStream fout &#x3D; new FileOutputStream(fd);</span><br><span class="line">        PrintWriter pw &#x3D; new FastPrintWriter(fout);</span><br><span class="line">        try &#123;</span><br><span class="line">            final String disabled;</span><br><span class="line">            synchronized (Binder.class) &#123;</span><br><span class="line">                disabled &#x3D; sDumpDisabled;</span><br><span class="line">            &#125;</span><br><span class="line">            if (disabled &#x3D;&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd, pw, args);</span><br><span class="line">                &#125; catch (SecurityException e) &#123;</span><br><span class="line">                    pw.println(&quot;Security exception: &quot; + e.getMessage());</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Unlike usual calls, in this case if an exception gets thrown</span><br><span class="line">                    &#x2F;&#x2F; back to us we want to print it back in to the dump data, since</span><br><span class="line">                    &#x2F;&#x2F; that is where the caller expects all interesting information to</span><br><span class="line">                    &#x2F;&#x2F; go.</span><br><span class="line">                    pw.println();</span><br><span class="line">                    pw.println(&quot;Exception occurred while dumping:&quot;);</span><br><span class="line">                    e.printStackTrace(pw);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pw.println(sDumpDisabled);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            pw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Like &#123;@link #dump(FileDescriptor, String[])&#125;, but ensures the target</span><br><span class="line">     * executes asynchronously.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dumpAsync(final FileDescriptor fd, final String[] args) &#123;</span><br><span class="line">        final FileOutputStream fout &#x3D; new FileOutputStream(fd);</span><br><span class="line">        final PrintWriter pw &#x3D; new FastPrintWriter(fout);</span><br><span class="line">        Thread thr &#x3D; new Thread(&quot;Binder.dumpAsync&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd, pw, args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    pw.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thr.start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Print the object&#39;s state into the given stream.</span><br><span class="line">     * </span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param fout The file to which you should dump your state.  This will be</span><br><span class="line">     * closed for you after you return.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation rewinds the parcels and calls onTransact.  On</span><br><span class="line">     * the remote side, transact calls into the binder to do the IPC.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final boolean transact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);</span><br><span class="line">        if (data !&#x3D; null) &#123;</span><br><span class="line">            data.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean r &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        if (reply !&#x3D; null) &#123;</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local implementation is a no-op.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void linkToDeath(DeathRecipient recipient, int flags) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local implementation is a no-op.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void checkParcel(IBinder obj, int code, Parcel parcel, String msg) &#123;</span><br><span class="line">        if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;&#x3D; 800*1024) &#123;</span><br><span class="line">            &#x2F;&#x2F; Trying to send &gt; 800k, this is way too much</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            sb.append(msg);</span><br><span class="line">            sb.append(&quot;: on &quot;);</span><br><span class="line">            sb.append(obj);</span><br><span class="line">            sb.append(&quot; calling &quot;);</span><br><span class="line">            sb.append(code);</span><br><span class="line">            sb.append(&quot; size &quot;);</span><br><span class="line">            sb.append(parcel.dataSize());</span><br><span class="line">            sb.append(&quot; (data: &quot;);</span><br><span class="line">            parcel.setDataPosition(0);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;, &quot;);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;, &quot;);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;)&quot;);</span><br><span class="line">            Slog.wtfStack(TAG, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private native final void init();</span><br><span class="line">    private native final void destroy();</span><br><span class="line">    &#x2F;&#x2F; Entry point from android_util_Binder.cpp&#39;s onTransact</span><br><span class="line">    private boolean execTransact(int code, long dataObj, long replyObj,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain(replyObj);</span><br><span class="line">        &#x2F;&#x2F; theoretically, we should call transact, which will call onTransact,</span><br><span class="line">        &#x2F;&#x2F; but all that does is rewind it, and we just got these from an IPC,</span><br><span class="line">        &#x2F;&#x2F; so we&#39;ll just call it directly.</span><br><span class="line">        boolean res;</span><br><span class="line">        &#x2F;&#x2F; Log any exceptions as warnings, don&#39;t silently suppress them.</span><br><span class="line">        &#x2F;&#x2F; If the call was FLAG_ONEWAY then these exceptions disappear into the ether.</span><br><span class="line">        try &#123;</span><br><span class="line">            res &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Binder call failed.&quot;, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply.setDataPosition(0);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply.setDataPosition(0);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Unconditionally log this, since this is generally unrecoverable.</span><br><span class="line">            Log.e(TAG, &quot;Caught an OutOfMemoryError from the binder stub implementation.&quot;, e);</span><br><span class="line">            RuntimeException re &#x3D; new RuntimeException(&quot;Out of memory&quot;, e);</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(re);</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        checkParcel(this, code, reply, &quot;Unreasonably large binder reply buffer&quot;);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        &#x2F;&#x2F; Just in case -- we are done with the IPC, so there should be no more strict</span><br><span class="line">        &#x2F;&#x2F; mode violations that have gathered for this thread.  Either they have been</span><br><span class="line">        &#x2F;&#x2F; parceled and are now in transport off to the caller, or we are returning back</span><br><span class="line">        &#x2F;&#x2F; to the main transaction loop to wait for another incoming transaction.  Either</span><br><span class="line">        &#x2F;&#x2F; way, strict mode begone!</span><br><span class="line">        StrictMode.clearGatheredViolations();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    public native boolean pingBinder();</span><br><span class="line">    public native boolean isBinderAlive();</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">        return transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    public native String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line">    public native boolean transactNative(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException;</span><br><span class="line">    public native void linkToDeath(DeathRecipient recipient, int flags)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(DUMP_TRANSACTION, data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(DUMP_TRANSACTION, data, reply, FLAG_ONEWAY);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxy() &#123;</span><br><span class="line">        mSelf &#x3D; new WeakReference(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private native final void destroy();</span><br><span class="line">    </span><br><span class="line">    private static final void sendDeathNotice(DeathRecipient recipient) &#123;</span><br><span class="line">        if (false) Log.v(&quot;JavaBinder&quot;, &quot;sendDeathNotice to &quot; + recipient);</span><br><span class="line">        try &#123;</span><br><span class="line">            recipient.binderDied();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RuntimeException exc) &#123;</span><br><span class="line">            Log.w(&quot;BinderNative&quot;, &quot;Uncaught exception from death notification&quot;,</span><br><span class="line">                    exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final private WeakReference mSelf;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private long mOrgue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder概述"><a href="#Binder概述" class="headerlink" title="Binder概述"></a>Binder概述</h1><h2 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h2><p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p>
<p><img src="http://gityuan.com/images/binder/java_binder/java_binder.jpg" alt="java_binder"></p>
<ul>
<li>图中红色代表整个framework层 binder架构相关组件；<ul>
<li>Binder类代表Server端，BinderProxy类代码Client端；</li>
</ul>
</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的，后面会详细说明。</li>
</ul>
<h2 id="Binder类图"><a href="#Binder类图" class="headerlink" title="Binder类图"></a>Binder类图</h2><p><img src="http://gityuan.com/images/binder/java_binder/class_ServiceManager.jpg" alt="class_java_binder"></p>
<ul>
<li><strong>ServiceManager：</strong>通过getIServiceManager方法获取的是ServiceManagerProxy对象； ServiceManager的addService, getService实际工作都交由ServiceManagerProxy的相应方法来处理；</li>
<li><strong>ServiceManagerProxy：</strong>其成员变量mRemote指向BinderProxy对象，ServiceManagerProxy的addService, getService方法最终是交由mRemote来完成。</li>
<li><strong>ServiceManagerNative</strong>：其方法asInterface()返回的是ServiceManagerProxy对象，ServiceManager便是借助ServiceManagerNative类来找到ServiceManagerProxy；</li>
<li><strong>Binder：</strong>其成员变量mObject和方法execTransact()用于native方法</li>
<li><strong>BinderInternal：</strong>内部有一个GcWatcher类，用于处理和调试与Binder相关的垃圾回收。</li>
<li><strong>IBinder：</strong>接口中常量FLAG_ONEWAY：客户端利用binder跟服务端通信是阻塞式的，但如果设置了FLAG_ONEWAY，这成为非阻塞的调用方式，客户端能立即返回，服务端采用回调方式来通知客户端完成情况。另外IBinder接口有一个内部接口DeathDecipient(死亡通告)。</li>
</ul>
<h2 id="Binder类分层"><a href="#Binder类分层" class="headerlink" title="Binder类分层"></a>Binder类分层</h2><p>整个Binder从kernel至，native，JNI，Framework层所涉及的全部类</p>
<p><img src="http://gityuan.com/images/binder/java_binder_framework.jpg" alt="java_binder_framework"></p>
<h1 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h1><h2 id="SM-addService"><a href="#SM-addService" class="headerlink" title="SM.addService"></a>SM.addService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看getIServiceManager()过程，如下：</p>
<h2 id="getIServiceManager"><a href="#getIServiceManager" class="headerlink" title="getIServiceManager"></a>getIServiceManager</h2><p><strong>ServiceManager.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>采用了单例模式获取ServiceManager getIServiceManager()返回的是ServiceManagerProxy(简称SMP)对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceManagerProxy</code> 是<code>ServiceManagerNative</code>的内部类，实现IServiceManager接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder checkService(String name) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] listServices(int dumpPriority) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getContextObject"><a href="#getContextObject" class="headerlink" title="getContextObject()"></a>getContextObject()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Return the global &quot;context object&quot; of the system.  This is usually</span><br><span class="line">     * an implementation of IServiceManager, which you can use to find</span><br><span class="line">     * other services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native IBinder getContextObject();</span><br></pre></td></tr></table></figure>

<p>调用jni中方法<code>android_os_BinderInternal_getContextObject</code>返回IBinder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b &#x3D; ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ProcessState::self()-&gt;getContextObject()，在<a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">获取ServiceManager</a>的第3节已详细解决，即<code>ProcessState::self()-&gt;getContextObject()</code>等价于 <code>new BpBinder(0)</code>;</p>
<h4 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder"></a>javaObjectForIBinder</h4><p>[-&gt; android_util_binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val) &#123;</span><br><span class="line">    if (val &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; &#x2F;&#x2F;返回false</span><br><span class="line">        jobject object &#x3D; static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line"></span><br><span class="line">    jobject object &#x3D; (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    if (object !&#x3D; NULL) &#123; &#x2F;&#x2F;第一次object为null</span><br><span class="line">        jobject res &#x3D; jniGetReferent(env, object);</span><br><span class="line">        if (res !&#x3D; NULL) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建BinderProxy对象</span><br><span class="line">    object &#x3D; env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    if (object !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;BinderProxy.mObject成员变量记录BpBinder对象</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">        val-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line"></span><br><span class="line">        jobject refObject &#x3D; env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        &#x2F;&#x2F;将BinderProxy对象信息附加到BpBinder的成员变量mObjects中</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line"></span><br><span class="line">        sp&lt;DeathRecipientList&gt; drl &#x3D; new DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        &#x2F;&#x2F;BinderProxy.mOrgue成员变量记录死亡通知对象</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast&lt;jlong&gt;(drl.get()));</span><br><span class="line"></span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据BpBinder(C++)生成BinderProxy(Java)对象. 主要工作是创建BinderProxy对象,并把BpBinder对象地址保存到BinderProxy.mObject成员变量. 到此，可知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject()) </span><br><span class="line">等价于</span><br><span class="line">ServiceManagerNative.asInterface(new BinderProxy())</span><br></pre></td></tr></table></figure>

<h2 id="SMN-asInterface"><a href="#SMN-asInterface" class="headerlink" title="SMN.asInterface"></a>SMN.asInterface</h2><p>[-&gt; ServiceManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;obj为BpBinder</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由于obj为BpBinder，该方法默认返回null</span><br><span class="line">    IServiceManager in &#x3D; (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in !&#x3D; null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line">    return new ServiceManagerProxy(obj); &#x2F;&#x2F;【见小节3.3.1】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，可知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(new BinderProxy()) </span><br><span class="line">等价于</span><br><span class="line">new ServiceManagerProxy(new BinderProxy())</span><br></pre></td></tr></table></figure>

<p> 为了方便，ServiceManagerProxy简称为SMP。</p>
<h3 id="ServiceManagerProxy初始化"><a href="#ServiceManagerProxy初始化" class="headerlink" title="ServiceManagerProxy初始化"></a>ServiceManagerProxy初始化</h3><p>[-&gt; ServiceManagerNative.java ::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote为BinderProxy对象，该BinderProxy对象对应于BpBinder(0)，其作为binder代理端，指向native层大管家service Manager。</p>
<p><code>ServiceManager.getIServiceManager</code>最终等价于<code>new ServiceManagerProxy(new BinderProxy())</code>,意味着【3.1】中的getIServiceManager().addService()，等价于SMP.addService().</p>
<p>framework层的ServiceManager的调用实际的工作确实交给SMP的成员变量BinderProxy；而BinderProxy通过jni方式，最终会调用BpBinder对象；可见上层binder架构的核心功能依赖native架构的服务来完成的。</p>
<h2 id="ServiceManagerProxy-addService"><a href="#ServiceManagerProxy-addService" class="headerlink" title="ServiceManagerProxy.addService"></a>ServiceManagerProxy.addService</h2><p>[-&gt; ServiceManagerNative.java ::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    &#x2F;&#x2F;【见小节3.5】</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">    &#x2F;&#x2F;mRemote为BinderProxy【见小节3.7】</span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="data-writeStrongBinder-service-Java"><a href="#data-writeStrongBinder-service-Java" class="headerlink" title="data.writeStrongBinder(service)Java"></a>data.writeStrongBinder(service)Java</h2><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public writeStrongBinder(IBinder val)&#123;</span><br><span class="line">    &#x2F;&#x2F;此处为Native调用【见3.5.1】</span><br><span class="line">    nativewriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativeWriteStrongBinder-JNI"><a href="#nativeWriteStrongBinder-JNI" class="headerlink" title="nativeWriteStrongBinder()JNI"></a>nativeWriteStrongBinder()JNI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static native void nativeWriteStrongBinder(long nativePtr, IBinder val);</span><br></pre></td></tr></table></figure>

<p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object) &#123;</span><br><span class="line">    &#x2F;&#x2F;将java层Parcel转换为native层Parcel</span><br><span class="line">    Parcel* parcel &#x3D; reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;【见3.5.2】</span><br><span class="line">        const status_t err &#x3D; parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</span><br><span class="line">        if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ibinderForJavaObject"><a href="#ibinderForJavaObject" class="headerlink" title="ibinderForJavaObject"></a>ibinderForJavaObject</h4><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Java层的Binder对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh &#x3D; (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetLongField(obj, gBinderOffsets.mObject);</span><br><span class="line">        return jbh !&#x3D; NULL ? jbh-&gt;get(env, obj) : NULL; &#x2F;&#x2F;【见3.5.3】</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;Java层的BinderProxy对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        return (IBinder*)env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Binde(Java)生成JavaBBinderHolder(C++)对象. 主要工作是创建JavaBBinderHolder对象,并把JavaBBinderHolder对象地址保存到Binder.mObject成员变量.</p>
<h4 id="JavaBBinderHolder-get"><a href="#JavaBBinderHolder-get" class="headerlink" title="JavaBBinderHolder.get()"></a>JavaBBinderHolder.get()</h4><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    sp&lt;JavaBBinder&gt; b &#x3D; mBinder.promote();</span><br><span class="line">    if (b &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;首次进来，创建JavaBBinder对象【见3.5.4】</span><br><span class="line">        b &#x3D; new JavaBBinder(env, obj);</span><br><span class="line">        mBinder &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaBBinderHolder有一个成员变量mBinder，保存当前创建的JavaBBinder对象，这是一个wp类型的，可能会被垃圾回收器给回收，所以每次使用前，都需要先判断是否存在。</p>
<h4 id="JavaBBinder初始化"><a href="#JavaBBinder初始化" class="headerlink" title="JavaBBinder初始化"></a>JavaBBinder初始化</h4><p>==&gt; [-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaBBinder(JNIEnv* env, jobject object)</span><br><span class="line">    : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object))</span><br><span class="line">&#123;</span><br><span class="line">    android_atomic_inc(&amp;gNumLocalRefs);</span><br><span class="line">    incRefsCreated(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建JavaBBinder，该对象继承于BBinder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.writeStrongBinder(service)</span><br><span class="line">最终等价于&#96;parcel-&gt;</span><br><span class="line">writeStrongBinder(new JavaBBinder(env, obj))&#96;;</span><br></pre></td></tr></table></figure>

<h3 id="writeStrongBinder-C"><a href="#writeStrongBinder-C" class="headerlink" title="writeStrongBinder()C++"></a>writeStrongBinder()C++</h3><p>[-&gt; parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    return flatten_binder(ProcessState::self(), val, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flatten-binder"><a href="#flatten-binder" class="headerlink" title="flatten_binder"></a>flatten_binder</h4><p>[-&gt; parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; &#x2F;*proc*&#x2F;,</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags &#x3D; 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    if (binder !&#x3D; NULL) &#123;</span><br><span class="line">        IBinder *local &#x3D; binder-&gt;localBinder();</span><br><span class="line">        if (!local) &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; binder-&gt;remoteBinder();</span><br><span class="line">            const int32_t handle &#x3D; proxy ? proxy-&gt;handle() : 0;</span><br><span class="line">            obj.type &#x3D; BINDER_TYPE_HANDLE; &#x2F;&#x2F;远程Binder</span><br><span class="line">            obj.binder &#x3D; 0;</span><br><span class="line">            obj.handle &#x3D; handle;</span><br><span class="line">            obj.cookie &#x3D; 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj.type &#x3D; BINDER_TYPE_BINDER; &#x2F;&#x2F;本地Binder，进入该分支</span><br><span class="line">            obj.binder &#x3D; reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie &#x3D; reinterpret_cast&lt;uintptr_t&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj.type &#x3D; BINDER_TYPE_BINDER;  &#x2F;&#x2F;本地Binder</span><br><span class="line">        obj.binder &#x3D; 0;</span><br><span class="line">        obj.cookie &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见小节3.6.2】</span><br><span class="line">    return finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Binder对象扁平化，转换成flat_binder_object对象。</p>
<ul>
<li>对于Binder实体，则cookie记录Binder实体的指针；</li>
<li>对于Binder代理，则用handle记录Binder代理的句柄；</li>
</ul>
<p>关于localBinder，代码见Binder.cpp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BBinder* BBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BBinder* IBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finish-flatten-binder"><a href="#finish-flatten-binder" class="headerlink" title="finish_flatten_binder"></a>finish_flatten_binder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline static status_t finish_flatten_binder(</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; , const flat_binder_object&amp; flat, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    return out-&gt;writeObject(flat, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会带Java代码addService过程，则接下来进入transact</p>
<h2 id="BinderProxy-transact"><a href="#BinderProxy-transact" class="headerlink" title="BinderProxy.transact"></a>BinderProxy.transact</h2><p>[-&gt; Binder.java ::BinderProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F;用于检测Parcel大小是否大于800k</span><br><span class="line">    Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">    return transactNative(code, data, reply, flags); &#x2F;&#x2F;【见3.8】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到ServiceManagerProxy.addService，其成员变量mRemote是BinderProxy。transactNative经过jni调用，进入下面的方法</p>
<h3 id="android-os-BinderProxy-transact"><a href="#android-os-BinderProxy-transact" class="headerlink" title="android_os_BinderProxy_transact"></a>android_os_BinderProxy_transact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">    jint code, jobject dataObj, jobject replyObj, jint flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;java Parcel转为native Parcel</span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;gBinderProxyOffsets.mObject中保存的是new BpBinder(0)对象</span><br><span class="line">    IBinder* target &#x3D; (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此处便是BpBinder::transact(), 经过native层，进入Binder驱动程序</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的BinderProxy.transact()最终交由Native层的BpBinder::transact()完成。Native Binder的<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a>中有详细说明BpBinder执行过程。另外，该方法可抛出RemoteException。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>addService的核心过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain(); &#x2F;&#x2F;此处还需要将java层的Parcel转为Native层的Parcel</span><br><span class="line">    data-&gt;writeStrongBinder(new JavaBBinder(env, obj));</span><br><span class="line">    BpBinder::transact(ADD_SERVICE_TRANSACTION, *data, reply, 0); &#x2F;&#x2F;与Binder驱动交互</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册服务过程就是通过BpBinder来发送<code>ADD_SERVICE_TRANSACTION</code>命令，与实现与binder驱动进行数据交互。</p>
<h1 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h1><h2 id="SM-getService"><a href="#SM-getService" class="headerlink" title="SM.getService"></a>SM.getService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder service &#x3D; sCache.get(name); &#x2F;&#x2F;先从缓存中查看HashMap</span><br><span class="line">        if (service !&#x3D; null) &#123;</span><br><span class="line">            return service;</span><br><span class="line">        &#125; else &#123;</span><br></pre></td></tr></table></figure>
<pre><code>        return getIServiceManager().getService(name); 【见4.2】
    }
} catch (RemoteException e) {
    Log.e(TAG, &quot;error in getService&quot;, e);
}
return null;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关于getIServiceManager()，在前面已经讲述了，等价于new ServiceManagerProxy(new BinderProxy())。 其中sCache &#x3D; new HashMap&lt;String, IBinder&gt;()以hashmap格式缓存已组成的名称。请求获取服务过程中，先从缓存中查询是否存在，如果缓存中不存在的话，再通过binder交互来查询相应的服务。</span><br><span class="line"></span><br><span class="line">## ServiceManagerProxy.getService()</span><br></pre></td></tr></table></figure>
<p>class ServiceManagerProxy implements IServiceManager {<br>    public IBinder getService(String name) throws RemoteException {<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IServiceManager.descriptor);<br>        data.writeString(name);<br>        //mRemote为BinderProxy 【见4.3】<br>        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);<br>        //从reply里面解析出获取的IBinder对象【见4.8】<br>        IBinder binder = reply.readStrongBinder();<br>        reply.recycle();<br>        data.recycle();<br>        return binder;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BinderProxy.transact</span><br><span class="line"></span><br><span class="line">[-&gt; Binder.java]</span><br></pre></td></tr></table></figure>
<p>final class BinderProxy implements IBinder {<br>    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {<br>        Binder.checkParcel(this, code, data, “Unreasonably large binder buffer”);<br>        return transactNative(code, data, reply, flags);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## android_os_BinderProxy_transact</span><br><span class="line"></span><br><span class="line">[-&gt; android_util_Binder.cpp]</span><br></pre></td></tr></table></figure>
<p>static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,<br>    jint code, jobject dataObj, jobject replyObj, jint flags)<br>{<br>    …<br>    //java Parcel转为native Parcel<br>    Parcel* data = parcelForJavaObject(env, dataObj);<br>    Parcel* reply = parcelForJavaObject(env, replyObj);<br>    …</p>
<pre><code>//gBinderProxyOffsets.mObject中保存的是new BpBinder(0)对象
IBinder* target = (IBinder*)
    env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);
...

//此处便是BpBinder::transact(), 经过native层[见小节4.5]
status_t err = target-&gt;transact(code, *data, reply, flags);
...
return JNI_FALSE;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BpBinder.transact</span><br></pre></td></tr></table></figure>
<p>status_t BpBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    if (mAlive) {<br>        // [见小节4.6]<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);<br>        if (status == DEAD_OBJECT) mAlive = 0;<br>        return status;<br>    }</p>
<pre><code>return DEAD_OBJECT;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## IPC.transact</span><br><span class="line"></span><br><span class="line">[-&gt; IPCThreadState.cpp]</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck(); //数据错误检查<br>    flags |= TF_ACCEPT_FDS;<br>    ….<br>    if (err == NO_ERROR) {<br>         // 传输数据<br>        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);<br>    }<br>    …</p>
<pre><code>// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果
if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        //等待回应事件
        err = waitForResponse(reply);
    }else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}
return err;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  IPC.waitForResponse</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck(); //数据错误检查<br>    flags |= TF_ACCEPT_FDS;<br>    ….<br>    if (err == NO_ERROR) {<br>         // 传输数据<br>        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);<br>    }<br>    …</p>
<pre><code>// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果
if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        //等待回应事件
        err = waitForResponse(reply);
    }else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}
return err;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  IPC.waitForResponse</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::waitForResponse(Parcel <em>reply, status_t *acquireResult)<br>{<br>    int32_t cmd;<br>    int32_t err;<br>    while (1) {<br>        if ((err=talkWithDriver()) &lt; NO_ERROR) break;<br>        …<br>        cmd = mIn.readInt32();<br>        switch (cmd) {<br>          case BR_REPLY:<br>          {<br>            binder_transaction_data tr;<br>            err = mIn.read(&amp;tr, sizeof(tr));<br>            if (reply) {<br>                if ((tr.flags &amp; TF_STATUS_CODE) == 0) {<br>                    //当reply对象回收时，则会调用freeBuffer来回收内存<br>                    reply-&gt;ipcSetDataReference(<br>                        reinterpret_cast&lt;const uint8_t</em>&gt;(tr.data.ptr.buffer),<br>                        tr.data_size,<br>                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),<br>                        tr.offsets_size/sizeof(binder_size_t),<br>                        freeBuffer, this);<br>                } else {<br>                    …<br>                }<br>            }<br>          }<br>          case :…<br>        }<br>    }<br>    …<br>    return err;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么这个reply是哪来的呢，在文章[Binder系列3—启动ServiceManager](http:&#x2F;&#x2F;gityuan.com&#x2F;2015&#x2F;11&#x2F;07&#x2F;binder-start-sm&#x2F;)</span><br><span class="line"></span><br><span class="line">### binder_send_reply</span><br><span class="line"></span><br><span class="line">[-&gt; servicemanager&#x2F;binder.c]</span><br></pre></td></tr></table></figure>
<p>void binder_send_reply(struct binder_state *bs, struct binder_io *reply, binder_uintptr_t buffer_to_free, int status) {<br>    struct {<br>        uint32_t cmd_free;<br>        binder_uintptr_t buffer;<br>        uint32_t cmd_reply;<br>        struct binder_transaction_data txn;<br>    } <strong>attribute</strong>((packed)) data;</p>
<pre><code>data.cmd_free = BC_FREE_BUFFER; //free buffer命令
data.buffer = buffer_to_free;
data.cmd_reply = BC_REPLY; // reply命令
data.txn.target.ptr = 0;
data.txn.cookie = 0;
data.txn.code = 0;
if (status) {
    ...
} else {=

    data.txn.flags = 0;
    data.txn.data_size = reply-&gt;data - reply-&gt;data0;
    data.txn.offsets_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
    data.txn.data.ptr.buffer = (uintptr_t)reply-&gt;data0;
    data.txn.data.ptr.offsets = (uintptr_t)reply-&gt;offs0;
}
//向Binder驱动通信
binder_write(bs, &amp;data, sizeof(data));</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">binder_write将BC_FREE_BUFFER和BC_REPLY命令协议发送给驱动，进入驱动。binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write，由于是BC_REPLY命令协议，则进入binder_transaction， 该方法会向请求服务的线程Todo队列插入事务。</span><br><span class="line"></span><br><span class="line">接下来，请求服务的进程在执行talkWithDriver的过程执行到binder_thread_read()，处理Todo队列的事务。</span><br><span class="line"></span><br><span class="line">## readStrongBinder</span><br><span class="line"></span><br><span class="line">[-&gt; Parcel.java]</span><br><span class="line"></span><br><span class="line">readStrongBinder的过程基本是writeStrongBinder逆过程。</span><br></pre></td></tr></table></figure>
<p>static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) {<br>    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);<br>    if (parcel != NULL) {<br>        //【见小节4.8.1】<br>        return javaObjectForIBinder(env, parcel-&gt;readStrongBinder());<br>    }<br>    return NULL;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。</span><br><span class="line"></span><br><span class="line">### readStrongBinder(C++)</span><br><span class="line"></span><br><span class="line">[-&gt; Parcel.cpp]</span><br></pre></td></tr></table></figure>
<p>sp<IBinder> Parcel::readStrongBinder() const<br>{<br>    sp<IBinder> val;<br>    //【见小节4.8.2】<br>    unflatten_binder(ProcessState::self(), *this, &amp;val);<br>    return val;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### unflatten_binder</span><br></pre></td></tr></table></figure>
<p>status_t unflatten_binder(const sp<ProcessState>&amp; proc,<br>    const Parcel&amp; in, sp<IBinder>* out)<br>{<br>    const flat_binder_object* flat = in.readObject(false);<br>    if (flat) {<br>        switch (flat-&gt;type) {<br>            case BINDER_TYPE_BINDER:<br>                <em>out = reinterpret_cast&lt;IBinder</em>&gt;(flat-&gt;cookie);<br>                return finish_unflatten_binder(NULL, <em>flat, in);<br>            case BINDER_TYPE_HANDLE:<br>                //进入该分支【见4.8.3】<br>                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);<br>                //创建BpBinder对象<br>                return finish_unflatten_binder(<br>                    static_cast&lt;BpBinder</em>&gt;(out-&gt;get()), *flat, in);<br>        }<br>    }<br>    return BAD_TYPE;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### getStrongProxyForHandle</span><br></pre></td></tr></table></figure>
<p>sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)<br>{<br>    sp<IBinder> result;</p>
<pre><code>AutoMutex _l(mLock);
//查找handle对应的资源项
handle_entry* e = lookupHandleLocked(handle);

if (e != NULL) {
    IBinder* b = e-&gt;binder;
    if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
        ...
        //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象
        b = new BpBinder(handle);
        e-&gt;binder = b;
        if (b) e-&gt;refs = b-&gt;getWeakRefs();
        result = b;
    } else {
        result.force_set(b);
        e-&gt;refs-&gt;decWeak(this);
    }
}
return result;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。回到[小节4.8] 经过javaObjectForIBinder将native层BpBinder对象转换为Java层BinderProxy对象。 也就是说通过getService()最终获取了指向目标Binder服务端的代理对象BinderProxy。</span><br><span class="line"></span><br><span class="line">## 小结</span><br><span class="line"></span><br><span class="line">getService的核心过程：</span><br></pre></td></tr></table></figure>
<p>public static IBinder getService(String name) {<br>    …<br>    Parcel reply = Parcel.obtain(); //此处还需要将java层的Parcel转为Native层的Parcel<br>    BpBinder::transact(GET_SERVICE_TRANSACTION, *data, reply, 0);  //与Binder驱动交互<br>    IBinder binder = javaObjectForIBinder(env, new BpBinder(handle));<br>    …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javaObjectForIBinder作用是创建BinderProxy对象，并将BpBinder对象的地址保存到BinderProxy对象的mObjects中。 获取服务过程就是通过BpBinder来发送&#96;GET_SERVICE_TRANSACTION&#96;命令，与实现与binder驱动进行数据交互。</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line"></span><br><span class="line">以IWindowManager为例</span><br></pre></td></tr></table></figure>
<p>public interface IWindowManager extends android.os.IInterface {</p>
<pre><code>public static abstract class Stub extends android.os.Binder implements android.view.IWindowManager {
    private static final java.lang.String DESCRIPTOR = &quot;android.view.IWindowManager&quot;;

    public Stub() {
        this.attachInterface(this, DESCRIPTOR);
    }

    public static android.view.IWindowManager asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        if (((iin != null) &amp;&amp; (iin instanceof android.view.IWindowManager))) {
            return ((android.view.IWindowManager) iin);
        }
        return new android.view.IWindowManager.Stub.Proxy(obj);
    }

    public android.os.IBinder asBinder() {
        return this;
    }

    private static class Proxy implements android.view.IWindowManager {
        private android.os.IBinder mRemote;

        Proxy(android.os.IBinder remote) {
            mRemote = remote;
        }

        public android.os.IBinder asBinder() {
            return mRemote;
        }
    }
    ...
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Binder</span><br></pre></td></tr></table></figure>
<p>public class Binder implements IBinder {<br>    public void attachInterface(IInterface owner, String descriptor) {<br>        mOwner = owner;<br>        mDescriptor = descriptor;<br>    }</p>
<pre><code>public IInterface queryLocalInterface(String descriptor) {
    if (mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BinderProxy</span><br></pre></td></tr></table></figure>
<p>final class BinderProxy implements IBinder {<br>    public IInterface queryLocalInterface(String descriptor) {<br>        return null;<br>    }<br>}</p>
<pre><code>

</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/" itemprop="url">项目管理/临时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T22:22:01+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目团队成员之间的沟通原则：<br>1） 沟通目标<br>2） 正确的沟通渠道<br>3） 合适的时间和合适的地点<br>4） 尽量采用面对面的交流<br>5） 采用双向沟通方式，有反馈<br>6） 激发沟通对象的积极性和兴趣</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/" itemprop="url">startActivity源码分析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T15:17:42+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/" itemprop="url" rel="index">
                    <span itemprop="name">Activity</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/" itemprop="url" rel="index">
                    <span itemprop="name">startActivity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Activity/startActivity/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;</span><br><span class="line">  - ActivityManagerService.java</span><br><span class="line">  - ActivityStackSupervisor.java</span><br><span class="line">  - ActivityStack.java</span><br><span class="line">  - ActivityRecord.java</span><br><span class="line">  - ProcessRecord.java</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">  - IActivityManager.java</span><br><span class="line">  - ActivityManagerNative.java (内含AMP)</span><br><span class="line">  - ActivityManager.java</span><br><span class="line"></span><br><span class="line">  - IApplicationThread.java</span><br><span class="line">  - ApplicationThreadNative.java (内含ATP)</span><br><span class="line">  - ActivityThread.java (内含ApplicationThread)</span><br><span class="line"></span><br><span class="line">  - ContextImpl.java</span><br></pre></td></tr></table></figure>

<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-vts-9.0_r13/core/java/android/app/IApplicationThread.aidl" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-vts-9.0_r13/core/java/android/app/IApplicationThread.aidl</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Activity启动发起后，通过Binder最终交由system进程中的AMS来完成，则启动流程如下图：</p>
<p><img src="http://gityuan.com/images/activity/start_activity.jpg" alt="start_activity"></p>
<p><img src="http://gityuan.com/images/activity/start_activity_process.jpg" alt="start_activity_process"></p>
<p>启动流程：</p>
<ol>
<li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li>
<li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li>
<li>Zygote进程fork出新的子进程，即App进程；</li>
<li>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li>
<li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</li>
</ol>
<p>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续计划再进一步讲解生命周期过程与系统是如何交互，以及UI渲染过程，敬请期待。</p>
<h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a><code>MainActivity</code></h2><p>发起页面请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        findViewById(R.id.btn_pic).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                startActivity(new Intent(MainActivity.this, TestSamplePictureActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a><code>Activity</code></h2><h3 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity()"></a><code>startActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        this.startActivity(intent, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;           </span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult()"></a><code>startActivityForResult()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123;</span><br><span class="line">        startActivityForResult(intent, requestCode, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">            @Nullable Bundle options) &#123;</span><br><span class="line">            ...</span><br><span class="line">            Instrumentation.ActivityResult ar &#x3D;</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">          	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>context who:当前Activity</li>
<li>IBinder contextThread：<code>ActivityThread</code>中的<code>ApplicationThread</code></li>
<li>IBinder token：attach()中赋值的IBinder</li>
<li>Activity target:当前Activity</li>
<li>Intent intent：自己传递的intent</li>
<li>int requestCode：返回码</li>
<li>Bundle options：传null也会有一些附加信息<code>transferSpringboardActivityOptions</code>、</li>
</ul>
<p>在返回<code>ActivityResult ar</code>后就过<code>mMainThread.sendActivityResult</code>方法返回到<code>ActivityThread</code>中。<strong>（后续分析）</strong></p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h2><p>每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</p>
<h3 id="execStartActivity"><a href="#execStartActivity" class="headerlink" title="execStartActivity()"></a><code>execStartActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">执行应用程序发出的startActivity调用。 默认实现负责更新任何活动的&#123;@link ActivityMonitor&#125;对象，并将此调用分派给系统活动管理器。 您可以覆盖它以监视应用程序启动活动，并修改执行该操作时发生的情况。</span><br><span class="line"></span><br><span class="line">此方法返回一个&#123;@link ActivityResult&#125;对象，可以在拦截应用程序调用时使用该对象以避免执行start activity操作，但仍返回应用程序期望的结果。 为此，请重写此方法以捕获对启动活动的调用，以便它返回一个新的ActivityResult，其中包含您希望应用程序看到的结果，而不调用超级类。 请注意，如果requestCode 0，则应用程序仅期望结果</span><br><span class="line"></span><br><span class="line">如果未找到用于运行给定Intent的Activity，则此方法将引发&#123;@link android.content.ActivityNotFoundException&#125;。</span><br><span class="line">@param who从中开始活动的上下文。</span><br><span class="line">@param contextThread从其开始活动的Context的主线程。</span><br><span class="line">@param token 内部令牌，标识正在启动活动的系统； 可以为null。</span><br><span class="line">@param target哪个活动正在执行启动（并因此接收到任何结果）； 如果不是通过活动进行此调用，则可以为null。</span><br><span class="line">@param intent实际启动的Intent。</span><br><span class="line">@param requestCode该请求结果的标识符； 如果呼叫者不期望结果，则小于零。</span><br><span class="line">@param options附加选项。</span><br><span class="line">@return要强制返回特定结果，请返回包含所需数据的ActivityResult对象。 否则返回null。 默认实现始终返回null。</span><br><span class="line">*&#x2F;</span><br><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">            ...</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            &#x2F;&#x2F;通过am去执行startActivity</span><br><span class="line">            int result &#x3D; ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            &#x2F;&#x2F;根据result结果判断抛出异常</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a><code>ActivityManager</code></h2><h3 id="getService"><a href="#getService" class="headerlink" title="getService()"></a><code>getService()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">        return IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton &#x3D;</span><br><span class="line">            new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected IActivityManager create() &#123;</span><br><span class="line">                    &#x2F;&#x2F;1. 获取服务的Binder对象</span><br><span class="line">                    final IBinder b &#x3D; ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                     &#x2F;&#x2F;2. aidl 获取AMS</span><br><span class="line">                    final IActivityManager am &#x3D; IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    return am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<p>ServiceManager是安卓中一个重要的类，用于管理所有的系统服务，维护着系统服务和客户端的binder通信。返回的是Binder对象,用来进行应用与系统服务之间的通信的.</p>
<h2 id="IActivityManager"><a href="#IActivityManager" class="headerlink" title="IActivityManager"></a><code>IActivityManager</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Aidl接口</span><br><span class="line">public interface IActivityManager extends IInterface &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startActivity-1"><a href="#startActivity-1" class="headerlink" title="startActivity()"></a><code>startActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">                             String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags,</span><br><span class="line">                             ProfilerInfo profilerInfo, Bundle options) throws RemoteException;</span><br></pre></td></tr></table></figure>

<p>IActivityManager是Aidl的客户端，通过客户端去调用服务端的<code>startActivity</code>的实现方法。我们要找到<code>IActivityManager</code>的具体实现类，在找到他的代理就可以查看它的源码了。</p>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><p><strong>此时进入system_server进程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityManagerService extends IActivityManager.Stub</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>ActivityManagerService</code>就是<code>IActivityManager</code>的具体实现类（如果不懂的话自己先写aidl完成通讯，在查看系统生成的实现类就理解了）</p>
<h3 id="startActivity-2"><a href="#startActivity-2" class="headerlink" title="startActivity()"></a><code>startActivity()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">                resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">                UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startActivityAsUser"><a href="#startActivityAsUser" class="headerlink" title="startActivityAsUser()"></a><code>startActivityAsUser()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">           Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">           int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,</span><br><span class="line">           boolean validateIncomingUser) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line"></span><br><span class="line">       userId &#x3D; mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">               Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; TODO: Switch to user app stacks here.</span><br><span class="line">       &#x2F;&#x2F;在此处切换到用户应用堆栈。</span><br><span class="line">       return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;)</span><br><span class="line">               .setCaller(caller)</span><br><span class="line">               .setCallingPackage(callingPackage)</span><br><span class="line">               .setResolvedType(resolvedType)</span><br><span class="line">               .setResultTo(resultTo)</span><br><span class="line">               .setResultWho(resultWho)</span><br><span class="line">               .setRequestCode(requestCode)</span><br><span class="line">               .setStartFlags(startFlags)</span><br><span class="line">               .setProfilerInfo(profilerInfo)</span><br><span class="line">               .setActivityOptions(bOptions)</span><br><span class="line">               .setMayWait(userId)</span><br><span class="line">               .execute();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>AMS的startActivity方法会调用AMS的startActivityAsUser方法,然后又调用另一个startActivityAsUser方法.最后来了一串链式调用设置信息,最后会来到ActivityStarter的execute方法.</p>
<p><strong>obtainStarter</strong>返回<code>ActivityStarter</code>对象。</p>
<h2 id="ActivityStartController"><a href="#ActivityStartController" class="headerlink" title="ActivityStartController"></a><code>ActivityStartController</code></h2><h3 id="obtainStarter"><a href="#obtainStarter" class="headerlink" title="obtainStarter()"></a><code>obtainStarter()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @return A starter to configure and execute starting an activity. It is valid until after</span><br><span class="line"> *         &#123;@link ActivityStarter#execute&#125; is invoked. At that point, the starter should be</span><br><span class="line"> *         considered invalid and no longer modified or used.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ActivityStarter obtainStarter(Intent intent, String reason) &#123;</span><br><span class="line">    return mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mFactory.obtain()从对象池中获取一个<code>ActivityStarter</code>对象。</p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a><code>ActivityStarter</code></h2><p>控制器，用于解释如何启动活动。<br>此类收集了用于确定将意图和标志如何转换为活动以及相关联的任务和堆栈的所有逻辑。</p>
<p>它是加载Activity的控制类，会收集所有的逻辑来决定如何将Intent和Flags转换为Activity，并将Activity和Task以及Stack相关联。</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Starts an activity based on the request parameters provided earlier.</span><br><span class="line">     * @return The starter result.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int execute() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO(b&#x2F;64750076): Look into passing request directly to these methods to allow</span><br><span class="line">            &#x2F;&#x2F; for transactional diffs and preprocessing.</span><br><span class="line">            &#x2F;&#x2F;TODO（b &#x2F; 64750076）：研究将请求直接传递给这些方法，以允许事务性差异和预处理。</span><br><span class="line">            if (mRequest.mayWait) &#123;</span><br><span class="line">                return startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                        mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                        mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                        mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                        mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                        mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                        mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                        mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                        mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                        mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            onExecutionComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据之前提供的请求参数启动活动。mayWait默认true表示我们应该等待启动请求的结果。</p>
<p>不管如何都不执行startActivity方法。</p>
<h3 id="startActivityMayWait"><a href="#startActivityMayWait" class="headerlink" title="startActivityMayWait"></a>startActivityMayWait</h3><p>这个方法很长很长,还看不懂，最后还是执行<code>startActivity()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">            String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">            ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">            Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,</span><br><span class="line">            int userId, TaskRecord inTask, String reason,</span><br><span class="line">            boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        &#x2F;&#x2F; Refuse possible leaked file descriptors</span><br><span class="line">        &#x2F;&#x2F;拒绝可能的泄漏文件描述符</span><br><span class="line">        if (intent !&#x3D; null &amp;&amp; intent.hasFileDescriptors()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当我们开始启动活动时，尽早通知跟踪器。应该是处理日志的。</span><br><span class="line">        mSupervisor.getActivityMetricsLogger().notifyActivityLaunching();</span><br><span class="line">        &#x2F;&#x2F;处理意图的应用程序组件的名称。</span><br><span class="line">        boolean componentSpecified &#x3D; intent.getComponent() !&#x3D; null;</span><br><span class="line">				&#x2F;&#x2F;返回向您发送当前正在处理的事务的进程的ID。 该pid可以与更高级别的系统服务一起使用，以确定其身份并检查权限。 如果当前线程当前未在执行传入事务，则返回其自己的pid。			</span><br><span class="line">        final int realCallingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">        &#x2F;&#x2F;Uid</span><br><span class="line">        final int realCallingUid &#x3D; Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Save a copy in case ephemeral needs it</span><br><span class="line">        &#x2F;&#x2F;保存副本以防临时需要</span><br><span class="line">        final Intent ephemeralIntent &#x3D; new Intent(intent);</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t modify the client&#39;s object!</span><br><span class="line">        intent &#x3D; new Intent(intent);        </span><br><span class="line">        ...                        </span><br><span class="line">						&#x2F;&#x2F;历史记录堆栈中的一个实体，代表一项活动。</span><br><span class="line">            final ActivityRecord[] outRecord &#x3D; new ActivityRecord[1];</span><br><span class="line">            int res &#x3D; startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                    voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                    ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                    allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">						&#x2F;&#x2F;将当前线程上的传入IPC的身份还原回&#123;@link #clearCallingIdentity&#125;返回的先前身份。</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还是走下面的方法</p>
<h3 id="startActivity-3"><a href="#startActivity-3" class="headerlink" title="startActivity()"></a>startActivity()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">            ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">            boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line"></span><br><span class="line">        if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastStartReason &#x3D; reason;</span><br><span class="line">        mLastStartActivityTimeMs &#x3D; System.currentTimeMillis();</span><br><span class="line">        mLastStartActivityRecord[0] &#x3D; null;</span><br><span class="line"></span><br><span class="line">        mLastStartActivityResult &#x3D; startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">                inTask, allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">        if (outActivity !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">            outActivity[0] &#x3D; mLastStartActivityRecord[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getExternalResult(mLastStartActivityResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样执行的还是很长很长的startActivity()方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            SafeActivityOptions options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">      	...</span><br><span class="line">        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                true &#x2F;* doResume *&#x2F;, checkedOptions, inTask, outActivity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码就是做一些规则判断，是否符合开启Activity的条件，不符合就直接返回错误码，<strong>还记得<code>Instrumentation</code>的<code>checkStartActivityResult（）</code>么，就是根据这里返回的结果抛出异常的比如：<code>ActivityNotFoundException</code></strong>最后还是执行startActivity方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">                int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">                ActivityRecord[] outActivity) &#123;</span><br><span class="line">        int result &#x3D; START_CANCELED;</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F;开始推迟布局传递。 在进行多项更改时很有用，但为了优化性能，仅应执行一次布局遍历。 可以多次调用此方法，并且在最后一个调用者致电&#123;@link continueSurfaceLayout&#125;后，将恢复布局</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">            &#x2F;&#x2F;注意：只能从&#123;@link startActivity&#125;调用此方法。</span><br><span class="line">            result &#x3D; startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; If we are not able to proceed, disassociate the activity from the task. Leaving an</span><br><span class="line">            &#x2F;&#x2F; activity in an incomplete state can lead to issues, such as performing operations</span><br><span class="line">            &#x2F;&#x2F; without a window container.</span><br><span class="line">            &#x2F;&#x2F;如果无法继续，请取消将活动与任务关联。 </span><br><span class="line">            &#x2F;&#x2F;将活动置于不完整状态可能会导致问题，例如在没有窗口容器的情况下执行操作。</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;当前任务的堆栈值，如果没有任务，则返回null。</span><br><span class="line">            final ActivityStack stack &#x3D; mStartActivity.getStack();</span><br><span class="line">            &#x2F;&#x2F;返回启动是否成功。</span><br><span class="line">            if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果此活动已从历史记录列表中删除，则返回true；如果仍在列表中并将稍后删除，则返回false。</span><br><span class="line">                stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                        null &#x2F;* intentResultData *&#x2F;, &quot;startActivity&quot;, true &#x2F;* oomAdj *&#x2F;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;延后布局恢复通过。 参见&#123;@link deferSurfaceLayout（）&#125;</span><br><span class="line">            mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要执行了<code>startActivityUnchecked</code>方法又是一个很长很长的方法，脑袋疼。</p>
<p>之后执行了<code>postStartActivityProcessing</code>,这个方法内部有一个描述</p>
<blockquote>
<p>//我们正在等待活动启动完成，但是该活动只是将另一个活动带到了前面。 我们还必须处理由于蹦床活动处于同一任务而导致任务已经在最前面的情况（由于蹦床将要完成，因此将被视为重点关注）。 让startActivityMayWait（）知道这一点，因此它等待新活动变为可见。</p>
<p>该活动已经在运行，因此尚未启动，但是由于它已经在最前面，所以要么被置于最前面，要么被传递给它新的意图。 通知对此信息感兴趣的任何人。</p>
</blockquote>
<h3 id="startActivityUnchecked"><a href="#startActivityUnchecked" class="headerlink" title="startActivityUnchecked()"></a><code>startActivityUnchecked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Note: This method should only be called from &#123;@link startActivity&#125;.</span><br><span class="line">    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            ActivityRecord[] outActivity) &#123;</span><br><span class="line">            ...</span><br><span class="line">				mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                        mOptions);</span><br><span class="line">				...</span><br><span class="line">        return START_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><p>ActivityStack是一个管理类，用来管理系统所有Activity的各种状态，其内部维护了TaskRecord的列表，因此从Activity任务栈这一角度来说，ActivityStack也可以理解为Activity堆栈。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。ActivityStackSupervisor中有多种ActivityStack实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">...</span><br><span class="line"> mStackSupervisor &#x3D; new ActivityStackSupervisor(this);</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityStackSupervisor implements DisplayListener &#123;</span><br><span class="line">   ...</span><br><span class="line">    ActivityStack mHomeStack;</span><br><span class="line">    ActivityStack mFocusedStack;</span><br><span class="line">    private ActivityStack mLastFocusedStack;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ActivityRecord</strong>：存在历史栈的一个实例，代表一个Activity。</li>
<li><strong>TaskRecord</strong>：Activity栈，内部维护一个ArrayList<ActivityRecord></li>
<li><strong>ActivityStack</strong>：并不是一个Activity栈，真正意义上的Activity栈是TaskRecord，这个类是负责管理各个Activity栈，内部维护一个ArrayList<TaskRecord></li>
<li><strong>ActivityStackSupervisor</strong>：内部持有一个ActivityStack，而ActivityStack内部也持有ActivityStackSupervisor，相当于ActivityStack的辅助管理类</li>
</ul>
<h3 id="resumeFocusedStackTopActivityLocked"><a href="#resumeFocusedStackTopActivityLocked" class="headerlink" title="resumeFocusedStackTopActivityLocked()"></a><code>resumeFocusedStackTopActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">        if (!readyToResume()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (targetStack !&#x3D; null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ActivityRecord r &#x3D; mFocusedStack.topRunningActivityLocked();</span><br><span class="line">        if (r &#x3D;&#x3D; null || !r.isState(RESUMED)) &#123;</span><br><span class="line">            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">        &#125; else if (r.isState(RESUMED)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">            mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a><code>ActivityStack</code></h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-35ca17cdd514d7cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="resumeTopActivityUncheckedLocked"><a href="#resumeTopActivityUncheckedLocked" class="headerlink" title="resumeTopActivityUncheckedLocked()"></a>resumeTopActivityUncheckedLocked()</h3><p>确保在栈顶部活动恢复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Ensure that the top activity in the stack is resumed.</span><br><span class="line"> *</span><br><span class="line"> * @param prev The previously resumed activity, for when in the process</span><br><span class="line"> * of pausing; can be null to call from elsewhere.</span><br><span class="line"> * @param options Activity options.</span><br><span class="line"> *</span><br><span class="line"> * @return Returns true if something is being resumed, or false if</span><br><span class="line"> * nothing happened.</span><br><span class="line"> *</span><br><span class="line"> * NOTE: It is not safe to call this method directly as it can cause an activity in a</span><br><span class="line"> *       non-focused stack to be resumed.</span><br><span class="line"> *       Use &#123;@link ActivityStackSupervisor#resumeFocusedStackTopActivityLocked&#125; to resume the</span><br><span class="line"> *       right activity for the current system state.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GuardedBy(&quot;mService&quot;)</span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t even start recursing.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Protect against recursion.</span><br><span class="line">        &#x2F;&#x2F;防止递归。</span><br><span class="line">        mStackSupervisor.inResumeTopActivity &#x3D; true;</span><br><span class="line">        result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; When resuming the top activity, it may be necessary to pause the top activity (for</span><br><span class="line">        &#x2F;&#x2F; example, returning to the lock screen. We suppress the normal pause logic in</span><br><span class="line">        &#x2F;&#x2F; &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span><br><span class="line">        &#x2F;&#x2F; end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span><br><span class="line">        &#x2F;&#x2F; to ensure any necessary pause logic occurs. In the case where the Activity will be</span><br><span class="line">        &#x2F;&#x2F; shown regardless of the lock screen, the call to</span><br><span class="line">        &#x2F;&#x2F; &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;恢复顶层活动时，可能有必要暂停顶层活动（例如，返回到锁定屏幕。由于顶层活动会在最后恢复，因此我们在&#123;@link #resumeTopActivityUncheckedLocked&#125;中取消了正常的暂停逻辑 为了确保发生任何必要的暂停逻辑，我们在此处再次调用&#123;@link ActivityStackSupervisor＃checkReadyForSleepLocked&#125;。</span><br><span class="line">        final ActivityRecord next &#x3D; topRunningActivityLocked(true &#x2F;* focusableOnly *&#x2F;);</span><br><span class="line">        if (next &#x3D;&#x3D; null || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resumeTopActivityInnerLocked"><a href="#resumeTopActivityInnerLocked" class="headerlink" title="resumeTopActivityInnerLocked()"></a><code>resumeTopActivityInnerLocked()</code></h3><pre><code>@GuardedBy(&quot;mService&quot;)
private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
    if (!mService.mBooting &amp;&amp; !mService.mBooted) {
        // Not ready yet!
        //还没有准备好！
        return false;
    }

          ...

        //堆栈中没有任何活动，让我们看看其他地方。
    if (!hasRunningActivity) {
        // There are no activities left in the stack, let&apos;s look somewhere else.
        return resumeTopActivityInNextFocusableStack(prev, options, &quot;noMoreActivities&quot;);
    }
        ...       
    mStackSupervisor.startSpecificActivityLocked(next, true, true);
    return true;
}</code></pre><h2 id="ActivityStackSupervisor-1"><a href="#ActivityStackSupervisor-1" class="headerlink" title="ActivityStackSupervisor"></a><code>ActivityStackSupervisor</code></h2><h3 id="startSpecificActivityLocked"><a href="#startSpecificActivityLocked" class="headerlink" title="startSpecificActivityLocked()"></a><code>startSpecificActivityLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        &#x2F;&#x2F; Is this activity&#39;s application already running?</span><br><span class="line">        &#x2F;&#x2F;此活动的应用程序已经在运行吗？</span><br><span class="line">        &#x2F;&#x2F;获取应用进程信息</span><br><span class="line">        ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line">				&#x2F;&#x2F;进程存在则启动</span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t add this if it is a platform component that is marked</span><br><span class="line">                    &#x2F;&#x2F; to run in multiple processes, because this is actually</span><br><span class="line">                    &#x2F;&#x2F; part of the framework so doesn&#39;t make sense to track as a</span><br><span class="line">                    &#x2F;&#x2F; separate apk in the process.</span><br><span class="line">                    &#x2F;&#x2F;如果它是标记为可以在多个进程中运行的平台组件，则不要添加它，因为它实际上是框架的一部分，因此在进程中作为单独的apk进行跟踪没有意义。</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a dead object exception was thrown -- fall through to</span><br><span class="line">            &#x2F;&#x2F; restart the application.</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;如果抛出了死对象异常-请重新启动应用程序。</span><br><span class="line">        &#125;</span><br><span class="line">				    &#x2F;&#x2F;进程不存在则创建</span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果进程存在调用<code>realStartActivityLocked</code>直接开起activity;如果没有进程则AMS创建一个进程<code>mService.startProcessLocked</code></p>
<h2 id="ActivityManagerService-1"><a href="#ActivityManagerService-1" class="headerlink" title="ActivityManagerService"></a><code>ActivityManagerService</code></h2><p>AMS(ActivityManagerService)是贯穿Android系统组件的核心服务，负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作。</p>
<h3 id="startProcessLocked"><a href="#startProcessLocked" class="headerlink" title="startProcessLocked()"></a><code>startProcessLocked()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">final ProcessRecord startProcessLocked(String processName,</span><br><span class="line">        ApplicationInfo info, boolean knownToBeDead, int intentFlags,</span><br><span class="line">        String hostingType, ComponentName hostingName, boolean allowWhileBooting,</span><br><span class="line">        boolean isolated, boolean keepIfLarge) &#123;</span><br><span class="line">    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">            hostingName, allowWhileBooting, isolated, 0 &#x2F;* isolatedUid *&#x2F;, keepIfLarge,</span><br><span class="line">            null &#x2F;* ABI override *&#x2F;, null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;,</span><br><span class="line">            null &#x2F;* crashHandler *&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则校验的代码太多了此类会经过一系列的startxxx方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">            boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)&#123;</span><br><span class="line">            ...</span><br><span class="line">            checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;);</span><br><span class="line">       		 final boolean success &#x3D; startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">       		 checkTime(startTime, &quot;startProcess: done starting proc!&quot;);</span><br><span class="line">      		  ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final boolean startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) &#123;</span><br><span class="line">						...</span><br><span class="line">						return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                    startTime);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,</span><br><span class="line">            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">            long startTime) &#123;</span><br><span class="line">            	...</span><br><span class="line">            	final ProcessStartResult startResult &#x3D; startProcess(hostingType, entryPoint, app,</span><br><span class="line">                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        invokeWith, startTime);</span><br><span class="line">                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                        startSeq, false);</span><br><span class="line">            	...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startProcess"><a href="#startProcess" class="headerlink" title="startProcess()"></a><code>startProcess()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private ProcessStartResult startProcess(String hostingType, String entryPoint,</span><br><span class="line">            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">            long startTime) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (hostingType.equals(&quot;webview_service&quot;)) &#123;</span><br><span class="line">                startResult &#x3D; startWebView(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, null,</span><br><span class="line">                        new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith,</span><br><span class="line">                        new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>AMS最后会调用Process类中的start方法</p>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a><code>Process</code></h2><p>根据类的解释<code>Process</code>：用于管理操作系统进程的工具。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  int uid, int gid, int[] gids,</span><br><span class="line">                                  int runtimeFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String invokeWith,</span><br><span class="line">                                  String[] zygoteArgs) &#123;</span><br><span class="line">        return zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; **</span><br><span class="line"> 开始一个新的进程。</span><br><span class="line"> </span><br><span class="line"> &lt;p&gt;如果启用了进程，则会创建一个新进程，并在其中执行&lt;var&gt; processClass &lt;&#x2F; var&gt;的静态main（）函数。该函数返回后，该过程将继续运行。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;如果进程可用的，则会在调用者的进程中创建一个新进程，并在其中调用&lt;var&gt; processClass &lt;&#x2F; var&gt;的main（）。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; niceName参数（如果不是一个空字符串）是一个自定义名称，该名称将赋予进程而不是使用processClass。即使您使用相同的基本&lt;var&gt; processClass &lt;&#x2F; var&gt;启动它们，这也使您可以轻松识别进程。</span><br><span class="line">     *</span><br><span class="line">     *当invokeWith不为null时，该过程将作为一个新鲜的应用而不是合子叉启动。请注意，仅在uid 0或runtimeFlags包含DEBUG_ENABLE_DEBUGGER时才允许这样做。</span><br><span class="line">     *</span><br><span class="line">     * @param processClass用作流程的主要入口点的类。</span><br><span class="line">     * @param niceName用于该过程的更易读的名称。</span><br><span class="line">     * @param uid进程将在其下运行的用户ID。</span><br><span class="line">     * @param gid将在其下运行进程的组ID。</span><br><span class="line">     * @param gids与该进程关联的其他组ID。</span><br><span class="line">     * @param runtimeFlags运行时的其他标志。</span><br><span class="line">     * @param targetSdkVersion应用程序的目标SDK版本。</span><br><span class="line">     * @param seInfo为新进程提供空的SELinux信息。</span><br><span class="line">     * @param abi非空，此应用程序应以ABI开头。</span><br><span class="line">     * @paramstructionSet为null，确定要使用的指令集。</span><br><span class="line">     * @param appDataDir空-确定应用程序的数据目录。</span><br><span class="line">     * @param invokeWith null-确定要调用的命令。</span><br><span class="line">     * @param zygoteArgs提供给zygote进程的其他参数。</span><br><span class="line">     *</span><br><span class="line">     * @return一个对象，描述尝试启动该过程的结果。</span><br><span class="line">     * @致命启动失败时抛出RuntimeException</span><br><span class="line">     * &#x2F;</span><br></pre></td></tr></table></figure>

<p>最后执行的是<code>ZygoteProcess</code>中start方法.</p>
<h2 id="ZygoteProcess"><a href="#ZygoteProcess" class="headerlink" title="ZygoteProcess"></a><code>ZygoteProcess</code></h2><p>和孵化进程保持通讯状态。 此类负责和孵化进程打开套接字，并代表{@link android.os.Process}类启动进程。</p>
<h3 id="start-1"><a href="#start-1" class="headerlink" title="start()"></a><code>start()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final Process.ProcessStartResult start(final String processClass,</span><br><span class="line">                                                  final String niceName,</span><br><span class="line">                                                  int uid, int gid, int[] gids,</span><br><span class="line">                                                  int runtimeFlags, int mountExternal,</span><br><span class="line">                                                  int targetSdkVersion,</span><br><span class="line">                                                  String seInfo,</span><br><span class="line">                                                  String abi,</span><br><span class="line">                                                  String instructionSet,</span><br><span class="line">                                                  String appDataDir,</span><br><span class="line">                                                  String invokeWith,</span><br><span class="line">                                                  String[] zygoteArgs) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, false &#x2F;* startChildZygote *&#x2F;,</span><br><span class="line">                    zygoteArgs);</span><br><span class="line">        &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="startViaZygote"><a href="#startViaZygote" class="headerlink" title="startViaZygote()"></a><code>startViaZygote()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private Process.ProcessStartResult startViaZygote(final String processClass,</span><br><span class="line">                                                  final String niceName,</span><br><span class="line">                                                  final int uid, final int gid,</span><br><span class="line">                                                  final int[] gids,</span><br><span class="line">                                                  int runtimeFlags, int mountExternal,</span><br><span class="line">                                                  int targetSdkVersion,</span><br><span class="line">                                                  String seInfo,</span><br><span class="line">                                                  String abi,</span><br><span class="line">                                                  String instructionSet,</span><br><span class="line">                                                  String appDataDir,</span><br><span class="line">                                                  String invokeWith,</span><br><span class="line">                                                  boolean startChildZygote,</span><br><span class="line">                                                  String[] extraArgs)</span><br><span class="line">                                                  throws ZygoteStartFailedEx &#123;</span><br><span class="line">     &#x2F;&#x2F;Zygote进程Main方法中的参数                                             </span><br><span class="line">    ArrayList&lt;String&gt; argsForZygote &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; --runtime-args, --setuid&#x3D;, --setgid&#x3D;,</span><br><span class="line">    &#x2F;&#x2F; and --setgroups&#x3D; must go first</span><br><span class="line">    argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">    argsForZygote.add(&quot;--setuid&#x3D;&quot; + uid);</span><br><span class="line">    argsForZygote.add(&quot;--setgid&#x3D;&quot; + gid);</span><br><span class="line">    argsForZygote.add(&quot;--runtime-flags&#x3D;&quot; + runtimeFlags);</span><br><span class="line">    if (mountExternal &#x3D;&#x3D; Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--mount-external-default&quot;);</span><br><span class="line">    &#125; else if (mountExternal &#x3D;&#x3D; Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--mount-external-read&quot;);</span><br><span class="line">    &#125; else if (mountExternal &#x3D;&#x3D; Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--mount-external-write&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    argsForZygote.add(&quot;--target-sdk-version&#x3D;&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; --setgroups is a comma-separated list</span><br><span class="line">    if (gids !&#x3D; null &amp;&amp; gids.length &gt; 0) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        sb.append(&quot;--setgroups&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        int sz &#x3D; gids.length;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            if (i !&#x3D; 0) &#123;</span><br><span class="line">                sb.append(&#39;,&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(gids[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (niceName !&#x3D; null) &#123;</span><br><span class="line">        argsForZygote.add(&quot;--nice-name&#x3D;&quot; + niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">    if (extraArgs !&#x3D; null) &#123;</span><br><span class="line">        for (String arg : extraArgs) &#123;</span><br><span class="line">            argsForZygote.add(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(mLock) &#123;</span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过孵化机制创建一个新的进程，这个方法还拼接了一些参数，在孵化进程中的main方法取出。</p>
<h3 id="openZygoteSocketIfNeeded"><a href="#openZygoteSocketIfNeeded" class="headerlink" title="openZygoteSocketIfNeeded()"></a><code>openZygoteSocketIfNeeded()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Tries to open socket to Zygote process if not already open. If</span><br><span class="line"> * already open, does nothing.  May block and retry.  Requires that mLock be held.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GuardedBy(&quot;mLock&quot;)</span><br><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);</span><br><span class="line"></span><br><span class="line">    if (primaryZygoteState &#x3D;&#x3D; null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            primaryZygoteState &#x3D; ZygoteState.connect(mSocket);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        maybeSetApiBlacklistExemptions(primaryZygoteState, false);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line">    if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The primary zygote didn&#39;t match. Try the secondary.</span><br><span class="line">    if (secondaryZygoteState &#x3D;&#x3D; null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            secondaryZygoteState &#x3D; ZygoteState.connect(mSecondarySocket);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        maybeSetApiBlacklistExemptions(secondaryZygoteState, false);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果尚未打开，则尝试打开套接字到Zygote进程。 如果已经打开，则不执行任何操作。 可能会阻止并重试。 要求保留mLock。</p>
<p>这个方法就是和孵化进程使用socker进行连接，如果连接了不执行操作。</p>
<p>现在socker已经连接上了孵化继承，就差通讯了。</p>
<h3 id="zygoteSendArgsAndGetResult"><a href="#zygoteSendArgsAndGetResult" class="headerlink" title="zygoteSendArgsAndGetResult()"></a><code>zygoteSendArgsAndGetResult()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Sends an argument list to the zygote process, which starts a new child</span><br><span class="line"> * and returns the child&#39;s pid. Please note: the present implementation</span><br><span class="line"> * replaces newlines in the argument list with spaces.</span><br><span class="line"> *</span><br><span class="line"> * @throws ZygoteStartFailedEx if process start failed for any reason</span><br><span class="line"> *&#x2F;</span><br><span class="line">@GuardedBy(&quot;mLock&quot;)</span><br><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">        throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Throw early if any of the arguments are malformed. This means we can</span><br><span class="line">        &#x2F;&#x2F; avoid writing a partial response to the zygote.</span><br><span class="line">        int sz &#x3D; args.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            if (args.get(i).indexOf(&#39;\n&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span><br><span class="line">         * Presently the wire format to the zygote process is:</span><br><span class="line">         * a) a count of arguments (argc, in essence)</span><br><span class="line">         * b) a number of newline-separated argument strings equal to count</span><br><span class="line">         *</span><br><span class="line">         * After the zygote process reads these it will write the pid of</span><br><span class="line">         * the child or -1 on failure, followed by boolean to</span><br><span class="line">         * indicate whether a wrapper process was used.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">        final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg &#x3D; args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Should there be a timeout on this?</span><br><span class="line">        Process.ProcessStartResult result &#x3D; new Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Always read the entire result from the input stream to avoid leaving</span><br><span class="line">        &#x2F;&#x2F; bytes in the stream for future process starts to accidentally stumble</span><br><span class="line">        &#x2F;&#x2F; upon.</span><br><span class="line">        result.pid &#x3D; inputStream.readInt();</span><br><span class="line">        result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        if (result.pid &lt; 0) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将参数列表发送到Zygote进程，该进程将启动一个新的子进程并返回该子进程的pid。</p>
<p>此方法完成和Zygote进程socker通讯，阻塞等待socker信息返回，返回来的数据用ProcessStartResult包装。</p>
<p>接下来请看<strong>【Android进程创建流程】</strong>，经过层层代码，最后fork出一个新进程，利用反射进入<code>ActivityThread.main</code></p>
<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a><code>ActivityThread</code></h2><p>这可以管理应用程序进程中主线程的执行，调度和执行活动，广播以及根据活动管理器的请求对其执行的其他操作。</p>
<h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（未完待续。。。）</p>
<p>请转移至<strong>【ActivityThread开启Activity】</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" itemprop="url">Android源码分析工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T14:15:45+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a></p>
<p><a href="https://android.googlesource.com/" target="_blank" rel="noopener">https://android.googlesource.com/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/" itemprop="url">Binder原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T13:28:45+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="什么是IPC"><a href="#什么是IPC" class="headerlink" title="什么是IPC"></a>什么是IPC</h2><p><strong>IPC(Inter-Process Communication)即进程间通信或者跨进程通信，指两个进程之间数据交换的过程</strong></p>
<p><strong>RPC(Remote Procedure Call的缩写) 是远程进程调用的意思。</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bundle</td>
<td align="center">简单易用</td>
<td align="center">只能传输bundle支持的数据类型</td>
<td align="center">四大组件间的进程通信</td>
</tr>
<tr>
<td align="center">文件共享</td>
<td align="center">简单易用</td>
<td align="center">不适合高并发环境，并且无法做到进程间的实时通讯</td>
<td align="center">无并发访问的情况，交换简单的数据，实时性不高的情况</td>
</tr>
<tr>
<td align="center">aidl</td>
<td align="center">功能强大，支持一对多并发通信，支持实时通信</td>
<td align="center">使用稍复杂，需要处理好线程同步</td>
<td align="center">一对多通信且且有RPC需求</td>
</tr>
<tr>
<td align="center">Messenger</td>
<td align="center">功能一般，支持一对多串行通信，支持实时通信</td>
<td align="center">不能处理好高并发的情况，不支持RPC，数据通过message进行传输，因此只能传输bundle支持的数据类型</td>
<td align="center">低并发一对多即时通讯无RPC需求，或者无法返回结构的RPC</td>
</tr>
<tr>
<td align="center">ContentProvider</td>
<td align="center">在数据源访问方面功能强大，支持一对多并发数据共享，可通过call方法扩展其它操作。</td>
<td align="center">可以理解受约束的AIDL，主要提供数据源的CRUD操作</td>
<td align="center">一对多进程间数据共享</td>
</tr>
<tr>
<td align="center">Socker</td>
<td align="center">功能强大，可以通过网络传输字节流，支持一对多并发实时通信。</td>
<td align="center">实现细节稍微有点繁琐，不支持直接的RPC</td>
<td align="center">网络数据交互</td>
</tr>
</tbody></table>
<h2 id="什么是AIDL"><a href="#什么是AIDL" class="headerlink" title="什么是AIDL"></a>什么是AIDL</h2><p>AIDL（Android Interface Definition Language）即Android接口定义语言，指Android 提供的一种进程间通信 (IPC) 机制。</p>
<h2 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h2><p>Binder是Android中一种跨进程通信的方式。从Android FrameWork角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。从Android应用层的角度来说， BInder是客户端和服务端进行通信的媒介。</p>
<p><strong>Binder线程池最大数为16，超过的请求会被阻塞。在进程间通信时处理并发时，如<code>ContentProvider</code>的CRUD（增删改查）操作方法最多有16个线程同时工作。</strong></p>
<h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p><strong>AIDL是基于Binder机制实现Android上的IPC。</strong></p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><p>简单介绍下什么是 Binder。Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。对于 Binder 更全面的定义，等我们介绍完 Binder 通信原理后再做详细说明。</p>
<ol>
<li>从IPC角度来说：Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有；</li>
<li>从Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h2 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h2><p><img src="http://gityuan.com/images/binder/java_binder/java_binder.jpg" alt="binder_arch"></p>
<h2 id="为什么必须理解-Binder-？"><a href="#为什么必须理解-Binder-？" class="headerlink" title="为什么必须理解 Binder ？"></a>为什么必须理解 Binder ？</h2><p>作为 Android 工程师的你，是不是常常会有这样的疑问：</p>
<ul>
<li>为什么 Activity 间传递对象需要序列化？</li>
<li>Activity 的启动流程是什么样的？</li>
<li>四大组件底层的通信机制是怎样的？</li>
<li>AIDL 内部的实现原理是什么？</li>
</ul>
<p>这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。</p>
<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。</p>
<h2 id="为什么使用-Binder"><a href="#为什么使用-Binder" class="headerlink" title="为什么使用 Binder ?"></a>为什么使用 Binder ?</h2><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<p>注：各种IPC方式数据拷贝次数，此表来源于<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现 - 设计篇</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-2160e70ca6e813ff28c34eec5ae8209c_1440w.jpg" alt="img"></p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<p><strong>最后用一张表格来总结下 Binder 的优势：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" alt="img"></p>
<h1 id="Linux-下传统的进程间通信原理"><a href="#Linux-下传统的进程间通信原理" class="headerlink" title="Linux 下传统的进程间通信原理"></a>Linux 下传统的进程间通信原理</h1><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="https://pic3.zhimg.com/80/v2-38e2ea1d22660b237e17d2a7f298f3d6_1440w.jpg" alt="img"></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h3 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-3c719337413b9c5c4ad0b6c6b8eb0291_1440w.jpg" alt="img"></p>
<h3 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() &#x2F;&#x2F;将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() &#x2F;&#x2F;将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h1 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC 通信原理</h1><p>理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。</p>
<p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy<em>from</em>user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy<em>to</em>user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aab2affe42958a659ea8a517ffaff5a0_1440w.jpg" alt="img"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ul>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ul>
<h1 id="Binder-跨进程通信原理"><a href="#Binder-跨进程通信原理" class="headerlink" title="Binder 跨进程通信原理"></a>Binder 跨进程通信原理</h1><p>理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。</p>
<h2 id="动态内核可加载模块-amp-amp-内存映射"><a href="#动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="动态内核可加载模块 &amp;&amp; 内存映射"></a>动态内核可加载模块 &amp;&amp; 内存映射</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p><strong>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</strong></p>
<p>该函数主要是创建虚拟内存区域 与 共享对象建立映射关系。用内存读写代替 I/O读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 函数原型</span><br><span class="line">  *&#x2F;</span><br><span class="line">void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure>

<p>内部原理：</p>
<ul>
<li>步骤1：创建虚拟内存区域</li>
<li>步骤2：实现地址映射关系(进程的虚拟地址空间关联到共享对象)</li>
</ul>
<p>使用时：</p>
<p>用户进程直接调用mmap()建立映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  *  MAP_SIZE的接收缓存区大小 ， 关联到共享对象中，即建立映射</span><br><span class="line">  *&#x2F;</span><br><span class="line">  mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);</span><br></pre></td></tr></table></figure>

<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h2 id="Binder-IPC-实现原理"><a href="#Binder-IPC-实现原理" class="headerlink" title="Binder IPC 实现原理"></a>Binder IPC 实现原理</h2><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy<em>from</em>user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_1440w.jpg" alt="img"></p>
<h1 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h1><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h2 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h2><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" alt="img"></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 对应的服务器。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7c68928e26f5b96b8b3471ebb1927107_1440w.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
<h2 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h2><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ul>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ul>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p><img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" alt="img"></p>
<h3 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-13361906ecda16e36a3b9cbe3d38cbc1_1440w.jpg" alt="img"></p>
<h2 id="Binder-的完整定义"><a href="#Binder-的完整定义" class="headerlink" title="Binder 的完整定义"></a>Binder 的完整定义</h2><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<h1 id="手动编码实现跨进程调用"><a href="#手动编码实现跨进程调用" class="headerlink" title="手动编码实现跨进程调用"></a>手动编码实现跨进程调用</h1><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<h2 id="各-Java-类职责描述"><a href="#各-Java-类职责描述" class="headerlink" title="各 Java 类职责描述"></a>各 Java 类职责描述</h2><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</li>
<li><strong>IInterface</strong> : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>
<li><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>
<li><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</li>
</ul>
<h2 id="实现过程讲解"><a href="#实现过程讲解" class="headerlink" title="实现过程讲解"></a>实现过程讲解</h2><p>一次跨进程通信必然会涉及到两个进程，在这个例子中 RemoteService 作为服务端进程，提供服务；ClientActivity 作为客户端进程，使用 RemoteService 提供的服务。如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7ca457119bd700a5acf7f69bb0c07e51_1440w.jpg" alt="img"></p>
<p>那么服务端进程具备什么样的能力？能为客户端提供什么样的服务呢？还记得我们前面介绍过的 IInterface 吗，它代表的就是服务端进程具体什么样的能力。因此我们需要定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端具备什么样的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类用来定义服务端 RemoteService 具备什么样的能力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只定义服务端具备什么样的能力是不够的，既然是跨进程调用，那么接下来我们得实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Stub extends Binder implements BookManager &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public static BookManager asInterface(IBinder binder) &#123;</span><br><span class="line">        if (binder &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        IInterface iin &#x3D; binder.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (iin !&#x3D; null &amp;&amp; iin instanceof BookManager)</span><br><span class="line">            return (BookManager) iin;</span><br><span class="line">        return new Proxy(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line"></span><br><span class="line">            case INTERFACE_TRANSACTION:</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            case TRANSAVTION_addBook:</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                Book arg0 &#x3D; null;</span><br><span class="line">                if (data.readInt() !&#x3D; 0) &#123;</span><br><span class="line">                    arg0 &#x3D; Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125;</span><br><span class="line">                this.addBook(arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stub 类中我们重点介绍下 <code>asInterface</code> 和 <code>onTransact</code>。</p>
<p>先说说 <code>asInterface</code>，当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如你在代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。</p>
<p>接下来我们就要实现这个代理类 Proxy 了，既然是代理类自然需要实现 BookManager 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements BookManager &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Proxy(IBinder remote) &#123;</span><br><span class="line">        this.remote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel replay &#x3D; Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            if (book !&#x3D; null) &#123;</span><br><span class="line">                data.writeInt(1);</span><br><span class="line">                book.writeToParcel(data, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data.writeInt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, 0);</span><br><span class="line">            replay.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看 addBook() 的实现；在 Stub 类中，addBook(Book book) 是一个抽象方法，Server 端需要去实现它。</p>
<ul>
<li>如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。</li>
<li>如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。</li>
</ul>
<p>在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。</p>
<p>这样一次跨进程调用就完成了。</p>
<h1 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h1><p><img src="http://gityuan.com/images/binder/summary/binder_proc_relation.png" alt="binder_proc_relation"></p>
<p>对于底层Binder驱动，通过<code>binder_procs</code>链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个<code>ProcessState</code>对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量<code>rb_root threads</code>，来记录当前进程内所有的binder_thread。</p>
<p>Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
