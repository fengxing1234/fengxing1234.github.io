<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/" itemprop="url">如何使用Aidl</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T11:58:35+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/21/Android/Binder/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Aidl/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Aidl是什么"><a href="#Aidl是什么" class="headerlink" title="Aidl是什么"></a>Aidl是什么</h1><p>它全称是Android Interface Definition Language，即Android接口定义语言，为了使其他的进程也可以访问本进程提供的服务，Android使用AIDL来公开服务的接口，它里面定义了本进程可以为其他进程提供什么服务，即定义了一些方法，其他进程就可以通过RPC（远程调用）来调用这些方法，从而获得服务，其中提供服务的进程称为服务端，获取服务的进程称为客户端。</p>
<p><img src="http://gityuan.com/images/binder/prepare/binder_interprocess_communication.png" alt="binder_interprocess_communication"></p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>AIDL的语法十分简单，与Java语言基本保持一致，需要记住的规则有以下几点：</p>
<ol>
<li>AIDL文件以 <strong>.aidl</strong> 为后缀名</li>
<li>AIDL支持的数据类型分为如下几种： <ul>
<li>八种基本数据类型：byte、char、short、int、long、float、double、boolean</li>
<li>String，CharSequence</li>
<li>实现了Parcelable接口的数据类型</li>
<li>List 类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象</li>
<li>Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象</li>
</ul>
</li>
<li>AIDL文件可以分为两类。一类用来声明实现了Parcelable接口的数据类型，以供其他AIDL文件使用那些非默认支持的数据类型。还有一类是用来定义接口方法，声明要暴露哪些接口给客户端调用，定向Tag就是用来标注这些方法的参数值</li>
<li>定向Tag。定向Tag表示在跨进程通信中数据的流向，用于标注方法的参数值，分为 in、out、inout 三种。其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。此外，如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。</li>
<li>明确导包。在AIDL文件中需要明确标明引用到的数据类型所在的包名，即使两个文件处在同个包名下。</li>
</ol>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>客户端绑定服务端的service调用服务端的方法，实现应用数据共享</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>创建aidl接口定义外暴露方法，以及需要的传递的实体。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-5aeb537d22344755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对外接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TestAidl.aidl</span><br><span class="line">package com.zhyen.test;</span><br><span class="line">import com.zhyen.test.Book;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface TestAidl &#123;</span><br><span class="line">       List&lt;Book&gt; getBookList();</span><br><span class="line"></span><br><span class="line">       void addBookInOut(inout Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Book改为声明Parcelable数据类型的AIDL文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Book.aidl</span><br><span class="line">package com.zhyen.test;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>

<p>java类型实体类，注意包的结构相同。此处都是<code>com.zhyen.test</code></p>
<p>自定义数据类型，用于进程间通信的话，必须实现Parcelable接口，Parcelable是类似于Java中的Serializable，Android中定义了Parcelable，用于进程间数据传递，对传输数据进行分解，编组的工作，相对于Serializable，他对于进程间通信更加高效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.test;</span><br><span class="line"></span><br><span class="line">import android.os.Parcel;</span><br><span class="line">import android.os.Parcelable;</span><br><span class="line"></span><br><span class="line">public class Book implements Parcelable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Book(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;book name：&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readFromParcel(Parcel dest) &#123;</span><br><span class="line">        name &#x3D; dest.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Book(Parcel in) &#123;</span><br><span class="line">        this.name &#x3D; in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;Book&gt; CREATOR &#x3D; new Creator&lt;Book&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Book createFromParcel(Parcel source) &#123;</span><br><span class="line">            return new Book(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Book[] newArray(int size) &#123;</span><br><span class="line">            return new Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写服务端service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.test;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class AidlBookService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;AidlService&quot;;</span><br><span class="line">    private List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        books &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        Book book1 &#x3D; new Book(&quot;活着&quot;);</span><br><span class="line">        Book book2 &#x3D; new Book(&quot;或者&quot;);</span><br><span class="line">        Book book3 &#x3D; new Book(&quot;叶应是叶&quot;);</span><br><span class="line">        Book book4 &#x3D; new Book(&quot;https:&#x2F;&#x2F;github.com&#x2F;leavesC&quot;);</span><br><span class="line">        Book book5 &#x3D; new Book(&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9df45b87cfdf&quot;);</span><br><span class="line">        Book book6 &#x3D; new Book(&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;new_one_object&quot;);</span><br><span class="line">        books.add(book1);</span><br><span class="line">        books.add(book2);</span><br><span class="line">        books.add(book3);</span><br><span class="line">        books.add(book4);</span><br><span class="line">        books.add(book5);</span><br><span class="line">        books.add(book6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TestAidl.Stub stub &#x3D; new TestAidl.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public List&lt;Book&gt; getBookList() throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;getBookList: &quot;);</span><br><span class="line">            return books;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void addBookInOut(Book book) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;addBookInOut: &quot; + book);</span><br><span class="line">            books.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">            android:name&#x3D;&quot;.AidlBookService&quot;</span><br><span class="line">            android:enabled&#x3D;&quot;true&quot;</span><br><span class="line">            android:exported&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;com.zhyen.test.action&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure>

<p>服务端已经做好了</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-f2595f3330c66dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>客户端连带着aidl目录全都复制到main目录下，负责java类Book，注意包的结构。</p>
<p>编写客户端代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.base.IMyService;</span><br><span class="line">import com.zhyen.base.Student;</span><br><span class="line">import com.zhyen.test.Book;</span><br><span class="line">import com.zhyen.test.TestAidl;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class TestAIDLActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAIDLActivity&quot;;</span><br><span class="line">    private boolean bookConnected;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    private ServiceConnection connectionBook &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: &quot; + name);</span><br><span class="line">            bookConnected &#x3D; true;</span><br><span class="line">            testAidl &#x3D; TestAidl.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            bookConnected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private TestAidl testAidl;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_activity);</span><br><span class="line">        findViewById(R.id.btn_add_book).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (!bookConnected) return;</span><br><span class="line">                    testAidl.addBookInOut(new Book(&quot;呵呵哒&quot;));</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_book_list).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!bookConnected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    List&lt;Book&gt; bookList &#x3D; testAidl.getBookList();</span><br><span class="line">                    for (Book book : bookList) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;onClick: &quot; + book.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bindServiceBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bindServiceBook() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent();</span><br><span class="line">        intent.setPackage(&quot;com.zhyen.test&quot;);</span><br><span class="line">        intent.setAction(&quot;com.zhyen.test.action&quot;);</span><br><span class="line">        bindService(intent, connectionBook, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unbindService(connectionBook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 活着</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 或者</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 叶应是叶</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: https:&#x2F;&#x2F;github.com&#x2F;leavesC</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9df45b87cfdf</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: http:&#x2F;&#x2F;blog.csdn.net&#x2F;new_one_object</span><br><span class="line">2020-05-21 18:33:13.678 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 呵呵哒</span><br><span class="line">2020-05-21 18:33:13.679 31931-31931&#x2F;com.zhyen.android I&#x2F;chatty: uid&#x3D;10206(com.zhyen.android) identical 6 lines</span><br><span class="line">2020-05-21 18:33:13.679 31931-31931&#x2F;com.zhyen.android D&#x2F;TestAIDLActivity: onClick: 呵呵哒</span><br></pre></td></tr></table></figure>

<h2 id="aidl编译后的样子"><a href="#aidl编译后的样子" class="headerlink" title="aidl编译后的样子"></a>aidl编译后的样子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> *&#x2F;</span><br><span class="line">package com.zhyen.test;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">public interface TestAidl extends android.os.IInterface &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.zhyen.test.TestAidl &#123;</span><br><span class="line">        private static final java.lang.String DESCRIPTOR &#x3D; &quot;com.zhyen.test.TestAidl&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Cast an IBinder object into an com.zhyen.test.TestAidl interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static com.zhyen.test.TestAidl asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin !&#x3D; null) &amp;&amp; (iin instanceof com.zhyen.test.TestAidl))) &#123;</span><br><span class="line">                return ((com.zhyen.test.TestAidl) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.zhyen.test.TestAidl.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">            java.lang.String descriptor &#x3D; DESCRIPTOR;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;com.zhyen.test.Book&gt; _result &#x3D; this.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_addBookInOut: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.zhyen.test.Book _arg0;</span><br><span class="line">                    if ((0 !&#x3D; data.readInt())) &#123;</span><br><span class="line">                        _arg0 &#x3D; com.zhyen.test.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _arg0 &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.addBookInOut(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    if ((_arg0 !&#x3D; null)) &#123;</span><br><span class="line">                        reply.writeInt(1);</span><br><span class="line">                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reply.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    return super.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.zhyen.test.TestAidl &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote &#x3D; remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public java.util.List&lt;com.zhyen.test.Book&gt; getBookList() throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.zhyen.test.Book&gt; _result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result &#x3D; _reply.createTypedArrayList(com.zhyen.test.Book.CREATOR);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addBookInOut(com.zhyen.test.Book book) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    if ((book !&#x3D; null)) &#123;</span><br><span class="line">                        _data.writeInt(1);</span><br><span class="line">                        book.writeToParcel(_data, 0);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _data.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBookInOut, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    if ((0 !&#x3D; _reply.readInt())) &#123;</span><br><span class="line">                        book.readFromParcel(_reply);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_getBookList &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">        static final int TRANSACTION_addBookInOut &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.util.List&lt;com.zhyen.test.Book&gt; getBookList() throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    public void addBookInOut(com.zhyen.test.Book book) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://gityuan.com/images/binder/AIDL/MyServer_java_binder.jpg" alt="aidl image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/" itemprop="url">自定义binder架构的C/S组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T17:46:25+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/Android/Binder/%E8%87%AA%E5%AE%9A%E4%B9%89binder%E6%9E%B6%E6%9E%84%E7%9A%84C-S%E7%BB%84%E4%BB%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Native层Binder"><a href="#Native层Binder" class="headerlink" title="Native层Binder"></a>Native层Binder</h1><p>源码结构：</p>
<ul>
<li>ClientDemo.cpp: 客户端程序</li>
<li>ServerDemo.cpp：服务端程序</li>
<li>IMyService.h：自定义的MyService服务的头文件</li>
<li>IMyService.cpp：自定义的MyService服务</li>
<li>Android.mk：源码build文件</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取service manager引用</span><br><span class="line">    sp &lt; IServiceManager &gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">    &#x2F;&#x2F;注册名为&quot;service.myservice&quot;的服务到service manager</span><br><span class="line">    sm-&gt;addService(String16(&quot;service.myservice&quot;), new BnMyService());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool(); &#x2F;&#x2F;启动线程池</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool(); &#x2F;&#x2F;把主线程加入线程池</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将名为”service.myservice”的BnMyService服务添加到ServiceManager，并启动服务</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取service manager引用</span><br><span class="line">    sp &lt; IServiceManager &gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">    &#x2F;&#x2F;获取名为&quot;service.myservice&quot;的binder接口</span><br><span class="line">    sp &lt; IBinder &gt; binder &#x3D; sm-&gt;getService(String16(&quot;service.myservice&quot;));</span><br><span class="line">    &#x2F;&#x2F;将biner对象转换为强引用类型的IMyService</span><br><span class="line">    sp&lt;IMyService&gt; cs &#x3D; interface_cast &lt; IMyService &gt; (binder);</span><br><span class="line">    &#x2F;&#x2F;利用binder引用调用远程sayHello()方法</span><br><span class="line">    cs-&gt;sayHello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取名为”service.myservice”的服务，再进行类型，最后调用远程方法<code>sayHello()</code></p>
<h2 id="创建MyService"><a href="#创建MyService" class="headerlink" title="创建MyService"></a>创建MyService</h2><p><strong>IMyService.h</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">namespace android</span><br><span class="line">&#123;</span><br><span class="line">    class IMyService : public IInterface</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        DECLARE_META_INTERFACE(MyService); &#x2F;&#x2F;使用宏，申明MyService</span><br><span class="line">        virtual void sayHello()&#x3D;0; &#x2F;&#x2F;定义方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义命令字段</span><br><span class="line">    enum</span><br><span class="line">    &#123;</span><br><span class="line">        HELLO &#x3D; 1,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;申明客户端BpMyService</span><br><span class="line">    class BpMyService: public BpInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        BpMyService(const sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">        virtual void sayHello();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;申明服务端BnMyService</span><br><span class="line">    class BnMyService: public BnInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags &#x3D; 0);</span><br><span class="line">        virtual void sayHello();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能：</p>
<ul>
<li>申明IMyService</li>
<li>申明BpMyService（Binder客户端）</li>
<li>申明BnMyService（Binder的服务端）</li>
</ul>
<p><strong>IMyService.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;IMyService.h&quot;</span><br><span class="line">namespace android</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;使用宏，完成MyService定义</span><br><span class="line">    IMPLEMENT_META_INTERFACE(MyService, &quot;android.demo.IMyService&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;客户端</span><br><span class="line">    BpMyService::BpMyService(const sp&lt;IBinder&gt;&amp; impl) :</span><br><span class="line">            BpInterface&lt;IMyService&gt;(impl) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现客户端sayHello方法</span><br><span class="line">    void BpMyService::sayHello() &#123;</span><br><span class="line">        printf(&quot;BpMyService::sayHello\n&quot;);</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMyService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(HELLO, data, &amp;reply);</span><br><span class="line">        printf(&quot;get num from BnMyService: %d\n&quot;, reply.readInt32());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;服务端，接收远程消息，处理onTransact方法</span><br><span class="line">    status_t BnMyService::onTransact(uint_t code, const Parcel&amp; data,</span><br><span class="line">            Parcel* reply, uint32_t flags) &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case HELLO: &#123;    &#x2F;&#x2F;收到HELLO命令的处理流程</span><br><span class="line">            printf(&quot;BnMyService:: got the client hello\n&quot;);</span><br><span class="line">            CHECK_INTERFACE(IMyService, data, reply);</span><br><span class="line">            sayHello();</span><br><span class="line">            reply-&gt;writeInt32(2015);</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现服务端sayHello方法</span><br><span class="line">    void BnMyService::sayHello() &#123;</span><br><span class="line">        printf(&quot;BnMyService::sayHello\n&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://gityuan.com/images/binder/binderSimple/native_binder_demo.jpg" alt="native_binder"></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><strong>编译生成</strong> 利用Android.mk编译上述代码，在Android的源码中，通过mm编译后，可生成两个可执行文件ServerDemo，ClientDemo。</p>
<p><strong>执行</strong></p>
<p>首先将这两个ServerDemo，ClientDemo可执行文件push到手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push ServerDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ClientDemo &#x2F;system&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>如果push不成功，那么先执行<code>adb remount</code>，再执行上面的指令；如果还不成功，可能就是权限不够。</p>
<p>如果上述开启成功，通过开启两个窗口运行（一个运行client端，另一个运行server端）</p>
<p><strong>结果</strong></p>
<p>服务端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/native_server.png" alt="native_server"></p>
<p>客户端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/native_client.png" alt="native_client"></p>
<h1 id="Framework层Binder"><a href="#Framework层Binder" class="headerlink" title="Framework层Binder"></a>Framework层Binder</h1><p>源码结构：</p>
<p>Server端</p>
<ol>
<li>ServerDemo.java：可执行程序</li>
<li>IMyService.java: 定义IMyService接口</li>
<li>MyService.java：定义MyService</li>
</ol>
<p>Client端</p>
<ol>
<li>ClientDemo.java：可执行程序</li>
<li>IMyService.java: 与Server端完全一致</li>
<li>MyServiceProxy.java：定义MyServiceProxy</li>
</ol>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><p><strong>ServerDemo.java</strong></p>
<p>可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;MyService Start&quot;);</span><br><span class="line">        &#x2F;&#x2F;准备Looper循环执行</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        &#x2F;&#x2F;设置为前台优先级</span><br><span class="line">        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        &#x2F;&#x2F;注册服务</span><br><span class="line">        ServiceManager.addService(&quot;MyService&quot;, new MyService());</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMyService.java</strong></p>
<p>定义sayHello()方法，DESCRIPTOR属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyService extends IInterface &#123;</span><br><span class="line">    static final java.lang.String DESCRIPTOR &#x3D; &quot;com.gityuan.frameworkBinder.MyServer&quot;;</span><br><span class="line">    public void sayHello(String str) throws RemoteException ;</span><br><span class="line">    static final int TRANSACTION_say &#x3D; android.os.IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyService.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Binder implements IMyService&#123;</span><br><span class="line"></span><br><span class="line">    public MyService() &#123;</span><br><span class="line">        this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 将MyService转换为IMyService接口 **&#x2F;</span><br><span class="line">    public static com.gityuan.frameworkBinder.IMyService asInterface( android.os.IBinder obj) &#123;</span><br><span class="line">        if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iInterface &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (((iInterface !&#x3D; null)&amp;&amp;(iInterface instanceof com.gityuan.frameworkBinder.IMyService)))&#123;</span><br><span class="line">            return ((com.gityuan.frameworkBinder.IMyService) iInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 服务端，接收远程消息，处理onTransact方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_say: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            String str &#x3D; data.readString();</span><br><span class="line">            sayHello(str);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 自定义sayHello()方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) &#123;</span><br><span class="line">        System.out.println(&quot;MyService:: Hello, &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><p><strong>ClientDemo.java</strong></p>
<p>可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Client start&quot;);</span><br><span class="line">        IBinder binder &#x3D; ServiceManager.getService(&quot;MyService&quot;); &#x2F;&#x2F;获取名为&quot;MyService&quot;的服务</span><br><span class="line">        IMyService myService &#x3D; new MyServiceProxy(binder); &#x2F;&#x2F;创建MyServiceProxy对象</span><br><span class="line">        myService.sayHello(&quot;binder&quot;); &#x2F;&#x2F;通过MyServiceProxy对象调用接口的方法</span><br><span class="line">        System.out.println(&quot;Client end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMyService.java</strong></p>
<p>与Server端的IMyService是一致，基本都是拷贝一份过来。</p>
<p><strong>MyServiceProxy.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyServiceProxy implements IMyService &#123;</span><br><span class="line">    private android.os.IBinder mRemote;  &#x2F;&#x2F;代表BpBinder</span><br><span class="line"></span><br><span class="line">    public MyServiceProxy(android.os.IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">        return DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 自定义的sayHello()方法 **&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello(String str) throws RemoteException &#123;</span><br><span class="line">        android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(str);</span><br><span class="line">            mRemote.transact(TRANSACTION_say, _data, _reply, 0);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h2><p><img src="http://gityuan.com/images/binder/binderSimple/MyServer_framework_binder.jpg" alt="framework_binder"></p>
<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>首先将ServerDemo，ClientDemo可执行文件，以及ServerDemo.jar，ClientDemo.jar都push到手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push ServerDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ClientDemo &#x2F;system&#x2F;bin</span><br><span class="line">adb push ServerDemo.jar &#x2F;system&#x2F;framework</span><br><span class="line">adb push ClientDemo.jar &#x2F;system&#x2F;framework</span><br></pre></td></tr></table></figure>

<p>如果push不成功，那么先执行<code>adb remount</code>，再执行上面的指令；如果还不成功，可能就是权限不够。</p>
<p>如果上述开启成功，通过开启两个窗口运行（一个运行client端，另一个运行server端）</p>
<p><strong>结果</strong></p>
<p>服务端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/framework_server.png" alt="framework_server"></p>
<p>客户端：</p>
<p><img src="http://gityuan.com/images/binder/binderSimple/framework_client.png" alt="framework_client"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/" itemprop="url">Binder机制framework层分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T13:42:10+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/Android/Binder/Binder%E6%9C%BA%E5%88%B6framework%E5%B1%82%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><p>基于6.0.0_r1地址<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r1/core/java/android/os/" target="_blank" rel="noopener">源码地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">  - IInterface.java</span><br><span class="line">  - IServiceManager.java</span><br><span class="line">  - ServiceManager.java</span><br><span class="line">  - ServiceManagerNative.java(内含ServiceManagerProxy类)</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">  - IBinder.java</span><br><span class="line">  - Binder.java(内含BinderProxy类)</span><br><span class="line">  - Parcel.java</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">  - BinderInternal.java</span><br><span class="line"></span><br><span class="line">framework&#x2F;base&#x2F;core&#x2F;jni&#x2F;</span><br><span class="line">  - AndroidRuntime.cpp</span><br><span class="line">  - android_os_Parcel.cpp</span><br><span class="line">  - android_util_Binder.cpp</span><br></pre></td></tr></table></figure>

<p><strong>IInterface</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Base class for Binder interfaces.  When defining a new interface,</span><br><span class="line"> * you must derive it from IInterface.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve the Binder object associated with this interface.</span><br><span class="line">     * You must use this instead of a plain cast, so that proxy objects</span><br><span class="line">     * can return the correct result.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IServiceManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Basic interface for finding and publishing system services.</span><br><span class="line"> * </span><br><span class="line"> * An implementation of this interface is usually published as the</span><br><span class="line"> * global context object, which can be retrieved via</span><br><span class="line"> * BinderNative.getContextObject().  An easy way to retrieve this</span><br><span class="line"> * is with the static method BnServiceManager.getDefault().</span><br><span class="line"> * </span><br><span class="line"> * @hide</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IServiceManager extends IInterface</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Blocks for a few seconds waiting for it to be</span><br><span class="line">     * published if it does not already exist.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder getService(String name) throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Non-blocking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IBinder checkService(String name) throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">                throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return a list of all currently running services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String[] listServices() throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Assign a permission controller to the service manager.  After set, this</span><br><span class="line">     * interface is checked before any services are added.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    static final String descriptor &#x3D; &quot;android.os.IServiceManager&quot;;</span><br><span class="line">    int GET_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">    int CHECK_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+1;</span><br><span class="line">    int ADD_SERVICE_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+2;</span><br><span class="line">    int LIST_SERVICES_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+3;</span><br><span class="line">    int CHECK_SERVICES_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+4;</span><br><span class="line">    int SET_PERMISSION_CONTROLLER_TRANSACTION &#x3D; IBinder.FIRST_CALL_TRANSACTION+5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ServiceManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** @hide *&#x2F;</span><br><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;ServiceManager&quot;;</span><br><span class="line">    private static IServiceManager sServiceManager;</span><br><span class="line">    private static HashMap&lt;String, IBinder&gt; sCache &#x3D; new HashMap&lt;String, IBinder&gt;();</span><br><span class="line">    private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a reference to a service with the given name.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the service to get</span><br><span class="line">     * @return a reference to the service, or &lt;code&gt;null&lt;&#x2F;code&gt; if the service doesn&#39;t exist</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the new service</span><br><span class="line">     * @param service the service object</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Place a new @a service called @a name into the service</span><br><span class="line">     * manager.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the new service</span><br><span class="line">     * @param service the service object</span><br><span class="line">     * @param allowIsolated set to true to allow isolated sandboxed processes</span><br><span class="line">     * to access this service</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void addService(String name, IBinder service, boolean allowIsolated) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Retrieve an existing service called @a name from the</span><br><span class="line">     * service manager.  Non-blocking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder checkService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().checkService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in checkService&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return a list of all currently running services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String[] listServices() throws RemoteException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return getIServiceManager().listServices();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in listServices&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This is only intended to be called when the process is first being brought</span><br><span class="line">     * up and bound by the activity manager. There is only one thread in the process</span><br><span class="line">     * at that time, so no locking is done.</span><br><span class="line">     * </span><br><span class="line">     * @param cache the cache of service references</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void initServiceCache(Map&lt;String, IBinder&gt; cache) &#123;</span><br><span class="line">        if (sCache.size() !&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;setServiceCache may only be called once&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sCache.putAll(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceManagerNative</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Native implementation of the service manager.  Most clients will only</span><br><span class="line"> * care about getDefault() and possibly asInterface().</span><br><span class="line"> * @hide</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class ServiceManagerNative extends Binder implements IServiceManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Cast a Binder object into a service manager interface, generating</span><br><span class="line">     * a proxy if needed.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public ServiceManagerNative()</span><br><span class="line">    &#123;</span><br><span class="line">        attachInterface(this, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">            case IServiceManager.GET_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; getService(name);</span><br><span class="line">                reply.writeStrongBinder(service);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.CHECK_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; checkService(name);</span><br><span class="line">                reply.writeStrongBinder(service);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.ADD_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String name &#x3D; data.readString();</span><br><span class="line">                IBinder service &#x3D; data.readStrongBinder();</span><br><span class="line">                boolean allowIsolated &#x3D; data.readInt() !&#x3D; 0;</span><br><span class="line">                addService(name, service, allowIsolated);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            case IServiceManager.LIST_SERVICES_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                String[] list &#x3D; listServices();</span><br><span class="line">                reply.writeStringArray(list);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            case IServiceManager.SET_PERMISSION_CONTROLLER_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IServiceManager.descriptor);</span><br><span class="line">                IPermissionController controller</span><br><span class="line">                        &#x3D; IPermissionController.Stub.asInterface(</span><br><span class="line">                                data.readStrongBinder());</span><br><span class="line">                setPermissionController(controller);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder asBinder()</span><br><span class="line">    &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder checkService(String name) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(CHECK_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String[] listServices() throws RemoteException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; services &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">            Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">            data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">            data.writeInt(n);</span><br><span class="line">            n++;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean res &#x3D; mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);</span><br><span class="line">                if (!res) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; The result code that is returned by the C++ code can</span><br><span class="line">                &#x2F;&#x2F; cause the call to throw an exception back instead of</span><br><span class="line">                &#x2F;&#x2F; returning a nice result...  so eat it here and go on.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            services.add(reply.readString());</span><br><span class="line">            reply.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        String[] array &#x3D; new String[services.size()];</span><br><span class="line">        services.toArray(array);</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(controller.asBinder());</span><br><span class="line">        mRemote.transact(SET_PERMISSION_CONTROLLER_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    private IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IBinder</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">public interface IBinder &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The first transaction code available for user commands.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int FIRST_CALL_TRANSACTION  &#x3D; 0x00000001;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The last transaction code available for user commands.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int LAST_CALL_TRANSACTION   &#x3D; 0x00ffffff;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: pingBinder().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int PING_TRANSACTION        &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;P&#39;&lt;&lt;16)|(&#39;N&#39;&lt;&lt;8)|&#39;G&#39;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: dump internal state.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int DUMP_TRANSACTION        &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;D&#39;&lt;&lt;16)|(&#39;M&#39;&lt;&lt;8)|&#39;P&#39;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: interrogate the recipient side</span><br><span class="line">     * of the transaction for its canonical interface descriptor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int INTERFACE_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;N&#39;&lt;&lt;16)|(&#39;T&#39;&lt;&lt;8)|&#39;F&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: send a tweet to the target</span><br><span class="line">     * object.  The data in the parcel is intended to be delivered to</span><br><span class="line">     * a shared messaging service associated with the object; it can be</span><br><span class="line">     * anything, as long as it is not more than 130 UTF-8 characters to</span><br><span class="line">     * conservatively fit within common messaging services.  As part of</span><br><span class="line">     * &#123;@link Build.VERSION_CODES#HONEYCOMB_MR2&#125;, all Binder objects are</span><br><span class="line">     * expected to support this protocol for fully integrated tweeting</span><br><span class="line">     * across the platform.  To support older code, the default implementation</span><br><span class="line">     * logs the tweet to the main log as a simple emulation of broadcasting</span><br><span class="line">     * it publicly over the Internet.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;Also, upon completing the dispatch, the object must make a cup</span><br><span class="line">     * of tea, return it to the caller, and exclaim &quot;jolly good message</span><br><span class="line">     * old boy!&quot;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int TWEET_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;T&#39;&lt;&lt;16)|(&#39;W&#39;&lt;&lt;8)|&#39;T&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * IBinder protocol transaction code: tell an app asynchronously that the</span><br><span class="line">     * caller likes it.  The app is responsible for incrementing and maintaining</span><br><span class="line">     * its own like counter, and may display this value to the user to indicate the</span><br><span class="line">     * quality of the app.  This is an optional command that applications do not</span><br><span class="line">     * need to handle, so the default implementation is to do nothing.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;There is no response returned and nothing about the</span><br><span class="line">     * system will be functionally affected by it, but it will improve the</span><br><span class="line">     * app&#39;s self-esteem.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int LIKE_TRANSACTION   &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;L&#39;&lt;&lt;16)|(&#39;I&#39;&lt;&lt;8)|&#39;K&#39;;</span><br><span class="line">    &#x2F;** @hide *&#x2F;</span><br><span class="line">    int SYSPROPS_TRANSACTION &#x3D; (&#39;_&#39;&lt;&lt;24)|(&#39;S&#39;&lt;&lt;16)|(&#39;P&#39;&lt;&lt;8)|&#39;R&#39;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Flag to &#123;@link #transact&#125;: this is a one-way call, meaning that the</span><br><span class="line">     * caller returns immediately, without waiting for a result from the</span><br><span class="line">     * callee. Applies only if the caller and callee are in different</span><br><span class="line">     * processes.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int FLAG_ONEWAY             &#x3D; 0x00000001;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Limit that should be placed on IPC sizes to keep them safely under the</span><br><span class="line">     * transaction buffer limit.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final int MAX_IPC_SIZE &#x3D; 64 * 1024;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the canonical name of the interface supported by this binder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check to see if the object still exists.</span><br><span class="line">     * </span><br><span class="line">     * @return Returns false if the</span><br><span class="line">     * hosting process is gone, otherwise the result (always by default</span><br><span class="line">     * true) returned by the pingBinder() implementation on the other</span><br><span class="line">     * side.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean pingBinder();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check to see if the process that the binder is in is still alive.</span><br><span class="line">     *</span><br><span class="line">     * @return false if the process is not alive.  Note that if it returns</span><br><span class="line">     * true, the process may have died while the call is returning.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isBinderAlive();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempt to retrieve a local implementation of an interface</span><br><span class="line">     * for this Binder object.  If null is returned, you will need</span><br><span class="line">     * to instantiate a proxy class to marshall calls through</span><br><span class="line">     * the transact() method.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor);</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Print the object&#39;s state into the given stream.</span><br><span class="line">     * </span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Like &#123;@link #dump(FileDescriptor, String[])&#125; but always executes</span><br><span class="line">     * asynchronously.  If the object is local, a new thread is created</span><br><span class="line">     * to perform the dump.</span><br><span class="line">     *</span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Perform a generic operation with the object.</span><br><span class="line">     * </span><br><span class="line">     * @param code The action to perform.  This should</span><br><span class="line">     * be a number between &#123;@link #FIRST_CALL_TRANSACTION&#125; and</span><br><span class="line">     * &#123;@link #LAST_CALL_TRANSACTION&#125;.</span><br><span class="line">     * @param data Marshalled data to send to the target.  Must not be null.</span><br><span class="line">     * If you are not sending any data, you must create an empty Parcel</span><br><span class="line">     * that is given here.</span><br><span class="line">     * @param reply Marshalled data to be received from the target.  May be</span><br><span class="line">     * null if you are not interested in the return value.</span><br><span class="line">     * @param flags Additional operation flags.  Either 0 for a normal</span><br><span class="line">     * RPC, or &#123;@link #FLAG_ONEWAY&#125; for a one-way RPC.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">        throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Interface for receiving a callback when the process hosting an IBinder</span><br><span class="line">     * has gone away.</span><br><span class="line">     * </span><br><span class="line">     * @see #linkToDeath</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public interface DeathRecipient &#123;</span><br><span class="line">        public void binderDied();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Register the recipient for a notification if this binder</span><br><span class="line">     * goes away.  If this binder object unexpectedly goes away</span><br><span class="line">     * (typically because its hosting process has been killed),</span><br><span class="line">     * then the given &#123;@link DeathRecipient&#125;&#39;s</span><br><span class="line">     * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method</span><br><span class="line">     * will be called.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;You will only receive death notifications for remote binders,</span><br><span class="line">     * as local binders by definition can&#39;t die without you dying as well.</span><br><span class="line">     * </span><br><span class="line">     * @throws RemoteException if the target IBinder&#39;s</span><br><span class="line">     * process has already died.</span><br><span class="line">     * </span><br><span class="line">     * @see #unlinkToDeath</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void linkToDeath(DeathRecipient recipient, int flags)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove a previously registered death notification.</span><br><span class="line">     * The recipient will no longer be called if this object</span><br><span class="line">     * dies.</span><br><span class="line">     * </span><br><span class="line">     * @return &#123;@code true&#125; if the &lt;var&gt;recipient&lt;&#x2F;var&gt; is successfully</span><br><span class="line">     * unlinked, assuring you that its</span><br><span class="line">     * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method</span><br><span class="line">     * will not be called;  &#123;@code false&#125; if the target IBinder has already</span><br><span class="line">     * died, meaning the method has been (or soon will be) called.</span><br><span class="line">     * </span><br><span class="line">     * @throws java.util.NoSuchElementException if the given</span><br><span class="line">     * &lt;var&gt;recipient&lt;&#x2F;var&gt; has not been registered with the IBinder, and</span><br><span class="line">     * the IBinder is still alive.  Note that if the &lt;var&gt;recipient&lt;&#x2F;var&gt;</span><br><span class="line">     * was never registered, but the IBinder has already died, then this</span><br><span class="line">     * exception will &lt;em&gt;not&lt;&#x2F;em&gt; be thrown, and you will receive a false</span><br><span class="line">     * return value instead.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Binder</strong></p>
<p>BinderProxy是Binder的内部类实现IBinder接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Set this flag to true to detect anonymous, local or member classes</span><br><span class="line">     * that extend this Binder class and that are not static. These kind</span><br><span class="line">     * of classes can potentially create leaks.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final boolean FIND_POTENTIAL_LEAKS &#x3D; false;</span><br><span class="line">    private static final boolean CHECK_PARCEL_SIZE &#x3D; false;</span><br><span class="line">    static final String TAG &#x3D; &quot;Binder&quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Control whether dump() calls are allowed.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String sDumpDisabled &#x3D; null;</span><br><span class="line">    &#x2F;* mObject is used by native code, do not remove or rename *&#x2F;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private IInterface mOwner;</span><br><span class="line">    private String mDescriptor;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the ID of the process that sent you the current transaction</span><br><span class="line">     * that is being processed.  This pid can be used with higher-level</span><br><span class="line">     * system services to determine its identity and check permissions.</span><br><span class="line">     * If the current thread is not currently executing an incoming transaction,</span><br><span class="line">     * then its own pid is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getCallingPid();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the Linux uid assigned to the process that sent you the</span><br><span class="line">     * current transaction that is being processed.  This uid can be used with</span><br><span class="line">     * higher-level system services to determine its identity and check</span><br><span class="line">     * permissions.  If the current thread is not currently executing an</span><br><span class="line">     * incoming transaction, then its own uid is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getCallingUid();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the UserHandle assigned to the process that sent you the</span><br><span class="line">     * current transaction that is being processed.  This is the user</span><br><span class="line">     * of the caller.  It is distinct from &#123;@link #getCallingUid()&#125; in that a</span><br><span class="line">     * particular user will have multiple distinct apps running under it each</span><br><span class="line">     * with their own uid.  If the current thread is not currently executing an</span><br><span class="line">     * incoming transaction, then its own UserHandle is returned.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final UserHandle getCallingUserHandle() &#123;</span><br><span class="line">        return new UserHandle(UserHandle.getUserId(getCallingUid()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reset the identity of the incoming IPC on the current thread.  This can</span><br><span class="line">     * be useful if, while handling an incoming call, you will be calling</span><br><span class="line">     * on interfaces of other objects that may be local to your process and</span><br><span class="line">     * need to do permission checks on the calls coming into them (so they</span><br><span class="line">     * will check the permission of your own local process, and not whatever</span><br><span class="line">     * process originally called you).</span><br><span class="line">     *</span><br><span class="line">     * @return Returns an opaque token that can be used to restore the</span><br><span class="line">     * original calling identity by passing it to</span><br><span class="line">     * &#123;@link #restoreCallingIdentity(long)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #getCallingPid()</span><br><span class="line">     * @see #getCallingUid()</span><br><span class="line">     * @see #restoreCallingIdentity(long)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native long clearCallingIdentity();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Restore the identity of the incoming IPC on the current thread</span><br><span class="line">     * back to a previously identity that was returned by &#123;@link</span><br><span class="line">     * #clearCallingIdentity&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param token The opaque token that was previously returned by</span><br><span class="line">     * &#123;@link #clearCallingIdentity&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #clearCallingIdentity</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void restoreCallingIdentity(long token);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets the native thread-local StrictMode policy mask.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The StrictMode settings are kept in two places: a Java-level</span><br><span class="line">     * threadlocal for libcore&#x2F;Dalvik, and a native threadlocal (set</span><br><span class="line">     * here) for propagation via Binder calls.  This is a little</span><br><span class="line">     * unfortunate, but necessary to break otherwise more unfortunate</span><br><span class="line">     * dependencies either of Dalvik on Android, or Android</span><br><span class="line">     * native-only code on Dalvik.</span><br><span class="line">     *</span><br><span class="line">     * @see StrictMode</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void setThreadStrictModePolicy(int policyMask);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets the current native thread-local StrictMode policy mask.</span><br><span class="line">     *</span><br><span class="line">     * @see #setThreadStrictModePolicy</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native int getThreadStrictModePolicy();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Flush any Binder commands pending in the current thread to the kernel</span><br><span class="line">     * driver.  This can be</span><br><span class="line">     * useful to call before performing an operation that may block for a long</span><br><span class="line">     * time, to ensure that any pending object references have been released</span><br><span class="line">     * in order to prevent the process from holding on to objects longer than</span><br><span class="line">     * it needs to.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void flushPendingCommands();</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Add the calling thread to the IPC thread pool.  This function does</span><br><span class="line">     * not return until the current process is exiting.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void joinThreadPool();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns true if the specified interface is a proxy.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final boolean isProxy(IInterface iface) &#123;</span><br><span class="line">        return iface.asBinder() !&#x3D; iface;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Call blocks until the number of executing binder threads is less</span><br><span class="line">     * than the maximum number of binder threads allowed for this process.</span><br><span class="line">     * @hide</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native void blockUntilThreadAvailable();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default constructor initializes the object.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Binder() &#123;</span><br><span class="line">        init();</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Binder&gt; klass &#x3D; getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Binder class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Convenience method for associating a specific interface with the Binder.</span><br><span class="line">     * After calling, queryLocalInterface() will be implemented for you</span><br><span class="line">     * to return the given owner IInterface when the corresponding</span><br><span class="line">     * descriptor is requested.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void attachInterface(IInterface owner, String descriptor) &#123;</span><br><span class="line">        mOwner &#x3D; owner;</span><br><span class="line">        mDescriptor &#x3D; descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation returns an empty interface name.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getInterfaceDescriptor() &#123;</span><br><span class="line">        return mDescriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation always returns true -- if you got here,</span><br><span class="line">     * the object is alive.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean pingBinder() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@inheritDoc&#125;</span><br><span class="line">     *</span><br><span class="line">     * Note that if you&#39;re calling on a local binder, this always returns true</span><br><span class="line">     * because your process is alive if you&#39;re calling it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isBinderAlive() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Use information supplied to attachInterface() to return the</span><br><span class="line">     * associated IInterface if it matches the requested</span><br><span class="line">     * descriptor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        if (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">            return mOwner;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Control disabling of dump calls in this process.  This is used by the system</span><br><span class="line">     * process watchdog to disable incoming dump calls while it has detecting the system</span><br><span class="line">     * is hung and is reporting that back to the activity controller.  This is to</span><br><span class="line">     * prevent the controller from getting hung up on bug reports at this point.</span><br><span class="line">     * @hide</span><br><span class="line">     *</span><br><span class="line">     * @param msg The message to show instead of the dump; if null, dumps are</span><br><span class="line">     * re-enabled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setDumpDisabled(String msg) &#123;</span><br><span class="line">        synchronized (Binder.class) &#123;</span><br><span class="line">            sDumpDisabled &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation is a stub that returns false.  You will want</span><br><span class="line">     * to override this to do the appropriate unmarshalling of transactions.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If you want to call this, call transact().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (code &#x3D;&#x3D; INTERFACE_TRANSACTION) &#123;</span><br><span class="line">            reply.writeString(getInterfaceDescriptor());</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (code &#x3D;&#x3D; DUMP_TRANSACTION) &#123;</span><br><span class="line">            ParcelFileDescriptor fd &#x3D; data.readFileDescriptor();</span><br><span class="line">            String[] args &#x3D; data.readStringArray();</span><br><span class="line">            if (fd !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd.getFileDescriptor(), args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        fd.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; swallowed, not propagated back to the caller</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Write the StrictMode header.</span><br><span class="line">            if (reply !&#x3D; null) &#123;</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StrictMode.clearGatheredViolations();</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Implemented to call the more convenient version</span><br><span class="line">     * &#123;@link #dump(FileDescriptor, PrintWriter, String[])&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) &#123;</span><br><span class="line">        FileOutputStream fout &#x3D; new FileOutputStream(fd);</span><br><span class="line">        PrintWriter pw &#x3D; new FastPrintWriter(fout);</span><br><span class="line">        try &#123;</span><br><span class="line">            final String disabled;</span><br><span class="line">            synchronized (Binder.class) &#123;</span><br><span class="line">                disabled &#x3D; sDumpDisabled;</span><br><span class="line">            &#125;</span><br><span class="line">            if (disabled &#x3D;&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd, pw, args);</span><br><span class="line">                &#125; catch (SecurityException e) &#123;</span><br><span class="line">                    pw.println(&quot;Security exception: &quot; + e.getMessage());</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Unlike usual calls, in this case if an exception gets thrown</span><br><span class="line">                    &#x2F;&#x2F; back to us we want to print it back in to the dump data, since</span><br><span class="line">                    &#x2F;&#x2F; that is where the caller expects all interesting information to</span><br><span class="line">                    &#x2F;&#x2F; go.</span><br><span class="line">                    pw.println();</span><br><span class="line">                    pw.println(&quot;Exception occurred while dumping:&quot;);</span><br><span class="line">                    e.printStackTrace(pw);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pw.println(sDumpDisabled);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            pw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Like &#123;@link #dump(FileDescriptor, String[])&#125;, but ensures the target</span><br><span class="line">     * executes asynchronously.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dumpAsync(final FileDescriptor fd, final String[] args) &#123;</span><br><span class="line">        final FileOutputStream fout &#x3D; new FileOutputStream(fd);</span><br><span class="line">        final PrintWriter pw &#x3D; new FastPrintWriter(fout);</span><br><span class="line">        Thread thr &#x3D; new Thread(&quot;Binder.dumpAsync&quot;) &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd, pw, args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    pw.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thr.start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Print the object&#39;s state into the given stream.</span><br><span class="line">     * </span><br><span class="line">     * @param fd The raw file descriptor that the dump is being sent to.</span><br><span class="line">     * @param fout The file to which you should dump your state.  This will be</span><br><span class="line">     * closed for you after you return.</span><br><span class="line">     * @param args additional arguments to the dump request.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default implementation rewinds the parcels and calls onTransact.  On</span><br><span class="line">     * the remote side, transact calls into the binder to do the IPC.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final boolean transact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);</span><br><span class="line">        if (data !&#x3D; null) &#123;</span><br><span class="line">            data.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean r &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        if (reply !&#x3D; null) &#123;</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local implementation is a no-op.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void linkToDeath(DeathRecipient recipient, int flags) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local implementation is a no-op.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void checkParcel(IBinder obj, int code, Parcel parcel, String msg) &#123;</span><br><span class="line">        if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;&#x3D; 800*1024) &#123;</span><br><span class="line">            &#x2F;&#x2F; Trying to send &gt; 800k, this is way too much</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            sb.append(msg);</span><br><span class="line">            sb.append(&quot;: on &quot;);</span><br><span class="line">            sb.append(obj);</span><br><span class="line">            sb.append(&quot; calling &quot;);</span><br><span class="line">            sb.append(code);</span><br><span class="line">            sb.append(&quot; size &quot;);</span><br><span class="line">            sb.append(parcel.dataSize());</span><br><span class="line">            sb.append(&quot; (data: &quot;);</span><br><span class="line">            parcel.setDataPosition(0);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;, &quot;);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;, &quot;);</span><br><span class="line">            sb.append(parcel.readInt());</span><br><span class="line">            sb.append(&quot;)&quot;);</span><br><span class="line">            Slog.wtfStack(TAG, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private native final void init();</span><br><span class="line">    private native final void destroy();</span><br><span class="line">    &#x2F;&#x2F; Entry point from android_util_Binder.cpp&#39;s onTransact</span><br><span class="line">    private boolean execTransact(int code, long dataObj, long replyObj,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain(replyObj);</span><br><span class="line">        &#x2F;&#x2F; theoretically, we should call transact, which will call onTransact,</span><br><span class="line">        &#x2F;&#x2F; but all that does is rewind it, and we just got these from an IPC,</span><br><span class="line">        &#x2F;&#x2F; so we&#39;ll just call it directly.</span><br><span class="line">        boolean res;</span><br><span class="line">        &#x2F;&#x2F; Log any exceptions as warnings, don&#39;t silently suppress them.</span><br><span class="line">        &#x2F;&#x2F; If the call was FLAG_ONEWAY then these exceptions disappear into the ether.</span><br><span class="line">        try &#123;</span><br><span class="line">            res &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Binder call failed.&quot;, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply.setDataPosition(0);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            if ((flags &amp; FLAG_ONEWAY) !&#x3D; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reply.setDataPosition(0);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Unconditionally log this, since this is generally unrecoverable.</span><br><span class="line">            Log.e(TAG, &quot;Caught an OutOfMemoryError from the binder stub implementation.&quot;, e);</span><br><span class="line">            RuntimeException re &#x3D; new RuntimeException(&quot;Out of memory&quot;, e);</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">            reply.writeException(re);</span><br><span class="line">            res &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        checkParcel(this, code, reply, &quot;Unreasonably large binder reply buffer&quot;);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        &#x2F;&#x2F; Just in case -- we are done with the IPC, so there should be no more strict</span><br><span class="line">        &#x2F;&#x2F; mode violations that have gathered for this thread.  Either they have been</span><br><span class="line">        &#x2F;&#x2F; parceled and are now in transport off to the caller, or we are returning back</span><br><span class="line">        &#x2F;&#x2F; to the main transaction loop to wait for another incoming transaction.  Either</span><br><span class="line">        &#x2F;&#x2F; way, strict mode begone!</span><br><span class="line">        StrictMode.clearGatheredViolations();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    public native boolean pingBinder();</span><br><span class="line">    public native boolean isBinderAlive();</span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">        return transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    public native String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line">    public native boolean transactNative(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException;</span><br><span class="line">    public native void linkToDeath(DeathRecipient recipient, int flags)</span><br><span class="line">            throws RemoteException;</span><br><span class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(DUMP_TRANSACTION, data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(DUMP_TRANSACTION, data, reply, FLAG_ONEWAY);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxy() &#123;</span><br><span class="line">        mSelf &#x3D; new WeakReference(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private native final void destroy();</span><br><span class="line">    </span><br><span class="line">    private static final void sendDeathNotice(DeathRecipient recipient) &#123;</span><br><span class="line">        if (false) Log.v(&quot;JavaBinder&quot;, &quot;sendDeathNotice to &quot; + recipient);</span><br><span class="line">        try &#123;</span><br><span class="line">            recipient.binderDied();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RuntimeException exc) &#123;</span><br><span class="line">            Log.w(&quot;BinderNative&quot;, &quot;Uncaught exception from death notification&quot;,</span><br><span class="line">                    exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final private WeakReference mSelf;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private long mOrgue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder概述"><a href="#Binder概述" class="headerlink" title="Binder概述"></a>Binder概述</h1><h2 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h2><p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p>
<p><img src="http://gityuan.com/images/binder/java_binder/java_binder.jpg" alt="java_binder"></p>
<ul>
<li>图中红色代表整个framework层 binder架构相关组件；<ul>
<li>Binder类代表Server端，BinderProxy类代码Client端；</li>
</ul>
</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的，后面会详细说明。</li>
</ul>
<h2 id="Binder类图"><a href="#Binder类图" class="headerlink" title="Binder类图"></a>Binder类图</h2><p><img src="http://gityuan.com/images/binder/java_binder/class_ServiceManager.jpg" alt="class_java_binder"></p>
<ul>
<li><strong>ServiceManager：</strong>通过getIServiceManager方法获取的是ServiceManagerProxy对象； ServiceManager的addService, getService实际工作都交由ServiceManagerProxy的相应方法来处理；</li>
<li><strong>ServiceManagerProxy：</strong>其成员变量mRemote指向BinderProxy对象，ServiceManagerProxy的addService, getService方法最终是交由mRemote来完成。</li>
<li><strong>ServiceManagerNative</strong>：其方法asInterface()返回的是ServiceManagerProxy对象，ServiceManager便是借助ServiceManagerNative类来找到ServiceManagerProxy；</li>
<li><strong>Binder：</strong>其成员变量mObject和方法execTransact()用于native方法</li>
<li><strong>BinderInternal：</strong>内部有一个GcWatcher类，用于处理和调试与Binder相关的垃圾回收。</li>
<li><strong>IBinder：</strong>接口中常量FLAG_ONEWAY：客户端利用binder跟服务端通信是阻塞式的，但如果设置了FLAG_ONEWAY，这成为非阻塞的调用方式，客户端能立即返回，服务端采用回调方式来通知客户端完成情况。另外IBinder接口有一个内部接口DeathDecipient(死亡通告)。</li>
</ul>
<h2 id="Binder类分层"><a href="#Binder类分层" class="headerlink" title="Binder类分层"></a>Binder类分层</h2><p>整个Binder从kernel至，native，JNI，Framework层所涉及的全部类</p>
<p><img src="http://gityuan.com/images/binder/java_binder_framework.jpg" alt="java_binder_framework"></p>
<h1 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h1><h2 id="SM-addService"><a href="#SM-addService" class="headerlink" title="SM.addService"></a>SM.addService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看getIServiceManager()过程，如下：</p>
<h2 id="getIServiceManager"><a href="#getIServiceManager" class="headerlink" title="getIServiceManager"></a>getIServiceManager</h2><p><strong>ServiceManager.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>采用了单例模式获取ServiceManager getIServiceManager()返回的是ServiceManagerProxy(简称SMP)对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceManagerProxy</code> 是<code>ServiceManagerNative</code>的内部类，实现IServiceManager接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return mRemote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IBinder checkService(String name) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] listServices(int dumpPriority) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPermissionController(IPermissionController controller)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getContextObject"><a href="#getContextObject" class="headerlink" title="getContextObject()"></a>getContextObject()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Return the global &quot;context object&quot; of the system.  This is usually</span><br><span class="line">     * an implementation of IServiceManager, which you can use to find</span><br><span class="line">     * other services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final native IBinder getContextObject();</span><br></pre></td></tr></table></figure>

<p>调用jni中方法<code>android_os_BinderInternal_getContextObject</code>返回IBinder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b &#x3D; ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ProcessState::self()-&gt;getContextObject()，在<a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">获取ServiceManager</a>的第3节已详细解决，即<code>ProcessState::self()-&gt;getContextObject()</code>等价于 <code>new BpBinder(0)</code>;</p>
<h4 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder"></a>javaObjectForIBinder</h4><p>[-&gt; android_util_binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val) &#123;</span><br><span class="line">    if (val &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; &#x2F;&#x2F;返回false</span><br><span class="line">        jobject object &#x3D; static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line"></span><br><span class="line">    jobject object &#x3D; (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    if (object !&#x3D; NULL) &#123; &#x2F;&#x2F;第一次object为null</span><br><span class="line">        jobject res &#x3D; jniGetReferent(env, object);</span><br><span class="line">        if (res !&#x3D; NULL) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建BinderProxy对象</span><br><span class="line">    object &#x3D; env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    if (object !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;BinderProxy.mObject成员变量记录BpBinder对象</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">        val-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line"></span><br><span class="line">        jobject refObject &#x3D; env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        &#x2F;&#x2F;将BinderProxy对象信息附加到BpBinder的成员变量mObjects中</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line"></span><br><span class="line">        sp&lt;DeathRecipientList&gt; drl &#x3D; new DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        &#x2F;&#x2F;BinderProxy.mOrgue成员变量记录死亡通知对象</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast&lt;jlong&gt;(drl.get()));</span><br><span class="line"></span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据BpBinder(C++)生成BinderProxy(Java)对象. 主要工作是创建BinderProxy对象,并把BpBinder对象地址保存到BinderProxy.mObject成员变量. 到此，可知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject()) </span><br><span class="line">等价于</span><br><span class="line">ServiceManagerNative.asInterface(new BinderProxy())</span><br></pre></td></tr></table></figure>

<h2 id="SMN-asInterface"><a href="#SMN-asInterface" class="headerlink" title="SMN.asInterface"></a>SMN.asInterface</h2><p>[-&gt; ServiceManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;obj为BpBinder</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由于obj为BpBinder，该方法默认返回null</span><br><span class="line">    IServiceManager in &#x3D; (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    if (in !&#x3D; null) &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line">    return new ServiceManagerProxy(obj); &#x2F;&#x2F;【见小节3.3.1】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，可知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(new BinderProxy()) </span><br><span class="line">等价于</span><br><span class="line">new ServiceManagerProxy(new BinderProxy())</span><br></pre></td></tr></table></figure>

<p> 为了方便，ServiceManagerProxy简称为SMP。</p>
<h3 id="ServiceManagerProxy初始化"><a href="#ServiceManagerProxy初始化" class="headerlink" title="ServiceManagerProxy初始化"></a>ServiceManagerProxy初始化</h3><p>[-&gt; ServiceManagerNative.java ::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote为BinderProxy对象，该BinderProxy对象对应于BpBinder(0)，其作为binder代理端，指向native层大管家service Manager。</p>
<p><code>ServiceManager.getIServiceManager</code>最终等价于<code>new ServiceManagerProxy(new BinderProxy())</code>,意味着【3.1】中的getIServiceManager().addService()，等价于SMP.addService().</p>
<p>framework层的ServiceManager的调用实际的工作确实交给SMP的成员变量BinderProxy；而BinderProxy通过jni方式，最终会调用BpBinder对象；可见上层binder架构的核心功能依赖native架构的服务来完成的。</p>
<h2 id="ServiceManagerProxy-addService"><a href="#ServiceManagerProxy-addService" class="headerlink" title="ServiceManagerProxy.addService"></a>ServiceManagerProxy.addService</h2><p>[-&gt; ServiceManagerNative.java ::ServiceManagerProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123;</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">    Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    &#x2F;&#x2F;【见小节3.5】</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? 1 : 0);</span><br><span class="line">    &#x2F;&#x2F;mRemote为BinderProxy【见小节3.7】</span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="data-writeStrongBinder-service-Java"><a href="#data-writeStrongBinder-service-Java" class="headerlink" title="data.writeStrongBinder(service)Java"></a>data.writeStrongBinder(service)Java</h2><p>[-&gt; Parcel.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public writeStrongBinder(IBinder val)&#123;</span><br><span class="line">    &#x2F;&#x2F;此处为Native调用【见3.5.1】</span><br><span class="line">    nativewriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativeWriteStrongBinder-JNI"><a href="#nativeWriteStrongBinder-JNI" class="headerlink" title="nativeWriteStrongBinder()JNI"></a>nativeWriteStrongBinder()JNI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static native void nativeWriteStrongBinder(long nativePtr, IBinder val);</span><br></pre></td></tr></table></figure>

<p>[-&gt; android_os_Parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object) &#123;</span><br><span class="line">    &#x2F;&#x2F;将java层Parcel转换为native层Parcel</span><br><span class="line">    Parcel* parcel &#x3D; reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;【见3.5.2】</span><br><span class="line">        const status_t err &#x3D; parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</span><br><span class="line">        if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ibinderForJavaObject"><a href="#ibinderForJavaObject" class="headerlink" title="ibinderForJavaObject"></a>ibinderForJavaObject</h4><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Java层的Binder对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh &#x3D; (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetLongField(obj, gBinderOffsets.mObject);</span><br><span class="line">        return jbh !&#x3D; NULL ? jbh-&gt;get(env, obj) : NULL; &#x2F;&#x2F;【见3.5.3】</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;Java层的BinderProxy对象</span><br><span class="line">    if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        return (IBinder*)env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Binde(Java)生成JavaBBinderHolder(C++)对象. 主要工作是创建JavaBBinderHolder对象,并把JavaBBinderHolder对象地址保存到Binder.mObject成员变量.</p>
<h4 id="JavaBBinderHolder-get"><a href="#JavaBBinderHolder-get" class="headerlink" title="JavaBBinderHolder.get()"></a>JavaBBinderHolder.get()</h4><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    sp&lt;JavaBBinder&gt; b &#x3D; mBinder.promote();</span><br><span class="line">    if (b &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;首次进来，创建JavaBBinder对象【见3.5.4】</span><br><span class="line">        b &#x3D; new JavaBBinder(env, obj);</span><br><span class="line">        mBinder &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaBBinderHolder有一个成员变量mBinder，保存当前创建的JavaBBinder对象，这是一个wp类型的，可能会被垃圾回收器给回收，所以每次使用前，都需要先判断是否存在。</p>
<h4 id="JavaBBinder初始化"><a href="#JavaBBinder初始化" class="headerlink" title="JavaBBinder初始化"></a>JavaBBinder初始化</h4><p>==&gt; [-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaBBinder(JNIEnv* env, jobject object)</span><br><span class="line">    : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object))</span><br><span class="line">&#123;</span><br><span class="line">    android_atomic_inc(&amp;gNumLocalRefs);</span><br><span class="line">    incRefsCreated(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建JavaBBinder，该对象继承于BBinder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.writeStrongBinder(service)</span><br><span class="line">最终等价于&#96;parcel-&gt;</span><br><span class="line">writeStrongBinder(new JavaBBinder(env, obj))&#96;;</span><br></pre></td></tr></table></figure>

<h3 id="writeStrongBinder-C"><a href="#writeStrongBinder-C" class="headerlink" title="writeStrongBinder()C++"></a>writeStrongBinder()C++</h3><p>[-&gt; parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    return flatten_binder(ProcessState::self(), val, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flatten-binder"><a href="#flatten-binder" class="headerlink" title="flatten_binder"></a>flatten_binder</h4><p>[-&gt; parcel.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; &#x2F;*proc*&#x2F;,</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags &#x3D; 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    if (binder !&#x3D; NULL) &#123;</span><br><span class="line">        IBinder *local &#x3D; binder-&gt;localBinder();</span><br><span class="line">        if (!local) &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; binder-&gt;remoteBinder();</span><br><span class="line">            const int32_t handle &#x3D; proxy ? proxy-&gt;handle() : 0;</span><br><span class="line">            obj.type &#x3D; BINDER_TYPE_HANDLE; &#x2F;&#x2F;远程Binder</span><br><span class="line">            obj.binder &#x3D; 0;</span><br><span class="line">            obj.handle &#x3D; handle;</span><br><span class="line">            obj.cookie &#x3D; 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj.type &#x3D; BINDER_TYPE_BINDER; &#x2F;&#x2F;本地Binder，进入该分支</span><br><span class="line">            obj.binder &#x3D; reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie &#x3D; reinterpret_cast&lt;uintptr_t&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj.type &#x3D; BINDER_TYPE_BINDER;  &#x2F;&#x2F;本地Binder</span><br><span class="line">        obj.binder &#x3D; 0;</span><br><span class="line">        obj.cookie &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见小节3.6.2】</span><br><span class="line">    return finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Binder对象扁平化，转换成flat_binder_object对象。</p>
<ul>
<li>对于Binder实体，则cookie记录Binder实体的指针；</li>
<li>对于Binder代理，则用handle记录Binder代理的句柄；</li>
</ul>
<p>关于localBinder，代码见Binder.cpp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BBinder* BBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BBinder* IBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finish-flatten-binder"><a href="#finish-flatten-binder" class="headerlink" title="finish_flatten_binder"></a>finish_flatten_binder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline static status_t finish_flatten_binder(</span><br><span class="line">    const sp&lt;IBinder&gt;&amp; , const flat_binder_object&amp; flat, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    return out-&gt;writeObject(flat, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会带Java代码addService过程，则接下来进入transact</p>
<h2 id="BinderProxy-transact"><a href="#BinderProxy-transact" class="headerlink" title="BinderProxy.transact"></a>BinderProxy.transact</h2><p>[-&gt; Binder.java ::BinderProxy]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F;用于检测Parcel大小是否大于800k</span><br><span class="line">    Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">    return transactNative(code, data, reply, flags); &#x2F;&#x2F;【见3.8】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到ServiceManagerProxy.addService，其成员变量mRemote是BinderProxy。transactNative经过jni调用，进入下面的方法</p>
<h3 id="android-os-BinderProxy-transact"><a href="#android-os-BinderProxy-transact" class="headerlink" title="android_os_BinderProxy_transact"></a>android_os_BinderProxy_transact</h3><p>[-&gt; android_util_Binder.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">    jint code, jobject dataObj, jobject replyObj, jint flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;java Parcel转为native Parcel</span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;gBinderProxyOffsets.mObject中保存的是new BpBinder(0)对象</span><br><span class="line">    IBinder* target &#x3D; (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此处便是BpBinder::transact(), 经过native层，进入Binder驱动程序</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的BinderProxy.transact()最终交由Native层的BpBinder::transact()完成。Native Binder的<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a>中有详细说明BpBinder执行过程。另外，该方法可抛出RemoteException。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>addService的核心过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    Parcel data &#x3D; Parcel.obtain(); &#x2F;&#x2F;此处还需要将java层的Parcel转为Native层的Parcel</span><br><span class="line">    data-&gt;writeStrongBinder(new JavaBBinder(env, obj));</span><br><span class="line">    BpBinder::transact(ADD_SERVICE_TRANSACTION, *data, reply, 0); &#x2F;&#x2F;与Binder驱动交互</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册服务过程就是通过BpBinder来发送<code>ADD_SERVICE_TRANSACTION</code>命令，与实现与binder驱动进行数据交互。</p>
<h1 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h1><h2 id="SM-getService"><a href="#SM-getService" class="headerlink" title="SM.getService"></a>SM.getService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder service &#x3D; sCache.get(name); &#x2F;&#x2F;先从缓存中查看HashMap</span><br><span class="line">        if (service !&#x3D; null) &#123;</span><br><span class="line">            return service;</span><br><span class="line">        &#125; else &#123;</span><br></pre></td></tr></table></figure>
<pre><code>        return getIServiceManager().getService(name); 【见4.2】
    }
} catch (RemoteException e) {
    Log.e(TAG, &quot;error in getService&quot;, e);
}
return null;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关于getIServiceManager()，在前面已经讲述了，等价于new ServiceManagerProxy(new BinderProxy())。 其中sCache &#x3D; new HashMap&lt;String, IBinder&gt;()以hashmap格式缓存已组成的名称。请求获取服务过程中，先从缓存中查询是否存在，如果缓存中不存在的话，再通过binder交互来查询相应的服务。</span><br><span class="line"></span><br><span class="line">## ServiceManagerProxy.getService()</span><br></pre></td></tr></table></figure>
<p>class ServiceManagerProxy implements IServiceManager {<br>    public IBinder getService(String name) throws RemoteException {<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IServiceManager.descriptor);<br>        data.writeString(name);<br>        //mRemote为BinderProxy 【见4.3】<br>        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);<br>        //从reply里面解析出获取的IBinder对象【见4.8】<br>        IBinder binder = reply.readStrongBinder();<br>        reply.recycle();<br>        data.recycle();<br>        return binder;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BinderProxy.transact</span><br><span class="line"></span><br><span class="line">[-&gt; Binder.java]</span><br></pre></td></tr></table></figure>
<p>final class BinderProxy implements IBinder {<br>    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {<br>        Binder.checkParcel(this, code, data, “Unreasonably large binder buffer”);<br>        return transactNative(code, data, reply, flags);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## android_os_BinderProxy_transact</span><br><span class="line"></span><br><span class="line">[-&gt; android_util_Binder.cpp]</span><br></pre></td></tr></table></figure>
<p>static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,<br>    jint code, jobject dataObj, jobject replyObj, jint flags)<br>{<br>    …<br>    //java Parcel转为native Parcel<br>    Parcel* data = parcelForJavaObject(env, dataObj);<br>    Parcel* reply = parcelForJavaObject(env, replyObj);<br>    …</p>
<pre><code>//gBinderProxyOffsets.mObject中保存的是new BpBinder(0)对象
IBinder* target = (IBinder*)
    env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);
...

//此处便是BpBinder::transact(), 经过native层[见小节4.5]
status_t err = target-&gt;transact(code, *data, reply, flags);
...
return JNI_FALSE;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BpBinder.transact</span><br></pre></td></tr></table></figure>
<p>status_t BpBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    if (mAlive) {<br>        // [见小节4.6]<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);<br>        if (status == DEAD_OBJECT) mAlive = 0;<br>        return status;<br>    }</p>
<pre><code>return DEAD_OBJECT;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## IPC.transact</span><br><span class="line"></span><br><span class="line">[-&gt; IPCThreadState.cpp]</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck(); //数据错误检查<br>    flags |= TF_ACCEPT_FDS;<br>    ….<br>    if (err == NO_ERROR) {<br>         // 传输数据<br>        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);<br>    }<br>    …</p>
<pre><code>// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果
if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        //等待回应事件
        err = waitForResponse(reply);
    }else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}
return err;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  IPC.waitForResponse</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck(); //数据错误检查<br>    flags |= TF_ACCEPT_FDS;<br>    ….<br>    if (err == NO_ERROR) {<br>         // 传输数据<br>        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);<br>    }<br>    …</p>
<pre><code>// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果
if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        //等待回应事件
        err = waitForResponse(reply);
    }else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}
return err;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  IPC.waitForResponse</span><br></pre></td></tr></table></figure>
<p>status_t IPCThreadState::waitForResponse(Parcel <em>reply, status_t *acquireResult)<br>{<br>    int32_t cmd;<br>    int32_t err;<br>    while (1) {<br>        if ((err=talkWithDriver()) &lt; NO_ERROR) break;<br>        …<br>        cmd = mIn.readInt32();<br>        switch (cmd) {<br>          case BR_REPLY:<br>          {<br>            binder_transaction_data tr;<br>            err = mIn.read(&amp;tr, sizeof(tr));<br>            if (reply) {<br>                if ((tr.flags &amp; TF_STATUS_CODE) == 0) {<br>                    //当reply对象回收时，则会调用freeBuffer来回收内存<br>                    reply-&gt;ipcSetDataReference(<br>                        reinterpret_cast&lt;const uint8_t</em>&gt;(tr.data.ptr.buffer),<br>                        tr.data_size,<br>                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),<br>                        tr.offsets_size/sizeof(binder_size_t),<br>                        freeBuffer, this);<br>                } else {<br>                    …<br>                }<br>            }<br>          }<br>          case :…<br>        }<br>    }<br>    …<br>    return err;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么这个reply是哪来的呢，在文章[Binder系列3—启动ServiceManager](http:&#x2F;&#x2F;gityuan.com&#x2F;2015&#x2F;11&#x2F;07&#x2F;binder-start-sm&#x2F;)</span><br><span class="line"></span><br><span class="line">### binder_send_reply</span><br><span class="line"></span><br><span class="line">[-&gt; servicemanager&#x2F;binder.c]</span><br></pre></td></tr></table></figure>
<p>void binder_send_reply(struct binder_state *bs, struct binder_io *reply, binder_uintptr_t buffer_to_free, int status) {<br>    struct {<br>        uint32_t cmd_free;<br>        binder_uintptr_t buffer;<br>        uint32_t cmd_reply;<br>        struct binder_transaction_data txn;<br>    } <strong>attribute</strong>((packed)) data;</p>
<pre><code>data.cmd_free = BC_FREE_BUFFER; //free buffer命令
data.buffer = buffer_to_free;
data.cmd_reply = BC_REPLY; // reply命令
data.txn.target.ptr = 0;
data.txn.cookie = 0;
data.txn.code = 0;
if (status) {
    ...
} else {=

    data.txn.flags = 0;
    data.txn.data_size = reply-&gt;data - reply-&gt;data0;
    data.txn.offsets_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
    data.txn.data.ptr.buffer = (uintptr_t)reply-&gt;data0;
    data.txn.data.ptr.offsets = (uintptr_t)reply-&gt;offs0;
}
//向Binder驱动通信
binder_write(bs, &amp;data, sizeof(data));</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">binder_write将BC_FREE_BUFFER和BC_REPLY命令协议发送给驱动，进入驱动。binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write，由于是BC_REPLY命令协议，则进入binder_transaction， 该方法会向请求服务的线程Todo队列插入事务。</span><br><span class="line"></span><br><span class="line">接下来，请求服务的进程在执行talkWithDriver的过程执行到binder_thread_read()，处理Todo队列的事务。</span><br><span class="line"></span><br><span class="line">## readStrongBinder</span><br><span class="line"></span><br><span class="line">[-&gt; Parcel.java]</span><br><span class="line"></span><br><span class="line">readStrongBinder的过程基本是writeStrongBinder逆过程。</span><br></pre></td></tr></table></figure>
<p>static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) {<br>    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);<br>    if (parcel != NULL) {<br>        //【见小节4.8.1】<br>        return javaObjectForIBinder(env, parcel-&gt;readStrongBinder());<br>    }<br>    return NULL;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。</span><br><span class="line"></span><br><span class="line">### readStrongBinder(C++)</span><br><span class="line"></span><br><span class="line">[-&gt; Parcel.cpp]</span><br></pre></td></tr></table></figure>
<p>sp<IBinder> Parcel::readStrongBinder() const<br>{<br>    sp<IBinder> val;<br>    //【见小节4.8.2】<br>    unflatten_binder(ProcessState::self(), *this, &amp;val);<br>    return val;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### unflatten_binder</span><br></pre></td></tr></table></figure>
<p>status_t unflatten_binder(const sp<ProcessState>&amp; proc,<br>    const Parcel&amp; in, sp<IBinder>* out)<br>{<br>    const flat_binder_object* flat = in.readObject(false);<br>    if (flat) {<br>        switch (flat-&gt;type) {<br>            case BINDER_TYPE_BINDER:<br>                <em>out = reinterpret_cast&lt;IBinder</em>&gt;(flat-&gt;cookie);<br>                return finish_unflatten_binder(NULL, <em>flat, in);<br>            case BINDER_TYPE_HANDLE:<br>                //进入该分支【见4.8.3】<br>                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);<br>                //创建BpBinder对象<br>                return finish_unflatten_binder(<br>                    static_cast&lt;BpBinder</em>&gt;(out-&gt;get()), *flat, in);<br>        }<br>    }<br>    return BAD_TYPE;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### getStrongProxyForHandle</span><br></pre></td></tr></table></figure>
<p>sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)<br>{<br>    sp<IBinder> result;</p>
<pre><code>AutoMutex _l(mLock);
//查找handle对应的资源项
handle_entry* e = lookupHandleLocked(handle);

if (e != NULL) {
    IBinder* b = e-&gt;binder;
    if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
        ...
        //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象
        b = new BpBinder(handle);
        e-&gt;binder = b;
        if (b) e-&gt;refs = b-&gt;getWeakRefs();
        result = b;
    } else {
        result.force_set(b);
        e-&gt;refs-&gt;decWeak(this);
    }
}
return result;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。回到[小节4.8] 经过javaObjectForIBinder将native层BpBinder对象转换为Java层BinderProxy对象。 也就是说通过getService()最终获取了指向目标Binder服务端的代理对象BinderProxy。</span><br><span class="line"></span><br><span class="line">## 小结</span><br><span class="line"></span><br><span class="line">getService的核心过程：</span><br></pre></td></tr></table></figure>
<p>public static IBinder getService(String name) {<br>    …<br>    Parcel reply = Parcel.obtain(); //此处还需要将java层的Parcel转为Native层的Parcel<br>    BpBinder::transact(GET_SERVICE_TRANSACTION, *data, reply, 0);  //与Binder驱动交互<br>    IBinder binder = javaObjectForIBinder(env, new BpBinder(handle));<br>    …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javaObjectForIBinder作用是创建BinderProxy对象，并将BpBinder对象的地址保存到BinderProxy对象的mObjects中。 获取服务过程就是通过BpBinder来发送&#96;GET_SERVICE_TRANSACTION&#96;命令，与实现与binder驱动进行数据交互。</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line"></span><br><span class="line">以IWindowManager为例</span><br></pre></td></tr></table></figure>
<p>public interface IWindowManager extends android.os.IInterface {</p>
<pre><code>public static abstract class Stub extends android.os.Binder implements android.view.IWindowManager {
    private static final java.lang.String DESCRIPTOR = &quot;android.view.IWindowManager&quot;;

    public Stub() {
        this.attachInterface(this, DESCRIPTOR);
    }

    public static android.view.IWindowManager asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
        if (((iin != null) &amp;&amp; (iin instanceof android.view.IWindowManager))) {
            return ((android.view.IWindowManager) iin);
        }
        return new android.view.IWindowManager.Stub.Proxy(obj);
    }

    public android.os.IBinder asBinder() {
        return this;
    }

    private static class Proxy implements android.view.IWindowManager {
        private android.os.IBinder mRemote;

        Proxy(android.os.IBinder remote) {
            mRemote = remote;
        }

        public android.os.IBinder asBinder() {
            return mRemote;
        }
    }
    ...
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Binder</span><br></pre></td></tr></table></figure>
<p>public class Binder implements IBinder {<br>    public void attachInterface(IInterface owner, String descriptor) {<br>        mOwner = owner;<br>        mDescriptor = descriptor;<br>    }</p>
<pre><code>public IInterface queryLocalInterface(String descriptor) {
    if (mDescriptor.equals(descriptor)) {
        return mOwner;
    }
    return null;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BinderProxy</span><br></pre></td></tr></table></figure>
<p>final class BinderProxy implements IBinder {<br>    public IInterface queryLocalInterface(String descriptor) {<br>        return null;<br>    }<br>}</p>
<pre><code>

</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/" itemprop="url">项目管理/临时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T22:22:01+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%B8%B4%E6%97%B6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目团队成员之间的沟通原则：<br>1） 沟通目标<br>2） 正确的沟通渠道<br>3） 合适的时间和合适的地点<br>4） 尽量采用面对面的交流<br>5） 采用双向沟通方式，有反馈<br>6） 激发沟通对象的积极性和兴趣</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url">startActivity源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T15:17:42+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/startActivity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="首次分析startActivity"><a href="#首次分析startActivity" class="headerlink" title="首次分析startActivity"></a>首次分析startActivity</h1><h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;</span><br><span class="line">  - ActivityManagerService.java</span><br><span class="line">  - ActivityStackSupervisor.java</span><br><span class="line">  - ActivityStack.java</span><br><span class="line">  - ActivityRecord.java</span><br><span class="line">  - ProcessRecord.java</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">  - IActivityManager.java</span><br><span class="line">  - ActivityManagerNative.java (内含AMP)</span><br><span class="line">  - ActivityManager.java</span><br><span class="line"></span><br><span class="line">  - IApplicationThread.java</span><br><span class="line">  - ApplicationThreadNative.java (内含ATP)</span><br><span class="line">  - ActivityThread.java (内含ApplicationThread)</span><br><span class="line"></span><br><span class="line">  - ContextImpl.java</span><br></pre></td></tr></table></figure>

<h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r1/core/java/android/app/IActivityManager.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r1/core/java/android/app/IActivityManager.java</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Activity启动发起后，通过Binder最终交由system进程中的AMS来完成，则启动流程如下图：</p>
<p><img src="http://gityuan.com/images/activity/start_activity.jpg" alt="start_activity"></p>
<p><img src="http://gityuan.com/images/activity/start_activity_process.jpg" alt="start_activity_process"></p>
<p>启动流程：</p>
<ol>
<li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li>
<li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li>
<li>Zygote进程fork出新的子进程，即App进程；</li>
<li>App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li>
<li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</li>
</ol>
<p>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续计划再进一步讲解生命周期过程与系统是如何交互，以及UI渲染过程，敬请期待。</p>
<h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><p>Android一般是这样开起一个界面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn_pic).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                startActivity(new Intent(MainActivity.this, TestSamplePictureActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p><strong>startActivity()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        this.startActivity(intent, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Note we want to go through this call for compatibility with</span><br><span class="line">            &#x2F;&#x2F; applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个重载方法</li>
<li>不管第二个参数如何都执行startActivityForResult</li>
</ul>
<p><strong>startActivityForResult</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123;</span><br><span class="line">        startActivityForResult(intent, requestCode, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">            @Nullable Bundle options) &#123;</span><br><span class="line">        &#x2F;&#x2F;只要没有用到ActivityGroup，mParent就为空</span><br><span class="line">        if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            options &#x3D; transferSpringboardActivityOptions(options);</span><br><span class="line">            Instrumentation.ActivityResult ar &#x3D;</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            if (ar !&#x3D; null) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; If this start is requesting a result, we can avoid making</span><br><span class="line">                &#x2F;&#x2F; the activity visible until the result is received.  Setting</span><br><span class="line">                &#x2F;&#x2F; this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br><span class="line">                &#x2F;&#x2F; activity hidden during this time, to avoid flickering.</span><br><span class="line">                &#x2F;&#x2F; This can only be done when a result is requested because</span><br><span class="line">                &#x2F;&#x2F; that guarantees we will get information back when the</span><br><span class="line">                &#x2F;&#x2F; activity is finished, no matter what happens to it.</span><br><span class="line">                mStartedActivity &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            &#x2F;&#x2F; TODO Consider clearing&#x2F;flushing other event sources and events for child windows.</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options !&#x3D; null) &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Note we want to go through this method for compatibility with</span><br><span class="line">                &#x2F;&#x2F; existing applications that may have overridden it.</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只要没有用到ActivityGroup，mParent就为空，正常使用会执行mInstrumentation.execStartActivity(）方法</p>
<h3 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation#execStartActivity"></a>Instrumentation#execStartActivity</h3><p><strong>mInstrumentation.execStartActivity()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, String target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        IApplicationThread whoThread &#x3D; (IApplicationThread) contextThread;</span><br><span class="line">        &#x2F;&#x2F;遍历mActivityMonitors，看目标Activity是否存在，如果不存在直接退出</span><br><span class="line">        if (mActivityMonitors !&#x3D; null) &#123;</span><br><span class="line">            synchronized (mSync) &#123;</span><br><span class="line">                final int N &#x3D; mActivityMonitors.size();</span><br><span class="line">                for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                    final ActivityMonitor am &#x3D; mActivityMonitors.get(i);</span><br><span class="line">                    ActivityResult result &#x3D; null;</span><br><span class="line">                    if (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                        result &#x3D; am.onStartActivity(intent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (result !&#x3D; null) &#123;</span><br><span class="line">                        am.mHits++;</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125; else if (am.match(who, null, intent)) &#123;</span><br><span class="line">                        am.mHits++;</span><br><span class="line">                        if (am.isBlocking()) &#123;</span><br><span class="line">                            return requestCode &gt;&#x3D; 0 ? am.getResult() : null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            &#x2F;&#x2F;通过am去执行startActivity</span><br><span class="line">            int result &#x3D; ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target, requestCode, 0, null, options);</span><br><span class="line">            &#x2F;&#x2F;根据返回值抛出异常</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Instrumentation类相当于一个管家，它的职责是管理各个应用程序和系统的交互，Instrumentation将在任何应用程序运行前初始化，每个进程只会存在一个Instrumentation对象，且每个Activity都有此对象的实际引用，可以通过它监测系统与应用程序之间的所有交互。</p>
<h3 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h3><p>首先看<code>ActivityManager.getService()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">        return IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton &#x3D;</span><br><span class="line">            new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected IActivityManager create() &#123;</span><br><span class="line">                    final IBinder b &#x3D; ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    final IActivityManager am &#x3D; IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    return am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<p>IActivityManager是一个aidl接口，</p>
<h3 id="IActivityManager"><a href="#IActivityManager" class="headerlink" title="IActivityManager"></a><code>IActivityManager</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Aidl接口</span><br><span class="line">public interface IActivityManager extends IInterface &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要找到他的实现类;如果我们自己自定的aidl接口，ide会自定生成实现类，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyService extends android.os.IInterface &#123;</span><br><span class="line">    </span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.zhyen.base.IMyService &#123;</span><br><span class="line">        private static final java.lang.String DESCRIPTOR &#x3D; &quot;com.zhyen.base.IMyService&quot;;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.zhyen.base.IMyService &#123;</span><br><span class="line">           </span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">    public java.util.List&lt;com.zhyen.base.Student&gt; getStudent() throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    public void addStudent(com.zhyen.base.Student student) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时只要操作stub类就可以进行通信；同理我们需要找到IActivityManager对应的“Stub”，这个“Stub”就是<strong>ActivityManagerNative</strong>。</p>
<h3 id="ActivityManagerNative"><a href="#ActivityManagerNative" class="headerlink" title="ActivityManagerNative"></a><code>ActivityManagerNative</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;</span><br><span class="line"></span><br><span class="line">      static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">              if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">              IActivityManager in &#x3D;</span><br><span class="line">                  (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">              if (in !&#x3D; null) &#123;</span><br><span class="line">                  return in;</span><br><span class="line">              &#125;</span><br><span class="line">              return new ActivityManagerProxy(obj);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承binder类实现IActivityManageraidl接口。</p>
<h3 id="ActivityManagerProxy-startActivity"><a href="#ActivityManagerProxy-startActivity" class="headerlink" title="ActivityManagerProxy#startActivity"></a><code>ActivityManagerProxy#startActivity</code></h3><p>经过以前的分析，如果是夸进程调用最终执行的是<code>ActivityManagerProxy</code>中对应的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager&#123;</span><br><span class="line">    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">                String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">                int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</span><br><span class="line">            Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">            Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">            data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">            data.writeStrongBinder(caller !&#x3D; null ? caller.asBinder() : null);</span><br><span class="line">            data.writeString(callingPackage);</span><br><span class="line">            intent.writeToParcel(data, 0);</span><br><span class="line">            data.writeString(resolvedType);</span><br><span class="line">            data.writeStrongBinder(resultTo);</span><br><span class="line">            data.writeString(resultWho);</span><br><span class="line">            data.writeInt(requestCode);</span><br><span class="line">            data.writeInt(startFlags);</span><br><span class="line">            if (profilerInfo !&#x3D; null) &#123;</span><br><span class="line">                data.writeInt(1);</span><br><span class="line">                profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data.writeInt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            if (options !&#x3D; null) &#123;</span><br><span class="line">                data.writeInt(1);</span><br><span class="line">                options.writeToParcel(data, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data.writeInt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">            int result &#x3D; reply.readInt();</span><br><span class="line">            reply.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);`</p>
<p>其实在Binder类中<code>mRemote.transact</code>就是回调ActivityManagerNative中的<code>onTransact</code>方法</p>
<p>[Binder]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);</span><br><span class="line"></span><br><span class="line">        if (data !&#x3D; null) &#123;</span><br><span class="line">            data.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean r &#x3D; onTransact(code, data, reply, flags);</span><br><span class="line">        if (reply !&#x3D; null) &#123;</span><br><span class="line">            reply.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来程序进入了system_servr进程，开始继续执行。</p>
<h3 id="ActivityManagerNative-onTransact"><a href="#ActivityManagerNative-onTransact" class="headerlink" title="ActivityManagerNative#onTransact"></a><code>ActivityManagerNative#onTransact</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">          throws RemoteException &#123;</span><br><span class="line">      switch (code) &#123;</span><br><span class="line">      case START_ACTIVITY_TRANSACTION:</span><br><span class="line">      &#123;</span><br><span class="line">          data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">          IBinder b &#x3D; data.readStrongBinder();</span><br><span class="line">          IApplicationThread app &#x3D; ApplicationThreadNative.asInterface(b);</span><br><span class="line">          String callingPackage &#x3D; data.readString();</span><br><span class="line">          Intent intent &#x3D; Intent.CREATOR.createFromParcel(data);</span><br><span class="line">          String resolvedType &#x3D; data.readString();</span><br><span class="line">          IBinder resultTo &#x3D; data.readStrongBinder();</span><br><span class="line">          String resultWho &#x3D; data.readString();</span><br><span class="line">          int requestCode &#x3D; data.readInt();</span><br><span class="line">          int startFlags &#x3D; data.readInt();</span><br><span class="line">          ProfilerInfo profilerInfo &#x3D; data.readInt() !&#x3D; 0</span><br><span class="line">                  ? ProfilerInfo.CREATOR.createFromParcel(data) : null;</span><br><span class="line">          Bundle options &#x3D; data.readInt() !&#x3D; 0</span><br><span class="line">                  ? Bundle.CREATOR.createFromParcel(data) : null;</span><br><span class="line">          int result &#x3D; startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                  resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          reply.writeInt(result);</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在onTransact中调用了startActivity，熟悉aidl的应该知道调用的是服务端的具体实现方法，这个具体实现就是<code>ActivityManagerService</code>类。</p>
<h3 id="ActivityManagerService-startActivity"><a href="#ActivityManagerService-startActivity" class="headerlink" title="ActivityManagerService#startActivity"></a><code>ActivityManagerService#startActivity</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">				...</span><br><span class="line">        public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123;</span><br><span class="line">            return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">                resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">                UserHandle.getCallingUserId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123;</span><br><span class="line">            enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">            userId &#x3D; handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                    false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">         </span><br><span class="line">            return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">                    resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                    profilerInfo, null, null, options, false, userId, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处mStackSupervisor的数据类型为<code>ActivityStackSupervisor</code></p>
<h3 id="ActivityStackSupervisor-startActivityMayWait"><a href="#ActivityStackSupervisor-startActivityMayWait" class="headerlink" title="ActivityStackSupervisor#startActivityMayWait"></a><code>ActivityStackSupervisor#startActivityMayWait</code></h3><p>当程序运行到这里时, ASS.startActivityMayWait的各个参数取值如下:</p>
<ul>
<li>caller = ApplicationThreadProxy, 用于跟调用者进程ApplicationThread进行通信的binder代理类.</li>
<li>callingUid = -1;</li>
<li>callingPackage = ContextImpl.getBasePackageName(),获取调用者Activity所在包名</li>
<li>intent: 这是启动Activity时传递过来的参数;</li>
<li>resolvedType = intent.resolveTypeIfNeeded</li>
<li>voiceSession = null;</li>
<li>voiceInteractor = null;</li>
<li>resultTo = Activity.mToken, 其中Activity是指调用者所在Activity, mToken对象保存自己所处的ActivityRecord信息</li>
<li>resultWho = Activity.mEmbeddedID, 其中Activity是指调用者所在Activity</li>
<li>requestCode = -1;</li>
<li>startFlags = 0;</li>
<li>profilerInfo = null;</li>
<li>outResult = null;</li>
<li>config = null;</li>
<li>options = null;</li>
<li>ignoreTargetSecurity = false;</li>
<li>userId = AMS.handleIncomingUser, 当调用者userId跟当前处于同一个userId,则直接返回该userId;当不相等时则根据调用者userId来决定是否需要将callingUserId转换为mCurrentUserId.</li>
<li>iContainer = null;</li>
<li>inTask = null;</li>
</ul>
<p>再来看看这个方法的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123;</span><br><span class="line">    ...</span><br><span class="line">    boolean componentSpecified &#x3D; intent.getComponent() !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;创建新的Intent对象，即便intent被修改也不受影响</span><br><span class="line">    intent &#x3D; new Intent(intent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;收集Intent所指向的Activity信息, 当存在多个可供选择的Activity,则直接向用户弹出resolveActivity [见2.7.1]</span><br><span class="line">    ActivityInfo aInfo &#x3D; resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);</span><br><span class="line"></span><br><span class="line">    ActivityContainer container &#x3D; (ActivityContainer)iContainer;</span><br><span class="line">    synchronized (mService) &#123;</span><br><span class="line">        if (container !&#x3D; null &amp;&amp; container.mParentActivity !&#x3D; null &amp;&amp;</span><br><span class="line">                container.mParentActivity.state !&#x3D; RESUMED) &#123;</span><br><span class="line">            ... &#x2F;&#x2F;不进入该分支, container &#x3D;&#x3D; nul</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int realCallingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">        final int realCallingUid &#x3D; Binder.getCallingUid();</span><br><span class="line">        int callingPid;</span><br><span class="line">        if (callingUid &gt;&#x3D; 0) &#123;</span><br><span class="line">            callingPid &#x3D; -1;</span><br><span class="line">        &#125; else if (caller &#x3D;&#x3D; null) &#123;</span><br><span class="line">            callingPid &#x3D; realCallingPid;</span><br><span class="line">            callingUid &#x3D; realCallingUid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            callingPid &#x3D; callingUid &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ActivityStack stack;</span><br><span class="line">        if (container &#x3D;&#x3D; null || container.mStack.isOnHomeDisplay()) &#123;</span><br><span class="line">            stack &#x3D; mFocusedStack; &#x2F;&#x2F; 进入该分支</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack &#x3D; container.mStack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;此时mConfigWillChange &#x3D; false</span><br><span class="line">        stack.mConfigWillChange &#x3D; config !&#x3D; null &amp;&amp; mService.mConfiguration.diff(config) !&#x3D; 0;</span><br><span class="line"></span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        if (aInfo !&#x3D; null &amp;&amp;</span><br><span class="line">                (aInfo.applicationInfo.privateFlags</span><br><span class="line">                        &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; heavy-weight进程处理流程, 一般情况下不进入该分支</span><br><span class="line">            if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res &#x3D; startActivityLocked(caller, intent, resolvedType, aInfo,</span><br><span class="line">                voiceSession, voiceInteractor, resultTo, resultWho,</span><br><span class="line">                requestCode, callingPid, callingUid, callingPackage,</span><br><span class="line">                realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</span><br><span class="line">                componentSpecified, null, container, inTask);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">        if (stack.mConfigWillChange) &#123;</span><br><span class="line">            ... &#x2F;&#x2F;不进入该分支</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (outResult !&#x3D; null) &#123;</span><br><span class="line">            ... &#x2F;&#x2F;不进入该分支</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程主要功能：通过resolveActivity来获取ActivityInfo信息, 然后再进入ASS.startActivityLocked().先来看看</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android9-0%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android9-0%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E6%B5%81%E7%A8%8B/" itemprop="url">Android9.0点击图标流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T14:32:33+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android9-0%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E6%B5%81%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android9-0%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E6%B5%81%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>源码分析工具:<a href="https://android.googlesource.com/" target="_blank" rel="noopener">https://android.googlesource.com/</a></li>
<li>源码分析版本：Android9.0.0_r56</li>
<li>源码所在目录：<a href="https://android.googlesource.com/?format=HTML" target="_blank" rel="noopener">android</a> / <a href="https://android.googlesource.com/platform/" target="_blank" rel="noopener">platform</a> / <a href="https://android.googlesource.com/platform/packages/" target="_blank" rel="noopener">packages</a> / <a href="https://android.googlesource.com/platform/packages/apps/" target="_blank" rel="noopener">apps</a> / <a href="https://android.googlesource.com/platform/packages/apps/Launcher2/" target="_blank" rel="noopener">Launcher2</a> / <a href="https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56" target="_blank" rel="noopener">refs/tags/android-9.0.0_r56</a> / <a href="https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56/" target="_blank" rel="noopener">.</a> / <a href="https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56/src?autodive=0" target="_blank" rel="noopener">src</a> / <a href="https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56/src/com?autodive=0" target="_blank" rel="noopener">com</a> / <a href="https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56/src/com/android?autodive=0" target="_blank" rel="noopener">android</a> / <strong>launcher2</strong></li>
<li>源码地址：<a href="https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56/src/com/android/launcher2/Launcher.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/packages/apps/Launcher2/+/refs/tags/android-9.0.0_r56/src/com/android/launcher2/Launcher.java</a></li>
</ul>
<p><strong>类的定义</strong></p>
<p>继承Activity，实现点击相关的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Launcher extends Activity</span><br><span class="line">        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,</span><br><span class="line">                   View.OnTouchListener &#123;</span><br></pre></td></tr></table></figure>

<p>点击图标触法点击事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Launches the intent referred by the clicked shortcut.</span><br><span class="line">     *</span><br><span class="line">     * @param v The view representing the clicked shortcut.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        &#x2F;&#x2F; Make sure that rogue clicks don&#39;t get through while allapps is launching, or after the</span><br><span class="line">        &#x2F;&#x2F; view has detached (it&#39;s possible for this to happen if the view is removed mid touch).</span><br><span class="line">        &#x2F;&#x2F;判断AttachInfo中mWindowToken，在view中的dispatchAttachedToWindow（）方法中赋值</span><br><span class="line">        if (v.getWindowToken() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!mWorkspace.isFinishedSwitchingState()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Object tag &#x3D; v.getTag();</span><br><span class="line">        &#x2F;&#x2F;快捷图标</span><br><span class="line">        if (tag instanceof ShortcutInfo) &#123;</span><br><span class="line">            &#x2F;&#x2F; Open shortcut</span><br><span class="line">            final Intent intent &#x3D; ((ShortcutInfo) tag).intent;</span><br><span class="line">            int[] pos &#x3D; new int[2];</span><br><span class="line">            v.getLocationOnScreen(pos);</span><br><span class="line">            intent.setSourceBounds(new Rect(pos[0], pos[1],</span><br><span class="line">                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));</span><br><span class="line">            boolean success &#x3D; startActivitySafely(v, intent, tag);</span><br><span class="line">            if (success &amp;&amp; v instanceof BubbleTextView) &#123;</span><br><span class="line">                mWaitingForResume &#x3D; (BubbleTextView) v;</span><br><span class="line">                mWaitingForResume.setStayPressed(true);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;文件夹</span><br><span class="line">        &#125; else if (tag instanceof FolderInfo) &#123;</span><br><span class="line">            if (v instanceof FolderIcon) &#123;</span><br><span class="line">                FolderIcon fi &#x3D; (FolderIcon) v;</span><br><span class="line">                handleFolderClick(fi);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;抽屉中的所有应用</span><br><span class="line">        &#125; else if (v &#x3D;&#x3D; mAllAppsButton) &#123;</span><br><span class="line">            if (isAllAppsVisible()) &#123;</span><br><span class="line">                showWorkspace(true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                onClickAllAppsButton(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Launcher.java#startActivitySafely方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boolean startActivitySafely(View v, Intent intent, Object tag) &#123;</span><br><span class="line">        boolean success &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            success &#x3D; startActivity(v, intent, tag);</span><br><span class="line">        &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">            Log.e(TAG, &quot;Unable to launch. tag&#x3D;&quot; + tag + &quot; intent&#x3D;&quot; + intent, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return success;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用Launcher.java中的startActivity，如果找不到对应的页面可能会抛出异常。</p>
<p><strong>Launcher.java#startActivity()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">boolean startActivity(View v, Intent intent, Object tag) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Only launch using the new animation if the shortcut has not opted out (this is a</span><br><span class="line">            &#x2F;&#x2F; private contract between launcher and may be ignored in the future).</span><br><span class="line">            boolean useLaunchAnimation &#x3D; (v !&#x3D; null) &amp;&amp;</span><br><span class="line">                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);</span><br><span class="line">            UserHandle user &#x3D; (UserHandle) intent.getParcelableExtra(ApplicationInfo.EXTRA_PROFILE);</span><br><span class="line">            LauncherApps launcherApps &#x3D; (LauncherApps)</span><br><span class="line">                    this.getSystemService(Context.LAUNCHER_APPS_SERVICE);</span><br><span class="line">            if (useLaunchAnimation) &#123;</span><br><span class="line">                ActivityOptions opts &#x3D; ActivityOptions.makeScaleUpAnimation(v, 0, 0,</span><br><span class="line">                        v.getMeasuredWidth(), v.getMeasuredHeight());</span><br><span class="line">                if (user &#x3D;&#x3D; null || user.equals(android.os.Process.myUserHandle())) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Could be launching some bookkeeping activity</span><br><span class="line">                    startActivity(intent, opts.toBundle());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    launcherApps.startMainActivity(intent.getComponent(), user,</span><br><span class="line">                            intent.getSourceBounds(),</span><br><span class="line">                            opts.toBundle());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (user &#x3D;&#x3D; null || user.equals(android.os.Process.myUserHandle())) &#123;</span><br><span class="line">                    startActivity(intent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    launcherApps.startMainActivity(intent.getComponent(), user,</span><br><span class="line">                            intent.getSourceBounds(), null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">            Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +</span><br><span class="line">                    &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +</span><br><span class="line">                    &quot;or use the exported attribute for this activity. &quot;</span><br><span class="line">                    + &quot;tag&#x3D;&quot;+ tag + &quot; intent&#x3D;&quot; + intent, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先intent中flag表示开启一个新任务栈</li>
<li>调用Activity的开启页面方法</li>
</ul>
<p>这样就走到了Activity的启动页面的流程了？</p>
<p>未完待续。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" itemprop="url">Android源码分析工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T14:15:45+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a></p>
<p><a href="https://android.googlesource.com/" target="_blank" rel="noopener">https://android.googlesource.com/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/" itemprop="url">Binder原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T13:28:45+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Android/Binder/Binder%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="什么是IPC"><a href="#什么是IPC" class="headerlink" title="什么是IPC"></a>什么是IPC</h2><p><strong>IPC(Inter-Process Communication)即进程间通信或者跨进程通信，指两个进程之间数据交换的过程</strong></p>
<p><strong>RPC(Remote Procedure Call的缩写) 是远程进程调用的意思。</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bundle</td>
<td align="center">简单易用</td>
<td align="center">只能传输bundle支持的数据类型</td>
<td align="center">四大组件间的进程通信</td>
</tr>
<tr>
<td align="center">文件共享</td>
<td align="center">简单易用</td>
<td align="center">不适合高并发环境，并且无法做到进程间的实时通讯</td>
<td align="center">无并发访问的情况，交换简单的数据，实时性不高的情况</td>
</tr>
<tr>
<td align="center">aidl</td>
<td align="center">功能强大，支持一对多并发通信，支持实时通信</td>
<td align="center">使用稍复杂，需要处理好线程同步</td>
<td align="center">一对多通信且且有RPC需求</td>
</tr>
<tr>
<td align="center">Messenger</td>
<td align="center">功能一般，支持一对多串行通信，支持实时通信</td>
<td align="center">不能处理好高并发的情况，不支持RPC，数据通过message进行传输，因此只能传输bundle支持的数据类型</td>
<td align="center">低并发一对多即时通讯无RPC需求，或者无法返回结构的RPC</td>
</tr>
<tr>
<td align="center">ContentProvider</td>
<td align="center">在数据源访问方面功能强大，支持一对多并发数据共享，可通过call方法扩展其它操作。</td>
<td align="center">可以理解受约束的AIDL，主要提供数据源的CRUD操作</td>
<td align="center">一对多进程间数据共享</td>
</tr>
<tr>
<td align="center">Socker</td>
<td align="center">功能强大，可以通过网络传输字节流，支持一对多并发实时通信。</td>
<td align="center">实现细节稍微有点繁琐，不支持直接的RPC</td>
<td align="center">网络数据交互</td>
</tr>
</tbody></table>
<h2 id="什么是AIDL"><a href="#什么是AIDL" class="headerlink" title="什么是AIDL"></a>什么是AIDL</h2><p>AIDL（Android Interface Definition Language）即Android接口定义语言，指Android 提供的一种进程间通信 (IPC) 机制。</p>
<h2 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h2><p>Binder是Android中一种跨进程通信的方式。从Android FrameWork角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。从Android应用层的角度来说， BInder是客户端和服务端进行通信的媒介。</p>
<p><strong>Binder线程池最大数为16，超过的请求会被阻塞。在进程间通信时处理并发时，如<code>ContentProvider</code>的CRUD（增删改查）操作方法最多有16个线程同时工作。</strong></p>
<h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p><strong>AIDL是基于Binder机制实现Android上的IPC。</strong></p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><p>简单介绍下什么是 Binder。Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。对于 Binder 更全面的定义，等我们介绍完 Binder 通信原理后再做详细说明。</p>
<ol>
<li>从IPC角度来说：Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有；</li>
<li>从Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h2 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h2><p><img src="http://gityuan.com/images/binder/java_binder/java_binder.jpg" alt="binder_arch"></p>
<h2 id="为什么必须理解-Binder-？"><a href="#为什么必须理解-Binder-？" class="headerlink" title="为什么必须理解 Binder ？"></a>为什么必须理解 Binder ？</h2><p>作为 Android 工程师的你，是不是常常会有这样的疑问：</p>
<ul>
<li>为什么 Activity 间传递对象需要序列化？</li>
<li>Activity 的启动流程是什么样的？</li>
<li>四大组件底层的通信机制是怎样的？</li>
<li>AIDL 内部的实现原理是什么？</li>
</ul>
<p>这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。</p>
<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。</p>
<h2 id="为什么使用-Binder"><a href="#为什么使用-Binder" class="headerlink" title="为什么使用 Binder ?"></a>为什么使用 Binder ?</h2><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<p>注：各种IPC方式数据拷贝次数，此表来源于<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现 - 设计篇</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-2160e70ca6e813ff28c34eec5ae8209c_1440w.jpg" alt="img"></p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<p><strong>最后用一张表格来总结下 Binder 的优势：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" alt="img"></p>
<h1 id="Linux-下传统的进程间通信原理"><a href="#Linux-下传统的进程间通信原理" class="headerlink" title="Linux 下传统的进程间通信原理"></a>Linux 下传统的进程间通信原理</h1><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="https://pic3.zhimg.com/80/v2-38e2ea1d22660b237e17d2a7f298f3d6_1440w.jpg" alt="img"></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h3 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-3c719337413b9c5c4ad0b6c6b8eb0291_1440w.jpg" alt="img"></p>
<h3 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() &#x2F;&#x2F;将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() &#x2F;&#x2F;将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h1 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC 通信原理</h1><p>理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。</p>
<p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy<em>from</em>user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy<em>to</em>user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aab2affe42958a659ea8a517ffaff5a0_1440w.jpg" alt="img"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ul>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ul>
<h1 id="Binder-跨进程通信原理"><a href="#Binder-跨进程通信原理" class="headerlink" title="Binder 跨进程通信原理"></a>Binder 跨进程通信原理</h1><p>理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。</p>
<h2 id="动态内核可加载模块-amp-amp-内存映射"><a href="#动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="动态内核可加载模块 &amp;&amp; 内存映射"></a>动态内核可加载模块 &amp;&amp; 内存映射</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p><strong>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</strong></p>
<p>该函数主要是创建虚拟内存区域 与 共享对象建立映射关系。用内存读写代替 I/O读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 函数原型</span><br><span class="line">  *&#x2F;</span><br><span class="line">void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure>

<p>内部原理：</p>
<ul>
<li>步骤1：创建虚拟内存区域</li>
<li>步骤2：实现地址映射关系(进程的虚拟地址空间关联到共享对象)</li>
</ul>
<p>使用时：</p>
<p>用户进程直接调用mmap()建立映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  *  MAP_SIZE的接收缓存区大小 ， 关联到共享对象中，即建立映射</span><br><span class="line">  *&#x2F;</span><br><span class="line">  mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);</span><br></pre></td></tr></table></figure>

<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h2 id="Binder-IPC-实现原理"><a href="#Binder-IPC-实现原理" class="headerlink" title="Binder IPC 实现原理"></a>Binder IPC 实现原理</h2><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy<em>from</em>user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_1440w.jpg" alt="img"></p>
<h1 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h1><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h2 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h2><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" alt="img"></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">http://www.google.com</a> 对应的服务器。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7c68928e26f5b96b8b3471ebb1927107_1440w.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
<h2 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h2><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ul>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ul>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p><img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" alt="img"></p>
<h3 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-13361906ecda16e36a3b9cbe3d38cbc1_1440w.jpg" alt="img"></p>
<h2 id="Binder-的完整定义"><a href="#Binder-的完整定义" class="headerlink" title="Binder 的完整定义"></a>Binder 的完整定义</h2><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<h1 id="手动编码实现跨进程调用"><a href="#手动编码实现跨进程调用" class="headerlink" title="手动编码实现跨进程调用"></a>手动编码实现跨进程调用</h1><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<h2 id="各-Java-类职责描述"><a href="#各-Java-类职责描述" class="headerlink" title="各 Java 类职责描述"></a>各 Java 类职责描述</h2><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</li>
<li><strong>IInterface</strong> : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>
<li><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>
<li><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</li>
</ul>
<h2 id="实现过程讲解"><a href="#实现过程讲解" class="headerlink" title="实现过程讲解"></a>实现过程讲解</h2><p>一次跨进程通信必然会涉及到两个进程，在这个例子中 RemoteService 作为服务端进程，提供服务；ClientActivity 作为客户端进程，使用 RemoteService 提供的服务。如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7ca457119bd700a5acf7f69bb0c07e51_1440w.jpg" alt="img"></p>
<p>那么服务端进程具备什么样的能力？能为客户端提供什么样的服务呢？还记得我们前面介绍过的 IInterface 吗，它代表的就是服务端进程具体什么样的能力。因此我们需要定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端具备什么样的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类用来定义服务端 RemoteService 具备什么样的能力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只定义服务端具备什么样的能力是不够的，既然是跨进程调用，那么接下来我们得实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Stub extends Binder implements BookManager &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public static BookManager asInterface(IBinder binder) &#123;</span><br><span class="line">        if (binder &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        IInterface iin &#x3D; binder.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (iin !&#x3D; null &amp;&amp; iin instanceof BookManager)</span><br><span class="line">            return (BookManager) iin;</span><br><span class="line">        return new Proxy(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line"></span><br><span class="line">            case INTERFACE_TRANSACTION:</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            case TRANSAVTION_addBook:</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                Book arg0 &#x3D; null;</span><br><span class="line">                if (data.readInt() !&#x3D; 0) &#123;</span><br><span class="line">                    arg0 &#x3D; Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125;</span><br><span class="line">                this.addBook(arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stub 类中我们重点介绍下 <code>asInterface</code> 和 <code>onTransact</code>。</p>
<p>先说说 <code>asInterface</code>，当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如你在代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。</p>
<p>接下来我们就要实现这个代理类 Proxy 了，既然是代理类自然需要实现 BookManager 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements BookManager &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Proxy(IBinder remote) &#123;</span><br><span class="line">        this.remote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addBook(Book book) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel replay &#x3D; Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            if (book !&#x3D; null) &#123;</span><br><span class="line">                data.writeInt(1);</span><br><span class="line">                book.writeToParcel(data, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data.writeInt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, 0);</span><br><span class="line">            replay.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看 addBook() 的实现；在 Stub 类中，addBook(Book book) 是一个抽象方法，Server 端需要去实现它。</p>
<ul>
<li>如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。</li>
<li>如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。</li>
</ul>
<p>在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。</p>
<p>这样一次跨进程调用就完成了。</p>
<h1 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h1><p><img src="http://gityuan.com/images/binder/summary/binder_proc_relation.png" alt="binder_proc_relation"></p>
<p>对于底层Binder驱动，通过<code>binder_procs</code>链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个<code>ProcessState</code>对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量<code>rb_root threads</code>，来记录当前进程内所有的binder_thread。</p>
<p>Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url">flutter项目中的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-19T12:38:57+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/flutter/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>如何保证flutter sdk版本统一与自动化管理</li>
</ul>
<h1 id="Flutter四种工程类型"><a href="#Flutter四种工程类型" class="headerlink" title="Flutter四种工程类型"></a>Flutter四种工程类型</h1><p>Flutter工程中，通常有以下几种工程类型，下面分别简单概述下：<br><strong>1. Flutter Application</strong><br>标准的Flutter App工程，包含标准的Dart层与Native平台层<br><strong>2. Flutter Module</strong><br>Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程<br><strong>3. Flutter Plugin</strong><br>Flutter平台插件工程，包含Dart层与Native平台层的实现<br><strong>4. Flutter Package</strong><br>Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/" itemprop="url">Java锁的分类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-17T20:34:29+08:00">
                2020-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E9%94%81/" itemprop="url" rel="index">
                    <span itemprop="name">锁</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/17/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="img"></p>
<h1 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h1><p><strong>定义</strong></p>
<ul>
<li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<ul>
<li>Java中，synchronized关键字和Lock的实现类都是悲观锁。</li>
</ul>
</li>
<li>乐观锁：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<ul>
<li>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li>
</ul>
</li>
</ul>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png" alt="img"></p>
<p><strong>使用场景</strong></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p><strong>使用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.base.multi_thread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ------------------------- 悲观锁的调用方式 -------------------------</span><br><span class="line">    public synchronized void testSynchronized() &#123;</span><br><span class="line">        &#x2F;&#x2F; 操作同步资源</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要保证多个线程使用的是同一个锁</span><br><span class="line">    private ReentrantLock reentrantLock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void testReentrant() &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        &#x2F;&#x2F; 操作同步资源</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ------------------------- 乐观锁的调用方式 -------------------------</span><br><span class="line">    &#x2F;&#x2F; 需要保证多个线程使用的是同一个AtomicInteger</span><br><span class="line">    private AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public void testAtomicInter() &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>要写入的新值 B</li>
</ul>
<p><strong>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</strong></p>
<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    private static final sun.misc.Unsafe U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    private static final long VALUE;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            VALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile int value;</span><br></pre></td></tr></table></figure>

<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li>unsafe： 获取并操作内存的数据。</li>
<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>
<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>
</ul>
<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ------------------------- JDK 8 -------------------------</span><br><span class="line">&#x2F;&#x2F; AtomicInteger 自增方法</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">  int var5;</span><br><span class="line">  do &#123;</span><br><span class="line">      var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------------------- OpenJDK 8 -------------------------</span><br><span class="line">&#x2F;&#x2F; Unsafe.java</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">   int v;</span><br><span class="line">   do &#123;</span><br><span class="line">       v &#x3D; getIntVolatile(o, offset);</span><br><span class="line">   &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * Atomically updates Java variable to &#123;@code x&#125; if it is currently</span><br><span class="line">  * holding &#123;@code expected&#125;.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line">  * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span><br><span class="line">  *</span><br><span class="line">  * @return &#123;@code true&#125; if successful</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @HotSpotIntrinsicCandidate</span><br><span class="line"> public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                                   int expected,</span><br><span class="line">                                                   int x);</span><br></pre></td></tr></table></figure>

<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>
<p><strong>CAS问题</strong></p>
<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>
<ul>
<li><p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
</ul>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
<h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png" alt="img"></p>
<p><strong>缺点</strong></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p><strong>自旋锁原理</strong></p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p><strong>常见自旋锁</strong></p>
<p>在自旋锁中 另有三种常见的锁形式:</p>
<ul>
<li>TicketLock</li>
<li>CLHlock</li>
<li>MCSlock</li>
</ul>
<h1 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h1><p>这四种锁是指锁的状态，专门针对synchronized的。</p>
<h2 id="为什么Synchronized能实现线程同步？"><a href="#为什么Synchronized能实现线程同步？" class="headerlink" title="为什么Synchronized能实现线程同步？"></a>为什么Synchronized能实现线程同步？</h2><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：</p>
<ul>
<li>Mark Word（标记字段）</li>
<li>Klass Pointer（类型指针）</li>
</ul>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p><strong>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</strong></p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="left">存储内容</th>
<th align="left">存储内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无锁</td>
<td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">偏向锁</td>
<td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">指向栈中锁记录的指针</td>
<td align="left">00</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">指向互斥量（重量级锁）的指针</td>
<td align="left">10</td>
</tr>
</tbody></table>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</strong></p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p><strong>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</strong></p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png" alt="img"></p>
<p><strong>综上，偏向锁通过对比Mark Word中的线程ID解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</strong></p>
<h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a23d746a.png" alt="img"></p>
<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>
<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/4499559e.png" alt="img"></p>
<p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7373984872572414699L;</span><br><span class="line">    &#x2F;** Synchronizer providing all implementation mechanics *&#x2F;</span><br><span class="line">    private final Sync sync;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base of synchronization control for this lock. Subclassed</span><br><span class="line">     * into fair and nonfair versions below. Uses AQS state to</span><br><span class="line">     * represent the number of holds on the lock.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">         * is to allow fast path for nonfair version.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        abstract void lock();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line">         * subclasses, but both need nonfair try for trylock method.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c &#x3D; getState() - releases;</span><br><span class="line">            if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free &#x3D; false;</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                free &#x3D; true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean isHeldExclusively() &#123;</span><br><span class="line">            &#x2F;&#x2F; While we must in general read state before owner,</span><br><span class="line">            &#x2F;&#x2F; we don&#39;t need to do so to check if current thread is owner</span><br><span class="line">            return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ConditionObject newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Methods relayed from outer class</span><br><span class="line"></span><br><span class="line">        final Thread getOwner() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getHoldCount() &#123;</span><br><span class="line">            return isHeldExclusively() ? getState() : 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLocked() &#123;</span><br><span class="line">            return getState() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Reconstitutes the instance from a stream (that is, deserializes it).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(0); &#x2F;&#x2F; reset to unlocked state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sync object for non-fair locks</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sync object for fair locks</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Fair version of tryAcquire.  Don&#39;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line">     * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync &#x3D; new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">     * given fairness policy.</span><br><span class="line">     *</span><br><span class="line">     * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png" alt="img"></p>
<p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        &#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class="line">        &#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class="line">        &#x2F;&#x2F; thread is first in queue.</span><br><span class="line">        Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        Node s;</span><br><span class="line">        return h !&#x3D; t &amp;&amp;</span><br><span class="line">            ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>
<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h1 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h1><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Widget &#123;</span><br><span class="line">    public synchronized void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;方法1执行...&quot;);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doOthers() &#123;</span><br><span class="line">        System.out.println(&quot;方法2执行...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>
<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/58fc5bc9.png" alt="img"></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ea597a0c.png" alt="img"></p>
<p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png" alt="img"></p>
<h1 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h1><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>
<p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>下图为ReentrantReadWriteLock的部分源码：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/762a042b.png" alt="img"></p>
<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p>
<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png" alt="img"></p>
<p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">	Thread current &#x3D; Thread.currentThread();</span><br><span class="line">	int c &#x3D; getState(); &#x2F;&#x2F; 取到当前锁的个数</span><br><span class="line">	int w &#x3D; exclusiveCount(c); &#x2F;&#x2F; 取写锁的个数w</span><br><span class="line">	if (c !&#x3D; 0) &#123; &#x2F;&#x2F; 如果已经有线程持有了锁(c!&#x3D;0)</span><br><span class="line">    &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)</span><br><span class="line">		if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread()) &#x2F;&#x2F; 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span><br><span class="line">			return false;</span><br><span class="line">		if (w + exclusiveCount(acquires) &gt; MAX_COUNT)    &#x2F;&#x2F; 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span><br><span class="line">      throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">		&#x2F;&#x2F; Reentrant acquire</span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#x2F;&#x2F; 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span><br><span class="line">		return false;</span><br><span class="line">	setExclusiveOwnerThread(current); &#x2F;&#x2F; 如果c&#x3D;0，w&#x3D;0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<p>接着是读锁的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">        return -1;                                   &#x2F;&#x2F; 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span><br><span class="line">    int r &#x3D; sharedCount(c);</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            firstReader &#x3D; current;</span><br><span class="line">            firstReaderHoldCount &#x3D; 1;</span><br><span class="line">        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line">            else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png" alt="img"></p>
<p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
