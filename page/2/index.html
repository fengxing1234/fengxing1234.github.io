<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/02/Button/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/02/Button/" itemprop="url">Button</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-02T21:53:03+08:00">
                2020-07-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/02/Button/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/07/02/Button/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/InkWell%E6%B0%B4%E6%B3%A2%E7%BA%B9%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/InkWell%E6%B0%B4%E6%B3%A2%E7%BA%B9%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C/" itemprop="url">InkWell水波纹点击效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-02T21:36:46+08:00">
                2020-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/widget%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">widget组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/InkWell%E6%B0%B4%E6%B3%A2%E7%BA%B9%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/InkWell%E6%B0%B4%E6%B3%A2%E7%BA%B9%E7%82%B9%E5%87%BB%E6%95%88%E6%9E%9C/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>InkWell是继承InkResponse，当然InkWell实现的水波纹最简单，InkResponse也可以很快的实现自定义的各种水波纹，InkResponse不强制水波纹是矩形的形状。</p>
<p>在flutter 开发中用InkWell或者GestureDetector将某个组件包起来，已添加点击事件。</p>
<p>GestureDetector 使用点击无水波纹出现，InkWell可以实现水波纹效果。 正常情况下使用 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InkWell(</span><br><span class="line">  		&#x2F;&#x2F;单击事件响应 不添加click是没有效果的</span><br><span class="line">       onTap: () &#123;</span><br><span class="line">       &#125;,</span><br><span class="line">       child: Container(</span><br><span class="line">         alignment: Alignment(0, 0),</span><br><span class="line">         height: 28,</span><br><span class="line">         width: 120,</span><br><span class="line">         child: Text(&quot;InkWell单击事件&quot;),</span><br><span class="line">       ),</span><br><span class="line">     ),</span><br></pre></td></tr></table></figure>

<p>上面的代码就能够实现水波纹效果</p>
<h4 id="1-widget-设置水波纹点击效果-并设置widget背景"><a href="#1-widget-设置水波纹点击效果-并设置widget背景" class="headerlink" title="1 widget 设置水波纹点击效果 并设置widget背景"></a>1 widget 设置水波纹点击效果 并设置widget背景</h4><p>如果在InkWell的上下都出现的颜色的设置，如上中的Container中如果加入了color:Colors.white,或者是Container中的其他widget设置了coloro属性，这时候InkWell的水波纹效果会无效。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde86d5be6fabf?imageslim" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Center(</span><br><span class="line">         child: new Material(</span><br><span class="line">           &#x2F;&#x2F; 设置背景颜色 默认矩形</span><br><span class="line">           color: Colors.purple,</span><br><span class="line">           child: new InkWell(</span><br><span class="line">             &#x2F;&#x2F;点击事件回调</span><br><span class="line">             onTap: () &#123;&#125;,</span><br><span class="line">             &#x2F;&#x2F;不要在这里设置背景色，for则会遮挡水波纹效果,如果设置的话尽量设置Material下面的color来实现背景色</span><br><span class="line">             child: new Container(</span><br><span class="line">               width: 300.0,</span><br><span class="line">               height: 50.0,</span><br><span class="line">               &#x2F;&#x2F;设置child 居中</span><br><span class="line">               alignment: Alignment(0, 0),</span><br><span class="line">               child: Text(&quot;登录&quot;,style: TextStyle(color: Colors.white,fontSize: 16.0),),</span><br><span class="line">             ),</span><br><span class="line">           ),</span><br><span class="line">         ),</span><br><span class="line">       ),</span><br></pre></td></tr></table></figure>

<p>或者 可以使用 Ink来设置，与Material设置color 的区别是，Ink可设置背景的形状样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new Center(</span><br><span class="line">     child: new Material(</span><br><span class="line">       &#x2F;&#x2F;INK可以实现装饰容器，实现矩形  设置背景色</span><br><span class="line">       child: new Ink(</span><br><span class="line">         &#x2F;&#x2F;设置背景  默认矩形</span><br><span class="line">         color: Colors.purple,</span><br><span class="line">         child: new InkWell(</span><br><span class="line">           &#x2F;&#x2F;点击事件回调</span><br><span class="line">           onTap: () &#123;&#125;,</span><br><span class="line">           child: new Container(</span><br><span class="line">             width: 300.0,</span><br><span class="line">             height: 50.0,</span><br><span class="line">             &#x2F;&#x2F;设置child 居中</span><br><span class="line">             alignment: Alignment(0, 0),</span><br><span class="line">             child: Text(&quot;登录&quot;,style: TextStyle(color: Colors.white,fontSize: 16.0),),</span><br><span class="line">           ),</span><br><span class="line">         ),</span><br><span class="line">       ),</span><br><span class="line">     ),</span><br><span class="line">   ),</span><br></pre></td></tr></table></figure>

<h4 id="2-圆角widget-设置水波纹点击效果"><a href="#2-圆角widget-设置水波纹点击效果" class="headerlink" title="2 圆角widget 设置水波纹点击效果"></a>2 圆角widget 设置水波纹点击效果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde86d5bcc00e0?imageslim" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">new Center(</span><br><span class="line">  child: new Material(</span><br><span class="line">    &#x2F;&#x2F;INK可以实现装饰容器</span><br><span class="line">    child: new Ink(</span><br><span class="line">      &#x2F;&#x2F;用ink圆角矩形</span><br><span class="line">    &#x2F;&#x2F; color: Colors.red,</span><br><span class="line">      decoration: new BoxDecoration(</span><br><span class="line">       &#x2F;&#x2F;不能同时”使用Ink的变量color属性以及decoration属性，两个只能存在一个</span><br><span class="line">        color: Colors.purple,</span><br><span class="line">        &#x2F;&#x2F;设置圆角</span><br><span class="line">        borderRadius: new BorderRadius.all(new Radius.circular(25.0)),</span><br><span class="line">      ),</span><br><span class="line">      child: new InkWell(</span><br><span class="line">        &#x2F;&#x2F;圆角设置,给水波纹也设置同样的圆角</span><br><span class="line">        &#x2F;&#x2F;如果这里不设置就会出现矩形的水波纹效果</span><br><span class="line">        borderRadius: new BorderRadius.circular(25.0), </span><br><span class="line">        &#x2F;&#x2F;设置点击事件回调</span><br><span class="line">        onTap: () &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        child: new Container(</span><br><span class="line">          width: 300.0,</span><br><span class="line">          height: 50.0,</span><br><span class="line">          &#x2F;&#x2F;设置child 居中</span><br><span class="line">          alignment: Alignment(0, 0),</span><br><span class="line">          child: Text(&quot;登录&quot;,style: TextStyle(color: Colors.white,fontSize: 16.0),),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>如果 InkWell 与Ink 不同时设置相同的圆角，例如 lnk 设置的圆角为20，而Ink没有设置,就会出现 矩形的水波纹点击效果</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde86d5bdff7e1?imageslim" alt="在这里插入图片描述"></p>
<h4 id="3-圆角widget-设置自定义水波纹颜色点击效果"><a href="#3-圆角widget-设置自定义水波纹颜色点击效果" class="headerlink" title="3 圆角widget 设置自定义水波纹颜色点击效果"></a>3 圆角widget 设置自定义水波纹颜色点击效果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde86d5bd1a41f?imageslim" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">new Center(</span><br><span class="line">  child: new Material(</span><br><span class="line">    child: new Ink(</span><br><span class="line">      &#x2F;&#x2F;设置背景</span><br><span class="line">      decoration: new BoxDecoration(</span><br><span class="line">        color: Colors.purple,</span><br><span class="line">        borderRadius: new BorderRadius.all(new Radius.circular(25.0)),</span><br><span class="line">      ),</span><br><span class="line">      child: new InkResponse(</span><br><span class="line">        borderRadius: new BorderRadius.all(new Radius.circular(25.0)),</span><br><span class="line">        &#x2F;&#x2F;点击或者toch控件高亮时显示的控件在控件上层,水波纹下层</span><br><span class="line">        &#x2F;&#x2F;highlightColor: Colors.yellowAccent,</span><br><span class="line">        &#x2F;&#x2F;点击或者toch控件高亮的shape形状</span><br><span class="line">        highlightShape: BoxShape.rectangle,</span><br><span class="line">        &#x2F;&#x2F;.InkResponse内部的radius这个需要注意的是，我们需要半径大于控件的宽，如果radius过小，显示的水波纹就是一个很小的圆，</span><br><span class="line">        &#x2F;&#x2F;水波纹的半径</span><br><span class="line">        radius: 300.0,</span><br><span class="line">        &#x2F;&#x2F;水波纹的颜色</span><br><span class="line">        splashColor: Colors.black,</span><br><span class="line">        &#x2F;&#x2F;true表示要剪裁水波纹响应的界面   false不剪裁  如果控件是圆角不剪裁的话水波纹是矩形</span><br><span class="line">        containedInkWell: true,</span><br><span class="line">        &#x2F;&#x2F;点击事件</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          print(&quot;click&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: new Container(</span><br><span class="line">          &#x2F;&#x2F;不能在InkResponse的child容器内部设置装饰器颜色，否则会遮盖住水波纹颜色的，containedInkWell设置为false就能看到是否是遮盖了。</span><br><span class="line">          width: 300.0,</span><br><span class="line">          height: 50.0,</span><br><span class="line">          &#x2F;&#x2F;设置child 居中</span><br><span class="line">          alignment: Alignment(0, 0),</span><br><span class="line">          child: Text(&quot;登录&quot;,style: TextStyle(color: Colors.white,fontSize: 16.0),),</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h4 id="4-圆角widget-设置高亮颜色点击效果"><a href="#4-圆角widget-设置高亮颜色点击效果" class="headerlink" title="4 圆角widget 设置高亮颜色点击效果"></a>4 圆角widget 设置高亮颜色点击效果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16bde86d7a2445ef?imageslim" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">new Center(</span><br><span class="line">   child: new Material(</span><br><span class="line">     child: new Ink(</span><br><span class="line">       &#x2F;&#x2F;设置背景</span><br><span class="line">       decoration: new BoxDecoration(</span><br><span class="line">         color: Colors.purple,</span><br><span class="line">         borderRadius: new BorderRadius.all(new Radius.circular(30.0)),</span><br><span class="line">       ),</span><br><span class="line">       child: new InkResponse(</span><br><span class="line">         borderRadius: new BorderRadius.all(new Radius.circular(30.0)),</span><br><span class="line">         &#x2F;&#x2F;点击或者toch控件高亮时显示的控件在控件上层,水波纹下层</span><br><span class="line">         highlightColor: Colors.purple[800],</span><br><span class="line">         &#x2F;&#x2F;点击或者toch控件高亮的shape形状</span><br><span class="line">         highlightShape: BoxShape.rectangle,</span><br><span class="line">         &#x2F;&#x2F;.InkResponse内部的radius这个需要注意的是，我们需要半径大于控件的宽，如果radius过小，显示的水波纹就是一个很小的圆，</span><br><span class="line">         &#x2F;&#x2F;水波纹的半径</span><br><span class="line">         radius: 0.0,</span><br><span class="line">         &#x2F;&#x2F;水波纹的颜色 设置了highlightColor属性后 splashColor将不起效果</span><br><span class="line">         splashColor: Colors.red,</span><br><span class="line">         &#x2F;&#x2F;true表示要剪裁水波纹响应的界面   false不剪裁  如果控件是圆角不剪裁的话水波纹是矩形</span><br><span class="line">         containedInkWell: true,</span><br><span class="line"></span><br><span class="line">         onTap: () &#123;</span><br><span class="line">           print(</span><br><span class="line">               &#39;click&#39;);</span><br><span class="line">         &#125;,</span><br><span class="line">         child: new Container(</span><br><span class="line">           &#x2F;&#x2F;不能在InkResponse的child容器内部设置装饰器颜色，否则会遮盖住水波纹颜色的，containedInkWell设置为false就能看到是否是遮盖了。</span><br><span class="line">           width: 300.0,</span><br><span class="line">           height: 50.0,</span><br><span class="line">           &#x2F;&#x2F;设置child 居中</span><br><span class="line">           alignment: Alignment(0, 0),</span><br><span class="line">           child: Text(&quot;登录&quot;,style: TextStyle(color: Colors.white,fontSize: 16.0),),</span><br><span class="line">         ),</span><br><span class="line">       ),</span><br><span class="line">     ),</span><br><span class="line">   ),</span><br><span class="line"> ),</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/BoxShadow%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E9%98%B4%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/BoxShadow%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E9%98%B4%E5%BD%B1/" itemprop="url">BoxShadow实现模糊阴影</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-02T21:12:37+08:00">
                2020-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/widget%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">widget组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/BoxShadow%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E9%98%B4%E5%BD%B1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/07/02/flutter/widget%E7%BB%84%E4%BB%B6/BoxShadow%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E9%98%B4%E5%BD%B1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://img-blog.csdnimg.cn/20190108104904699.png" alt="在这里插入图片描述"></p>
<h3 id="第一个圆形button"><a href="#第一个圆形button" class="headerlink" title="第一个圆形button"></a>第一个圆形button</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Widget _circleButton() &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    margin: EdgeInsets.only(left: 20),</span><br><span class="line">    decoration: BoxDecoration(shape: BoxShape.circle, boxShadow: [</span><br><span class="line">      &#x2F;&#x2F;&#x2F;阴影颜色&#x2F;位置&#x2F;大小等</span><br><span class="line">      BoxShadow(color: Colors.grey[300],offset: Offset(1, 1),</span><br><span class="line">        &#x2F;&#x2F;&#x2F;模糊阴影半径</span><br><span class="line">        blurRadius: 5,</span><br><span class="line">      ),</span><br><span class="line">      BoxShadow(color: Colors.grey[300], offset: Offset(-1, -1), blurRadius: 5),</span><br><span class="line">      BoxShadow(color: Colors.grey[300], offset: Offset(1, -1), blurRadius: 5),</span><br><span class="line">      BoxShadow(color: Colors.grey[300], offset: Offset(-1, 1), blurRadius: 5)</span><br><span class="line">    ]),</span><br><span class="line">    child: CircleAvatar(</span><br><span class="line">      radius: 20,</span><br><span class="line">      backgroundColor: Colors.white,</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Icon(</span><br><span class="line">            Icons.launch,</span><br><span class="line">            color: Colors.black87,</span><br><span class="line">            size: 20,</span><br><span class="line">          ),</span><br><span class="line">          Text(</span><br><span class="line">            &quot;分享&quot;,</span><br><span class="line">            style: TextStyle(</span><br><span class="line">              color: Colors.grey[400],</span><br><span class="line">              fontSize: 10,</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二个图片"><a href="#第二个图片" class="headerlink" title="第二个图片"></a>第二个图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Widget _rectangleButton() &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    margin: EdgeInsets.only(top: 20, left: 20),</span><br><span class="line">    decoration: BoxDecoration(shape: BoxShape.rectangle, boxShadow: [</span><br><span class="line">      BoxShadow(color: Colors.grey[300],offset: Offset(1, 1),blurRadius: 5,),</span><br><span class="line">      BoxShadow(color: Colors.grey[300], offset: Offset(-1, -1), blurRadius: 5),</span><br><span class="line">      BoxShadow(color: Colors.grey[300], offset: Offset(1, -1), blurRadius: 5),</span><br><span class="line">      BoxShadow(color: Colors.grey[300], offset: Offset(-1, 1), blurRadius: 5)</span><br><span class="line">    ]),</span><br><span class="line">    child: FlatButton(</span><br><span class="line">        onPressed: () &#123;&#125;,</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        padding: EdgeInsets.only(left: 30, right: 30, top: 10, bottom: 10),</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Icon(</span><br><span class="line">              Icons.launch,</span><br><span class="line">              color: Colors.black87,</span><br><span class="line">              size: 20,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              &quot;分享&quot;,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.grey[400],</span><br><span class="line">                fontSize: 10,</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三个图片"><a href="#第三个图片" class="headerlink" title="第三个图片"></a>第三个图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Widget _flatButton1() &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    margin: EdgeInsets.only(top: 20, left: 20),</span><br><span class="line">    decoration: BoxDecoration(shape: BoxShape.rectangle, boxShadow: [</span><br><span class="line">      &#x2F;&#x2F;BoxShadow中Offset (1,1)右下，(-1,-1)左上,(1,-1)右上,(-1,1)左下</span><br><span class="line">      BoxShadow(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        offset: Offset(1, 1),</span><br><span class="line">        blurRadius: 5,</span><br><span class="line">      ),</span><br><span class="line">      BoxShadow(</span><br><span class="line">          color: Colors.blueAccent, offset: Offset(-1, -1), blurRadius: 5),</span><br><span class="line">    ]),</span><br><span class="line">    child: FlatButton(</span><br><span class="line">        onPressed: () &#123;&#125;,</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        padding: EdgeInsets.only(left: 30, right: 30, top: 10, bottom: 10),</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Icon(</span><br><span class="line">              Icons.launch,</span><br><span class="line">              color: Colors.black87,</span><br><span class="line">              size: 20,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              &quot;分享&quot;,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.grey[400],</span><br><span class="line">                fontSize: 10,</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四个图片"><a href="#第四个图片" class="headerlink" title="第四个图片"></a>第四个图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Widget _flatButton2() &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    margin: EdgeInsets.only(top: 20, left: 20),</span><br><span class="line">    decoration: BoxDecoration(shape: BoxShape.rectangle, boxShadow: [</span><br><span class="line">      &#x2F;&#x2F;BoxShadow中Offset (1,1)右下，(-1,-1)左上,(1,-1)右上,(-1,1)左下</span><br><span class="line">      BoxShadow(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        offset: Offset(-1, 1),</span><br><span class="line">        blurRadius: 5,</span><br><span class="line">      ),</span><br><span class="line">      BoxShadow(color: Colors.blueAccent, offset: Offset(1, -1), blurRadius: 5),</span><br><span class="line">    ]),</span><br><span class="line">    child: FlatButton(</span><br><span class="line">        onPressed: () &#123;&#125;,</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        padding: EdgeInsets.only(left: 30, right: 30, top: 10, bottom: 10),</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Icon(</span><br><span class="line">              Icons.launch,</span><br><span class="line">              color: Colors.black87,</span><br><span class="line">              size: 20,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              &quot;分享&quot;,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.grey[400],</span><br><span class="line">                fontSize: 10,</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五个图片"><a href="#第五个图片" class="headerlink" title="第五个图片"></a>第五个图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Widget _materialButton() &#123;</span><br><span class="line">  return Padding(</span><br><span class="line">    padding: EdgeInsets.only(top: 20, left: 20),</span><br><span class="line">    child: MaterialButton(</span><br><span class="line">      padding: EdgeInsets.only(left: 30, right: 30, top: 10, bottom: 10),</span><br><span class="line">      color: Colors.white,</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      elevation: 5,</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Icon(</span><br><span class="line">            Icons.launch,</span><br><span class="line">            color: Colors.black87,</span><br><span class="line">            size: 20,</span><br><span class="line">          ),</span><br><span class="line">          Text(</span><br><span class="line">            &quot;分享&quot;,</span><br><span class="line">            style: TextStyle(</span><br><span class="line">              color: Colors.grey[400],</span><br><span class="line">              fontSize: 10,</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/01/flutter/widget%E7%BB%84%E4%BB%B6/Scaffold/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/01/flutter/widget%E7%BB%84%E4%BB%B6/Scaffold/" itemprop="url">Scaffold</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-01T15:51:09+08:00">
                2020-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/widget%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">widget组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/01/flutter/widget%E7%BB%84%E4%BB%B6/Scaffold/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/07/01/flutter/widget%E7%BB%84%E4%BB%B6/Scaffold/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;脚手架</span><br><span class="line">Scaffold(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.appBar,&#x2F;&#x2F;设置应用栏，显示在脚手架顶部</span><br><span class="line">    this.body,&#x2F;&#x2F;设置脚手架内容区域控件</span><br><span class="line">    this.floatingActionButton,&#x2F;&#x2F;设置显示在上层区域的按钮，默认位置位于右下角</span><br><span class="line">    this.floatingActionButtonLocation,&#x2F;&#x2F;设置floatingActionButton的位置</span><br><span class="line">    this.floatingActionButtonAnimator,&#x2F;&#x2F;floatingActionButtonAnimator 动画 动画，但是设置了没有效果？</span><br><span class="line">    this.persistentFooterButtons,&#x2F;&#x2F;一组显示在脚手架底部的按钮(在bottomNavigationBar底部导航栏的上面)</span><br><span class="line">    this.drawer,&#x2F;&#x2F;设置左边侧边栏</span><br><span class="line">    this.endDrawer,&#x2F;&#x2F;设置右边侧边栏</span><br><span class="line">    this.bottomNavigationBar,&#x2F;&#x2F;设置脚手架 底部导航栏</span><br><span class="line">    this.bottomSheet,&#x2F;&#x2F;底部抽屉栏</span><br><span class="line">    this.backgroundColor,&#x2F;&#x2F;设置脚手架内容区域的颜色</span><br><span class="line">    this.resizeToAvoidBottomPadding &#x3D; true,&#x2F;&#x2F; ? 控制界面内容 body 是否重新布局来避免底部被覆盖，比如当键盘显示的时候，重新布局避免被键盘盖住内容。</span><br><span class="line">    this.primary &#x3D; true,&#x2F;&#x2F;脚手架是否显示在最低部</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BEngine%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BEngine%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" itemprop="url">Flutter之Engine启动流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-29T17:19:04+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BEngine%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BEngine%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flutter之Engine启动流程"><a href="#Flutter之Engine启动流程" class="headerlink" title="Flutter之Engine启动流程"></a>Flutter之Engine启动流程</h1><p>在Android中，应用的启动都是从<code>Application</code>的创建开始，所以基本上都会来自定义实现<code>Application</code>并在该类中进行一些初始化操作，如推送、分享、支付等。<code>Flutter</code>也不例外，也会在自定义的<code>Application</code>中进行<code>Engine</code>的初始化操作。</p>
<h3 id="1、Engine的初始化"><a href="#1、Engine的初始化" class="headerlink" title="1、Engine的初始化"></a>1、Engine的初始化</h3><p><code>FlutterApplication</code>就是一个自定义的<code>Application</code>类，在该类中进行了<code>Engine</code>的初始化，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterApplication extends Application &#123;</span><br><span class="line">    @Override</span><br><span class="line">    @CallSuper</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        &#x2F;&#x2F;初始化</span><br><span class="line">        FlutterMain.startInitialization(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再来看<code>FlutterMain</code>类的<code>startInitialization</code>方法，因为<code>Engine</code>的初始化是通过该方法开始的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void startInitialization(@NonNull Context applicationContext) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果在进行Robolectric测试，则暂不进行初始化操作</span><br><span class="line">    if (isRunningInRobolectricTest) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    FlutterLoader.getInstance().startInitialization(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>startInitialization</code>方法中又调用了<code>FlutterLoader</code>的<code>startInitialization</code>方法，该方法是<code>Engine</code>初始化的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterLoader &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    public void startInitialization(@NonNull Context applicationContext) &#123;</span><br><span class="line">        startInitialization(applicationContext, new Settings());</span><br><span class="line">    &#125;</span><br><span class="line">    public void startInitialization(@NonNull Context applicationContext, @NonNull Settings settings) &#123;</span><br><span class="line">        &#x2F;&#x2F;不允许多次初始化</span><br><span class="line">        if (this.settings !&#x3D; null) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;必须在主线程中初始化</span><br><span class="line">        if (Looper.myLooper() !&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;startInitialization must be called on the main thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.settings &#x3D; settings;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;当前时间</span><br><span class="line">        long initStartTimestampMillis &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">        &#x2F;&#x2F;初始化配置</span><br><span class="line">        initConfig(applicationContext);</span><br><span class="line">        &#x2F;&#x2F;初始化资源</span><br><span class="line">        initResources(applicationContext);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;加载flutter.so动态库</span><br><span class="line">        System.loadLibrary(&quot;flutter&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;初始化一个类VsyncWaiter，主要是同步Android的VSYNC信号给Engine</span><br><span class="line">        VsyncWaiter</span><br><span class="line">            .getInstance((WindowManager) applicationContext.getSystemService(Context.WINDOW_SERVICE))</span><br><span class="line">            .init();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;记录Engine的初始化时间</span><br><span class="line">        long initTimeMillis &#x3D; SystemClock.uptimeMillis() - initStartTimestampMillis;</span><br><span class="line">        FlutterJNI.nativeRecordStartTimestamp(initTimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里重点在于<code>flutter.so</code>动态库的加载。由于Java VM在加载动态库时第一个调用的是<code>JNI_OnLoad</code>函数，所以就先来看该函数的实现。</p>
<p>[-&gt; flutter/shell/platform/android/library_loader.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) &#123;</span><br><span class="line">  &#x2F;&#x2F;Initialize the Java VM.</span><br><span class="line">  &#x2F;&#x2F;将vm作为一个全局变量</span><br><span class="line">  fml::jni::InitJavaVM(vm);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;获取当前线程的env</span><br><span class="line">  JNIEnv* env &#x3D; fml::jni::AttachCurrentThread();</span><br><span class="line">  bool result &#x3D; false;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;Register FlutterMain.</span><br><span class="line">  &#x2F;&#x2F;Java Native方法的注册，主要是注册了FlutterJNI类的nativeInit、nativeRecordStartTimestamp方法。</span><br><span class="line">  result &#x3D; flutter::FlutterMain::Register(env);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;Register PlatformView</span><br><span class="line">  &#x2F;&#x2F;Java Native方法的注册</span><br><span class="line">  result &#x3D; flutter::PlatformViewAndroid::Register(env);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;Register VSyncWaiter.</span><br><span class="line">  &#x2F;&#x2F;Java Native方法的注册</span><br><span class="line">  result &#x3D; flutter::VsyncWaiterAndroid::Register(env);</span><br><span class="line"></span><br><span class="line">  return JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>到此，<code>Engine</code>就已经成功初始化，流程图如下。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/24/1707722f05de4956?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="2、Engine对象的创建"><a href="#2、Engine对象的创建" class="headerlink" title="2、Engine对象的创建"></a>2、Engine对象的创建</h3><p><code>Engine</code>初始化成功后，就可以来创建<code>Engine</code>。在<code>Android</code>中，<code>Engine</code>是从<code>FlutterActivity</code>的<code>onCreate</code>方法开始创建的，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterActivity extends Activity implements FlutterView.Provider, PluginRegistry, ViewFactory &#123;</span><br><span class="line"></span><br><span class="line">    private final FlutterActivityDelegate delegate &#x3D; new FlutterActivityDelegate(this, this);</span><br><span class="line">    </span><br><span class="line">    private final FlutterActivityEvents eventDelegate &#x3D; delegate;</span><br><span class="line">    private final FlutterView.Provider viewProvider &#x3D; delegate;</span><br><span class="line">    private final PluginRegistry pluginRegistry &#x3D; delegate;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        eventDelegate.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>顾名思义，<code>FlutterActivityDelegate</code>是一个代理类，全权负责<code>FlutterActivity</code>的所有工作。由于<code>Activity</code>在其生命周期内调用的第一个方法是<code>onCreate</code>。所以来看类<code>FlutterActivityDelegate</code>中的<code>onCreate</code>方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final class FlutterActivityDelegate</span><br><span class="line">        implements FlutterActivityEvents,</span><br><span class="line">                   FlutterView.Provider,</span><br><span class="line">                   PluginRegistry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            Window window &#x3D; activity.getWindow();</span><br><span class="line">            window.addFlags(LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">            window.setStatusBarColor(0x40000000);</span><br><span class="line">            window.getDecorView().setSystemUiVisibility(PlatformPlugin.DEFAULT_SYSTEM_UI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] args &#x3D; getArgsFromIntent(activity.getIntent());</span><br><span class="line">        FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), args);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;是否自定义FlutterView，默认不需要自定义</span><br><span class="line">        flutterView &#x3D; viewFactory.createFlutterView(activity);</span><br><span class="line">        if (flutterView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;是否自定义FlutterNativeView，默认不自定义</span><br><span class="line">            FlutterNativeView nativeView &#x3D; viewFactory.createFlutterNativeView();</span><br><span class="line">            &#x2F;&#x2F;创建flutterView</span><br><span class="line">            flutterView &#x3D; new FlutterView(activity, null, nativeView);</span><br><span class="line">            &#x2F;&#x2F;flutterView铺满整个屏幕</span><br><span class="line">            flutterView.setLayoutParams(matchParent);</span><br><span class="line">            activity.setContentView(flutterView);</span><br><span class="line">            &#x2F;&#x2F;创建launchView，launchView是Flutter加载第一帧前的展示View</span><br><span class="line">            launchView &#x3D; createLaunchView();</span><br><span class="line">            if (launchView !&#x3D; null) &#123;</span><br><span class="line">                addLaunchView();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (loadIntent(activity.getIntent())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;获取flutter代码路径</span><br><span class="line">        String appBundlePath &#x3D; FlutterMain.findAppBundlePath();</span><br><span class="line">        if (appBundlePath !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;运行Flutter代码</span><br><span class="line">            runBundle(appBundlePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>onCreate</code>方法中，主要做了以下两件事。</p>
<ol>
<li>创建了一个<code>FlutterView</code>，该View是Flutter界面在Android端的载体。</li>
<li>Flutter代码的运行，其实现原理后面再详解。</li>
</ol>
<p>先来看<code>FlutterView</code>的创建，它继承自<code>SurfaceView</code>，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterView extends SurfaceView implements BinaryMessenger, TextureRegistry &#123;</span><br><span class="line">    public FlutterView(Context context, AttributeSet attrs, FlutterNativeView nativeView) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line"></span><br><span class="line">        Activity activity &#x3D; getActivity(getContext());</span><br><span class="line">        if (activity &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Bad context&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nativeView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建FlutterNativeView对象</span><br><span class="line">            mNativeView &#x3D; new FlutterNativeView(activity.getApplicationContext());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mNativeView &#x3D; nativeView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>FlutterView</code>中，会创建一个<code>FlutterNativeView</code>对象，其构造函数的实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterNativeView implements BinaryMessenger &#123;</span><br><span class="line">    public FlutterNativeView(@NonNull Context context) &#123;</span><br><span class="line">        this(context, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FlutterNativeView(@NonNull Context context, boolean isBackgroundView) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        &#x2F;&#x2F;创建FlutterPluginRegistry对象</span><br><span class="line">        mPluginRegistry &#x3D; new FlutterPluginRegistry(this, context);</span><br><span class="line">        &#x2F;&#x2F;创建FlutterJNI对象</span><br><span class="line">        mFlutterJNI &#x3D; new FlutterJNI();</span><br><span class="line">        mFlutterJNI.addIsDisplayingFlutterUiListener(flutterUiDisplayListener);</span><br><span class="line">        &#x2F;&#x2F;创建DartExecutor对象，该对象主要用于Android与Flutter间的通信，如生命周期。</span><br><span class="line">        this.dartExecutor &#x3D; new DartExecutor(mFlutterJNI, context.getAssets());</span><br><span class="line">        &#x2F;&#x2F;添加Engine生命周期监听</span><br><span class="line">        mFlutterJNI.addEngineLifecycleListener(new EngineLifecycleListenerImpl());</span><br><span class="line">        &#x2F;&#x2F;执行attach方法</span><br><span class="line">        attach(this, isBackgroundView);</span><br><span class="line">        assertAttached();</span><br><span class="line">    &#125;</span><br><span class="line">    private void attach(FlutterNativeView view, boolean isBackgroundView) &#123;</span><br><span class="line">        mFlutterJNI.attachToNative(isBackgroundView);</span><br><span class="line">        dartExecutor.onAttachedToJNI();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要是用于Android与Native间的相互调用</span><br><span class="line">public class FlutterJNI &#123;</span><br><span class="line">  @UiThread</span><br><span class="line">  public void attachToNative(boolean isBackgroundView) &#123;</span><br><span class="line">    ...</span><br><span class="line">    nativePlatformViewId &#x3D; nativeAttach(this, isBackgroundView);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;native方法</span><br><span class="line">  private native long nativeAttach(@NonNull FlutterJNI flutterJNI, boolean isBackgroundView);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里重点在于<code>attach</code>方法，该方法会通过<code>FlutterJNI</code>的<code>nativeAttach</code>方法来进行UI、GPU、IO等线程的创建、Dart VM的创建及<code>Engine</code>对象的创建等。下面先来看<code>nativeAttach</code>方法在<code>Engine</code>中的对应实现。</p>
<p>[-&gt; flutter/shell/platform/android/platform_view_android_jni.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static jlong AttachJNI(JNIEnv* env,</span><br><span class="line">                       jclass clazz,</span><br><span class="line">                       jobject flutterJNI,</span><br><span class="line">                       jboolean is_background_view) &#123;</span><br><span class="line">  fml::jni::JavaObjectWeakGlobalRef java_object(env, flutterJNI);</span><br><span class="line">  &#x2F;&#x2F;AndroidShellHolder对象的创建</span><br><span class="line">  auto shell_holder &#x3D; std::make_unique&lt;AndroidShellHolder&gt;(</span><br><span class="line">      FlutterMain::Get().GetSettings(), java_object, is_background_view);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>AttachJNI</code>函数中主要是创建一个<code>AndroidShellHolder</code>对象，它的构造函数实现如下。</p>
<p>[-&gt; flutter/shell/platform/android/android_shell_holder.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">AndroidShellHolder::AndroidShellHolder(</span><br><span class="line">    flutter::Settings settings,</span><br><span class="line">    fml::jni::JavaObjectWeakGlobalRef java_object,</span><br><span class="line">    bool is_background_view)</span><br><span class="line">    : settings_(std::move(settings)), java_object_(java_object) &#123;</span><br><span class="line">  static size_t shell_count &#x3D; 1;</span><br><span class="line">  auto thread_label &#x3D; std::to_string(shell_count++);</span><br><span class="line">            </span><br><span class="line">  &#x2F;&#x2F;创建目标线程</span><br><span class="line">  if (is_background_view) &#123;</span><br><span class="line">    &#x2F;&#x2F;仅创建UI线程</span><br><span class="line">    thread_host_ &#x3D; &#123;thread_label, ThreadHost::Type::UI&#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;创建UI线程、GPU线程及IO线程</span><br><span class="line">    thread_host_ &#x3D; &#123;thread_label, ThreadHost::Type::UI | ThreadHost::Type::GPU |</span><br><span class="line">                                      ThreadHost::Type::IO&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Detach from JNI when the UI and GPU threads exit.</span><br><span class="line">  auto jni_exit_task([key &#x3D; thread_destruct_key_]() &#123;</span><br><span class="line">    FML_CHECK(pthread_setspecific(key, reinterpret_cast&lt;void*&gt;(1)) &#x3D;&#x3D; 0);</span><br><span class="line">  &#125;);</span><br><span class="line">  thread_host_.ui_thread-&gt;GetTaskRunner()-&gt;PostTask(jni_exit_task);</span><br><span class="line">  if (!is_background_view) &#123;</span><br><span class="line">    thread_host_.gpu_thread-&gt;GetTaskRunner()-&gt;PostTask(jni_exit_task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fml::WeakPtr&lt;PlatformViewAndroid&gt; weak_platform_view;</span><br><span class="line">  Shell::CreateCallback&lt;PlatformView&gt; on_create_platform_view &#x3D;</span><br><span class="line">      [is_background_view, java_object, &amp;weak_platform_view](Shell&amp; shell) &#123;</span><br><span class="line">        std::unique_ptr&lt;PlatformViewAndroid&gt; platform_view_android;</span><br><span class="line">        &#x2F;&#x2F;创建PlatformViewAndroid对象</span><br><span class="line">        if (is_background_view) &#123;</span><br><span class="line">          &#x2F;&#x2F;不具备渲染能力且在后台运行</span><br><span class="line">          platform_view_android &#x3D; std::make_unique&lt;PlatformViewAndroid&gt;(</span><br><span class="line">              shell,                   &#x2F;&#x2F; delegate</span><br><span class="line">              shell.GetTaskRunners(),  &#x2F;&#x2F; task runners</span><br><span class="line">              java_object              &#x2F;&#x2F; java object handle for JNI interop</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F;具备渲染能力</span><br><span class="line">          platform_view_android &#x3D; std::make_unique&lt;PlatformViewAndroid&gt;(</span><br><span class="line">              shell,                   &#x2F;&#x2F; delegate</span><br><span class="line">              shell.GetTaskRunners(),  &#x2F;&#x2F; task runners</span><br><span class="line">              java_object,             &#x2F;&#x2F; java object handle for JNI interop</span><br><span class="line">              shell.GetSettings()</span><br><span class="line">                  .enable_software_rendering  &#x2F;&#x2F; use software rendering</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        weak_platform_view &#x3D; platform_view_android-&gt;GetWeakPtr();</span><br><span class="line">        return platform_view_android;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  Shell::CreateCallback&lt;Rasterizer&gt; on_create_rasterizer &#x3D; [](Shell&amp; shell) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建删格化器</span><br><span class="line">    return std::make_unique&lt;Rasterizer&gt;(shell, shell.GetTaskRunners());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;将当前线程（Android主线程）作为平台线程（platform thread）并确保已经初始化Message Loop</span><br><span class="line">  fml::MessageLoop::EnsureInitializedForCurrentThread();</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; gpu_runner;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; ui_runner;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; io_runner;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; platform_runner &#x3D;</span><br><span class="line">      fml::MessageLoop::GetCurrent().GetTaskRunner();</span><br><span class="line">  if (is_background_view) &#123;</span><br><span class="line">    auto single_task_runner &#x3D; thread_host_.ui_thread-&gt;GetTaskRunner();</span><br><span class="line">    gpu_runner &#x3D; single_task_runner;</span><br><span class="line">    ui_runner &#x3D; single_task_runner;</span><br><span class="line">    io_runner &#x3D; single_task_runner;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    gpu_runner &#x3D; thread_host_.gpu_thread-&gt;GetTaskRunner();</span><br><span class="line">    ui_runner &#x3D; thread_host_.ui_thread-&gt;GetTaskRunner();</span><br><span class="line">    io_runner &#x3D; thread_host_.io_thread-&gt;GetTaskRunner();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建TaskRunners对象</span><br><span class="line">  flutter::TaskRunners task_runners(thread_label,     &#x2F;&#x2F; label</span><br><span class="line">                                    platform_runner,  &#x2F;&#x2F; platform</span><br><span class="line">                                    gpu_runner,       &#x2F;&#x2F; gpu</span><br><span class="line">                                    ui_runner,        &#x2F;&#x2F; ui</span><br><span class="line">                                    io_runner         &#x2F;&#x2F; io</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;创建Shell对象</span><br><span class="line">  shell_ &#x3D;</span><br><span class="line">      Shell::Create(task_runners,             &#x2F;&#x2F; task runners</span><br><span class="line">                    GetDefaultWindowData(),   &#x2F;&#x2F; window data</span><br><span class="line">                    settings_,                &#x2F;&#x2F; settings</span><br><span class="line">                    on_create_platform_view,  &#x2F;&#x2F; platform view create callback</span><br><span class="line">                    on_create_rasterizer      &#x2F;&#x2F; rasterizer create callback</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  platform_view_ &#x3D; weak_platform_view;</span><br><span class="line">  FML_DCHECK(platform_view_);</span><br><span class="line"></span><br><span class="line">  is_valid_ &#x3D; shell_ !&#x3D; nullptr;</span><br><span class="line"></span><br><span class="line">  if (is_valid_) &#123;</span><br><span class="line">    &#x2F;&#x2F;降低GPU线程的优先级</span><br><span class="line">    task_runners.GetGPUTaskRunner()-&gt;PostTask([]() &#123;</span><br><span class="line">      &#x2F;&#x2F;Android将-8描述为“最重要的显示线程，用于合成屏幕和检索输入事件”。 保守地将GPU线程设置为比其优先级稍低的优先级。</span><br><span class="line">      &#x2F;&#x2F;将GPU线程优先级设为-5。</span><br><span class="line">      if (::setpriority(PRIO_PROCESS, gettid(), -5) !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果无法将GPU线程优先级设为-5，那么继续将GPU线程优先级设为-2。</span><br><span class="line">        if (::setpriority(PRIO_PROCESS, gettid(), -2) !&#x3D; 0) &#123;</span><br><span class="line">          FML_LOG(ERROR) &lt;&lt; &quot;Failed to set GPU task runner priority&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;将UI线程优先级设为-1。</span><br><span class="line">    task_runners.GetUITaskRunner()-&gt;PostTask([]() &#123;</span><br><span class="line">      if (::setpriority(PRIO_PROCESS, gettid(), -1) !&#x3D; 0) &#123;</span><br><span class="line">        FML_LOG(ERROR) &lt;&lt; &quot;Failed to set UI task runner priority&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码还是比较多的，但主要做了以下几件事。</p>
<ol>
<li>目标线程的创建，如果<code>is_background_view</code>为true，则仅会创建UI线程，否则会创建UI、GPU及IO线程。<code>is_background_view</code>默认为false。</li>
<li>将当前线程（Android主线程）作为平台线程（platform thread）并确保已经初始化Message Loop。</li>
<li><code>Shell</code>对象的创建。</li>
<li>GPU线程及UI线程优先级的修改。</li>
</ol>
<p>从上面可以得出Android主线程（UI线程）是作为<code>Flutter</code>的平台线程（platform thread）存在的，与<code>Flutter</code>的UI线程不是同一线程，所以不要将Android的主线程（UI线程）与<code>Flutter</code>的UI线程搞混。</p>
<p>再来看<code>Shell</code>对象的创建。</p>
<p>[-&gt; flutter/shell/common/shell.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Shell&gt; Shell::Create(</span><br><span class="line">    TaskRunners task_runners,</span><br><span class="line">    const WindowData window_data,</span><br><span class="line">    Settings settings,</span><br><span class="line">    Shell::CreateCallback&lt;PlatformView&gt; on_create_platform_view,</span><br><span class="line">    Shell::CreateCallback&lt;Rasterizer&gt; on_create_rasterizer) &#123;</span><br><span class="line">  PerformInitializationTasks(settings);</span><br><span class="line">  PersistentCache::SetCacheSkSL(settings.cache_sksl);</span><br><span class="line">  &#x2F;&#x2F;Dart虚拟机的创建</span><br><span class="line">  auto vm &#x3D; DartVMRef::Create(settings);</span><br><span class="line">  auto vm_data &#x3D; vm-&gt;GetVMData();</span><br><span class="line"></span><br><span class="line">  return Shell::Create(std::move(task_runners),        &#x2F;&#x2F;</span><br><span class="line">                       std::move(window_data),         &#x2F;&#x2F;</span><br><span class="line">                       std::move(settings),            &#x2F;&#x2F;</span><br><span class="line">                       vm_data-&gt;GetIsolateSnapshot(),  &#x2F;&#x2F; isolate snapshot</span><br><span class="line">                       on_create_platform_view,        &#x2F;&#x2F;</span><br><span class="line">                       on_create_rasterizer,           &#x2F;&#x2F;</span><br><span class="line">                       std::move(vm)                   &#x2F;&#x2F;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>Create</code>函数中，会进行Dart VM的创建，其创建流程参考<a href="https://juejin.im/post/5e5478d651882549274a5340" target="_blank" rel="noopener">Flutter之Dart虚拟机启动 </a>一文。</p>
<p>再来看<code>Create</code>函数，在该函数中会调用<code>CreateShellOnPlatformThread</code>函数，顾名思义，<code>CreateShellOnPlatformThread</code>函数就是在平台线程中创建<code>Shell</code>对象。</p>
<p>[-&gt; flutter/shell/common/shell.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Shell&gt; Shell::Create(</span><br><span class="line">    TaskRunners task_runners,</span><br><span class="line">    const WindowData window_data,</span><br><span class="line">    Settings settings,</span><br><span class="line">    fml::RefPtr&lt;const DartSnapshot&gt; isolate_snapshot,</span><br><span class="line">    const Shell::CreateCallback&lt;PlatformView&gt;&amp; on_create_platform_view,</span><br><span class="line">    const Shell::CreateCallback&lt;Rasterizer&gt;&amp; on_create_rasterizer,</span><br><span class="line">    DartVMRef vm) &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  fml::AutoResetWaitableEvent latch;</span><br><span class="line">  std::unique_ptr&lt;Shell&gt; shell;</span><br><span class="line">  fml::TaskRunner::RunNowOrPostTask(</span><br><span class="line">      task_runners.GetPlatformTaskRunner(),</span><br><span class="line">      fml::MakeCopyable([&amp;latch,                                          &#x2F;&#x2F;</span><br><span class="line">                         vm &#x3D; std::move(vm),                              &#x2F;&#x2F;</span><br><span class="line">                         &amp;shell,                                          &#x2F;&#x2F;</span><br><span class="line">                         task_runners &#x3D; std::move(task_runners),          &#x2F;&#x2F;</span><br><span class="line">                         window_data,                                     &#x2F;&#x2F;</span><br><span class="line">                         settings,                                        &#x2F;&#x2F;</span><br><span class="line">                         isolate_snapshot &#x3D; std::move(isolate_snapshot),  &#x2F;&#x2F;</span><br><span class="line">                         on_create_platform_view,                         &#x2F;&#x2F;</span><br><span class="line">                         on_create_rasterizer                             &#x2F;&#x2F;</span><br><span class="line">  ]() mutable &#123;</span><br><span class="line">        &#x2F;&#x2F;在平台线程中创建Shell对象</span><br><span class="line">        shell &#x3D; CreateShellOnPlatformThread(std::move(vm),</span><br><span class="line">                                            std::move(task_runners),      &#x2F;&#x2F;</span><br><span class="line">                                            window_data,                  &#x2F;&#x2F;</span><br><span class="line">                                            settings,                     &#x2F;&#x2F;</span><br><span class="line">                                            std::move(isolate_snapshot),  &#x2F;&#x2F;</span><br><span class="line">                                            on_create_platform_view,      &#x2F;&#x2F;</span><br><span class="line">                                            on_create_rasterizer          &#x2F;&#x2F;</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F;锁唤醒</span><br><span class="line">        latch.Signal();</span><br><span class="line">      &#125;));</span><br><span class="line">  &#x2F;&#x2F;锁等待</span><br><span class="line">  latch.Wait();</span><br><span class="line">  return shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Shell&gt; Shell::CreateShellOnPlatformThread(</span><br><span class="line">    DartVMRef vm,</span><br><span class="line">    TaskRunners task_runners,</span><br><span class="line">    const WindowData window_data,</span><br><span class="line">    Settings settings,</span><br><span class="line">    fml::RefPtr&lt;const DartSnapshot&gt; isolate_snapshot,</span><br><span class="line">    const Shell::CreateCallback&lt;PlatformView&gt;&amp; on_create_platform_view,</span><br><span class="line">    const Shell::CreateCallback&lt;Rasterizer&gt;&amp; on_create_rasterizer) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;创建Shell对象</span><br><span class="line">  auto shell &#x3D;</span><br><span class="line">      std::unique_ptr&lt;Shell&gt;(new Shell(std::move(vm), task_runners, settings));</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在GPU线程上创建光栅化器。</span><br><span class="line">  std::promise&lt;std::unique_ptr&lt;Rasterizer&gt;&gt; rasterizer_promise;</span><br><span class="line">  auto rasterizer_future &#x3D; rasterizer_promise.get_future();</span><br><span class="line">  std::promise&lt;fml::WeakPtr&lt;SnapshotDelegate&gt;&gt; snapshot_delegate_promise;</span><br><span class="line">  auto snapshot_delegate_future &#x3D; snapshot_delegate_promise.get_future();</span><br><span class="line">  fml::TaskRunner::RunNowOrPostTask(</span><br><span class="line">      task_runners.GetGPUTaskRunner(), [&amp;rasterizer_promise,  &#x2F;&#x2F;</span><br><span class="line">                                        &amp;snapshot_delegate_promise,</span><br><span class="line">                                        on_create_rasterizer,  &#x2F;&#x2F;</span><br><span class="line">                                        shell &#x3D; shell.get()    &#x2F;&#x2F;</span><br><span class="line">  ]() &#123;</span><br><span class="line">        std::unique_ptr&lt;Rasterizer&gt; rasterizer(on_create_rasterizer(*shell));</span><br><span class="line">        snapshot_delegate_promise.set_value(rasterizer-&gt;GetSnapshotDelegate());</span><br><span class="line">        rasterizer_promise.set_value(std::move(rasterizer));</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在平台线程（platform thread）也就是Android主线程中创建platform view</span><br><span class="line">  auto platform_view &#x3D; on_create_platform_view(*shell.get());</span><br><span class="line">  if (!platform_view || !platform_view-&gt;GetWeakPtr()) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;由platform view创建vsync waiter，</span><br><span class="line">  auto vsync_waiter &#x3D; platform_view-&gt;CreateVSyncWaiter();</span><br><span class="line">  if (!vsync_waiter) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在IO线程上创建IO manager。 必须先初始化IO manager，因为它具有其他子系统依赖的状态。 必须首先引导它，并获取必要的引用以初始化其他子系统。</span><br><span class="line">  std::promise&lt;std::unique_ptr&lt;ShellIOManager&gt;&gt; io_manager_promise;</span><br><span class="line">  auto io_manager_future &#x3D; io_manager_promise.get_future();</span><br><span class="line">  std::promise&lt;fml::WeakPtr&lt;ShellIOManager&gt;&gt; weak_io_manager_promise;</span><br><span class="line">  auto weak_io_manager_future &#x3D; weak_io_manager_promise.get_future();</span><br><span class="line">  std::promise&lt;fml::RefPtr&lt;SkiaUnrefQueue&gt;&gt; unref_queue_promise;</span><br><span class="line">  auto unref_queue_future &#x3D; unref_queue_promise.get_future();</span><br><span class="line">  auto io_task_runner &#x3D; shell-&gt;GetTaskRunners().GetIOTaskRunner();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TODO(gw280): The WeakPtr here asserts that we are derefing it on the</span><br><span class="line">  &#x2F;&#x2F; same thread as it was created on. We are currently on the IO thread</span><br><span class="line">  &#x2F;&#x2F; inside this lambda but we need to deref the PlatformView, which was</span><br><span class="line">  &#x2F;&#x2F; constructed on the platform thread.</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter&#x2F;issues&#x2F;42948</span><br><span class="line">  fml::TaskRunner::RunNowOrPostTask(</span><br><span class="line">      io_task_runner,</span><br><span class="line">      [&amp;io_manager_promise,                                               &#x2F;&#x2F;</span><br><span class="line">       &amp;weak_io_manager_promise,                                          &#x2F;&#x2F;</span><br><span class="line">       &amp;unref_queue_promise,                                              &#x2F;&#x2F;</span><br><span class="line">       platform_view &#x3D; platform_view-&gt;GetWeakPtr(),                       &#x2F;&#x2F;</span><br><span class="line">       io_task_runner,                                                    &#x2F;&#x2F;</span><br><span class="line">       is_backgrounded_sync_switch &#x3D; shell-&gt;GetIsGpuDisabledSyncSwitch()  &#x2F;&#x2F;</span><br><span class="line">  ]() &#123;</span><br><span class="line">        auto io_manager &#x3D; std::make_unique&lt;ShellIOManager&gt;(</span><br><span class="line">            platform_view.getUnsafe()-&gt;CreateResourceContext(),</span><br><span class="line">            is_backgrounded_sync_switch, io_task_runner);</span><br><span class="line">        weak_io_manager_promise.set_value(io_manager-&gt;GetWeakPtr());</span><br><span class="line">        unref_queue_promise.set_value(io_manager-&gt;GetSkiaUnrefQueue());</span><br><span class="line">        io_manager_promise.set_value(std::move(io_manager));</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Send dispatcher_maker to the engine constructor because shell won&#39;t have</span><br><span class="line">  &#x2F;&#x2F; platform_view set until Shell::Setup is called later.</span><br><span class="line">  auto dispatcher_maker &#x3D; platform_view-&gt;GetDispatcherMaker();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在Flutter的UI线程中创建engine对象</span><br><span class="line">  std::promise&lt;std::unique_ptr&lt;Engine&gt;&gt; engine_promise;</span><br><span class="line">  auto engine_future &#x3D; engine_promise.get_future();</span><br><span class="line">  fml::TaskRunner::RunNowOrPostTask(</span><br><span class="line">      shell-&gt;GetTaskRunners().GetUITaskRunner(),</span><br><span class="line">      fml::MakeCopyable([&amp;engine_promise,                                 &#x2F;&#x2F;</span><br><span class="line">                         shell &#x3D; shell.get(),                             &#x2F;&#x2F;</span><br><span class="line">                         &amp;dispatcher_maker,                               &#x2F;&#x2F;</span><br><span class="line">                         &amp;window_data,                                    &#x2F;&#x2F;</span><br><span class="line">                         isolate_snapshot &#x3D; std::move(isolate_snapshot),  &#x2F;&#x2F;</span><br><span class="line">                         vsync_waiter &#x3D; std::move(vsync_waiter),          &#x2F;&#x2F;</span><br><span class="line">                         &amp;weak_io_manager_future,                         &#x2F;&#x2F;</span><br><span class="line">                         &amp;snapshot_delegate_future,                       &#x2F;&#x2F;</span><br><span class="line">                         &amp;unref_queue_future                              &#x2F;&#x2F;</span><br><span class="line">  ]() mutable &#123;</span><br><span class="line">        const auto&amp; task_runners &#x3D; shell-&gt;GetTaskRunners();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;在UI线程创建animator，这里主要是为了将平台的vsync信号同步给animator</span><br><span class="line">        auto animator &#x3D; std::make_unique&lt;Animator&gt;(*shell, task_runners,</span><br><span class="line">                                                   std::move(vsync_waiter));</span><br><span class="line">        &#x2F;&#x2F;Engine对象的创建，此时已经切换到Flutter的UI线程</span><br><span class="line">        engine_promise.set_value(std::make_unique&lt;Engine&gt;(</span><br><span class="line">            *shell,                         &#x2F;&#x2F;</span><br><span class="line">            dispatcher_maker,               &#x2F;&#x2F;</span><br><span class="line">            *shell-&gt;GetDartVM(),            &#x2F;&#x2F;</span><br><span class="line">            std::move(isolate_snapshot),    &#x2F;&#x2F;</span><br><span class="line">            task_runners,                   &#x2F;&#x2F;</span><br><span class="line">            window_data,                    &#x2F;&#x2F;</span><br><span class="line">            shell-&gt;GetSettings(),           &#x2F;&#x2F;</span><br><span class="line">            std::move(animator),            &#x2F;&#x2F;</span><br><span class="line">            weak_io_manager_future.get(),   &#x2F;&#x2F;</span><br><span class="line">            unref_queue_future.get(),       &#x2F;&#x2F;</span><br><span class="line">            snapshot_delegate_future.get()  &#x2F;&#x2F;</span><br><span class="line">            ));</span><br><span class="line">      &#125;));</span><br><span class="line">      </span><br><span class="line">  &#x2F;&#x2F;启动Shell</span><br><span class="line">  if (!shell-&gt;Setup(std::move(platform_view),  &#x2F;&#x2F;</span><br><span class="line">                    engine_future.get(),       &#x2F;&#x2F;</span><br><span class="line">                    rasterizer_future.get(),   &#x2F;&#x2F;</span><br><span class="line">                    io_manager_future.get())   &#x2F;&#x2F;</span><br><span class="line">  ) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return shell;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>CreateShellOnPlatformThread</code>函数的实现还是蛮复杂的，但主要还是做了以下几件事。</p>
<ul>
<li>在平台线程中创建一个<code>Shell</code>对象。</li>
<li>在GPU线程创建删格化器，<code>Flutter</code>在绘制完成后，会将数据给它进行删格化处理。关于<code>Flutter</code>的绘制原理可以参考<a href="https://juejin.im/post/5dbed32ee51d456bbe38c6c0" target="_blank" rel="noopener">Flutter的绘制流程简述</a>这篇文章。</li>
<li>在平台线程中创建一个<code>PlatformViewAndroid</code>对象。如果<code>is_background_view</code>为true，会创建一个具备渲染能力的<code>PlatformViewAndroid</code>对象，否则创建的是一个不具备渲染能力且在后台执行的<code>PlatformViewAndroid</code>对象。</li>
<li>通过<code>PlatformView</code>来创建vsync waiter，主要用于VSYNC信号的同步。</li>
<li>在IO线程创建IO manager。</li>
<li>在Flutter的UI线程创建Engine对象。</li>
<li>在平台线程启动<code>Shell</code>，调用<code>Shell</code>对象的<code>Setup</code>函数。</li>
</ul>
<p>这里先忽略其他，主要来看<code>Engine</code>对象的创建。在其构造函数中，会创建一个<code>RuntimeController</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Engine::Engine(Delegate&amp; delegate,</span><br><span class="line">               const PointerDataDispatcherMaker&amp; dispatcher_maker,</span><br><span class="line">               DartVM&amp; vm,</span><br><span class="line">               fml::RefPtr&lt;const DartSnapshot&gt; isolate_snapshot,</span><br><span class="line">               TaskRunners task_runners,</span><br><span class="line">               const WindowData window_data,</span><br><span class="line">               Settings settings,</span><br><span class="line">               std::unique_ptr&lt;Animator&gt; animator,</span><br><span class="line">               fml::WeakPtr&lt;IOManager&gt; io_manager,</span><br><span class="line">               fml::RefPtr&lt;SkiaUnrefQueue&gt; unref_queue,</span><br><span class="line">               fml::WeakPtr&lt;SnapshotDelegate&gt; snapshot_delegate)</span><br><span class="line">    : delegate_(delegate),</span><br><span class="line">      settings_(std::move(settings)),</span><br><span class="line">      animator_(std::move(animator)),</span><br><span class="line">      activity_running_(true),</span><br><span class="line">      have_surface_(false),</span><br><span class="line">      image_decoder_(task_runners,</span><br><span class="line">                     vm.GetConcurrentWorkerTaskRunner(),</span><br><span class="line">                     io_manager),</span><br><span class="line">      task_runners_(std::move(task_runners)),</span><br><span class="line">      weak_factory_(this) &#123;</span><br><span class="line">  &#x2F;&#x2F;RuntimeController对象的创建</span><br><span class="line">  runtime_controller_ &#x3D; std::make_unique&lt;RuntimeController&gt;(</span><br><span class="line">      *this,                        &#x2F;&#x2F; runtime delegate</span><br><span class="line">      &amp;vm,                          &#x2F;&#x2F; VM</span><br><span class="line">      std::move(isolate_snapshot),  &#x2F;&#x2F; isolate snapshot</span><br><span class="line">      task_runners_,                &#x2F;&#x2F; task runners</span><br><span class="line">      std::move(snapshot_delegate),</span><br><span class="line">      std::move(io_manager),                 &#x2F;&#x2F; io manager</span><br><span class="line">      std::move(unref_queue),                &#x2F;&#x2F; Skia unref queue</span><br><span class="line">      image_decoder_.GetWeakPtr(),           &#x2F;&#x2F; image decoder</span><br><span class="line">      settings_.advisory_script_uri,         &#x2F;&#x2F; advisory script uri</span><br><span class="line">      settings_.advisory_script_entrypoint,  &#x2F;&#x2F; advisory script entrypoint</span><br><span class="line">      settings_.idle_notification_callback,  &#x2F;&#x2F; idle notification callback</span><br><span class="line">      window_data,                           &#x2F;&#x2F; window data</span><br><span class="line">      settings_.isolate_create_callback,     &#x2F;&#x2F; isolate create callback</span><br><span class="line">      settings_.isolate_shutdown_callback,   &#x2F;&#x2F; isolate shutdown callback</span><br><span class="line">      settings_.persistent_isolate_data      &#x2F;&#x2F; persistent isolate data</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  pointer_data_dispatcher_ &#x3D; dispatcher_maker(*this);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里的<code>RuntimeController</code>是一个非常重要的对象，在后面很多地方都会用到它。由于篇幅原因，先来看一下从<code>FlutterActivity</code>到<code>RuntimeController</code>对象创建的流程图。</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="368"></svg>)</p>
<h4 id="2-1、RootIsolate对象的创建"><a href="#2-1、RootIsolate对象的创建" class="headerlink" title="2.1、RootIsolate对象的创建"></a>2.1、RootIsolate对象的创建</h4><p>再来看<code>RuntimeController</code>对象的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">RuntimeController::RuntimeController(</span><br><span class="line">    RuntimeDelegate&amp; p_client,</span><br><span class="line">    DartVM* p_vm,</span><br><span class="line">    fml::RefPtr&lt;const DartSnapshot&gt; p_isolate_snapshot,</span><br><span class="line">    TaskRunners p_task_runners,</span><br><span class="line">    fml::WeakPtr&lt;SnapshotDelegate&gt; p_snapshot_delegate,</span><br><span class="line">    fml::WeakPtr&lt;IOManager&gt; p_io_manager,</span><br><span class="line">    fml::RefPtr&lt;SkiaUnrefQueue&gt; p_unref_queue,</span><br><span class="line">    fml::WeakPtr&lt;ImageDecoder&gt; p_image_decoder,</span><br><span class="line">    std::string p_advisory_script_uri,</span><br><span class="line">    std::string p_advisory_script_entrypoint,</span><br><span class="line">    const std::function&lt;void(int64_t)&gt;&amp; idle_notification_callback,</span><br><span class="line">    const WindowData&amp; p_window_data,</span><br><span class="line">    const fml::closure&amp; p_isolate_create_callback,</span><br><span class="line">    const fml::closure&amp; p_isolate_shutdown_callback,</span><br><span class="line">    std::shared_ptr&lt;const fml::Mapping&gt; p_persistent_isolate_data)</span><br><span class="line">    : client_(p_client),</span><br><span class="line">      vm_(p_vm),</span><br><span class="line">      isolate_snapshot_(std::move(p_isolate_snapshot)),</span><br><span class="line">      task_runners_(p_task_runners),</span><br><span class="line">      snapshot_delegate_(p_snapshot_delegate),</span><br><span class="line">      io_manager_(p_io_manager),</span><br><span class="line">      unref_queue_(p_unref_queue),</span><br><span class="line">      image_decoder_(p_image_decoder),</span><br><span class="line">      advisory_script_uri_(p_advisory_script_uri),</span><br><span class="line">      advisory_script_entrypoint_(p_advisory_script_entrypoint),</span><br><span class="line">      idle_notification_callback_(idle_notification_callback),</span><br><span class="line">      window_data_(std::move(p_window_data)),</span><br><span class="line">      isolate_create_callback_(p_isolate_create_callback),</span><br><span class="line">      isolate_shutdown_callback_(p_isolate_shutdown_callback),</span><br><span class="line">      persistent_isolate_data_(std::move(p_persistent_isolate_data)) &#123;</span><br><span class="line">  &#x2F;&#x2F;创建RootIsolate</span><br><span class="line">  auto strong_root_isolate &#x3D;</span><br><span class="line">      DartIsolate::CreateRootIsolate(vm_-&gt;GetVMData()-&gt;GetSettings(),  &#x2F;&#x2F;</span><br><span class="line">                                     isolate_snapshot_,                &#x2F;&#x2F;</span><br><span class="line">                                     task_runners_,                    &#x2F;&#x2F;</span><br><span class="line">                                     std::make_unique&lt;Window&gt;(this),   &#x2F;&#x2F;</span><br><span class="line">                                     snapshot_delegate_,               &#x2F;&#x2F;</span><br><span class="line">                                     io_manager_,                      &#x2F;&#x2F;</span><br><span class="line">                                     unref_queue_,                     &#x2F;&#x2F;</span><br><span class="line">                                     image_decoder_,                   &#x2F;&#x2F;</span><br><span class="line">                                     p_advisory_script_uri,            &#x2F;&#x2F;</span><br><span class="line">                                     p_advisory_script_entrypoint,     &#x2F;&#x2F;</span><br><span class="line">                                     nullptr,                          &#x2F;&#x2F;</span><br><span class="line">                                     isolate_create_callback_,         &#x2F;&#x2F;</span><br><span class="line">                                     isolate_shutdown_callback_        &#x2F;&#x2F;</span><br><span class="line">                                     )</span><br><span class="line">          .lock();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在构造函数中，会调用<code>CreateRootIsolate</code>函数来创建一个<code>isolate</code>作为根<code>Isolate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;DartIsolate&gt; DartIsolate::CreateRootIsolate(</span><br><span class="line">    const Settings&amp; settings,</span><br><span class="line">    fml::RefPtr&lt;const DartSnapshot&gt; isolate_snapshot,</span><br><span class="line">    TaskRunners task_runners,</span><br><span class="line">    std::unique_ptr&lt;Window&gt; window,</span><br><span class="line">    fml::WeakPtr&lt;SnapshotDelegate&gt; snapshot_delegate,</span><br><span class="line">    fml::WeakPtr&lt;IOManager&gt; io_manager,</span><br><span class="line">    fml::RefPtr&lt;SkiaUnrefQueue&gt; unref_queue,</span><br><span class="line">    fml::WeakPtr&lt;ImageDecoder&gt; image_decoder,</span><br><span class="line">    std::string advisory_script_uri,</span><br><span class="line">    std::string advisory_script_entrypoint,</span><br><span class="line">    Dart_IsolateFlags* flags,</span><br><span class="line">    const fml::closure&amp; isolate_create_callback,</span><br><span class="line">    const fml::closure&amp; isolate_shutdown_callback) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;创建isolate对象</span><br><span class="line">  Dart_Isolate vm_isolate &#x3D;</span><br><span class="line">      CreateDartIsolateGroup(std::move(isolate_group_data),</span><br><span class="line">                             std::move(isolate_data), flags, error.error());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;DartIsolate&gt;* root_isolate_data &#x3D;</span><br><span class="line">      static_cast&lt;std::shared_ptr&lt;DartIsolate&gt;*&gt;(Dart_IsolateData(vm_isolate));</span><br><span class="line"></span><br><span class="line">  (*root_isolate_data)-&gt;SetWindow(std::move(window));</span><br><span class="line"></span><br><span class="line">  return (*root_isolate_data)-&gt;GetWeakIsolatePtr();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再来看<code>CreateDartIsolateGroup</code>函数，该函数主要做了两件事。</p>
<ul>
<li>通过Dart VM来创建isolate对象，并将该isolate对象作为root isolate。</li>
<li>初始化isolate对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Dart_Isolate DartIsolate::CreateDartIsolateGroup(</span><br><span class="line">    std::unique_ptr&lt;std::shared_ptr&lt;DartIsolateGroupData&gt;&gt; isolate_group_data,</span><br><span class="line">    std::unique_ptr&lt;std::shared_ptr&lt;DartIsolate&gt;&gt; isolate_data,</span><br><span class="line">    Dart_IsolateFlags* flags,</span><br><span class="line">    char** error) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;通过Dart VM创建一个isolate对象</span><br><span class="line">  Dart_Isolate isolate &#x3D; Dart_CreateIsolateGroup(</span><br><span class="line">      (*isolate_group_data)-&gt;GetAdvisoryScriptURI().c_str(),</span><br><span class="line">      (*isolate_group_data)-&gt;GetAdvisoryScriptEntrypoint().c_str(),</span><br><span class="line">      (*isolate_group_data)-&gt;GetIsolateSnapshot()-&gt;GetDataMapping(),</span><br><span class="line">      (*isolate_group_data)-&gt;GetIsolateSnapshot()-&gt;GetInstructionsMapping(),</span><br><span class="line">      flags, isolate_group_data.get(), isolate_data.get(), error);</span><br><span class="line"></span><br><span class="line">  if (isolate &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Ownership of the isolate data objects has been transferred to the Dart VM.</span><br><span class="line">  std::shared_ptr&lt;DartIsolate&gt; embedder_isolate(*isolate_data);</span><br><span class="line">  isolate_group_data.release();</span><br><span class="line">  isolate_data.release();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;初始化isolate对象</span><br><span class="line">  if (!InitializeIsolate(std::move(embedder_isolate), isolate, error)) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isolate;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>先来看<code>Dart_CreateIsolateGroup</code>函数在Dart VM的实现，在其实现函数中会创建<code>isolate</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Dart_CreateIsolateGroup(const char* script_uri,</span><br><span class="line">                        const char* name,</span><br><span class="line">                        const uint8_t* snapshot_data,</span><br><span class="line">                        const uint8_t* snapshot_instructions,</span><br><span class="line">                        Dart_IsolateFlags* flags,</span><br><span class="line">                        void* isolate_group_data,</span><br><span class="line">                        void* isolate_data,</span><br><span class="line">                        char** error) &#123;</span><br><span class="line"></span><br><span class="line">  Dart_IsolateFlags api_flags;</span><br><span class="line">  if (flags &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">    Isolate::FlagsInitialize(&amp;api_flags);</span><br><span class="line">    flags &#x3D; &amp;api_flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* non_null_name &#x3D; name &#x3D;&#x3D; nullptr ? &quot;isolate&quot; : name;</span><br><span class="line">  std::unique_ptr&lt;IsolateGroupSource&gt; source(</span><br><span class="line">      new IsolateGroupSource(script_uri, non_null_name, snapshot_data,</span><br><span class="line">                             snapshot_instructions, nullptr, -1, *flags));</span><br><span class="line">  auto group &#x3D; new IsolateGroup(std::move(source), isolate_group_data);</span><br><span class="line">  IsolateGroup::RegisterIsolateGroup(group);</span><br><span class="line">  Dart_Isolate isolate &#x3D;</span><br><span class="line">      CreateIsolate(group, non_null_name, isolate_data, error);</span><br><span class="line">  if (isolate !&#x3D; nullptr) &#123;</span><br><span class="line">    group-&gt;set_initial_spawn_successful();</span><br><span class="line">  &#125;</span><br><span class="line">  return isolate;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>CreateIsolate</code>函数就会创建一个<code>isolate</code>对象，关于后续的<code>isolate</code>对象的创建及<code>isolate</code>的更多内容可以去阅读<a href="https://juejin.im/post/5e149a7df265da5d3b32e167" target="_blank" rel="noopener">深入理解Isolate</a>这篇文章。</p>
<p>再来看<code>isolate</code>对象的初始化函数——<code>InitializeIsolate</code>的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">bool DartIsolate::InitializeIsolate(</span><br><span class="line">    std::shared_ptr&lt;DartIsolate&gt; embedder_isolate,</span><br><span class="line">    Dart_Isolate isolate,</span><br><span class="line">    char** error) &#123;</span><br><span class="line">  if (!embedder_isolate-&gt;Initialize(isolate)) &#123;&#x2F;&#x2F;初始化</span><br><span class="line">    *error &#x3D; fml::strdup(&quot;Embedder could not initialize the Dart isolate.&quot;);</span><br><span class="line">9999    return false;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;isolate加载library</span><br><span class="line">  if (!embedder_isolate-&gt;LoadLibraries()) &#123;</span><br><span class="line">    *error &#x3D; fml::strdup(</span><br><span class="line">        &quot;Embedder could not load libraries in the new Dart isolate.&quot;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Root isolates will be setup by the engine and the service isolate (which is</span><br><span class="line">  &#x2F;&#x2F; also a root isolate) by the utility routines in the VM. However, secondary</span><br><span class="line">  &#x2F;&#x2F; isolates will be run by the VM if they are marked as runnable.</span><br><span class="line">  if (!embedder_isolate-&gt;IsRootIsolate()) &#123;</span><br><span class="line">    auto child_isolate_preparer &#x3D;</span><br><span class="line">        embedder_isolate-&gt;GetIsolateGroupData().GetChildIsolatePreparer();</span><br><span class="line">    if (!child_isolate_preparer(embedder_isolate.get())) &#123;</span><br><span class="line">      *error &#x3D; fml::strdup(&quot;Could not prepare the child isolate to run.&quot;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">bool DartIsolate::Initialize(Dart_Isolate dart_isolate) &#123;</span><br><span class="line">  if (phase_ !&#x3D; Phase::Uninitialized) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (dart_isolate &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (Dart_CurrentIsolate() !&#x3D; dart_isolate) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;从这里开始，可以安全的使用isolate</span><br><span class="line">  SetIsolate(dart_isolate);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We are entering a new scope (for the first time since initialization) and</span><br><span class="line">  &#x2F;&#x2F; we want to restore the current scope to null when we exit out of this</span><br><span class="line">  &#x2F;&#x2F; method. This balances the implicit Dart_EnterIsolate call made by</span><br><span class="line">  &#x2F;&#x2F; Dart_CreateIsolateGroup (which calls the Initialize).</span><br><span class="line">  Dart_ExitIsolate();</span><br><span class="line"></span><br><span class="line">  tonic::DartIsolateScope scope(isolate());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;设置UI线程的消息处理器</span><br><span class="line">  SetMessageHandlingTaskRunner(GetTaskRunners().GetUITaskRunner());</span><br><span class="line"></span><br><span class="line">  if (tonic::LogIfError(</span><br><span class="line">          Dart_SetLibraryTagHandler(tonic::DartState::HandleLibraryTag))) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!UpdateThreadPoolNames()) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;初始化完成</span><br><span class="line">  phase_ &#x3D; Phase::Initialized;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DartIsolate::SetMessageHandlingTaskRunner(</span><br><span class="line">    fml::RefPtr&lt;fml::TaskRunner&gt; runner) &#123;</span><br><span class="line">  if (!IsRootIsolate() || !runner) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message_handling_task_runner_ &#x3D; runner;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;设置消息处理器</span><br><span class="line">  message_handler().Initialize(</span><br><span class="line">      [runner](std::function&lt;void()&gt; task) &#123; runner-&gt;PostTask(task); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最终在<code>SetMessageHandlingTaskRunner</code>函数中将<code>UITaskRunner</code>设置为<code>Flutter</code>中UI线程的消息处理器，进行UI线程中消息的分发并处理。也就是说在<code>RootIsolate</code>中，消息并不是通过线程池中来分发及处理的，所以不要在UI线程的消息中进行耗时操作，否则影响UI绘制。其实在Android平台上的<code>Flutter</code>的消息处理机制与<code>Android</code>中的消息机制类似，都是使用的Android平台的<code>Looper</code>。更多内容后面再来一一讲解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void DartMessageHandler::Initialize(TaskDispatcher dispatcher) &#123;</span><br><span class="line">  &#x2F;&#x2F; Only can be called once.</span><br><span class="line">  TONIC_CHECK(!task_dispatcher_ &amp;&amp; dispatcher);</span><br><span class="line">  task_dispatcher_ &#x3D; dispatcher;</span><br><span class="line">  Dart_SetMessageNotifyCallback(MessageNotifyCallback);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>Dart_SetMessageNotifyCallback</code>中其实就是给<code>RootIsolate</code>设置消息通知回调，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DART_EXPORT void Dart_SetMessageNotifyCallback(</span><br><span class="line">    Dart_MessageNotifyCallback message_notify_callback) &#123;</span><br><span class="line">  Isolate* isolate &#x3D; Isolate::Current();</span><br><span class="line">  CHECK_ISOLATE(isolate);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    NoSafepointScope no_safepoint_scope;</span><br><span class="line">    isolate-&gt;set_message_notify_callback(message_notify_callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (message_notify_callback !&#x3D; nullptr &amp;&amp; isolate-&gt;HasPendingMessages()) &#123;</span><br><span class="line">    ::Dart_ExitIsolate();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If a new handler gets installed and there are pending messages in the</span><br><span class="line">    &#x2F;&#x2F; queue (e.g. OOB messages for doing vm service work) we need to notify</span><br><span class="line">    &#x2F;&#x2F; the newly registered callback, otherwise the embedder might never get</span><br><span class="line">    &#x2F;&#x2F; notified about the pending messages.</span><br><span class="line">    message_notify_callback(Api::CastIsolate(isolate));</span><br><span class="line"></span><br><span class="line">    ::Dart_EnterIsolate(Api::CastIsolate(isolate));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>关于<code>RootIsolate</code>的相关调用流程图如下。</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="772"></svg>)</p>
<p>到此，一个<code>Engine</code>对象就已经创建完毕。再回到<code>Shell</code>中，来看<code>Shell</code>的<code>Setup</code>函数是如何启动的。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">bool Shell::Setup(std::unique_ptr&lt;PlatformView&gt; platform_view,</span><br><span class="line">                  std::unique_ptr&lt;Engine&gt; engine,</span><br><span class="line">                  std::unique_ptr&lt;Rasterizer&gt; rasterizer,</span><br><span class="line">                  std::unique_ptr&lt;ShellIOManager&gt; io_manager) &#123;</span><br><span class="line">  if (is_setup_) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;platform_view、engine、rasterizer及io_manager只要有一个创建失败，Shell启动就会失败</span><br><span class="line">  if (!platform_view || !engine || !rasterizer || !io_manager) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  platform_view_ &#x3D; std::move(platform_view);</span><br><span class="line">  engine_ &#x3D; std::move(engine);</span><br><span class="line">  rasterizer_ &#x3D; std::move(rasterizer);</span><br><span class="line">  io_manager_ &#x3D; std::move(io_manager);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The weak ptr must be generated in the platform thread which owns the unique</span><br><span class="line">  &#x2F;&#x2F; ptr.</span><br><span class="line">  weak_engine_ &#x3D; engine_-&gt;GetWeakPtr();</span><br><span class="line">  weak_rasterizer_ &#x3D; rasterizer_-&gt;GetWeakPtr();</span><br><span class="line">  weak_platform_view_ &#x3D; platform_view_-&gt;GetWeakPtr();</span><br><span class="line"></span><br><span class="line">  is_setup_ &#x3D; true;</span><br><span class="line"></span><br><span class="line">  vm_-&gt;GetServiceProtocol()-&gt;AddHandler(this, GetServiceProtocolDescription());</span><br><span class="line"></span><br><span class="line">  PersistentCache::GetCacheForProcess()-&gt;AddWorkerTaskRunner(</span><br><span class="line">      task_runners_.GetIOTaskRunner());</span><br><span class="line"></span><br><span class="line">  PersistentCache::GetCacheForProcess()-&gt;SetIsDumpingSkp(</span><br><span class="line">      settings_.dump_skp_on_shader_compilation);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TODO(gw280): The WeakPtr here asserts that we are derefing it on the</span><br><span class="line">  &#x2F;&#x2F; same thread as it was created on. Shell is constructed on the platform</span><br><span class="line">  &#x2F;&#x2F; thread but we need to call into the Engine on the UI thread, so we need</span><br><span class="line">  &#x2F;&#x2F; to use getUnsafe() here to avoid failing the assertion.</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter&#x2F;issues&#x2F;42947</span><br><span class="line">  display_refresh_rate_ &#x3D; weak_engine_.getUnsafe()-&gt;GetDisplayRefreshRate();</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>Setup</code>函数中主要是检查<code>Shell</code>的子组件是否已经初始化，如<code>Engine</code>、<code>platform_view</code>、<code>rasterizer</code>、<code>io manager</code>等，然后将这些组件设置为全局。</p>
<p>如果该函数返回<code>true</code>就表示<code>Engine</code>已经创建成功。</p>
<h3 id="3、Engine的运行"><a href="#3、Engine的运行" class="headerlink" title="3、Engine的运行"></a>3、Engine的运行</h3><p>再回到类<code>FlutterActivityDelegate</code>中，当<code>Engine</code>创建完毕后，再调用<code>runBundle</code>方法来执行<code>Flutter</code>代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class FlutterActivityDelegate</span><br><span class="line">        implements FlutterActivityEvents,</span><br><span class="line">                   FlutterView.Provider,</span><br><span class="line">                   PluginRegistry &#123;</span><br><span class="line">    private void runBundle(String appBundlePath) &#123;</span><br><span class="line">        if (!flutterView.getFlutterNativeView().isApplicationRunning()) &#123;</span><br><span class="line">            FlutterRunArguments args &#x3D; new FlutterRunArguments();</span><br><span class="line">            &#x2F;&#x2F;flutter代码路径</span><br><span class="line">            args.bundlePath &#x3D; appBundlePath;</span><br><span class="line">            &#x2F;&#x2F;flutter入口函数</span><br><span class="line">            args.entrypoint &#x3D; &quot;main&quot;;</span><br><span class="line">            flutterView.runFromBundle(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>先来看<code>FlutterRunArguments</code>，它仅有三个字段，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterRunArguments &#123;</span><br><span class="line">  public String bundlePath;</span><br><span class="line">  public String entrypoint;</span><br><span class="line">  public String libraryPath;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>runBundle</code>方法中调用<code>FlutterView</code>的<code>runFromBundle</code>方法时，字段<code>libraryPath</code>为空。在后面会用到根据<code>entrypoint</code>及<code>libraryPath</code>有不同实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class FlutterView extends SurfaceView implements BinaryMessenger, TextureRegistry &#123;</span><br><span class="line">    public void runFromBundle(FlutterRunArguments args) &#123;</span><br><span class="line">      assertAttached();</span><br><span class="line">      preRun();</span><br><span class="line">      &#x2F;&#x2F;运行flutter代码</span><br><span class="line">      mNativeView.runFromBundle(args);</span><br><span class="line">      postRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FlutterNativeView implements BinaryMessenger &#123;</span><br><span class="line">    public void runFromBundle(FlutterRunArguments args) &#123;</span><br><span class="line">        if (args.entrypoint &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new AssertionError(&quot;An entrypoint must be specified&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        assertAttached();</span><br><span class="line">        if (applicationIsRunning)</span><br><span class="line">            throw new AssertionError(</span><br><span class="line">                    &quot;This Flutter engine instance is already running an application&quot;);</span><br><span class="line">        mFlutterJNI.runBundleAndSnapshotFromLibrary(</span><br><span class="line">            args.bundlePath,</span><br><span class="line">            args.entrypoint,</span><br><span class="line">            args.libraryPath,</span><br><span class="line">            mContext.getResources().getAssets()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        applicationIsRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FlutterJNI &#123;</span><br><span class="line">  @UiThread</span><br><span class="line">  public void runBundleAndSnapshotFromLibrary(</span><br><span class="line">      @NonNull String bundlePath,</span><br><span class="line">      @Nullable String entrypointFunctionName,</span><br><span class="line">      @Nullable String pathToEntrypointFunction,</span><br><span class="line">      @NonNull AssetManager assetManager</span><br><span class="line">  ) &#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    ensureAttachedToNative();</span><br><span class="line">    nativeRunBundleAndSnapshotFromLibrary(</span><br><span class="line">        nativePlatformViewId,</span><br><span class="line">        bundlePath,</span><br><span class="line">        entrypointFunctionName,</span><br><span class="line">        pathToEntrypointFunction,</span><br><span class="line">        assetManager</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private native void nativeRunBundleAndSnapshotFromLibrary(</span><br><span class="line">      long nativePlatformViewId,</span><br><span class="line">      @NonNull String bundlePath,</span><br><span class="line">      @Nullable String entrypointFunctionName,</span><br><span class="line">      @Nullable String pathToEntrypointFunction,</span><br><span class="line">      @NonNull AssetManager manager</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>nativeRunBundleAndSnapshotFromLibrary</code>又是一个<code>native</code>方法，它在<code>Engine</code>中对应的函数实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void RunBundleAndSnapshotFromLibrary(JNIEnv* env,</span><br><span class="line">                                            jobject jcaller,</span><br><span class="line">                                            jlong shell_holder,</span><br><span class="line">                                            jstring jBundlePath,</span><br><span class="line">                                            jstring jEntrypoint,</span><br><span class="line">                                            jstring jLibraryUrl,</span><br><span class="line">                                            jobject jAssetManager) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;根据配置文件来启动Engine</span><br><span class="line">  ANDROID_SHELL_HOLDER-&gt;Launch(std::move(config));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>RunBundleAndSnapshotFromLibrary</code>主要是对传递的参数进行封装，然后调用<code>Shell</code>的<code>Launch</code>函数来运行<code>Engine</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void AndroidShellHolder::Launch(RunConfiguration config) &#123;</span><br><span class="line">  if (!IsValid()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;根据配置运行Engine</span><br><span class="line">  shell_-&gt;RunEngine(std::move(config));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>RunEngine</code>函数的代码实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void Shell::RunEngine(RunConfiguration run_configuration) &#123;</span><br><span class="line">  RunEngine(std::move(run_configuration), nullptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Shell::RunEngine(</span><br><span class="line">    RunConfiguration run_configuration,</span><br><span class="line">    const std::function&lt;void(Engine::RunStatus)&gt;&amp; result_callback) &#123;</span><br><span class="line">  auto result &#x3D; [platform_runner &#x3D; task_runners_.GetPlatformTaskRunner(),</span><br><span class="line">                 result_callback](Engine::RunStatus run_result) &#123;</span><br><span class="line">    if (!result_callback) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    platform_runner-&gt;PostTask(</span><br><span class="line">        [result_callback, run_result]() &#123; result_callback(run_result); &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F;在Flutter的UI线程调用Engine对象的run函数</span><br><span class="line">  fml::TaskRunner::RunNowOrPostTask(</span><br><span class="line">      task_runners_.GetUITaskRunner(),</span><br><span class="line">      fml::MakeCopyable(</span><br><span class="line">          [run_configuration &#x3D; std::move(run_configuration),</span><br><span class="line">           weak_engine &#x3D; weak_engine_, result]() mutable &#123;</span><br><span class="line">            if (!weak_engine) &#123;</span><br><span class="line">              result(Engine::RunStatus::Failure);</span><br><span class="line">              return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;weak_engine是在执行shell的Setup函数时设置的。</span><br><span class="line">            auto run_result &#x3D; weak_engine-&gt;Run(std::move(run_configuration));</span><br><span class="line">            if (run_result &#x3D;&#x3D; flutter::Engine::RunStatus::Failure) &#123;</span><br><span class="line">              FML_LOG(ERROR) &lt;&lt; &quot;Could not launch engine with configuration.&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            result(run_result);</span><br><span class="line">          &#125;));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过执行<code>Engine</code>对象的<code>Run</code>函数，就可以让<code>Engine</code>对象跑起来，实现代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Engine::RunStatus Engine::Run(RunConfiguration configuration) &#123;</span><br><span class="line">  if (!configuration.IsValid()) &#123;</span><br><span class="line">    return RunStatus::Failure;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_entry_point_ &#x3D; configuration.GetEntrypoint();</span><br><span class="line">  last_entry_point_library_ &#x3D; configuration.GetEntrypointLibrary();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;准备并启动Isolate</span><br><span class="line">  auto isolate_launch_status &#x3D;</span><br><span class="line">      PrepareAndLaunchIsolate(std::move(configuration));</span><br><span class="line">      </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  return isolate_running ? Engine::RunStatus::Success</span><br><span class="line">                         : Engine::RunStatus::Failure;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面再来看<code>PrepareAndLaunchIsolate</code>函数的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Engine::RunStatus Engine::PrepareAndLaunchIsolate(</span><br><span class="line">    RunConfiguration configuration) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认情况下，configuration.GetEntrypointLibrary()为空</span><br><span class="line">  if (configuration.GetEntrypointLibrary().empty()) &#123;</span><br><span class="line">    &#x2F;&#x2F;运行isolate</span><br><span class="line">    if (!isolate-&gt;Run(configuration.GetEntrypoint(),</span><br><span class="line">                      settings_.dart_entrypoint_args)) &#123;</span><br><span class="line">      FML_LOG(ERROR) &lt;&lt; &quot;Could not run the isolate.&quot;;</span><br><span class="line">      return RunStatus::Failure;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (!isolate-&gt;RunFromLibrary(configuration.GetEntrypointLibrary(),</span><br><span class="line">                                 configuration.GetEntrypoint(),</span><br><span class="line">                                 settings_.dart_entrypoint_args)) &#123;</span><br><span class="line">      FML_LOG(ERROR) &lt;&lt; &quot;Could not run the isolate.&quot;;</span><br><span class="line">      return RunStatus::Failure;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return RunStatus::Success;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>configuration.GetEntrypointLibrary()</code>返回值为空，所以这里会调用<code>DartIsolate</code>的<code>run</code>函数来运行<code>isolate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool DartIsolate::Run(const std::string&amp; entrypoint_name,</span><br><span class="line">                      const std::vector&lt;std::string&gt;&amp; args,</span><br><span class="line">                      const fml::closure&amp; on_run) &#123;</span><br><span class="line">  if (phase_ !&#x3D; Phase::Ready) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tonic::DartState::Scope scope(this);</span><br><span class="line"></span><br><span class="line">  auto user_entrypoint_function &#x3D;</span><br><span class="line">      Dart_GetField(Dart_RootLibrary(), tonic::ToDart(entrypoint_name.c_str()));</span><br><span class="line"></span><br><span class="line">  auto entrypoint_args &#x3D; tonic::ToDart(args);</span><br><span class="line">  &#x2F;&#x2F;调用main方法</span><br><span class="line">  if (!InvokeMainEntrypoint(user_entrypoint_function, entrypoint_args)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  phase_ &#x3D; Phase::Running;</span><br><span class="line"></span><br><span class="line">  if (on_run) &#123;</span><br><span class="line">    on_run();</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>InvokeMainEntrypoint</code>顾名思义就是调用<code>Flutter</code>项目中的入口函数——<code>main</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static bool InvokeMainEntrypoint(Dart_Handle user_entrypoint_function,</span><br><span class="line">                                 Dart_Handle args) &#123;</span><br><span class="line">  if (tonic::LogIfError(user_entrypoint_function)) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; &quot;Could not resolve main entrypoint function.&quot;;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Dart_Handle start_main_isolate_function &#x3D;</span><br><span class="line">      tonic::DartInvokeField(Dart_LookupLibrary(tonic::ToDart(&quot;dart:isolate&quot;)),</span><br><span class="line">                             &quot;_getStartMainIsolateFunction&quot;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  if (tonic::LogIfError(start_main_isolate_function)) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; &quot;Could not resolve main entrypoint trampoline.&quot;;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (tonic::LogIfError(tonic::DartInvokeField(</span><br><span class="line">          Dart_LookupLibrary(tonic::ToDart(&quot;dart:ui&quot;)), &quot;_runMainZoned&quot;,</span><br><span class="line">          &#123;start_main_isolate_function, user_entrypoint_function, args&#125;))) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; &quot;Could not invoke the main entrypoint.&quot;;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>来看<code>_getStartMainIsolateFunction</code>函数的实现，它返回了一个<code>_startMainIsolate</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">Function _getStartMainIsolateFunction() &#123;</span><br><span class="line">  return _startMainIsolate;</span><br><span class="line">&#125;</span><br><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">void _startMainIsolate(Function entryPoint, List&lt;String&gt; args) &#123;</span><br><span class="line">  _startIsolate(</span><br><span class="line">      null, &#x2F;&#x2F; no parent port</span><br><span class="line">      entryPoint,</span><br><span class="line">      args,</span><br><span class="line">      null, &#x2F;&#x2F; no message</span><br><span class="line">      true, &#x2F;&#x2F; isSpawnUri</span><br><span class="line">      null, &#x2F;&#x2F; no control port</span><br><span class="line">      null); &#x2F;&#x2F; no capabilities</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再来看<code>_runMainZoned</code>函数的实现，它就直接执行<code>_getStartMainIsolateFunction</code>函数的返回函数<code>_startMainIsolate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@pragma(&#39;vm:entry-point&#39;)</span><br><span class="line">&#x2F;&#x2F; ignore: unused_element</span><br><span class="line">void _runMainZoned(Function startMainIsolateFunction,</span><br><span class="line">                   Function userMainFunction,</span><br><span class="line">                   List&lt;String&gt; args) &#123;</span><br><span class="line">  startMainIsolateFunction(()&#123;</span><br><span class="line">    runZoned&lt;void&gt;(() &#123;</span><br><span class="line">      if (userMainFunction is _BinaryFunction) &#123;</span><br><span class="line">        &#x2F;&#x2F; This seems to be undocumented but supported by the command line VM.</span><br><span class="line">        &#x2F;&#x2F; Let&#39;s do the same in case old entry-points are ported to Flutter.</span><br><span class="line">        (userMainFunction as dynamic)(args, &#39;&#39;);</span><br><span class="line">      &#125; else if (userMainFunction is _UnaryFunction) &#123;</span><br><span class="line">        (userMainFunction as dynamic)(args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        userMainFunction();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, onError: (Object error, StackTrace stackTrace) &#123;</span><br><span class="line">      _reportUnhandledException(error.toString(), stackTrace.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, null);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>_startMainIsolate</code>函数中就是直接运行<code>RootIsolate</code>并执行入口函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">void _startIsolate(</span><br><span class="line">    SendPort parentPort,</span><br><span class="line">    Function entryPoint,</span><br><span class="line">    List&lt;String&gt; args,</span><br><span class="line">    var message,</span><br><span class="line">    bool isSpawnUri,</span><br><span class="line">    RawReceivePort controlPort,</span><br><span class="line">    List capabilities) &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;将所有用户代码处理延迟到消息循环的下一次运行。 这使我们能够拦截事件分发中的某些条件，例如从暂停状态开始。</span><br><span class="line">  RawReceivePort port &#x3D; new RawReceivePort();</span><br><span class="line">  port.handler &#x3D; (_) &#123;</span><br><span class="line">    port.close();</span><br><span class="line"></span><br><span class="line">    if (isSpawnUri) &#123;</span><br><span class="line">      if (entryPoint is _BinaryFunction) &#123;</span><br><span class="line">        (entryPoint as dynamic)(args, message);</span><br><span class="line">      &#125; else if (entryPoint is _UnaryFunction) &#123;</span><br><span class="line">        (entryPoint as dynamic)(args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        entryPoint();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      entryPoint(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F;确保消息处理程序已触发。</span><br><span class="line">  port.sendPort.send(null);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>_startIsolate</code>方法中，就会执行<code>Flutter</code>中的入口函数，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void main() &#x3D;&gt; runApp(MyApp());</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>运行<code>Flutter</code>代码的流程图如下。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/26/17081913307d8f79?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>由于东西比较多，所以本文只是描述了<code>Engine</code>的整体创建流程，一些细节也没有具体讲述。但如果熟悉了<code>Engine</code>的创建流程，那么也就能很快的去了解细节的具体实现。</p>
<p><strong>【参考资料】</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BTimer%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BTimer%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" itemprop="url">Flutter之Timer原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-29T17:17:22+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BTimer%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Flutter%E4%B9%8BTimer%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flutter之Timer原理解析"><a href="#Flutter之Timer原理解析" class="headerlink" title="Flutter之Timer原理解析"></a>Flutter之Timer原理解析</h1><p>在开发中，<code>Timer</code>总是一定无法绕过的。通过它，我们可以来实现任务的轮询、定时执行等。当然，由于一些原因，一些平台中不建议使用<code>Timer</code>。在<code>Android</code>中，基本上就是不建议使用它，而是通过<code>Handler</code>、<code>ScheduledThreadPoolExecutor</code>等来替代<code>Timer</code>。那如果在<code>Flutter</code>中尼？下面就来看<code>Flutter</code>中如何使用<code>Timer</code>及<code>Timer</code>的实现原理。</p>
<h3 id="1、Timer的使用"><a href="#1、Timer的使用" class="headerlink" title="1、Timer的使用"></a>1、Timer的使用</h3><p>在<code>Flutter</code>中，<code>Timer</code>是无处不在的，有直接使用其API，也有使用<code>Timer</code>的包装类，如<code>Future</code>。但在本文，会通过<code>Timer</code>及其API来深入了解实现原理。先来看<code>Timer</code>的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;任务的定时执行。延迟1秒后输出f1</span><br><span class="line">Timer(Duration(milliseconds: 1000), () &#123;</span><br><span class="line">  print(&quot;f1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;任务的周期性执行</span><br><span class="line">Timer.periodic(Duration(milliseconds: 1000), (timer) &#123;</span><br><span class="line">  print(&quot;f2&quot;);</span><br><span class="line">  count++;</span><br><span class="line">  if (count &#x3D;&#x3D; 3) &#123;</span><br><span class="line">    &#x2F;&#x2F;当执行count&#x3D;3时，取消timer中的任务</span><br><span class="line">    timer.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;异步任务执行，输出f3</span><br><span class="line">Timer.run(() &#123;</span><br><span class="line">  print(&quot;f3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上就是<code>Timer</code>的全部用法，主要是任务的定时执行、任务的周期性执行及任务的异步执行。由于任务周期性执行的实现原理与任务定时执行的实现原理基本相同，所有<code>Timer</code>就主要分为定时任务的执行及异步任务的执行两中情况。</p>
<p>下面也就根据这两种情况来分析<code>Timer</code>的实现原理。</p>
<h3 id="2、Timer原理解析"><a href="#2、Timer原理解析" class="headerlink" title="2、Timer原理解析"></a>2、Timer原理解析</h3><p>由于无论那种任务类型都需要创建一个<code>Timer</code>对象，所以就先来看<code>Timer</code>对象的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class Timer &#123;</span><br><span class="line">  &#x2F;&#x2F;延迟一定时间后执行callback</span><br><span class="line">  factory Timer(Duration duration, void callback()) &#123;</span><br><span class="line">    if (Zone.current &#x3D;&#x3D; Zone.root) &#123;</span><br><span class="line">      &#x2F;&#x2F; No need to bind the callback. We know that the root&#39;s timer will</span><br><span class="line">      &#x2F;&#x2F; be invoked in the root zone.</span><br><span class="line">      return Zone.current.createTimer(duration, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    return Zone.current</span><br><span class="line">        .createTimer(duration, Zone.current.bindCallbackGuarded(callback));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建一个timer对象</span><br><span class="line">  external static Timer _createTimer(Duration duration, void callback());</span><br><span class="line">  &#x2F;&#x2F;创建一个可轮询timer对象</span><br><span class="line">  external static Timer _createPeriodicTimer(</span><br><span class="line">      Duration duration, void callback(Timer timer));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上面代码中，<code>Timer</code>构造函数中最会终调用<code>_createTimer</code>来创建一个<code>_Timer</code>对象。所以下面就来看<code>_createTimer</code>方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@patch</span><br><span class="line">class Timer &#123;</span><br><span class="line">  @patch</span><br><span class="line">  static Timer _createTimer(Duration duration, void callback()) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO(iposva): Remove _TimerFactory and use VMLibraryHooks exclusively.</span><br><span class="line">    if (_TimerFactory._factory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      _TimerFactory._factory &#x3D; VMLibraryHooks.timerFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    if (_TimerFactory._factory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new UnsupportedError(&quot;Timer interface not supported.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int milliseconds &#x3D; duration.inMilliseconds;</span><br><span class="line">    if (milliseconds &lt; 0) milliseconds &#x3D; 0;</span><br><span class="line">    return _TimerFactory._factory(milliseconds, (_) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;, false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>_createTimer</code>中，最终调用的是<code>_TimerFactory._factory</code>方法。由于在<code>Flutter</code>的第一个<code>isolate</code>初始化成功后，会调用<code>_setupHooks</code>方法将<code>_Timer._factory</code>赋给<code>_TimerFactory._factory</code>。所以<code>_createTimer</code>中最终调用了<code>_Timer._factory</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">_setupHooks() &#123;</span><br><span class="line">  VMLibraryHooks.timerFactory &#x3D; _Timer._factory;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>_Timer._factory</code>方法中，直接就是创建一个<code>_timer</code>对象，也就是在<code>Timer</code>的具体实现类是<code>_Timer</code>。下面就来看<code>_Timer</code>的具体实现代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line">class _Timer implements Timer &#123;</span><br><span class="line">  &#x2F;&#x2F;消息类型：表示需要取消event handler中已存在某个timer</span><br><span class="line">  static const _NO_TIMER &#x3D; -1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;根据发送的值来区分消息类型</span><br><span class="line">  &#x2F;&#x2F;消息类型：表示异步执行的timer</span><br><span class="line">  static const _ZERO_EVENT &#x3D; 1;</span><br><span class="line">  &#x2F;&#x2F;消息类型：表示已经超时的timer</span><br><span class="line">  static const _TIMEOUT_EVENT &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;创建一个二叉堆，该堆按照唤醒时间进行排序。</span><br><span class="line">  static final _heap &#x3D; new _TimerHeap();</span><br><span class="line">  &#x2F;&#x2F;链表中的第一个Timer</span><br><span class="line">  static _Timer _firstZeroTimer;</span><br><span class="line">  &#x2F;&#x2F;链表中的最后一个Timer</span><br><span class="line">  static _Timer _lastZeroTimer;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;使用id来对具有相同到期时间的Timer进行排序。</span><br><span class="line">  &#x2F;&#x2F;ID_MASK入队后或计时器队列为空时，将回收ID。</span><br><span class="line">  static const _ID_MASK &#x3D; 0x1fffffff;</span><br><span class="line">  static int _idCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  static RawReceivePort _receivePort;</span><br><span class="line">  static SendPort _sendPort;</span><br><span class="line">  static int _scheduledWakeupTime;</span><br><span class="line"></span><br><span class="line">  static bool _handlingCallbacks &#x3D; false;</span><br><span class="line"></span><br><span class="line">  Function _callback; &#x2F;&#x2F;timer触发的回调方法，如果timer已被取消，则为null</span><br><span class="line">  int _wakeupTime; &#x2F;&#x2F;唤醒时间</span><br><span class="line">  final int _milliSeconds; &#x2F;&#x2F;创建指定的持续时间</span><br><span class="line">  final bool _repeating; &#x2F;&#x2F;是否周期性</span><br><span class="line">  var _indexOrNext; &#x2F;&#x2F;如果Timer在_TimerHeap中，该值就是在该堆中的索引。如果是在链表中，则是当前Timer指向的下一个Timer</span><br><span class="line">  int _id; &#x2F;&#x2F;当前Timer所对应的id，如果到期时间相同，则根据此id来进行排序</span><br><span class="line"></span><br><span class="line">  int _tick &#x3D; 0; &#x2F;&#x2F; Backing for [tick],</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取下一个可用id</span><br><span class="line">  static int _nextId() &#123;</span><br><span class="line">    var result &#x3D; _idCount;</span><br><span class="line">    _idCount &#x3D; (_idCount + 1) &amp; _ID_MASK;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建一个Timer对象</span><br><span class="line">  _Timer._internal(</span><br><span class="line">      this._callback, this._wakeupTime, this._milliSeconds, this._repeating)</span><br><span class="line">      : _id &#x3D; _nextId();</span><br><span class="line"></span><br><span class="line">  static Timer _createTimer(</span><br><span class="line">      void callback(Timer timer), int milliSeconds, bool repeating) &#123;</span><br><span class="line">    &#x2F;&#x2F;milliSeconds不能小于0，小于0也就意味着超时，需要立即执行。</span><br><span class="line">    if (milliSeconds &lt; 0) &#123;</span><br><span class="line">      milliSeconds &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取当前时间</span><br><span class="line">    int now &#x3D; VMLibraryHooks.timerMillisecondClock();</span><br><span class="line">    &#x2F;&#x2F;得到Timer的唤醒时间</span><br><span class="line">    int wakeupTime &#x3D; (milliSeconds &#x3D;&#x3D; 0) ? now : (now + 1 + milliSeconds);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建一个Timer对象</span><br><span class="line">    _Timer timer &#x3D;</span><br><span class="line">        new _Timer._internal(callback, wakeupTime, milliSeconds, repeating);</span><br><span class="line">    &#x2F;&#x2F;将新创建的Timer放到适当的结构中，并在必要时进行对应的通知。</span><br><span class="line">    &#x2F;&#x2F;如果Timer中是异步任务，则加入到链表中，否则加入到二叉堆中</span><br><span class="line">    timer._enqueue();</span><br><span class="line">    return timer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;通过工厂模式来创建一个timer</span><br><span class="line">  factory _Timer(int milliSeconds, void callback(Timer timer)) &#123;</span><br><span class="line">    return _createTimer(callback, milliSeconds, false);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;通过工厂模式来创建一个周期性执行的timer</span><br><span class="line">  factory _Timer.periodic(int milliSeconds, void callback(Timer timer)) &#123;</span><br><span class="line">    return _createTimer(callback, milliSeconds, true);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;timer是否在二叉堆中</span><br><span class="line">  bool get _isInHeap &#x3D;&gt; _indexOrNext is int;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;首先根据唤醒时间来排序，如果唤醒时间相同则根据timer的_id来排序</span><br><span class="line">  int _compareTo(_Timer other) &#123;</span><br><span class="line">    int c &#x3D; _wakeupTime - other._wakeupTime;</span><br><span class="line">    if (c !&#x3D; 0) return c;</span><br><span class="line">    return _id - other._id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;判断timer是否可使用，实际上就是判断回调方法是否为null</span><br><span class="line">  bool get isActive &#x3D;&gt; _callback !&#x3D; null;</span><br><span class="line"></span><br><span class="line">  int get tick &#x3D;&gt; _tick;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;取消已经设置的timer，如果Timer存在于二叉堆中，则将其从堆中删除。否则继续保留在链表中，因为它们需要消耗相应的待处理消息。</span><br><span class="line">  void cancel() &#123;</span><br><span class="line">    _callback &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;实际上只有存在于二叉堆中的Timer被删除。链表中的Timer需要消耗其相应的唤醒消息，以便将它们留在队列中。</span><br><span class="line">    if (!_isInHeap) return;</span><br><span class="line">    bool update &#x3D; _heap.isFirst(this);</span><br><span class="line">    _heap.remove(this);</span><br><span class="line">    if (update) &#123;</span><br><span class="line">      _notifyEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;主要是重新计算下一次的唤醒时间。仅会在周期性执行的Timer中调用，</span><br><span class="line">  void _advanceWakeupTime() &#123;</span><br><span class="line">    &#x2F;&#x2F;重新计算下一次唤醒时间。 对于已经超时的Timer，当前时间就是下一个唤醒时间。</span><br><span class="line">    _id &#x3D; _nextId();</span><br><span class="line">    if (_milliSeconds &gt; 0) &#123;</span><br><span class="line">      _wakeupTime +&#x3D; _milliSeconds;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      _wakeupTime &#x3D; VMLibraryHooks.timerMillisecondClock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;将Timer添加到二叉堆或者链表中，如果唤醒时间相同则按照先进先出的规则来取出</span><br><span class="line">  void _enqueue() &#123;</span><br><span class="line">    if (_milliSeconds &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      if (_firstZeroTimer &#x3D;&#x3D; null) &#123;</span><br><span class="line">        _lastZeroTimer &#x3D; this;</span><br><span class="line">        _firstZeroTimer &#x3D; this;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        _lastZeroTimer._indexOrNext &#x3D; this;</span><br><span class="line">        _lastZeroTimer &#x3D; this;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Every zero timer gets its own event.</span><br><span class="line">      _notifyZeroHandler();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      _heap.add(this);</span><br><span class="line">      if (_heap.isFirst(this)) &#123;</span><br><span class="line">        _notifyEventHandler();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;对于包含异步任务的timer，需要发送一个消息类型为_ZERO_EVENT的消息。之所以消息类型是_ZERO_EVENT，主要是为了区分EventHandler消息（_TIMEOUT_EVENT消息）。</span><br><span class="line">  static void _notifyZeroHandler() &#123;</span><br><span class="line">    if (_sendPort &#x3D;&#x3D; null) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    _sendPort.send(_ZERO_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;从链表中获取即将执行的timer及二叉堆中到期时间小于_firstZeroTimer的timer</span><br><span class="line">  static List _queueFromZeroEvent() &#123;</span><br><span class="line">    var pendingTimers &#x3D; new List();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从二叉堆中查询到期时间小于_firstZeroTimer的timer，并加入到一个List中</span><br><span class="line">    var timer;</span><br><span class="line">    while (!_heap.isEmpty &amp;&amp; (_heap.first._compareTo(_firstZeroTimer) &lt; 0)) &#123;</span><br><span class="line">      timer &#x3D; _heap.removeFirst();</span><br><span class="line">      pendingTimers.add(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取链表中的第一个timer</span><br><span class="line">    timer &#x3D; _firstZeroTimer;</span><br><span class="line">    _firstZeroTimer &#x3D; timer._indexOrNext;</span><br><span class="line">    timer._indexOrNext &#x3D; null;</span><br><span class="line">    pendingTimers.add(timer);</span><br><span class="line">    return pendingTimers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void _notifyEventHandler() &#123;</span><br><span class="line">    if (_handlingCallbacks) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果正在进行timer的回调处理，则不继续向下执行</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果不存在即将执行的timers，则关闭receive port</span><br><span class="line">    if ((_firstZeroTimer &#x3D;&#x3D; null) &amp;&amp; _heap.isEmpty) &#123;</span><br><span class="line">      &#x2F;&#x2F;没有待处理的计时器，则关闭receive port并通知event handler。</span><br><span class="line">      if (_sendPort !&#x3D; null) &#123;</span><br><span class="line">        _cancelWakeup();</span><br><span class="line">        _shutdownTimerHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125; else if (_heap.isEmpty) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果二叉堆中不存在timer，则取消唤醒。</span><br><span class="line">      _cancelWakeup();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;仅在请求的唤醒时间与预定的唤醒时间不同时发送消息。</span><br><span class="line">    var wakeupTime &#x3D; _heap.first._wakeupTime;</span><br><span class="line">    if ((_scheduledWakeupTime &#x3D;&#x3D; null) ||</span><br><span class="line">        (wakeupTime !&#x3D; _scheduledWakeupTime)) &#123;</span><br><span class="line">      _scheduleWakeup(wakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取已经超时的timer</span><br><span class="line">  static List _queueFromTimeoutEvent() &#123;</span><br><span class="line">    var pendingTimers &#x3D; new List();</span><br><span class="line">    if (_firstZeroTimer !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;从二叉堆中获取唤醒时间小于链表中第一个timer唤醒时间的timer，并将该timer添加到pendingTimers中</span><br><span class="line">      var timer;</span><br><span class="line">      while (!_heap.isEmpty &amp;&amp; (_heap.first._compareTo(_firstZeroTimer) &lt; 0)) &#123;</span><br><span class="line">        timer &#x3D; _heap.removeFirst();</span><br><span class="line">        pendingTimers.add(timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;从二叉堆中获取已经到期的timer并添加到pendingTimers中</span><br><span class="line">      var currentTime &#x3D; VMLibraryHooks.timerMillisecondClock();</span><br><span class="line">      var timer;</span><br><span class="line">      while (!_heap.isEmpty &amp;&amp; (_heap.first._wakeupTime &lt;&#x3D; currentTime)) &#123;</span><br><span class="line">        timer &#x3D; _heap.removeFirst();</span><br><span class="line">        pendingTimers.add(timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pendingTimers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void _runTimers(List pendingTimers) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果目前没有待处理的timer，那么就有机会在新加入timer之前来重置_idCount</span><br><span class="line">    if (_heap.isEmpty &amp;&amp; (_firstZeroTimer &#x3D;&#x3D; null)) &#123;</span><br><span class="line">      _idCount &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果没有待处理的timer，则结束方法的执行</span><br><span class="line">    if (pendingTimers.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Trigger all of the pending timers. New timers added as part of the</span><br><span class="line">    &#x2F;&#x2F; callbacks will be enqueued now and notified in the next spin at the</span><br><span class="line">    &#x2F;&#x2F; earliest.</span><br><span class="line">    _handlingCallbacks &#x3D; true;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取下一个timer</span><br><span class="line">        var timer &#x3D; pendingTimers[i];</span><br><span class="line">        timer._indexOrNext &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; One of the timers in the pending_timers list can cancel</span><br><span class="line">        &#x2F;&#x2F; one of the later timers which will set the callback to</span><br><span class="line">        &#x2F;&#x2F; null. Or the pending zero timer has been canceled earlier.</span><br><span class="line">        if (timer._callback !&#x3D; null) &#123;</span><br><span class="line">          var callback &#x3D; timer._callback;</span><br><span class="line">          if (!timer._repeating) &#123;</span><br><span class="line">            &#x2F;&#x2F;将timer标记为无效</span><br><span class="line">            timer._callback &#x3D; null;</span><br><span class="line">          &#125; else if (timer._milliSeconds &gt; 0) &#123;</span><br><span class="line">            var ms &#x3D; timer._milliSeconds;</span><br><span class="line">            int overdue &#x3D;</span><br><span class="line">                VMLibraryHooks.timerMillisecondClock() - timer._wakeupTime;</span><br><span class="line">            if (overdue &gt; ms) &#123;</span><br><span class="line">              int missedTicks &#x3D; overdue ~&#x2F; ms;</span><br><span class="line">              timer._wakeupTime +&#x3D; missedTicks * ms;</span><br><span class="line">              timer._tick +&#x3D; missedTicks;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          timer._tick +&#x3D; 1;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;执行timer中注册的回调方法</span><br><span class="line">          callback(timer);</span><br><span class="line">          &#x2F;&#x2F; Re-insert repeating timer if not canceled.</span><br><span class="line">          &#x2F;&#x2F;如果timer未取消，则重新插入链表或者二叉堆中</span><br><span class="line">          if (timer._repeating &amp;&amp; (timer._callback !&#x3D; null)) &#123;</span><br><span class="line">            &#x2F;&#x2F;更新唤醒时间</span><br><span class="line">            timer._advanceWakeupTime();</span><br><span class="line">            timer._enqueue();</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;执行微任务，仅限于非RootIsolate。</span><br><span class="line">          var immediateCallback &#x3D; _removePendingImmediateCallback();</span><br><span class="line">          if (immediateCallback !&#x3D; null) &#123;</span><br><span class="line">            immediateCallback();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _handlingCallbacks &#x3D; false;</span><br><span class="line">      &#x2F;&#x2F;重新向二叉堆或者链表中插入pendingTimers中还存在的timer</span><br><span class="line">      for (i++; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        var timer &#x3D; pendingTimers[i];</span><br><span class="line">        timer._enqueue();</span><br><span class="line">      &#125;</span><br><span class="line">      _notifyEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void _handleMessage(msg) &#123;</span><br><span class="line">    var pendingTimers;</span><br><span class="line">    if (msg &#x3D;&#x3D; _ZERO_EVENT) &#123;</span><br><span class="line">      &#x2F;&#x2F;获取包含异步任务的timer</span><br><span class="line">      pendingTimers &#x3D; _queueFromZeroEvent();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      _scheduledWakeupTime &#x3D; null; &#x2F;&#x2F; Consumed the last scheduled wakeup now.</span><br><span class="line">      &#x2F;&#x2F;获取已经超时的timer</span><br><span class="line">      pendingTimers &#x3D; _queueFromTimeoutEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;执行Timer的回调方法</span><br><span class="line">    _runTimers(pendingTimers);</span><br><span class="line">    &#x2F;&#x2F;如果当前没有待执行的Timer，则通知event handler或者关闭port</span><br><span class="line">    _notifyEventHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;告诉event handler，在特定时间，当前isolated中的timer需要被唤醒</span><br><span class="line">  static void _scheduleWakeup(int wakeupTime) &#123;</span><br><span class="line">    if (_sendPort &#x3D;&#x3D; null) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    VMLibraryHooks.eventHandlerSendData(null, _sendPort, wakeupTime);</span><br><span class="line">    _scheduledWakeupTime &#x3D; wakeupTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;取消event handler中等待唤醒的timer</span><br><span class="line">  static void _cancelWakeup() &#123;</span><br><span class="line">    if (_sendPort !&#x3D; null) &#123;</span><br><span class="line">      VMLibraryHooks.eventHandlerSendData(null, _sendPort, _NO_TIMER);</span><br><span class="line">      _scheduledWakeupTime &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;创建一个receive port并注册一个message handler</span><br><span class="line">  static void _createTimerHandler() &#123;</span><br><span class="line">    assert(_sendPort &#x3D;&#x3D; null);</span><br><span class="line">    _receivePort &#x3D; new RawReceivePort(_handleMessage);</span><br><span class="line">    _sendPort &#x3D; _receivePort.sendPort;</span><br><span class="line">    _scheduledWakeupTime &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void _shutdownTimerHandler() &#123;</span><br><span class="line">    _receivePort.close();</span><br><span class="line">    _receivePort &#x3D; null;</span><br><span class="line">    _sendPort &#x3D; null;</span><br><span class="line">    _scheduledWakeupTime &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;创建_timer对象</span><br><span class="line">  static Timer _factory(</span><br><span class="line">      int milliSeconds, void callback(Timer timer), bool repeating) &#123;</span><br><span class="line">    if (repeating) &#123;</span><br><span class="line">      return new _Timer.periodic(milliSeconds, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    return new _Timer(milliSeconds, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>_Timer</code>中，根据任务类型的不同，将<code>timer</code>添加到不同的数据结构中。如果是异步任务，则会将<code>timer</code>添加到一个单链表中，根据FIFO的顺序来执行；如果是定时任务，则会将<code>timer</code>添加到<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>中并根据唤醒时间来进行排序。</p>
<p>下面就先来看异步任务执行的实现原理。</p>
<h4 id="2-1、异步任务的执行"><a href="#2-1、异步任务的执行" class="headerlink" title="2.1、异步任务的执行"></a>2.1、异步任务的执行</h4><p>根据上面代码。可以发现，包含异步任务的<code>timer</code>是将<code>timer</code>添加到以<code>Timer</code>为节点的单链表中，再通过<code>SendPort</code>来发送一个类型为<code>_ZERO_EVENT</code>的消息。</p>
<p>那么<code>SendPort</code>是如何发送消息的尼？这在<a href="https://juejin.im/post/5e149a7df265da5d3b32e167" target="_blank" rel="noopener">Isolate的创建流程</a>一文中做了详细的介绍。其发送消息就是通过<code>PostMessage</code>函数来将消息添加到<code>Isolate</code>对应的<code>MessageHandler</code>中，然后等待<code>MessageHandler</code>的处理。下面来看<code>PostMessage</code>函数的实现代码。</p>
<p>[-&gt;third_party/dart/runtime/vm/message_handler.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void MessageHandler::PostMessage(std::unique_ptr&lt;Message&gt; message,</span><br><span class="line">                                 bool before_events) &#123;</span><br><span class="line">  Message::Priority saved_priority;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MonitorLocker ml(&amp;monitor_);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    saved_priority &#x3D; message-&gt;priority();</span><br><span class="line">    if (message-&gt;IsOOB()) &#123;</span><br><span class="line">      &#x2F;&#x2F;加入到OOB类型消息的队列中</span><br><span class="line">      oob_queue_-&gt;Enqueue(std::move(message), before_events);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;加入到OOB类型消息的队列中</span><br><span class="line">      queue_-&gt;Enqueue(std::move(message), before_events);</span><br><span class="line">    &#125;</span><br><span class="line">    if (paused_for_messages_) &#123;</span><br><span class="line">      ml.Notify();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;通过task_running_来防止短时间内多次重复执行</span><br><span class="line">    if (pool_ !&#x3D; nullptr &amp;&amp; !task_running_) &#123;</span><br><span class="line">      task_running_ &#x3D; true;</span><br><span class="line">      &#x2F;&#x2F;交给线程池来异步执行（非RootIsolate）</span><br><span class="line">      const bool launched_successfully &#x3D; pool_-&gt;Run&lt;MessageHandlerTask&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;调用自定义的消息通知</span><br><span class="line">  MessageNotify(saved_priority);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由于在<code>Flutter</code>的<code>RootIsolate</code>中，<code>pool_</code>为null。所以在非<code>RootIsolate</code>中，消息是通过线程池中的子线程来执行<code>RawReceivePort</code>对象创建时设置的回调方法——<code>_handleMessage</code>。</p>
<p>再来看<code>MessageNotify</code>函数，它的实现是在其子类<code>IsolateMessageHandler</code>中。</p>
<p>[-&gt;third_party/dart/runtime/vm/isolate.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void IsolateMessageHandler::MessageNotify(Message::Priority priority) &#123;</span><br><span class="line">  if (priority &gt;&#x3D; Message::kOOBPriority) &#123;</span><br><span class="line">    &#x2F;&#x2F;即使mutator线程繁忙，也要处理优先级为OOB的消息</span><br><span class="line">    I-&gt;ScheduleInterrupts(Thread::kMessageInterrupt);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;获取Isolate的message_notify_callback_的值</span><br><span class="line">  Dart_MessageNotifyCallback callback &#x3D; I-&gt;message_notify_callback();</span><br><span class="line">  if (callback !&#x3D; nullptr) &#123;</span><br><span class="line">    &#x2F;&#x2F; Allow the embedder to handle message notification.</span><br><span class="line">    (*callback)(Api::CastIsolate(I));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一般情况下，<code>callback</code>为null，但<code>RootIsolate</code>却例外。是因为在<a href="https://juejin.im/post/5e535ca2f265da573e6723f3" target="_blank" rel="noopener">Flutter的Engine启动</a>过程中，也就是在<code>RootIsolate</code>的<code>MessageHandler</code>初始化时，会给<code>callback</code>赋值。</p>
<p>[-&gt;third_party/tonic/dart_message_handler.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void DartMessageHandler::Initialize(TaskDispatcher dispatcher) &#123;</span><br><span class="line">  &#x2F;&#x2F;仅能调用一次</span><br><span class="line">  task_dispatcher_ &#x3D; dispatcher;</span><br><span class="line">  &#x2F;&#x2F;给RootIsolate的message_notify_callback_赋值</span><br><span class="line">  Dart_SetMessageNotifyCallback(MessageNotifyCallback);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>也就是当调用<code>callback</code>时，对应的是<code>MessageNotifyCallback</code>函数的执行。</p>
<p>[-&gt;third_party/tonic/dart_message_handler.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void DartMessageHandler::OnMessage(DartState* dart_state) &#123;</span><br><span class="line">  auto task_dispatcher_ &#x3D; dart_state-&gt;message_handler().task_dispatcher_;</span><br><span class="line"></span><br><span class="line">  auto weak_dart_state &#x3D; dart_state-&gt;GetWeakPtr();</span><br><span class="line">  &#x2F;&#x2F;在Android中，任务交给UI线程中的loop来执行。</span><br><span class="line">  &#x2F;&#x2F;在iOS中，也是通过类似loop的消息处理器来执行</span><br><span class="line">  task_dispatcher_([weak_dart_state]() &#123;</span><br><span class="line">    if (auto dart_state &#x3D; weak_dart_state.lock()) &#123;</span><br><span class="line">      dart_state-&gt;message_handler().OnHandleMessage(dart_state.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DartMessageHandler::MessageNotifyCallback(Dart_Isolate dest_isolate) &#123;</span><br><span class="line">  auto dart_state &#x3D; DartState::From(dest_isolate);</span><br><span class="line">  &#x2F;&#x2F;调用OnMessage函数</span><br><span class="line">  dart_state-&gt;message_handler().OnMessage(dart_state);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过上面代码，可以发现在<code>Android</code>平台的<code>RootIsolate</code>中，消息的处理是通过UI线程中的<code>loop</code>来处理。从<code>Android</code>角度来看，就是通过<code>handler</code>来发送一个消息。</p>
<p>总而言之，<code>timer</code>中异步任务的处理主要分为以下两种情况。</p>
<ol>
<li>在非<code>RootIsolate</code>中，是通过线程池获取一个子线程来处理任务。</li>
<li>在<code>RootIsolate</code>中，如果是<code>Android</code>平台，则通过UI线程中的<code>loop</code>来处理任务。如果是iOS平台，则通过UI线程中的类似<code>loop</code>的消息处理器来处理任务。</li>
</ol>
<h4 id="2-2、定时任务的执行"><a href="#2-2、定时任务的执行" class="headerlink" title="2.2、定时任务的执行"></a>2.2、定时任务的执行</h4><p>通过对_ZERO_EVENT消息的处理来执行了<code>timer</code>中的异步任务。那么再来看定时任务的执行，该任务则是通过<code>event handler</code>来处理的。</p>
<p>在<a href="https://juejin.im/post/5e5478d651882549274a5340" target="_blank" rel="noopener">Flutter之Dart虚拟机启动</a>一文中说过，当Dart VM虚拟机启动时会创建一个名为<code>event handler</code>的子线程，并在该子线程中通过异步IO来实现任务的执行。根据平台不同，异步IO的实现方式不同。在<code>Android</code>中，是通过<code>Linux</code>的<code>epoll</code>来实现的；在<code>iOS</code>中，是通过<code>kqueue</code>来实现的。</p>
<p>把<code>timer</code>对象添加到<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>之后，会根据唤醒时间来排序，如果当前<code>timer</code>对象的唤醒时间最短，则会通知<code>event handler</code>。这里的<code>VMLibraryHooks.eventHandlerSendData</code>是在<code>Isolate</code>初始化时赋值的，它对应着<code>_EventHandler._sendData</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@patch</span><br><span class="line">class _EventHandler &#123;</span><br><span class="line">  @patch</span><br><span class="line">  static void _sendData(Object sender, SendPort sendPort, int data)</span><br><span class="line">      native &quot;EventHandler_SendData&quot;;</span><br><span class="line"></span><br><span class="line">  static int _timerMillisecondClock()</span><br><span class="line">      native &quot;EventHandler_TimerMillisecondClock&quot;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>[-&gt;third_party/dart/runtime/bin/eventhandler.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void FUNCTION_NAME(EventHandler_SendData)(Dart_NativeArguments args) &#123;</span><br><span class="line">  &#x2F;&#x2F; Get the id out of the send port. If the handle is not a send port</span><br><span class="line">  &#x2F;&#x2F; we will get an error and propagate that out.</span><br><span class="line">  Dart_Handle handle &#x3D; Dart_GetNativeArgument(args, 1);</span><br><span class="line">  Dart_Port dart_port;</span><br><span class="line">  &#x2F;&#x2F;拿到SendPort</span><br><span class="line">  handle &#x3D; Dart_SendPortGetId(handle, &amp;dart_port);</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  Dart_Handle sender &#x3D; Dart_GetNativeArgument(args, 0);</span><br><span class="line">  intptr_t id;</span><br><span class="line">  if (Dart_IsNull(sender)) &#123;</span><br><span class="line">    id &#x3D; kTimerId;</span><br><span class="line">  &#125; else &#123;...&#125;</span><br><span class="line">  &#x2F;&#x2F;拿到唤醒时间</span><br><span class="line">  int64_t data &#x3D; DartUtils::GetIntegerValue(Dart_GetNativeArgument(args, 2));</span><br><span class="line">  &#x2F;&#x2F;发送消息</span><br><span class="line">  event_handler-&gt;SendData(id, dart_port, data);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由于<code>event_handler</code>在不同系统有不同实现，所以这里以Android为例。</p>
<p>[-&gt;third_party/dart/runtime/bin/eventhandler_android.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送数据</span><br><span class="line">void EventHandlerImplementation::SendData(intptr_t id,</span><br><span class="line">                                          Dart_Port dart_port,</span><br><span class="line">                                          int64_t data) &#123;</span><br><span class="line">  WakeupHandler(id, dart_port, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventHandlerImplementation::WakeupHandler(intptr_t id,</span><br><span class="line">                                               Dart_Port dart_port,</span><br><span class="line">                                               int64_t data) &#123;</span><br><span class="line">  InterruptMessage msg;</span><br><span class="line">  &#x2F;&#x2F;消息id</span><br><span class="line">  msg.id &#x3D; id;</span><br><span class="line">  &#x2F;&#x2F;传递的dart_port</span><br><span class="line">  msg.dart_port &#x3D; dart_port;</span><br><span class="line">  &#x2F;&#x2F;消息需要传递的数据，在当前传递的是任务的唤醒时间</span><br><span class="line">  msg.data &#x3D; data;</span><br><span class="line">  &#x2F;&#x2F; WriteToBlocking will write up to 512 bytes atomically, and since our msg</span><br><span class="line">  &#x2F;&#x2F; is smaller than 512, we don&#39;t need a thread lock.</span><br><span class="line">  &#x2F;&#x2F; See: http:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;7&#x2F;pipe, section &#39;Pipe_buf&#39;.</span><br><span class="line">  ASSERT(kInterruptMessageSize &lt; PIPE_BUF);</span><br><span class="line">  &#x2F;&#x2F;消息写入</span><br><span class="line">  intptr_t result &#x3D;</span><br><span class="line">      FDUtils::WriteToBlocking(interrupt_fds_[1], &amp;msg, kInterruptMessageSize);</span><br><span class="line">  if (result !&#x3D; kInterruptMessageSize) &#123;</span><br><span class="line">    if (result &#x3D;&#x3D; -1) &#123;</span><br><span class="line">      perror(&quot;Interrupt message failure:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    FATAL1(&quot;Interrupt message failure. Wrote %&quot; Pd &quot; bytes.&quot;, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理拿到的事件</span><br><span class="line">void EventHandlerImplementation::HandleEvents(struct epoll_event* events,</span><br><span class="line">                                              int size) &#123;</span><br><span class="line">  bool interrupt_seen &#x3D; false;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">    if (events[i].data.ptr &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">      interrupt_seen &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      DescriptorInfo* di &#x3D;</span><br><span class="line">          reinterpret_cast&lt;DescriptorInfo*&gt;(events[i].data.ptr);</span><br><span class="line">      const intptr_t old_mask &#x3D; di-&gt;Mask();</span><br><span class="line">      const intptr_t event_mask &#x3D; GetPollEvents(events[i].events, di);</span><br><span class="line">      if ((event_mask &amp; (1 &lt;&lt; kErrorEvent)) !&#x3D; 0) &#123;</span><br><span class="line">        di-&gt;NotifyAllDartPorts(event_mask);</span><br><span class="line">        UpdateEpollInstance(old_mask, di);</span><br><span class="line">      &#125; else if (event_mask !&#x3D; 0) &#123;</span><br><span class="line">        Dart_Port port &#x3D; di-&gt;NextNotifyDartPort(event_mask);</span><br><span class="line">        UpdateEpollInstance(old_mask, di);</span><br><span class="line">        &#x2F;&#x2F;通过消息的dart_port来调用注册的回调方法</span><br><span class="line">        DartUtils::PostInt32(port, event_mask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (interrupt_seen) &#123;</span><br><span class="line">    &#x2F;&#x2F; Handle after socket events, so we avoid closing a socket before we handle</span><br><span class="line">    &#x2F;&#x2F; the current events.</span><br><span class="line">    HandleInterruptFd();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过<code>epoll</code>就能在指定的时间来处理事件，然后通过<code>dart_port</code>来找到对应的<code>MessageHandler</code>并处理。</p>
<p>[-&gt;third_party/dart/runtime/bin/dartutils.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool DartUtils::PostInt32(Dart_Port port_id, int32_t value) &#123;</span><br><span class="line">  &#x2F;&#x2F; Post a message with the integer value.</span><br><span class="line">  int32_t min &#x3D; 0xc0000000;  &#x2F;&#x2F; -1073741824</span><br><span class="line">  int32_t max &#x3D; 0x3fffffff;  &#x2F;&#x2F; 1073741823</span><br><span class="line">  ASSERT(min &lt;&#x3D; value &amp;&amp; value &lt; max);</span><br><span class="line">  Dart_CObject object;</span><br><span class="line">  object.type &#x3D; Dart_CObject_kInt32;</span><br><span class="line">  object.value.as_int32 &#x3D; value;</span><br><span class="line">  return Dart_PostCObject(port_id, &amp;object);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>[-&gt;third_party/dart/runtime/vm/native_api_impl.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DART_EXPORT bool Dart_PostCObject(Dart_Port port_id, Dart_CObject* message) &#123;</span><br><span class="line">  return PostCObjectHelper(port_id, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static bool PostCObjectHelper(Dart_Port port_id, Dart_CObject* message) &#123;</span><br><span class="line">  ApiMessageWriter writer;</span><br><span class="line">  std::unique_ptr&lt;Message&gt; msg &#x3D;</span><br><span class="line">      writer.WriteCMessage(message, port_id, Message::kNormalPriority);</span><br><span class="line"></span><br><span class="line">  if (msg &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Post the message at the given port.</span><br><span class="line">  return PortMap::PostMessage(std::move(msg));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最终也就跟_ZERO_EVENT消息的处理流程一样，在当前<code>isolate</code>的<code>MessageHandler</code>中调用创建<code>RawReceivePort</code>对象时设置的回调方法——<code>_handleMessage</code>。</p>
<h4 id="2-3、回调方法的执行"><a href="#2-3、回调方法的执行" class="headerlink" title="2.3、回调方法的执行"></a>2.3、回调方法的执行</h4><p>无论是异步任务，还是需要延时执行的任务，最终执行的回调方法都是<code>_handleMessage</code>。在该回调方法中，会根据消息类型来进行不同的区分，如果消息类型是<code>_ZERO_EVENT</code>，则会从<code>_queueFromZeroEvent</code>取出对应的<code>Timer</code>对象并执行其回调方法；否则就从<code>_queueFromTimeoutEvent</code>中取出对应<code>timer</code>对象并执行其回调方法。</p>
<p>先来看<code>_queueFromZeroEvent</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  static List _queueFromZeroEvent() &#123;</span><br><span class="line">    var pendingTimers &#x3D; new List();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从二叉堆中查询到期时间小于_firstZeroTimer的timer，并加入到一个List中</span><br><span class="line">    var timer;</span><br><span class="line">    while (!_heap.isEmpty &amp;&amp; (_heap.first._compareTo(_firstZeroTimer) &lt; 0)) &#123;</span><br><span class="line">      timer &#x3D; _heap.removeFirst();</span><br><span class="line">      pendingTimers.add(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取链表中的第一个timer</span><br><span class="line">    timer &#x3D; _firstZeroTimer;</span><br><span class="line">    _firstZeroTimer &#x3D; timer._indexOrNext;</span><br><span class="line">    timer._indexOrNext &#x3D; null;</span><br><span class="line">    pendingTimers.add(timer);</span><br><span class="line">    return pendingTimers;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在该方法中，会将<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>中唤醒时间比链表中的第一个<code>timer</code>对象唤醒时间还短的<code>timer</code>对象加入到集合<code>pendingTimers</code>中，然后再将链表中的第一个<code>timer</code>对象加入到集合<code>pendingTimers</code>中。</p>
<p>再来看<code>_queueFromTimeoutEvent</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  static List _queueFromTimeoutEvent() &#123;</span><br><span class="line">    var pendingTimers &#x3D; new List();</span><br><span class="line">    if (_firstZeroTimer !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F;从二叉堆中获取唤醒时间小于链表中第一个timer唤醒时间的timer，并将该timer添加到pendingTimers中</span><br><span class="line">      var timer;</span><br><span class="line">      while (!_heap.isEmpty &amp;&amp; (_heap.first._compareTo(_firstZeroTimer) &lt; 0)) &#123;</span><br><span class="line">        timer &#x3D; _heap.removeFirst();</span><br><span class="line">        pendingTimers.add(timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;从二叉堆中获取已经到期的timer并添加到pendingTimers中</span><br><span class="line">      var currentTime &#x3D; VMLibraryHooks.timerMillisecondClock();</span><br><span class="line">      var timer;</span><br><span class="line">      while (!_heap.isEmpty &amp;&amp; (_heap.first._wakeupTime &lt;&#x3D; currentTime)) &#123;</span><br><span class="line">        timer &#x3D; _heap.removeFirst();</span><br><span class="line">        pendingTimers.add(timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pendingTimers;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在该方法中，也会将<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>中唤醒时间比链表中的第一个<code>timer</code>对象唤醒时间还短的<code>timer</code>对象加入到集合<code>pendingTimers</code>中。如果此时链表的第一个<code>timer</code>对象为空，则会将<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>中<code>Timer</code>对象的唤醒时间与当前时间进行对比，如果唤醒时间小于当前当前时间，则将<code>timer</code>添加到集合<code>pendingTimers</code>中。</p>
<p>经过<code>_queueFromZeroEvent</code>与<code>_queueFromTimeoutEvent</code>两个方法，就获取到了所有待执行的<code>timer</code>对象。然后调用<code>_runTimers</code>方法来执行所有待执行的<code>timer</code>对象。待<code>_runTimers</code>方法执行完毕后，还会调用<code>_notifyEventHandler</code>来通知<code>event handler</code>或者关闭<code>port</code>。</p>
<p>再来看<code>_runTimers</code>方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  static void _runTimers(List pendingTimers) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果目前没有待处理的timer，那么就有机会在新加入timer之前来重置_idCount</span><br><span class="line">    if (_heap.isEmpty &amp;&amp; (_firstZeroTimer &#x3D;&#x3D; null)) &#123;</span><br><span class="line">      _idCount &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果没有待处理的timer，则结束方法的执行</span><br><span class="line">    if (pendingTimers.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Trigger all of the pending timers. New timers added as part of the</span><br><span class="line">    &#x2F;&#x2F; callbacks will be enqueued now and notified in the next spin at the</span><br><span class="line">    &#x2F;&#x2F; earliest.</span><br><span class="line">    _handlingCallbacks &#x3D; true;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取下一个timer</span><br><span class="line">        var timer &#x3D; pendingTimers[i];</span><br><span class="line">        timer._indexOrNext &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; One of the timers in the pending_timers list can cancel</span><br><span class="line">        &#x2F;&#x2F; one of the later timers which will set the callback to</span><br><span class="line">        &#x2F;&#x2F; null. Or the pending zero timer has been canceled earlier.</span><br><span class="line">        if (timer._callback !&#x3D; null) &#123;</span><br><span class="line">          var callback &#x3D; timer._callback;</span><br><span class="line">          if (!timer._repeating) &#123;</span><br><span class="line">            &#x2F;&#x2F;将timer标记为无效</span><br><span class="line">            timer._callback &#x3D; null;</span><br><span class="line">          &#125; else if (timer._milliSeconds &gt; 0) &#123;</span><br><span class="line">            var ms &#x3D; timer._milliSeconds;</span><br><span class="line">            int overdue &#x3D;</span><br><span class="line">                VMLibraryHooks.timerMillisecondClock() - timer._wakeupTime;</span><br><span class="line">            if (overdue &gt; ms) &#123;</span><br><span class="line">              int missedTicks &#x3D; overdue ~&#x2F; ms;</span><br><span class="line">              timer._wakeupTime +&#x3D; missedTicks * ms;</span><br><span class="line">              timer._tick +&#x3D; missedTicks;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          timer._tick +&#x3D; 1;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;执行timer中注册的回调方法</span><br><span class="line">          callback(timer);</span><br><span class="line">          &#x2F;&#x2F; Re-insert repeating timer if not canceled.</span><br><span class="line">          &#x2F;&#x2F;如果timer未取消，则重新插入链表或者二叉堆中</span><br><span class="line">          if (timer._repeating &amp;&amp; (timer._callback !&#x3D; null)) &#123;</span><br><span class="line">            &#x2F;&#x2F;更新唤醒时间</span><br><span class="line">            timer._advanceWakeupTime();</span><br><span class="line">            timer._enqueue();</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;执行微任务，仅限于非RootIsolate。</span><br><span class="line">          var immediateCallback &#x3D; _removePendingImmediateCallback();</span><br><span class="line">          if (immediateCallback !&#x3D; null) &#123;</span><br><span class="line">            immediateCallback();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _handlingCallbacks &#x3D; false;</span><br><span class="line">      &#x2F;&#x2F;重新向二叉堆或者链表中插入pendingTimers中还存在的timer</span><br><span class="line">      for (i++; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        var timer &#x3D; pendingTimers[i];</span><br><span class="line">        timer._enqueue();</span><br><span class="line">      &#125;</span><br><span class="line">      _notifyEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上面代码中，主要就是遍历<code>pendingTimers</code>中的<code>Timer</code>对象，获取<code>Timer</code>中的任务<code>callback</code>并执行，在上面示例中，就是输出f1、f2及f3。如果是周期性任务，则会在<code>callback</code>执行完毕后更新唤醒时间并重新添加到链表或<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>中。如果在非<code>RootIsolate</code>中，还会执行微任务。如果最终<code>pendingTimers</code>中还存在未遍历的<code>Timer</code>，则将这些<code>Timer</code>添加到链表或<a href="https://zh.wikipedia.org/wiki/二叉堆" target="_blank" rel="noopener">二叉堆</a>中并通知<code>event handler</code>。</p>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>经过上面的分析，全面了解了<code>Timer</code>的使用及其实现原理。它的使用很简单，实现原理也分为以下几点。</p>
<ol>
<li>如果是异步任务，则通过<code>isolate</code>中的<code>MessageHandler</code>来处理。使用方式是调用<code>Timer</code>的<code>run</code>方法。</li>
<li>如果是定时任务或周期性任务，则通过<code>event handler</code>来处理并通过<code>isolate</code>中的<code>MessageHandler</code>来执行任务。使用方式是通过工厂模式创建<code>Timer</code>或者调用<code>Timer</code>的<code>periodic</code>方法。</li>
<li>如果在非<code>RootIsolate</code>中，<code>Timer</code>的任务执行完毕后都会执行微任务。</li>
</ol>
<p>由于<code>Future</code>的异步机制是通过<code>Timer</code>来实现的，所以了解了<code>Timer</code>的实现原理，也就知道了<code>Future</code>的异步部分的实现原理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Fluter%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%BE%AE%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Fluter%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%BE%AE%E4%BB%BB%E5%8A%A1/" itemprop="url">Fluter消息机制之微任务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-29T17:13:29+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Fluter%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%BE%AE%E4%BB%BB%E5%8A%A1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/29/flutter/%E6%9C%AA%E6%9B%BE%E7%90%86%E8%A7%A3/Fluter%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%BE%AE%E4%BB%BB%E5%8A%A1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Fluter消息机制之微任务"><a href="#Fluter消息机制之微任务" class="headerlink" title="Fluter消息机制之微任务"></a>Fluter消息机制之微任务</h1><p>在<code>Flutter</code>中，异步任务主要是通过<code>Timer</code>及微任务来实现。在<a href="https://juejin.im/post/5ee19d11518825433b134766" target="_blank" rel="noopener">Flutter之Timer原理解析</a>一文中，讲述了通过<code>Timer</code>来实现异步任务的原理，那么本文就来看异步任务的另一种实现，微任务的使用及其实现原理。</p>
<h3 id="1、微任务的使用"><a href="#1、微任务的使用" class="headerlink" title="1、微任务的使用"></a>1、微任务的使用</h3><p>先来看微任务的使用，代码很简单，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用法一</span><br><span class="line">Future.microtask(() &#123;</span><br><span class="line">  print(&quot;microtask1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;用法二</span><br><span class="line">scheduleMicrotask(() &#123;</span><br><span class="line">  print(&quot;microtask2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;用法三</span><br><span class="line">Zone.current.scheduleMicrotask(()&#123;</span><br><span class="line">  print(&quot;microtask3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;用法四</span><br><span class="line">Zone.root.scheduleMicrotask(()&#123;</span><br><span class="line">  print(&quot;microtask4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上就是微任务的所有用法。基本上都是前两种使用方式比较多，但前面两种用法仅是对后面两种用法的封装而已。下面就来看微任务的实现原理，不过在分析微任务的实现原理之前需要先了解一下UI线程是如何创建的。</p>
<h3 id="2、UI线程的创建"><a href="#2、UI线程的创建" class="headerlink" title="2、UI线程的创建"></a>2、UI线程的创建</h3><p>在<a href="https://juejin.im/post/5e535ca2f265da573e6723f3" target="_blank" rel="noopener">Flutter之Engine启动流程</a>一文中，提过在<code>Engine</code>创建过程中会创建UI线程、IO线程及GPU线程，但未深入。所以这里就以Android平台为例来深入的来了解<code>Flutter</code>中UI线程是如何创建的（IO线程、GPU线程与UI线程都是同一类型的对象，但命名不同）。</p>
<p>[-&gt; flutter/shell/platform/android/android_shell_holder.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AndroidShellHolder::AndroidShellHolder(</span><br><span class="line">    flutter::Settings settings,</span><br><span class="line">    fml::jni::JavaObjectWeakGlobalRef java_object,</span><br><span class="line">    bool is_background_view)</span><br><span class="line">    : settings_(std::move(settings)), java_object_(java_object) &#123;</span><br><span class="line">  static size_t shell_count &#x3D; 1;</span><br><span class="line">  auto thread_label &#x3D; std::to_string(shell_count++);</span><br><span class="line">            </span><br><span class="line">  &#x2F;&#x2F;创建目标线程</span><br><span class="line">  if (is_background_view) &#123;</span><br><span class="line">    &#x2F;&#x2F;仅创建UI线程</span><br><span class="line">    thread_host_ &#x3D; &#123;thread_label, ThreadHost::Type::UI&#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;创建UI线程、GPU线程及IO线程</span><br><span class="line">    thread_host_ &#x3D; &#123;thread_label, ThreadHost::Type::UI | ThreadHost::Type::GPU |</span><br><span class="line">                                      ThreadHost::Type::IO&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里的<code>thread_host_</code>是一个结构体，所以直接来看该结构体中的具体实现。</p>
<p>[-&gt; flutter/shell/common/thread_host.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;flutter&#x2F;shell&#x2F;common&#x2F;thread_host.h&quot;</span><br><span class="line"></span><br><span class="line">namespace flutter &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ThreadHost::ThreadHost(std::string name_prefix, uint64_t mask) &#123;</span><br><span class="line">  if (mask &amp; ThreadHost::Type::Platform) &#123;</span><br><span class="line">    &#x2F;&#x2F;Platform线程的创建，在Android中，由于Platform线程是Android中的主线程，所以名称为xxxx.platform的platform_thread不会创建</span><br><span class="line">    platform_thread &#x3D; std::make_unique&lt;fml::Thread&gt;(name_prefix + &quot;.platform&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (mask &amp; ThreadHost::Type::UI) &#123;</span><br><span class="line">    &#x2F;&#x2F;ui线程的创建</span><br><span class="line">    ui_thread &#x3D; std::make_unique&lt;fml::Thread&gt;(name_prefix + &quot;.ui&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (mask &amp; ThreadHost::Type::GPU) &#123;</span><br><span class="line">    &#x2F;&#x2F;gpu线程的创建</span><br><span class="line">    gpu_thread &#x3D; std::make_unique&lt;fml::Thread&gt;(name_prefix + &quot;.gpu&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (mask &amp; ThreadHost::Type::IO) &#123;</span><br><span class="line">    &#x2F;&#x2F;io线程的创建</span><br><span class="line">    io_thread &#x3D; std::make_unique&lt;fml::Thread&gt;(name_prefix + &quot;.io&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从上面就可以看出ui线程、io线程及GPU线程是同一类型的对象，但命名不同。那么再来看UI线程的具体实现。</p>
<p>[-&gt; flutter/fml/thread.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread(const std::string&amp; name) : joined_(false) &#123;</span><br><span class="line">  fml::AutoResetWaitableEvent latch;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; runner;</span><br><span class="line">  &#x2F;&#x2F;创建一个thread对象</span><br><span class="line">  thread_ &#x3D; std::make_unique&lt;std::thread&gt;([&amp;latch, &amp;runner, name]() -&gt; void &#123;</span><br><span class="line">    &#x2F;&#x2F;设置当前线程名称，由于这里是UI线程的创建，所以name是xxx.ui</span><br><span class="line">    SetCurrentThreadName(name);</span><br><span class="line">    &#x2F;&#x2F;创建一个MessageLoop对象</span><br><span class="line">    fml::MessageLoop::EnsureInitializedForCurrentThread();</span><br><span class="line">    &#x2F;&#x2F;获取MessageLoop对应的loop</span><br><span class="line">    auto&amp; loop &#x3D; MessageLoop::GetCurrent();</span><br><span class="line">    runner &#x3D; loop.GetTaskRunner();</span><br><span class="line">    &#x2F;&#x2F;唤醒</span><br><span class="line">    latch.Signal();</span><br><span class="line">    &#x2F;&#x2F;运行loop</span><br><span class="line">    loop.Run();</span><br><span class="line">  &#125;);</span><br><span class="line">  &#x2F;&#x2F;等待</span><br><span class="line">  latch.Wait();</span><br><span class="line">  task_runner_ &#x3D; runner;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>Thread</code>的构造函数中，会创建一个新线程。在该线程创建成功后，会给线程设置名称，如xxxxx.ui、xxxxx.gpu、xxxxx.io等。还会给该线程设置一个<code>MessageLoop</code>对象，最后再来执行<code>MessageLoop</code>的<code>run</code>函数，即使<code>MessageLoop</code>跑起来。</p>
<p>这里重点来看<code>MessageLoop</code>对象的创建，它的实现如下。</p>
<p>[-&gt; flutter/fml/message_loop.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;tls_message_loop类似Java中的ThreadLocal，用来保证MessageLoop仅属于某个线程，其他线程不可访问该MessageLoop</span><br><span class="line">FML_THREAD_LOCAL ThreadLocalUniquePtr&lt;MessageLoop&gt; tls_message_loop;</span><br><span class="line"></span><br><span class="line">void MessageLoop::EnsureInitializedForCurrentThread() &#123;</span><br><span class="line">  &#x2F;&#x2F;保证每个进行仅有一个MessageLoop对象</span><br><span class="line">  if (tls_message_loop.get() !&#x3D; nullptr) &#123;</span><br><span class="line">    &#x2F;&#x2F; Already initialized.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  tls_message_loop.reset(new MessageLoop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建MessageLoop对象</span><br><span class="line">MessageLoop::MessageLoop()</span><br><span class="line">      &#x2F;&#x2F;MessageLoopImpl对象的创建</span><br><span class="line">    : loop_(MessageLoopImpl::Create()),</span><br><span class="line">      &#x2F;&#x2F;TaskRunner对象的创建</span><br><span class="line">      task_runner_(fml::MakeRefCounted&lt;fml::TaskRunner&gt;(loop_)) &#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里重点在<code>loop_</code>。它是一个<code>MessageLoopImpl</code>对象，由于各个平台不同，所以<code>MessageLoopImpl</code>的具体实现也不一样。这里以Android为例，当调用<code>create</code>方法时会创建一个继承自<code>MessageLoopImpl</code>的<code>MessageLoopAndroid</code>对象。</p>
<p>[-&gt; flutter/fml/platform/android/message_loop_android.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">static constexpr int kClockType &#x3D; CLOCK_MONOTONIC;</span><br><span class="line"></span><br><span class="line">static ALooper* AcquireLooperForThread() &#123;</span><br><span class="line">  ALooper* looper &#x3D; ALooper_forThread();</span><br><span class="line"></span><br><span class="line">  if (looper &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果当前线程不存在looper，则创建一个新的looper</span><br><span class="line">    looper &#x3D; ALooper_prepare(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;如果当前线程存在looper，则获取其引用并返回</span><br><span class="line">  ALooper_acquire(looper);</span><br><span class="line">  return looper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">MessageLoopAndroid::MessageLoopAndroid()</span><br><span class="line">      &#x2F;&#x2F;创建一个looper对象</span><br><span class="line">    : looper_(AcquireLooperForThread()),</span><br><span class="line">      timer_fd_(::timerfd_create(kClockType, TFD_NONBLOCK | TFD_CLOEXEC)),</span><br><span class="line">      running_(false) &#123;</span><br><span class="line"></span><br><span class="line">  static const int kWakeEvents &#x3D; ALOOPER_EVENT_INPUT;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;执行回调方法</span><br><span class="line">  ALooper_callbackFunc read_event_fd &#x3D; [](int, int events, void* data) -&gt; int &#123;</span><br><span class="line">    if (events &amp; kWakeEvents) &#123;</span><br><span class="line">      reinterpret_cast&lt;MessageLoopAndroid*&gt;(data)-&gt;OnEventFired();</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;  &#x2F;&#x2F; continue receiving callbacks</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  int add_result &#x3D; ::ALooper_addFd(looper_.get(),          &#x2F;&#x2F; looper</span><br><span class="line">                                   timer_fd_.get(),        &#x2F;&#x2F; fd</span><br><span class="line">                                   ALOOPER_POLL_CALLBACK,  &#x2F;&#x2F; ident</span><br><span class="line">                                   kWakeEvents,            &#x2F;&#x2F; events</span><br><span class="line">                                   read_event_fd,          &#x2F;&#x2F; callback</span><br><span class="line">                                   this                    &#x2F;&#x2F; baton</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageLoopAndroid::~MessageLoopAndroid() &#123;</span><br><span class="line">  int remove_result &#x3D; ::ALooper_removeFd(looper_.get(), timer_fd_.get());</span><br><span class="line">  FML_CHECK(remove_result &#x3D;&#x3D; 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;looper的运行</span><br><span class="line">void MessageLoopAndroid::Run() &#123;</span><br><span class="line">  FML_DCHECK(looper_.get() &#x3D;&#x3D; ALooper_forThread());</span><br><span class="line"></span><br><span class="line">  running_ &#x3D; true;</span><br><span class="line"></span><br><span class="line">  while (running_) &#123;</span><br><span class="line">    &#x2F;&#x2F;等待事件执行</span><br><span class="line">    int result &#x3D; ::ALooper_pollOnce(-1,       &#x2F;&#x2F; infinite timeout</span><br><span class="line">                                    nullptr,  &#x2F;&#x2F; out fd,</span><br><span class="line">                                    nullptr,  &#x2F;&#x2F; out events,</span><br><span class="line">                                    nullptr   &#x2F;&#x2F; out data</span><br><span class="line">    );</span><br><span class="line">    if (result &#x3D;&#x3D; ALOOPER_POLL_TIMEOUT || result &#x3D;&#x3D; ALOOPER_POLL_ERROR) &#123;</span><br><span class="line">      &#x2F;&#x2F; This handles the case where the loop is terminated using ALooper APIs.</span><br><span class="line">      running_ &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;终止事件执行</span><br><span class="line">void MessageLoopAndroid::Terminate() &#123;</span><br><span class="line">  running_ &#x3D; false;</span><br><span class="line">  ALooper_wake(looper_.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;唤醒事件的执行</span><br><span class="line">void MessageLoopAndroid::WakeUp(fml::TimePoint time_point) &#123;</span><br><span class="line">  bool result &#x3D; TimerRearm(timer_fd_.get(), time_point);</span><br><span class="line">  FML_DCHECK(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听Loop的回调函数</span><br><span class="line">void MessageLoopAndroid::OnEventFired() &#123;</span><br><span class="line">  if (TimerDrain(timer_fd_.get())) &#123;</span><br><span class="line">    RunExpiredTasksNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码其实就是通过<code>ALooper</code>来实现一个异步IO。在Android中，<code>ALooper</code>可以认为是一个对<code>Looper</code>的包装，也就是通过<code>ALooper</code>来操作<code>Looper</code>。</p>
<p><strong>注意</strong>：这里所说的<code>ALooper</code>来操作<code>Looper</code>指的是Native层中的<code>Looper</code>，而不是framework层的<code>Looper</code>。</p>
<p>当<code>MessageLoopAndroid</code>对象创建成功后，再调用该对象的<code>run</code>函数使UI线程中的任务处理跑起来。这时候UI线程就成功创建完毕并做了相应的初始化。</p>
<p>以上就是在<code>Android</code>平台中UI线程的创建，而在其他平台，UI线程的创建也与Android平台类似，唯一的不同之处就在于异步IO的实现。比如在iOS中，异步IO是采用<code>CFRunLoop</code>来实现的。</p>
<h3 id="3、微任务实现原理"><a href="#3、微任务实现原理" class="headerlink" title="3、微任务实现原理"></a>3、微任务实现原理</h3><p>再回到微任务的实现中。以<code>scheduleMicrotask</code>方法为例，来看其代码实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void scheduleMicrotask(void callback()) &#123;</span><br><span class="line">  _Zone currentZone &#x3D; Zone.current;</span><br><span class="line">  &#x2F;&#x2F;当前Zone与_rootZone是否是同一个Zone对象。</span><br><span class="line">  if (identical(_rootZone, currentZone)) &#123;</span><br><span class="line">    &#x2F;&#x2F; No need to bind the callback. We know that the root&#39;s scheduleMicrotask</span><br><span class="line">    &#x2F;&#x2F; will be invoked in the root zone.</span><br><span class="line">    _rootScheduleMicrotask(null, null, _rootZone, callback);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>基本上自定义<code>Zone</code>都不会来自定义<code>scheduleMicrotask</code>方法的实现，所以自定义<code>Zone</code>的<code>scheduleMicrotask</code>方法最终都是调用<code>_rootScheduleMicrotask</code>方法。下面就来看该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void _rootScheduleMicrotask(</span><br><span class="line">    Zone self, ZoneDelegate parent, Zone zone, void f()) &#123;</span><br><span class="line">  ...</span><br><span class="line">  _scheduleAsyncCallback(f);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码很简单，就是调用<code>_scheduleAsyncCallback</code>方法，再来看该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;节点为_AsyncCallbackEntry对象的单链表的头节点</span><br><span class="line">_AsyncCallbackEntry _nextCallback;</span><br><span class="line">&#x2F;&#x2F;节点为_AsyncCallbackEntry对象的单链表的尾节点</span><br><span class="line">_AsyncCallbackEntry _lastCallback;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;优先级回调方法放在链表的头部，如果存在多个，则按照添加顺序排列</span><br><span class="line">_AsyncCallbackEntry _lastPriorityCallback;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前是否在执行回调方法</span><br><span class="line">bool _isInCallbackLoop &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历链表并执行相应的回调方法</span><br><span class="line">void _microtaskLoop() &#123;</span><br><span class="line">  while (_nextCallback !&#x3D; null) &#123;</span><br><span class="line">    _lastPriorityCallback &#x3D; null;</span><br><span class="line">    _AsyncCallbackEntry entry &#x3D; _nextCallback;</span><br><span class="line">    _nextCallback &#x3D; entry.next;</span><br><span class="line">    if (_nextCallback &#x3D;&#x3D; null) _lastCallback &#x3D; null;</span><br><span class="line">    (entry.callback)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开始执行回调方法</span><br><span class="line">void _startMicrotaskLoop() &#123;</span><br><span class="line">  _isInCallbackLoop &#x3D; true;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; Moved to separate function because try-finally prevents</span><br><span class="line">    &#x2F;&#x2F; good optimization.</span><br><span class="line">    _microtaskLoop();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    _lastPriorityCallback &#x3D; null;</span><br><span class="line">    _isInCallbackLoop &#x3D; false;</span><br><span class="line">    if (_nextCallback !&#x3D; null) &#123;</span><br><span class="line">      _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将回调方法添加到链表中</span><br><span class="line">void _scheduleAsyncCallback(_AsyncCallback callback) &#123;</span><br><span class="line">  _AsyncCallbackEntry newEntry &#x3D; new _AsyncCallbackEntry(callback);</span><br><span class="line">  if (_nextCallback &#x3D;&#x3D; null) &#123;</span><br><span class="line">    _nextCallback &#x3D; _lastCallback &#x3D; newEntry;</span><br><span class="line">    &#x2F;&#x2F;如果当前还未处理回调方法</span><br><span class="line">    if (!_isInCallbackLoop) &#123;</span><br><span class="line">      _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    _lastCallback.next &#x3D; newEntry;</span><br><span class="line">    _lastCallback &#x3D; newEntry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _schedulePriorityAsyncCallback(_AsyncCallback callback) &#123;</span><br><span class="line">  if (_nextCallback &#x3D;&#x3D; null) &#123;</span><br><span class="line">    _scheduleAsyncCallback(callback);</span><br><span class="line">    _lastPriorityCallback &#x3D; _lastCallback;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  _AsyncCallbackEntry entry &#x3D; new _AsyncCallbackEntry(callback);</span><br><span class="line">  if (_lastPriorityCallback &#x3D;&#x3D; null) &#123;</span><br><span class="line">    entry.next &#x3D; _nextCallback;</span><br><span class="line">    _nextCallback &#x3D; _lastPriorityCallback &#x3D; entry;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    entry.next &#x3D; _lastPriorityCallback.next;</span><br><span class="line">    _lastPriorityCallback.next &#x3D; entry;</span><br><span class="line">    _lastPriorityCallback &#x3D; entry;</span><br><span class="line">    if (entry.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">      _lastCallback &#x3D; entry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码很简单，在<code>_scheduleAsyncCallback</code>方法中，就是将要执行的微任务包装成一个<code>_AsyncCallbackEntry</code>对象，并将该对象添加到链表中，也就是所有微任务都是链表中的一个节点，当遍历该链表并执行节点中的回调方法即是微任务的执行。</p>
<p>这里要注意一下<code>_schedulePriorityAsyncCallback</code>方法，它也是将微任务包装成一个<code>_AsyncCallbackEntry</code>对象并添加到链表中。但这里的微任务优先级高，是直接将微任务添加到链表的头部。目前仅有当前<code>Zone</code>对象的<code>handleUncaughtError</code>方法中才会调用<code>_schedulePriorityAsyncCallback</code>，也就是捕获错误的优先级比普通微任务的优先级都要高。</p>
<p>链表创建成功后，就需要能够在合适的时机来遍历该链表，这时候就来看<code>_scheduleImmediate</code>方法的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class _AsyncRun &#123;</span><br><span class="line">  &#x2F;&#x2F;这里的callback对应的就是_startMicrotaskLoop方法</span><br><span class="line">  external static void _scheduleImmediate(void callback());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="3-1、微任务集合"><a href="#3-1、微任务集合" class="headerlink" title="3.1、微任务集合"></a>3.1、微任务集合</h4><p>来看<code>_scheduleImmediate</code>方法的实现，实现代码很简单，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@patch</span><br><span class="line">class _AsyncRun &#123;</span><br><span class="line">  @patch</span><br><span class="line">  static void _scheduleImmediate(void callback()) &#123;</span><br><span class="line">    if (_ScheduleImmediate._closure &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new UnsupportedError(&quot;Microtasks are not supported&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    _ScheduleImmediate._closure(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef void _ScheduleImmediateClosure(void callback());</span><br><span class="line"></span><br><span class="line">class _ScheduleImmediate &#123;</span><br><span class="line">  static _ScheduleImmediateClosure _closure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Engine初始化时调用</span><br><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">void _setScheduleImmediateClosure(_ScheduleImmediateClosure closure) &#123;</span><br><span class="line">  _ScheduleImmediate._closure &#x3D; closure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">void _ensureScheduleImmediate() &#123;</span><br><span class="line">  _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由于<code>_setScheduleImmediateClosure</code>是在<code>RootIsolate</code>创建成功后的<code>InitDartAsync</code>函数中调用的，所以来看<code>InitDartAsync</code>函数的实现。</p>
<p>[-&gt; flutter/lib/ui/dart_runtime_hooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void InitDartAsync(Dart_Handle builtin_library, bool is_ui_isolate) &#123;</span><br><span class="line">  Dart_Handle schedule_microtask;</span><br><span class="line">  if (is_ui_isolate) &#123;</span><br><span class="line">    schedule_microtask &#x3D;</span><br><span class="line">        GetFunction(builtin_library, &quot;_getScheduleMicrotaskClosure&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Dart_Handle isolate_lib &#x3D; Dart_LookupLibrary(ToDart(&quot;dart:isolate&quot;));</span><br><span class="line">    Dart_Handle method_name &#x3D;</span><br><span class="line">        Dart_NewStringFromCString(&quot;_getIsolateScheduleImmediateClosure&quot;);</span><br><span class="line">    schedule_microtask &#x3D; Dart_Invoke(isolate_lib, method_name, 0, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  Dart_Handle async_library &#x3D; Dart_LookupLibrary(ToDart(&quot;dart:async&quot;));</span><br><span class="line">  Dart_Handle set_schedule_microtask &#x3D; ToDart(&quot;_setScheduleImmediateClosure&quot;);</span><br><span class="line">  Dart_Handle result &#x3D; Dart_Invoke(async_library, set_schedule_microtask, 1,</span><br><span class="line">                                   &amp;schedule_microtask);</span><br><span class="line">  PropagateIfError(result);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码很简单，根据不同<code>isolate</code>有不同实现。先来看ui_isolate，也就是<code>RootIsolate</code>，在<code>RootIsolate</code>中，赋给<code>_ScheduleImmediate._closure</code>的值是<code>_getScheduleMicrotaskClosure</code>方法，所以来看该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void _scheduleMicrotask(void callback()) native &#39;ScheduleMicrotask&#39;;</span><br><span class="line"></span><br><span class="line">@pragma(&#39;vm:entry-point&#39;)</span><br><span class="line">Function _getScheduleMicrotaskClosure() &#x3D;&gt; _scheduleMicrotask; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面代码很简单，就是对应着<code>ScheduleMicrotask</code>函数。</p>
<p>[-&gt; flutter/lib/ui/dart_runtime_hooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ScheduleMicrotask(Dart_NativeArguments args) &#123;</span><br><span class="line">  Dart_Handle closure &#x3D; Dart_GetNativeArgument(args, 0);</span><br><span class="line">  UIDartState::Current()-&gt;ScheduleMicrotask(closure);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>ScheduleMicrotask</code>函数中解析传递的参数，然后在调用当前<code>UIDartState</code>对象的<code>ScheduleMicrotask</code>函数。</p>
<p>[-&gt; flutter/lib/ui/ui_dart_state.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void UIDartState::ScheduleMicrotask(Dart_Handle closure) &#123;</span><br><span class="line">  if (tonic::LogIfError(closure) || !Dart_IsClosure(closure)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  microtask_queue_.ScheduleMicrotask(closure);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>UIDartState</code>对象的<code>ScheduleMicrotask</code>函数中，又会调用<code>DartMicrotaskQueue</code>对象的<code>ScheduleMicrotask</code>函数。</p>
<p>[-&gt; tonic/dart_microtask_queue.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DartMicrotaskQueue::ScheduleMicrotask(Dart_Handle callback) &#123;</span><br><span class="line">  queue_.emplace_back(DartState::Current(), callback);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最终来到<code>DartMicrotaskQueue</code>对象，在该对象中存在一个集合<code>queue_</code>，而<code>ScheduleMicrotask</code>函数中就是把<code>callback</code>添加到该集合中。也就是在<code>RootIsolate</code>中，最终是把<code>_startMicrotaskLoop</code>方法作为参数添加到集合<code>queue_</code>中。</p>
<p>再来看非<code>ui_isolate</code>中的处理情况，在非<code>ui_isolate</code>中，赋给<code>_ScheduleImmediate._closure</code>的值就变成了<code>_getIsolateScheduleImmediateClosure</code>方法。该方法的实现就简单多了，来看下面代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ImmediateCallback _pendingImmediateCallback;</span><br><span class="line"></span><br><span class="line">void _isolateScheduleImmediate(void callback()) &#123;</span><br><span class="line">  _pendingImmediateCallback &#x3D; callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@pragma(&quot;vm:entry-point&quot;, &quot;call&quot;)</span><br><span class="line">Function _getIsolateScheduleImmediateClosure() &#123;</span><br><span class="line">  return _isolateScheduleImmediate;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上面代码中，仅是把赋给了<code>_pendingImmediateCallback</code>，也就是把<code>_startMicrotaskLoop</code>方法作为值赋给了<code>_pendingImmediateCallback</code>。</p>
<h4 id="3-2、微任务的执行"><a href="#3-2、微任务的执行" class="headerlink" title="3.2、微任务的执行"></a>3.2、微任务的执行</h4><p>经过前面的准备，下面就可以在合适的时机来执行<code>_startMicrotaskLoop</code>方法，从而来处理所有微任务。</p>
<p>这里也分为<code>ui_isolate</code>及非<code>ui_isolate</code>两种情况，先来看当前<code>isolate</code>是<code>ui_isolate</code>的情况。</p>
<p>再来看<code>UIDartState</code>对象的实现，除了将<code>_startMicrotaskLoop</code>添加到集合中，也会在该对象中通过<code>FlushMicrotasksNow</code>函数来执行<code>_startMicrotaskLoop</code>方法，代码如下。</p>
<p>[-&gt; flutter/lib/ui/ui_dart_state.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void UIDartState::FlushMicrotasksNow() &#123;</span><br><span class="line">  microtask_queue_.RunMicrotasks();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再来看<code>RunMicrotasks</code>的实现，代码如下。</p>
<p>[-&gt; tonic/dart_microtask_queue.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void DartMicrotaskQueue::RunMicrotasks() &#123;</span><br><span class="line">  while (!queue_.empty()) &#123;</span><br><span class="line">    MicrotaskQueue local;</span><br><span class="line">    std::swap(queue_, local);</span><br><span class="line">    &#x2F;&#x2F;遍历集合中的所有元素</span><br><span class="line">    for (const auto&amp; callback : local) &#123;</span><br><span class="line">      if (auto dart_state &#x3D; callback.dart_state().lock()) &#123;</span><br><span class="line">        DartState::Scope dart_scope(dart_state.get());</span><br><span class="line">        &#x2F;&#x2F;调用_startMicrotaskLoop方法，callback.value()对应是_startMicrotaskLoop</span><br><span class="line">        Dart_Handle result &#x3D; Dart_InvokeClosure(callback.value(), 0, nullptr);</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>至此，知道了在<code>ui_isolate</code>中，微任务是如何添加到集合中、如何执行的。那么再来想一个问题，微任务的执行时机是在什么时候尼？这就需要来看调用<code>FlushMicrotasksNow</code>函数的时机。</p>
<p>经过查看<code>Flutter</code>源码。可以发现，<code>Flutter</code>中仅在<code>Window</code>对象的<code>BeginFrame</code>函数及<code>UIDartState</code>对象的<code>AddOrRemoveTaskObserver</code>函数中调用了调用了<code>FlushMicrotasksNow</code>函数。因此先来看<code>BeginFrame</code>的实现。</p>
<p>[-&gt; flutter/lib/ui/window/window.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Window::BeginFrame(fml::TimePoint frameTime) &#123;</span><br><span class="line">  std::shared_ptr&lt;tonic::DartState&gt; dart_state &#x3D; library_.dart_state().lock();</span><br><span class="line">  if (!dart_state)</span><br><span class="line">    return;</span><br><span class="line">  tonic::DartState::Scope scope(dart_state);</span><br><span class="line"></span><br><span class="line">  int64_t microseconds &#x3D; (frameTime - fml::TimePoint()).ToMicroseconds();</span><br><span class="line">  &#x2F;&#x2F;调用_beginFrame方法来开始绘制</span><br><span class="line">  tonic::LogIfError(tonic::DartInvokeField(library_.value(), &quot;_beginFrame&quot;,</span><br><span class="line">                                           &#123;</span><br><span class="line">                                               Dart_NewInteger(microseconds),</span><br><span class="line">                                           &#125;));</span><br><span class="line">  &#x2F;&#x2F;执行所有微任务</span><br><span class="line">  UIDartState::Current()-&gt;FlushMicrotasksNow();</span><br><span class="line">  &#x2F;&#x2F;调用_drawFrame来绘制UI</span><br><span class="line">  tonic::LogIfError(tonic::DartInvokeField(library_.value(), &quot;_drawFrame&quot;, &#123;&#125;));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码很简单，但也说明了，在<code>Flutter</code>中的<code>window</code>调用<code>_beginFrame</code>与<code>_drawFrame</code>方法之间会把所有微任务处理掉。也就注定了不能在微任务中做耗时操作，否则影响UI的绘制。</p>
<p>再来看<code>AddOrRemoveTaskObserver</code>函数。</p>
<p>[-&gt; flutter/lib/ui/ui_dart_state.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">UIDartState::UIDartState(</span><br><span class="line">    TaskRunners task_runners,</span><br><span class="line">    TaskObserverAdd add_callback,</span><br><span class="line">    TaskObserverRemove remove_callback,</span><br><span class="line">    fml::WeakPtr&lt;SnapshotDelegate&gt; snapshot_delegate,</span><br><span class="line">    fml::WeakPtr&lt;IOManager&gt; io_manager,</span><br><span class="line">    fml::RefPtr&lt;SkiaUnrefQueue&gt; skia_unref_queue,</span><br><span class="line">    fml::WeakPtr&lt;ImageDecoder&gt; image_decoder,</span><br><span class="line">    std::string advisory_script_uri,</span><br><span class="line">    std::string advisory_script_entrypoint,</span><br><span class="line">    std::string logger_prefix,</span><br><span class="line">    UnhandledExceptionCallback unhandled_exception_callback,</span><br><span class="line">    std::shared_ptr&lt;IsolateNameServer&gt; isolate_name_server)</span><br><span class="line">    : task_runners_(std::move(task_runners)),</span><br><span class="line">      &#x2F;&#x2F;给add_callback_赋值</span><br><span class="line">      add_callback_(std::move(add_callback)),</span><br><span class="line">      ...</span><br><span class="line">      isolate_name_server_(std::move(isolate_name_server)) &#123;</span><br><span class="line">  AddOrRemoveTaskObserver(true &#x2F;* add *&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UIDartState::AddOrRemoveTaskObserver(bool add) &#123;</span><br><span class="line">  auto task_runner &#x3D; task_runners_.GetUITaskRunner();</span><br><span class="line">  if (!task_runner) &#123;</span><br><span class="line">    &#x2F;&#x2F; This may happen in case the isolate has no thread affinity (for example,</span><br><span class="line">    &#x2F;&#x2F; the service isolate).</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  FML_DCHECK(add_callback_ &amp;&amp; remove_callback_);</span><br><span class="line">  if (add) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里是一个lambda表达式，传递给add_callback_一个函数</span><br><span class="line">    add_callback_(reinterpret_cast&lt;intptr_t&gt;(this),</span><br><span class="line">                  [this]() &#123; this-&gt;FlushMicrotasksNow(); &#125;);&#x2F;&#x2F;执行所有微任务</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    remove_callback_(reinterpret_cast&lt;intptr_t&gt;(this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里重点来看<code>add_callback_</code>，它是在<code>UIDartState</code>对象初始化的时候赋值的。由于<code>DartIsolate</code>继承自<code>UIDartState</code>，所以来看<code>DartIsolate</code>对象的创建。</p>
<p>[-&gt; flutter/runtime/dart_isolate.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DartIsolate::DartIsolate(const Settings&amp; settings,</span><br><span class="line">                         TaskRunners task_runners,</span><br><span class="line">                         fml::WeakPtr&lt;SnapshotDelegate&gt; snapshot_delegate,</span><br><span class="line">                         fml::WeakPtr&lt;IOManager&gt; io_manager,</span><br><span class="line">                         fml::RefPtr&lt;SkiaUnrefQueue&gt; unref_queue,</span><br><span class="line">                         fml::WeakPtr&lt;ImageDecoder&gt; image_decoder,</span><br><span class="line">                         std::string advisory_script_uri,</span><br><span class="line">                         std::string advisory_script_entrypoint,</span><br><span class="line">                         bool is_root_isolate)</span><br><span class="line">    : UIDartState(std::move(task_runners),</span><br><span class="line">                  &#x2F;&#x2F;add_callback_对应的值</span><br><span class="line">                  settings.task_observer_add,</span><br><span class="line">                  settings.task_observer_remove,</span><br><span class="line">                  std::move(snapshot_delegate),</span><br><span class="line">                  std::move(io_manager),</span><br><span class="line">                  std::move(unref_queue),</span><br><span class="line">                  std::move(image_decoder),</span><br><span class="line">                  advisory_script_uri,</span><br><span class="line">                  advisory_script_entrypoint,</span><br><span class="line">                  settings.log_tag,</span><br><span class="line">                  settings.unhandled_exception_callback,</span><br><span class="line">                  DartVMRef::GetIsolateNameServer()),</span><br><span class="line">      is_root_isolate_(is_root_isolate) &#123;</span><br><span class="line">  phase_ &#x3D; Phase::Uninitialized;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上面代码中，把<code>settings</code>对象的<code>task_observer_add</code>赋给了<code>add_callback_</code>。而<code>settings</code>是在<code>FlutterMain</code>的<code>Init</code>函数中创建并初始化的，所以在<code>FlutterMain</code>初始化时，就会给<code>settings</code>对象的<code>task_observer_add</code>赋值。</p>
<p>[-&gt; flutter/shell/platform/android/flutter_main.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void FlutterMain::Init(JNIEnv* env,</span><br><span class="line">                       jclass clazz,</span><br><span class="line">                       jobject context,</span><br><span class="line">                       jobjectArray jargs,</span><br><span class="line">                       jstring kernelPath,</span><br><span class="line">                       jstring appStoragePath,</span><br><span class="line">                       jstring engineCachesPath) &#123;</span><br><span class="line">  std::vector&lt;std::string&gt; args;</span><br><span class="line">  args.push_back(&quot;flutter&quot;);</span><br><span class="line">  for (auto&amp; arg : fml::jni::StringArrayToVector(env, jargs)) &#123;</span><br><span class="line">    args.push_back(std::move(arg));</span><br><span class="line">  &#125;</span><br><span class="line">  auto command_line &#x3D; fml::CommandLineFromIterators(args.begin(), args.end());</span><br><span class="line"></span><br><span class="line">  auto settings &#x3D; SettingsFromCommandLine(command_line);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;add_callback_对应的函数</span><br><span class="line">  settings.task_observer_add &#x3D; [](intptr_t key, fml::closure callback) &#123;</span><br><span class="line">    fml::MessageLoop::GetCurrent().AddTaskObserver(key, std::move(callback));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  settings.task_observer_remove &#x3D; [](intptr_t key) &#123;</span><br><span class="line">    fml::MessageLoop::GetCurrent().RemoveTaskObserver(key);</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再来看线程所对应的<code>MessageLoopImpl</code>对象，前面说过<code>MessageLoopAndroid</code>继承自<code>MessageLoopImpl</code>。所以来看<code>AddTaskObserver</code>函数的实现。</p>
<p>[-&gt; flutter/fml/message_loop_impl.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void MessageLoopImpl::AddTaskObserver(intptr_t key,</span><br><span class="line">                                      const fml::closure&amp; callback) &#123;</span><br><span class="line">  if (callback !&#x3D; nullptr) &#123;</span><br><span class="line">    &#x2F;&#x2F;每个MessageLoopImpl对象拥有唯一的queue_id_</span><br><span class="line">    task_queue_-&gt;AddTaskObserver(queue_id_, key, callback);</span><br><span class="line">  &#125; else &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里的<code>task_queue_</code>是一个<code>MessageLoopTaskQueues</code>对象，它的<code>AddTaskObserver</code>函数实现如下。</p>
<p>[-&gt; flutter/fml/message_loop_task_queues.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void MessageLoopTaskQueues::AddTaskObserver(TaskQueueId queue_id,</span><br><span class="line">                                            intptr_t key,</span><br><span class="line">                                            const fml::closure&amp; callback) &#123;</span><br><span class="line">  std::scoped_lock queue_lock(GetMutex(queue_id));</span><br><span class="line">  &#x2F;&#x2F;UIDartState为key。包含FlushMicrotasksNow函数调用的callback为value</span><br><span class="line">  queue_entries_[queue_id]-&gt;task_observers[key] &#x3D; std::move(callback);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码中的<code>queue_entries_</code>是一个以<code>TaskQueueId</code>为key、<code>TaskQueueEntry</code>对象为value的map，而<code>TaskQueueEntry</code>中的<code>task_observers</code>也是一个map。所以<code>AddTaskObserver</code>函数就是把包含<code>FlushMicrotasksNow</code>函数调用的<code>callback</code>以<code>UIDartState</code>对象为key存入map中。</p>
<p>在<a href="https://juejin.im/post/5ee19d11518825433b134766" target="_blank" rel="noopener">Flutter之Timer原理解析</a>一文中，如果在<code>ui_isolate</code>中，最终是通过<code>DartMessageHandler</code>的<code>OnMessage</code>函数来处理<code>event handler</code>消息及普通消息，代码如下。</p>
<p>[-&gt;third_party/tonic/dart_message_handler.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void DartMessageHandler::Initialize(TaskDispatcher dispatcher) &#123;</span><br><span class="line">  &#x2F;&#x2F; Only can be called once.</span><br><span class="line">  TONIC_CHECK(!task_dispatcher_ &amp;&amp; dispatcher);</span><br><span class="line">  task_dispatcher_ &#x3D; dispatcher;</span><br><span class="line">  Dart_SetMessageNotifyCallback(MessageNotifyCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DartMessageHandler::OnMessage(DartState* dart_state) &#123;</span><br><span class="line">  auto task_dispatcher_ &#x3D; dart_state-&gt;message_handler().task_dispatcher_;</span><br><span class="line"></span><br><span class="line">  auto weak_dart_state &#x3D; dart_state-&gt;GetWeakPtr();</span><br><span class="line">  &#x2F;&#x2F;在Android中，任务交给UI线程中的loop来执行。</span><br><span class="line">  &#x2F;&#x2F;在iOS中，也是通过类似loop的消息处理器来执行</span><br><span class="line">  task_dispatcher_([weak_dart_state]() &#123;</span><br><span class="line">    if (auto dart_state &#x3D; weak_dart_state.lock()) &#123;</span><br><span class="line">      dart_state-&gt;message_handler().OnHandleMessage(dart_state.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>代码中的<code>task_dispatcher_</code>是在<code>DartMessageHandler</code>对象调用<code>Initialize</code>函数时设置的。根据<a href="https://juejin.im/post/5e535ca2f265da573e6723f3" target="_blank" rel="noopener">Flutter之Engine启动流程</a>，知道是在<code>Initialize</code>函数是在<code>RootIsolate</code>初始化时调用的，那么就来看一下<code>Initialize</code>函数的实现。</p>
<p>[-&gt; flutter/runtime/dart_isolate.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool DartIsolate::InitializeIsolate(</span><br><span class="line">    std::shared_ptr&lt;DartIsolate&gt; embedder_isolate,</span><br><span class="line">    Dart_Isolate isolate,</span><br><span class="line">    char** error) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;设置UI线程的消息处理器</span><br><span class="line">  SetMessageHandlingTaskRunner(GetTaskRunners().GetUITaskRunner());</span><br><span class="line">  ...</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DartIsolate::SetMessageHandlingTaskRunner(</span><br><span class="line">    fml::RefPtr&lt;fml::TaskRunner&gt; runner) &#123;</span><br><span class="line">  if (!IsRootIsolate() || !runner) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message_handling_task_runner_ &#x3D; runner;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;设置消息处理器</span><br><span class="line">  message_handler().Initialize(</span><br><span class="line">      [runner](std::function&lt;void()&gt; task) &#123; runner-&gt;PostTask(task); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>根据上面代码，可以知道<code>task_dispatcher_</code>中其实就是将任务task通过<code>PostTask</code>函数添加到<code>looper</code>中。</p>
<p>[-&gt; flutter/fml/task_runner.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TaskRunner::TaskRunner(fml::RefPtr&lt;MessageLoopImpl&gt; loop)</span><br><span class="line">    : loop_(std::move(loop)) &#123;&#125;</span><br><span class="line">void TaskRunner::PostTask(const fml::closure&amp; task) &#123;</span><br><span class="line">  loop_-&gt;PostTask(task, fml::TimePoint::Now());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以Android平台为例，这里的<code>loop_</code>就是一个<code>MessageLoopAndroid</code>对象。所以再来看<code>MessageLoopAndroid</code>中<code>PostTask</code>的实现。</p>
<p>[-&gt; flutter/fml/message_loop_impl.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void MessageLoopImpl::PostTask(const fml::closure&amp; task,</span><br><span class="line">                               fml::TimePoint target_time) &#123;</span><br><span class="line">  ...</span><br><span class="line">  task_queue_-&gt;RegisterTask(queue_id_, task, target_time);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>PostTask</code>函数中最终还是调用的<code>task_queue_</code>的<code>RegisterTask</code>函数，再来看该函数的实现。</p>
<p>[-&gt; flutter/fml/message_loop_task_queues.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void MessageLoopTaskQueues::RegisterTask(TaskQueueId queue_id,</span><br><span class="line">                                         const fml::closure&amp; task,</span><br><span class="line">                                         fml::TimePoint target_time) &#123;</span><br><span class="line">  std::scoped_lock queue_lock(GetMutex(queue_id));</span><br><span class="line"></span><br><span class="line">  size_t order &#x3D; order_++;</span><br><span class="line">  const auto&amp; queue_entry &#x3D; queue_entries_[queue_id];</span><br><span class="line">  queue_entry-&gt;delayed_tasks.push(&#123;order, task, target_time&#125;);</span><br><span class="line">  TaskQueueId loop_to_wake &#x3D; queue_id;</span><br><span class="line">  if (queue_entry-&gt;subsumed_by !&#x3D; _kUnmerged) &#123;</span><br><span class="line">    loop_to_wake &#x3D; queue_entry-&gt;subsumed_by;</span><br><span class="line">  &#125;</span><br><span class="line">  WakeUpUnlocked(loop_to_wake,</span><br><span class="line">                 queue_entry-&gt;delayed_tasks.top().GetTargetTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MessageLoopTaskQueues::WakeUpUnlocked(TaskQueueId queue_id,</span><br><span class="line">                                           fml::TimePoint time) const &#123;</span><br><span class="line">  if (queue_entries_.at(queue_id)-&gt;wakeable) &#123;</span><br><span class="line">    queue_entries_.at(queue_id)-&gt;wakeable-&gt;WakeUp(time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>RegisterTask</code>函数中，把任务task添加到优先级队列<code>delayed_tasks</code>中。然后再调用<code>MessageLoopAndroid</code>对象的<code>WakeUp</code>函数。</p>
<p>[-&gt; flutter/fml/platform/android/message_loop_android.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MessageLoopAndroid::WakeUp(fml::TimePoint time_point) &#123;</span><br><span class="line">  bool result &#x3D; TimerRearm(timer_fd_.get(), time_point);</span><br><span class="line">  FML_DCHECK(result);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>WakeUp</code>函数就是通过<code>TimerRearm</code>函数来在合适的时机唤醒<code>looper</code>。根据前面UI线程的创建过程，可得知在<code>looper</code>唤醒后的回调函数<code>read_event_fd</code>中是执行<code>MessageLoopAndroid</code>对象的<code>OnEventFired</code>函数，而在该函数中又直接调用<code>MessageLoopAndroid</code>对象的<code>FlushTasks</code>函数，下面就来看<code>FlushTasks</code>函数的实现。</p>
<p>[-&gt; flutter/fml/message_loop_impl.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void MessageLoopImpl::FlushTasks(FlushType type) &#123;</span><br><span class="line">  TRACE_EVENT0(&quot;fml&quot;, &quot;MessageLoop::FlushTasks&quot;);</span><br><span class="line">  std::vector&lt;fml::closure&gt; invocations;</span><br><span class="line"></span><br><span class="line">  task_queue_-&gt;GetTasksToRunNow(queue_id_, type, invocations);</span><br><span class="line"></span><br><span class="line">  for (const auto&amp; invocation : invocations) &#123;</span><br><span class="line">    &#x2F;&#x2F;执行普通回调方法</span><br><span class="line">    invocation();</span><br><span class="line">    std::vector&lt;fml::closure&gt; observers &#x3D;</span><br><span class="line">        task_queue_-&gt;GetObserversToNotify(queue_id_);</span><br><span class="line">    for (const auto&amp; observer : observers) &#123;</span><br><span class="line">      &#x2F;&#x2F;observer对应着UIDartState对象的FlushMicrotasksNow函数，这里也就是执行所有的微任务</span><br><span class="line">      observer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MessageLoopImpl::RunExpiredTasksNow() &#123;</span><br><span class="line">  FlushTasks(FlushType::kAll);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在<code>FlushTasks</code>函数中，每一个已到期的<code>event handler</code>任务或异步任务执行完毕后，都会执行所有的微任务。</p>
<p>到此，在<code>ui_isolate</code>中，最终在以下两种时机来执行微任务。</p>
<ol>
<li>在调用<code>window</code>的<code>_beginFrame</code>与<code>_drawFrame</code>方法之间会把所有微任务处理掉。也就注定了不能在微任务中做耗时操作，否则影响UI的绘制。</li>
<li>在每一个已到期的<code>event handler</code>任务或异步任务执行完毕后，都会执行所有的微任务。</li>
</ol>
<p>再来看在非<code>ui_isolate</code>中微任务的执行时机。也主要分为以下几种情况。</p>
<ol>
<li>根据<a href="https://juejin.im/post/5ee19d11518825433b134766" target="_blank" rel="noopener">Flutter之Timer原理解析</a>一文可得知，在每一个<code>event handler</code>任务或异步任务执行完毕后，都会执行所有的微任务。</li>
<li>如果当前是生产环境，<code>Isolate</code>中消息类型是<code>kDrainServiceExtensionsMsg</code>且消息优先级是<code>kImmediateAction</code>，则也会执行所有微任务</li>
</ol>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>以上就是微任务的使用及使用原理。还是有一定难度的。结合<a href="https://juejin.im/post/5ee19d11518825433b134766" target="_blank" rel="noopener">Flutter之Timer原理解析</a>一文，基本上就可以了解<code>Flutter</code>中的消息机制，这样在使用微任务及其他异步任务时也能做到了然于胸。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/BLoC%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/28/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/BLoC%E6%A8%A1%E5%BC%8F/" itemprop="url">BLoC模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-28T13:58:24+08:00">
                2020-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/Flutter%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/28/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/BLoC%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/28/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/BLoC%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>BLoC是<strong>B</strong>usiness <strong>L</strong>ogic <strong>C</strong>omponents的缩写。BLoC的哲学就是app里的所有东西都应该被认为是事件流：一部分组件订阅事件，另一部分组件则响应事件。BLoC居中管理这些会话。Dart甚至把流（Stream）内置到了语言本身里。</p>
<p>这个模式最好的地方就是你不需要引入任何的插件，也不需要学习其他的语法。所有需要的内容Flutter都有提供。</p>
<p>写app的时候，不管你用的是Flutter或者其他的框架，把类分层都是很关键的。这更像是一个非正式的约定，不是一定要在代码里有怎么样的体现。</p>
<p>每层，或者一组类，都负责一个总体的职责。在初始项目里有一个目录<strong>DataLayer</strong>。这个数据层专门用来负责app的model和与后台通信。它对UI一无所知。</p>
<h1 id="二、BLoC"><a href="#二、BLoC" class="headerlink" title="二、BLoC"></a>二、BLoC</h1><p>BLoC基本就是基于Dart的流（Stream）的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-919a03da365990e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>流，和Future一样，也是在<code>dart:async</code>包里。一个流就像一个future，不同的是流不只是异步的返回一个值，流可以随着时间的推移返回很多的值。如果一个future最终是一个值的话，那么一个流就是会随着时间可以返回一个系列的值。</p>
<p><code>dart:async</code>包提供了一个<code>StreamController</code>类。流控制器管理的两个对象流和槽（sink）。sink和流相对应，流提供提供数据，sink接受输入值。</p>
<p>总结一下，BLoC用来处理逻辑，sink接受输入，流输出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/25/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/runZoned/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/25/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/runZoned/" itemprop="url">flutter/实战开发/runZoned</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-25T21:11:14+08:00">
                2020-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/Flutter%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/25/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/runZoned/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/25/flutter/%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/runZoned/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flutter异常捕获"><a href="#Flutter异常捕获" class="headerlink" title="Flutter异常捕获"></a>Flutter异常捕获</h1><p>在介绍Flutter异常捕获之前必须先了解一下Dart单线程模型，只有了解了Dart的代码执行流程，我们才能知道该在什么地方去捕获异常。</p>
<h2 id="一、Dart单线程模型"><a href="#一、Dart单线程模型" class="headerlink" title="一、Dart单线程模型"></a>一、Dart单线程模型</h2><p>在Java和Objective-C（以下简称“OC”）中，如果程序发生异常且没有被捕获，那么程序将会终止，但是这在Dart或JavaScript中则不会！究其原因，这和它们的运行机制有关系。Java和OC都是多线程模型的编程语言，任意一个线程触发异常且该异常未被捕获时，就会导致整个进程退出。但Dart和JavaScript不会，它们都是单线程模型，运行机制很相似(但有区别)，下面我们通过Dart官方提供的一张图来看看Dart大致运行原理：</p>
<p><img src="https://pcdn.flutterchina.club/imgs/2-12.png" alt="图2-12"></p>
<p>Dart 在单线程中是以消息循环机制来运行的，其中包含两个任务队列，一个是“微任务队列” <strong>microtask queue</strong>，另一个叫做“事件队列” <strong>event queue</strong>。从图中可以发现，微任务队列的执行优先级高于事件队列。</p>
<p>现在我们来介绍一下Dart线程运行过程，如上图中所示，入口函数 main() 执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，事件任务执行完毕后程序便会退出，但是，在事件任务执行的过程中也可以插入新的微任务和事件任务，在这种情况下，整个线程的执行过程便是一直在循环，不会退出，而Flutter中，主线程的执行过程正是如此，永不终止。</p>
<p>在Dart中，所有的外部事件任务都在事件队列中，如IO、计时器、点击、以及绘制事件等，而微任务通常来源于Dart内部，并且微任务非常少，之所以如此，是因为微任务队列优先级高，如果微任务太多，执行时间总和就越久，事件队列任务的延迟也就越久，对于GUI应用来说最直观的表现就是比较卡，所以必须得保证微任务队列不会太长。值得注意的是，我们可以通过<code>Future.microtask(…)</code>方法向微任务队列插入一个任务。</p>
<p>在事件循环中，当某个任务发生异常并没有被捕获时，程序并不会退出，而直接导致的结果是<strong>当前任务</strong>的后续代码就不会被执行了，也就是说一个任务中的异常是不会影响其它任务执行的。</p>
<h2 id="二、Flutter异常捕获"><a href="#二、Flutter异常捕获" class="headerlink" title="二、Flutter异常捕获"></a>二、Flutter异常捕获</h2><p>Dart中可以通过<code>try/catch/finally</code>来捕获代码块异常，这个和其它编程语言类似，如果读者不清楚，可以查看Dart语言文档，不再赘述，下面我们看看Flutter中的异常捕获。</p>
<h3 id="Flutter框架异常捕获"><a href="#Flutter框架异常捕获" class="headerlink" title="Flutter框架异常捕获"></a>Flutter框架异常捕获</h3><p>Flutter 框架为我们在很多关键的方法进行了异常捕获。这里举一个例子，当我们布局发生越界或不合规范时，Flutter就会自动弹出一个错误界面，这是因为Flutter已经在执行build方法时添加了异常捕获，最终的源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//执行build方法  </span></span><br><span class="line">    built = build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    <span class="comment">// 有异常时则弹出错误提示  </span></span><br><span class="line">    built = ErrorWidget.builder(_debugReportException(<span class="string">'building <span class="subst">$this</span>'</span>, e, stack));</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在发生异常时，Flutter默认的处理方式是弹一个ErrorWidget，但如果我们想自己捕获异常并上报到报警平台的话应该怎么做？我们进入<code>_debugReportException()</code>方法看看：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FlutterErrorDetails _debugReportException(</span><br><span class="line">  <span class="built_in">String</span> context,</span><br><span class="line">  <span class="built_in">dynamic</span> exception,</span><br><span class="line">  StackTrace stack, &#123;</span><br><span class="line">  InformationCollector informationCollector</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">//构建错误详情对象  </span></span><br><span class="line">  <span class="keyword">final</span> FlutterErrorDetails details = FlutterErrorDetails(</span><br><span class="line">    exception: exception,</span><br><span class="line">    stack: stack,</span><br><span class="line">    <span class="keyword">library</span>: <span class="string">'widgets library'</span>,</span><br><span class="line">    context: context,</span><br><span class="line">    informationCollector: informationCollector,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//报告错误 </span></span><br><span class="line">  FlutterError.reportError(details);</span><br><span class="line">  <span class="keyword">return</span> details;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，错误是通过<code>FlutterError.reportError</code>方法上报的，继续跟踪：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> reportError(FlutterErrorDetails details) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (onError != <span class="keyword">null</span>)</span><br><span class="line">    onError(details); <span class="comment">//调用了onError回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>onError</code>是<code>FlutterError</code>的一个静态属性，它有一个默认的处理方法 <code>dumpErrorToConsole</code>，到这里就清晰了，如果我们想自己上报异常，只需要提供一个自定义的错误处理回调即可，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  FlutterError.onError = (FlutterErrorDetails details) &#123;</span><br><span class="line">    reportError(details);</span><br><span class="line">  &#125;;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以处理那些Flutter为我们捕获的异常了，接下来我们看看如何捕获其它异常。</p>
<h3 id="其它异常捕获与日志收集"><a href="#其它异常捕获与日志收集" class="headerlink" title="其它异常捕获与日志收集"></a>其它异常捕获与日志收集</h3><p>在Flutter中，还有一些Flutter没有为我们捕获的异常，如调用空对象方法异常、Future中的异常。在Dart中，异常分两类：同步异常和异步异常，同步异常可以通过<code>try/catch</code>捕获，而异步异常则比较麻烦，如下面的代码是捕获不了<code>Future</code>的异常的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>)).then((e) =&gt; Future.error(<span class="string">"xxx"</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dart中有一个<code>runZoned(...)</code> 方法，可以给执行对象指定一个Zone。Zone表示一个代码执行的环境范围，为了方便理解，读者可以将Zone类比为一个代码执行沙箱，不同沙箱的之间是隔离的，沙箱可以捕获、拦截或修改一些代码行为，如Zone中可以捕获日志输出、Timer创建、微任务调度的行为，同时Zone也可以捕获所有未处理的异常。下面我们看看<code>runZoned(...)</code>方法定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R runZoned&lt;R&gt;(R body(), &#123;</span><br><span class="line">    <span class="built_in">Map</span> zoneValues, </span><br><span class="line">    ZoneSpecification zoneSpecification,</span><br><span class="line">    <span class="built_in">Function</span> onError,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>zoneValues</code>: Zone 的私有数据，可以通过实例<code>zone[key]</code>获取，可以理解为每个“沙箱”的私有数据。</p>
</li>
<li><p><code>zoneSpecification</code>：Zone的一些配置，可以自定义一些代码行为，比如拦截日志输出行为等，举个例子：</p>
<p>下面是拦截应用中所有调用<code>print</code>输出日志的行为。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runZoned(() =&gt; runApp(MyApp()), zoneSpecification: <span class="keyword">new</span> ZoneSpecification(</span><br><span class="line">      <span class="built_in">print</span>: (Zone self, ZoneDelegate parent, Zone zone, <span class="built_in">String</span> line) &#123;</span><br><span class="line">        parent.<span class="built_in">print</span>(zone, <span class="string">"Intercepted: <span class="subst">$line</span>"</span>);</span><br><span class="line">      &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们APP中所有调用<code>print</code>方法输出日志的行为都会被拦截，通过这种方式，我们也可以在应用中记录日志，等到应用触发未捕获的异常时，将异常信息和日志统一上报。ZoneSpecification还可以自定义一些其他行为，读者可以查看API文档。</p>
</li>
<li><p><code>onError</code>：Zone中未捕获异常处理回调，如果开发者提供了onError回调或者通过<code>ZoneSpecification.handleUncaughtError</code>指定了错误处理回调，那么这个zone将会变成一个error-zone，该error-zone中发生未捕获异常(无论同步还是异步)时都会调用开发者提供的回调，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runZoned(() &#123;</span><br><span class="line">    runApp(MyApp());</span><br><span class="line">&#125;, onError: (<span class="built_in">Object</span> obj, StackTrace stack) &#123;</span><br><span class="line">    <span class="keyword">var</span> details=makeDetails(obj,stack);</span><br><span class="line">    reportError(details);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样一来，结合上面的<code>FlutterError.onError</code>我们就可以捕获我们Flutter应用中全部错误了！需要注意的是，error-zone内部发生的错误是不会跨越当前error-zone的边界的，如果想跨越error-zone边界去捕获异常，可以通过共同的“源”zone来捕获，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> future = <span class="keyword">new</span> Future.value(<span class="number">499</span>);</span><br><span class="line">runZoned(() &#123;</span><br><span class="line">    <span class="keyword">var</span> future2 = future.then((_) &#123; <span class="keyword">throw</span> <span class="string">"error in first error-zone"</span>; &#125;);</span><br><span class="line">    runZoned(() &#123;</span><br><span class="line">        <span class="keyword">var</span> future3 = future2.catchError((e) &#123; <span class="built_in">print</span>(<span class="string">"Never reached!"</span>); &#125;);</span><br><span class="line">    &#125;, onError: (e) &#123; <span class="built_in">print</span>(<span class="string">"unused error handler"</span>); &#125;);</span><br><span class="line">&#125;, onError: (e) &#123; <span class="built_in">print</span>(<span class="string">"catches error of first error-zone."</span>); &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们最终的异常捕获和上报代码大致如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> collectLog(<span class="built_in">String</span> line)&#123;</span><br><span class="line">    ... <span class="comment">//收集日志</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> reportErrorAndLog(FlutterErrorDetails details)&#123;</span><br><span class="line">    ... <span class="comment">//上报错误和日志逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlutterErrorDetails makeDetails(<span class="built_in">Object</span> obj, StackTrace stack)&#123;</span><br><span class="line">    ...<span class="comment">// 构建错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  FlutterError.onError = (FlutterErrorDetails details) &#123;</span><br><span class="line">    reportErrorAndLog(details);</span><br><span class="line">  &#125;;</span><br><span class="line">  runZoned(</span><br><span class="line">    () =&gt; runApp(MyApp()),</span><br><span class="line">    zoneSpecification: ZoneSpecification(</span><br><span class="line">      <span class="built_in">print</span>: (Zone self, ZoneDelegate parent, Zone zone, <span class="built_in">String</span> line) &#123;</span><br><span class="line">        collectLog(line); <span class="comment">// 收集日志</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">    onError: (<span class="built_in">Object</span> obj, StackTrace stack) &#123;</span><br><span class="line">      <span class="keyword">var</span> details = makeDetails(obj, stack);</span><br><span class="line">      reportErrorAndLog(details);</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/25/flutter/widget%E7%BB%84%E4%BB%B6/WillPopScope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/25/flutter/widget%E7%BB%84%E4%BB%B6/WillPopScope/" itemprop="url">WillPopScope</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-25T20:01:40+08:00">
                2020-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/widget%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">widget组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/25/flutter/widget%E7%BB%84%E4%BB%B6/WillPopScope/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/25/flutter/widget%E7%BB%84%E4%BB%B6/WillPopScope/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WillPopScope"><a href="#WillPopScope" class="headerlink" title="WillPopScope"></a>WillPopScope</h1><p>WillPopScope用于处理是否离开当前页面，在Flutter中有多种方式可以离开当前页面，比如AppBar、CupertinoNavigationBar上面的返回按钮，点击将会回到前一个页面，在Android手机上点击实体（虚拟）返回按钮，也将会回到前一个页面，此功能对于iOS程序员来说可能特别容易忽略。</p>
<p>以下几种情况我们会用到WillPopScope：</p>
<ol>
<li>需要询问用户是否退出。</li>
<li>App中有多个Navigator，想要的是让其中一个 Navigator 退出，而不是直接让在 Widget tree 底层的 Navigator 退出。</li>
</ol>
<h2 id="询问用户是否退出"><a href="#询问用户是否退出" class="headerlink" title="询问用户是否退出"></a>询问用户是否退出</h2><p>在Android App中最开始的页面点击后退按钮，默认会关闭当前activity并回到桌面，我们希望此时弹出对话框或者给出提示“再次点击退出”，避免用户的误操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WillPopScope(</span><br><span class="line">    onWillPop: () <span class="keyword">async</span> =&gt; showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) =&gt;</span><br><span class="line">            AlertDialog(title: Text(<span class="string">'你确定要退出吗？'</span>), actions: &lt;Widget&gt;[</span><br><span class="line">              RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'退出'</span>),</span><br><span class="line">                  onPressed: () =&gt; Navigator.of(context).pop(<span class="keyword">true</span>)),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'取消'</span>),</span><br><span class="line">                  onPressed: () =&gt; Navigator.of(context).pop(<span class="keyword">false</span>)),</span><br><span class="line">            ])),</span><br><span class="line">    child: Container(</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      child: Text(<span class="string">'点击后退按钮，询问是否退出。'</span>),</span><br><span class="line">    ))复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720b4c8f178d772?imageslim" alt="img"></p>
<p>我们也可以把效果做成快速点击2次退出：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DateTime</span> _lastQuitTime;</span><br><span class="line">WillPopScope(</span><br><span class="line">    onWillPop: () <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_lastQuitTime == <span class="keyword">null</span> ||</span><br><span class="line">          <span class="built_in">DateTime</span>.now().difference(_lastQuitTime).inSeconds &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'再按一次 Back 按钮退出'</span>);</span><br><span class="line">        Scaffold.of(context)</span><br><span class="line">            .showSnackBar(SnackBar(content: Text(<span class="string">'再按一次 Back 按钮退出'</span>)));</span><br><span class="line">        _lastQuitTime = <span class="built_in">DateTime</span>.now();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'退出'</span>);</span><br><span class="line">        Navigator.of(context).pop(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    child: Container(</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      child: Text(<span class="string">'点击后退按钮，询问是否退出。'</span>),</span><br><span class="line">    ))复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720b4c92d75a3db?imageslim" alt="img"></p>
<h2 id="App中有多个Navigator"><a href="#App中有多个Navigator" class="headerlink" title="App中有多个Navigator"></a>App中有多个Navigator</h2><p>我们的App通常是在<strong>MaterialApp</strong>和<strong>CupertinoApp</strong>下，<strong>MaterialApp</strong>和<strong>CupertinoApp</strong>本身有一个Navigator，所以默认情况下调用<strong>Navigator.pop</strong>或者<strong>Navigator.push</strong>就是在操作此Navigator。不过在一些情况下，我们希望有自己定义的Navigator，比如如下场景：</p>
<ul>
<li>在页面底部有一个常驻bar，其上展示内容，这个常驻bar就需要一个自己的Navigator。</li>
<li>在使用TabView、BottomNavigationBar、CupertinoTabView这些组件时，希望有多个Tab，但每个Tab中有自己的导航行为，这时需要给每一个Tab加一个Navigator。</li>
</ul>
<p>首页：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  GlobalKey&lt;NavigatorState&gt; _key = GlobalKey();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: WillPopScope(</span><br><span class="line">          onWillPop: () <span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_key.currentState.canPop()) &#123;</span><br><span class="line">              _key.currentState.pop();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Expanded(</span><br><span class="line">                child: Navigator(</span><br><span class="line">                  key: _key,</span><br><span class="line">                  onGenerateRoute: (RouteSettings settings) =&gt;</span><br><span class="line">                      MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                    <span class="keyword">return</span> OnePage();</span><br><span class="line">                  &#125;),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                height: <span class="number">50</span>,</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                child: Text(<span class="string">'底部Bar'</span>),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          )),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>第一个页面：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Container(</span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'去下一个页面'</span>),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Navigator.push(context, MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                <span class="keyword">return</span> TwoPage();</span><br><span class="line">              &#125;));</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>第二个页面：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Container(</span><br><span class="line">          child: Text(<span class="string">'这是第二个页面'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720b4c96e562f0d?imageslim" alt="img"></p>
<p>使用TabView、BottomNavigationBar、CupertinoTabView这些组件时也是一样的原理，只需在每一个Tab中加入Navigator，不要忘记指定<strong>key</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
