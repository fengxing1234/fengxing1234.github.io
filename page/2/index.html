<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" itemprop="url">抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-11T00:52:09+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>抽象工厂模式考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</p>
<p><strong>定义：</strong>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8d93e04646ff68f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>模式的结构：</strong></p>
<p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p>
<ul>
<li>抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<p><strong>解决的问题：</strong></p>
<p><strong>优点：</strong></p>
<p>​    抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p>
<ul>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>​    产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。</p>
<ul>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
<p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p>
<p><strong>抽象工厂模式与工厂方法模式的区别：</strong></p>
<p>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，<strong>工厂方法模式针对的是一个产品等级结构</strong>；而<strong>抽象工厂模式则是针对的多个产品等级结构（产品族，维度不同）</strong>。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>同种类称为同等级，也就是说：<a href="http://c.biancheng.net/view/1348.html" target="_blank" rel="noopener">工厂方法模式</a>只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<ul>
<li><strong>产品等级结构</strong> ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li><strong>产品族</strong> ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-514e13d327ed2a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，上图所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。</p>
<p><strong>步骤一：创建抽象产品族类</strong> ，定义抽象产品的公共接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;产品1 空调</span><br><span class="line">public interface IAirConditioner &#123;</span><br><span class="line">    void airConditioner();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;产品2 电视</span><br><span class="line">public interface ITelevision &#123;</span><br><span class="line"></span><br><span class="line">    void television();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：</strong> 创建<strong>具体产品类</strong>（继承抽象产品类）， 定义生产的具体产品；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;生产海尔的空调</span><br><span class="line">public class HaierAirConditionerImpl implements IAirConditioner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void airConditioner() &#123;</span><br><span class="line">        System.out.println(&quot;海尔空调&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生产TCL空调</span><br><span class="line">public class TCLAirConditioner implements IAirConditioner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void airConditioner() &#123;</span><br><span class="line">        System.out.println(&quot;TCL空调&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生产海尔电视</span><br><span class="line">public class HaierTelevisionImpl implements ITelevision &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void television() &#123;</span><br><span class="line">        System.out.println(&quot;海尔电视机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生产TCL电视</span><br><span class="line">public class TCLTelevisionImpl implements ITelevision &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void television() &#123;</span><br><span class="line">        System.out.println(&quot;TCL电视机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：</strong> 创建<strong>抽象工厂类</strong>，定义具体工厂的公共接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 抽象工厂类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建空调</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    IAirConditioner createAirConditioner();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建电视</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ITelevision createTelevision();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：</strong>创建<strong>具体工厂类</strong>（继承抽象工厂类），定义创建对应具体产品实例的方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class HaierFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IAirConditioner createAirConditioner() &#123;</span><br><span class="line">        return new HaierAirConditionerImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ITelevision createTelevision() &#123;</span><br><span class="line">        return new HaierTelevisionImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TCLFactory implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IAirConditioner createAirConditioner() &#123;</span><br><span class="line">        return new TCLAirConditioner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ITelevision createTelevision() &#123;</span><br><span class="line">        return new TCLTelevisionImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：</strong>客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void abstractFactory() &#123;</span><br><span class="line">        &#x2F;&#x2F;海尔工厂类</span><br><span class="line">        HaierFactory haierFactory &#x3D; new HaierFactory();</span><br><span class="line">        &#x2F;&#x2F;通过海尔工厂类创建空调产品类</span><br><span class="line">        IAirConditioner airConditioner &#x3D; haierFactory.createAirConditioner();</span><br><span class="line">        &#x2F;&#x2F;调用海尔空调</span><br><span class="line">        airConditioner.airConditioner();</span><br><span class="line">        &#x2F;&#x2F;通过海尔工厂类创建电视产品类</span><br><span class="line">        ITelevision television &#x3D; haierFactory.createTelevision();</span><br><span class="line">        &#x2F;&#x2F;调用海尔电视</span><br><span class="line">        television.television();</span><br><span class="line"></span><br><span class="line">        TCLFactory tclFactory &#x3D; new TCLFactory();</span><br><span class="line">        IAirConditioner TclAirConditioner &#x3D; tclFactory.createAirConditioner();</span><br><span class="line">        TclAirConditioner.airConditioner();</span><br><span class="line">        ITelevision TCLTelevision &#x3D; tclFactory.createTelevision();</span><br><span class="line">        TCLTelevision.television();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">海尔空调</span><br><span class="line">海尔电视机</span><br><span class="line">TCL空调</span><br><span class="line">TCL电视机</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4118241-d2e598ce2191faa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p>
<p>​    所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" itemprop="url">简单工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-11T00:25:06+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>定义：</strong></p>
<p>又称为静态工厂方法，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p><strong>类型：</strong>创建型</p>
<p><strong>类图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-4369560047d5e33e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>模式的结构：</strong></p>
<ul>
<li><p>工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。</p>
</li>
<li><p>抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。</p>
</li>
<li><p>具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。</p>
</li>
</ul>
<p><strong>解决的问题：</strong></p>
<p>将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。</p>
<blockquote>
<p>即使用者可直接消费产品而不需要知道其生产的细节</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li>
<li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</p>
</li>
<li><p>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</p>
</li>
<li><p>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</p>
</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；</li>
<li>当工厂类负责创建的对象（具体产品）比较少时。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>背景：小成有一个塑料生产厂，用来做塑料加工生意</li>
<li>目的：最近推出了2个产品，小成希望使用<strong>简单工厂模式</strong>实现2款产品的生产</li>
</ul>
<p><strong>步骤1.</strong> 创建抽象产品类，定义具体产品的公共接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IPlasticProduct &#123;</span><br><span class="line">    void show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2.</strong> 创建具体产品类（继承抽象产品类），定义生产的具体产品</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PlasticProductA implements IPlasticProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;塑料产品A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PlasticProductB implements IPlasticProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;塑料产品B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3.</strong> 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PlasticFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static IPlasticProduct factory(String productName) &#123;</span><br><span class="line">        switch (productName) &#123;</span><br><span class="line">            case &quot;A&quot;:</span><br><span class="line">                return new PlasticProductA();</span><br><span class="line">            case &quot;B&quot;:</span><br><span class="line">                return new PlasticProductB();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤4.</strong> 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void simpleFactory() &#123;</span><br><span class="line">        IPlasticProduct a &#x3D; PlasticFactory.factory(&quot;A&quot;);</span><br><span class="line">        if (a !&#x3D; null) &#123;</span><br><span class="line">            a.show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IPlasticProduct b &#x3D; PlasticFactory.factory(&quot;B&quot;);</span><br><span class="line">        if (b !&#x3D; null) &#123;</span><br><span class="line">            b.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">塑料产品A</span><br><span class="line">塑料产品B</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" itemprop="url">工厂方法模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T23:12:08+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</p>
<p>同种类称为同等级，工厂方法模式只考虑生产同等级的产品。</p>
<blockquote>
<p>工厂模式根据抽象程度的不同分为三种：简单工厂模式（也叫静态工厂模式）、工厂方法模式、以及抽象工厂模式。工厂模式是编程中经常用到的一种模式。</p>
</blockquote>
<p><strong>定义：</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-b36d05b634d25efd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>模式的结构</strong></p>
<ul>
<li><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</p>
</li>
<li><p>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</p>
</li>
<li><p>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</p>
</li>
<li><p>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p>
</li>
</ul>
<p><strong>说明：</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</p>
</li>
<li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
</li>
<li><p>可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。</p>
</li>
<li><p>对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。</p>
</li>
<li><p>降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
<p><strong>适用场景：</strong>工厂方法模式通常适用于以下场景:</p>
<ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌。</li>
</ul>
<h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><p>某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式， 现使用工厂方法模式设计该系统。</p>
<p><strong>步骤1：</strong> 创建<strong>抽象工厂类</strong>，定义具体工厂的公共接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ILogFactory &#123;</span><br><span class="line">    ILog createLog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：</strong> 创建<strong>抽象产品类</strong> ，定义具体产品的公共接口；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ILog &#123;</span><br><span class="line">    void writeLog(String log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：</strong> 创建<strong>具体产品类</strong>（继承抽象产品类）， 定义生产的具体产品；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FileLog implements ILog &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeLog(String log) &#123;</span><br><span class="line">        System.out.println(&quot;把日志写进文件 日志内容 &#x3D; &quot; + log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DatabaseLog implements ILog &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeLog(String log) &#123;</span><br><span class="line">        System.out.println(&quot;把日志写进数据库 日志内容 &#x3D; &quot; + log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：创建具体工厂类</strong>（继承抽象工厂类），定义创建对应具体产品实例的方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FileLogFactory implements ILogFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ILog createLog() &#123;</span><br><span class="line">        return new FileLog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DatabaseFactory implements ILogFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ILog createLog() &#123;</span><br><span class="line">        return new DatabaseLog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) &#123;</span><br><span class="line">        FileLogFactory fileLogFactory &#x3D; new FileLogFactory();</span><br><span class="line">        ILog fileLog &#x3D; fileLogFactory.createLog();</span><br><span class="line">        fileLog.writeLog(&quot;把日志写进文件&quot;);</span><br><span class="line">        DatabaseFactory databaseFactory &#x3D; new DatabaseFactory();</span><br><span class="line">        ILog databaseLog &#x3D; databaseFactory.createLog();</span><br><span class="line">        databaseLog.writeLog(&quot;把日记写进数据库&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把日志写进文件 日志内容 &#x3D; 把日志写进文件</span><br><span class="line">把日志写进数据库 日志内容 &#x3D; 把日记写进数据库</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T22:27:02+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>定义：</strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-bf75b274fdebee9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>单例三要素：</strong></p>
<ul>
<li>私有构造</li>
<li>私有静态引用指向自身实例</li>
<li>静态公有方法返回自身实例</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>在内存中只有一个对象，节省内存空间。</li>
<li>避免频繁的创建销毁对象，可以提高性能。</li>
<li>避免对共享资源的多重占用。</li>
<li>可以全局访问。</li>
</ul>
<p><strong>适用场景：</strong>由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。我总结了一下我所知道的适合使用单例模式的场景：</p>
<ul>
<li><p>需要频繁实例化然后销毁的对象。</p>
</li>
<li><p>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</p>
</li>
<li><p>有状态的工具类对象。</p>
</li>
<li><p>频繁访问数据库或文件的对象。</p>
</li>
<li><p>所有要求只有一个对象的场景。</p>
<p><strong>单例模式注意事项：</strong></p>
</li>
<li><p>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</p>
</li>
<li><p>不要做断开单例类对象与类中静态引用的危险操作。</p>
</li>
<li><p>多线程使用单例使用共享资源时，注意线程安全问题。</p>
</li>
</ul>
<p>通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。</p>
<p><strong>根据实例化对象时机的不同分为两种：</strong></p>
<ul>
<li>懒汉式单例：而懒汉式在<strong>在第一次调用的时候</strong>实例化自己。</li>
<li>饿汉式单例：饿汉式单例在<strong>类第一次加载时</strong>就实例化一个对象交给自己的引用。饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是<strong>线程安全的。</strong></li>
</ul>
<h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">			singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DCL-双检查锁机制"><a href="#DCL-双检查锁机制" class="headerlink" title="DCL 双检查锁机制"></a>DCL 双检查锁机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DclSingleton &#123;</span><br><span class="line">    private static volatile DclSingleton mInstance &#x3D; null;</span><br><span class="line">    private DclSingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static DclSingleton getInstance() &#123;</span><br><span class="line">        if (mInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (DclSingleton.class) &#123;</span><br><span class="line">                if (mInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mInstance &#x3D; new DclSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不足：JVM的即时编译器中存在指令重排序的优化</li>
<li>解决：将实例设置为Volatile</li>
<li>优化：静态内部类/枚举</li>
</ul>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerSingleton &#123;</span><br><span class="line">    private StaticInnerSingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static StaticInnerSingleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final StaticInnerSingleton sInstance &#x3D; new StaticInnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>运用类中静态变量的唯一性</li>
<li>JVM本身同步控制机制（final、static）保证了线程安全</li>
<li>没有使用Synchronized，保证了性能的优化</li>
<li>静态内部类是私有的，除了外部类其他是无法访问的</li>
</ul>
<h1 id="单例模式的对象长时间不用会被jvm垃圾收集器收集吗"><a href="#单例模式的对象长时间不用会被jvm垃圾收集器收集吗" class="headerlink" title="单例模式的对象长时间不用会被jvm垃圾收集器收集吗"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗</h1><h1 id="在一个jvm中会出现多个单例吗"><a href="#在一个jvm中会出现多个单例吗" class="headerlink" title="在一个jvm中会出现多个单例吗"></a>在一个jvm中会出现多个单例吗</h1><p>​    在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">Constructor ct = c.getDeclaredConstructor();</span><br><span class="line">ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = (Singleton)ct.newInstance();</span><br></pre></td></tr></table></figure>

<p>这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/UML/UML%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/UML/UML%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="url">UML中类的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T21:15:22+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UML/" itemprop="url" rel="index">
                    <span itemprop="name">UML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/10/UML/UML%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/10/UML/UML%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>类图知识点：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-3f8577784f7dfdc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>类图分为三部分，依次是类名、属性、方法</p>
</li>
<li><p>以&lt;&lt;开头和以&gt;&gt;结尾的为注释信息</p>
</li>
<li><p>修饰符+代表public，-代表private，#代表protected，什么都没有代表包可见。</p>
</li>
<li><p>带下划线的属性或方法代表是静态的。</p>
</li>
</ul>
<p>在java以及其他的面向对象设计模式中，类与类之间主要有6种关系，他们分别是：</p>
<ul>
<li>依赖</li>
<li>关联</li>
<li>聚合</li>
<li>组合</li>
<li>继承</li>
<li>实现</li>
</ul>
<p>他们的耦合度依次增强</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖<img src="https://upload-images.jianshu.io/upload_images/4118241-b8cac23467b8431c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h1><p><img src="https://upload-images.jianshu.io/upload_images/4118241-46ead55a043b1c3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。定义比较晦涩难懂，但在java中的表现还是比较直观的：<strong>类A当中使用了类B，其中类B是作为类A的方法参数、方法中的局部变量、或者静态方法调用</strong>。类上面的图例中：People类依赖于Book类和Food类，Book类和Food类是作为类中方法的参数形式出现在People类中的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class People&#123;</span><br><span class="line">    &#x2F;&#x2F;Book作为read方法的形参</span><br><span class="line">     public void read(Book book)&#123;</span><br><span class="line">        System.out.println(“读的书是”+book.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关联"><a href="#关联" class="headerlink" title="关联))"></a>关联<img src="https://upload-images.jianshu.io/upload_images/4118241-0df900778ab7f3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">)<img src="/Users/fengxing/blogs/source/image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%85%B3%E8%81%94.png" alt="image.png">)<img src="https://upload-images.jianshu.io/upload_images/4118241-3304f5652e0e10ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h1><ul>
<li>关联关系中作为成员变量的类一般会在类中赋值</li>
</ul>
<p><strong>双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</strong></p>
<p> 对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。关联关系分为单向关联和双向关联。在java中，单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。</p>
<p><strong>单项关联</strong></p>
<p><img src="https://img-blog.csdn.net/20160507192549756" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private Car car &#x3D; new Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>双向关联</strong></p>
<p><img src="https://img-blog.csdn.net/20160507192628366" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Husband&#123;</span><br><span class="line">    private Wife wife&#x3D;new Wife();</span><br><span class="line"></span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;my wife name:&quot;+wife.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Wife&#123;</span><br><span class="line">    private Husband husband&#x3D;new Husband();</span><br><span class="line"></span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;my husband name:&quot;+husband.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合<img src="https://upload-images.jianshu.io/upload_images/4118241-2e286214e4402d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h1><ul>
<li>从<code>set</code>方法中传递过来的叫聚合</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-16c2707d4666de18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class People&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    House house; </span><br><span class="line">    &#x2F;&#x2F;聚合关系中作为成员变量的类一般使用set方法赋值</span><br><span class="line">     public void setCar(Car car)&#123;</span><br><span class="line">        This.car &#x3D; car;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHouse(House house)&#123;</span><br><span class="line">        This.house &#x3D; house;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void driver()&#123;</span><br><span class="line">        System.out.println(“车的型号：”+car.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    public void sleep()&#123;</span><br><span class="line">        System.out.println(“我在房子里睡觉：”+house.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合<img src="https://upload-images.jianshu.io/upload_images/4118241-16bf5e2669ef869d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h1><ul>
<li>在构造方法中实例化其他类叫组合</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-a87c3182e0dd1052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。在下图的例子中，People与Soul、Body之间是组合关系，当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Public class People&#123;</span><br><span class="line">    Soul soul;</span><br><span class="line">    Body body; </span><br><span class="line">    &#x2F;&#x2F;组合关系中的成员变量一般会在构造方法中赋值</span><br><span class="line">     Public People(Soul soul, Body body)&#123; </span><br><span class="line">        This.soul &#x3D; soul;</span><br><span class="line">        This.body &#x3D; body;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Public void study()&#123;</span><br><span class="line">        System.out.println(“学习要用灵魂”+soul.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    Public void eat()&#123;</span><br><span class="line">        System.out.println(“吃饭用身体：”+body.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承<img src="https://upload-images.jianshu.io/upload_images/4118241-b67f94bc3650ad16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h1><p><img src="https://upload-images.jianshu.io/upload_images/4118241-b2e030a7da785f79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>​    继承表示类与类（或者接口与接口）之间的父子关系。在java中，用关键字extends表示继承关系。UML图例中，继承关系用实线+空心箭头表示，箭头指向父类。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现<img src="https://upload-images.jianshu.io/upload_images/4118241-6af21432d37bf5da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h1><p><img src="https://upload-images.jianshu.io/upload_images/4118241-a80ee9fdf19a635d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>​     表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作。在java中使用implements表示。UML图例中，实现关系用虚线+空心箭头表示，箭头指向接口。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" itemprop="url">代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T20:12:32+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>定义：</strong></p>
<p><strong>类型：</strong></p>
<p><strong>类图：</strong></p>
<p><strong>模式的结构：</strong></p>
<p><strong>解决的问题：</strong></p>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<p><strong>适用场景：</strong></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>结果：</strong></p>
<h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><h2 id="代理模式基本概念及分类"><a href="#代理模式基本概念及分类" class="headerlink" title="代理模式基本概念及分类"></a>代理模式基本概念及分类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img-blog.csdnimg.cn/20190601204007375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为其他对象提供一种代理以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理对象起到中介的作用，可去掉功能服务或增加额外的服务。负责为委托类预处理消息，过滤消息并将请求分派给委托类处理，以及进行消息被委托类执行后的后续操作。</p>
<p>例如火车票代售处是火车站的代理，相对于火车站，可以提供额外的服务，如电话预约，提供额外服务的同时，会收取一定金额的手续费。也可以将原有的功能去掉，如代售处不能提供退票服务。</p>
<h3 id="代理模式模型"><a href="#代理模式模型" class="headerlink" title="代理模式模型"></a>代理模式模型</h3><p>代理模式一般设计到角色有4 种：</p>
<ul>
<li><strong>抽象角色</strong>：对应代理接口（&lt;&lt; interface &gt;&gt;Subject），用来定义代理类和委托类的公共对外方法/接口；</li>
<li><strong>真实角色</strong>：对应委托类（接口实现类RealSubject），真正实现业务逻辑的类，是代理角色所代表的真实对象，是最终要引用的对象；</li>
<li><strong>代理角色</strong>：对应代理类（Proxy），用来代理和封装真实角色。代理角色内部含有对真实对象的引用，从而可以操作真实对象。同时，代理对象可以在执行真是对象操作时，添加或去除其他操作，相当于对真实对象进行封装；</li>
<li><strong>客户角色</strong>：对应客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190601204859723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在代理模式中真实角色对于客户端角色来说的透明的，也就是客户端不知道也无需知道真实角色的存在。 为了保持行为的一致性，代理角色和真实角色通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</p>
<p>通过代理角色这中间一层，能有效控制对真实角色（委托类对象）的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p>
<h3 id="代理模式特点"><a href="#代理模式特点" class="headerlink" title="代理模式特点"></a>代理模式特点</h3><h4 id="代理模式优点"><a href="#代理模式优点" class="headerlink" title="代理模式优点"></a>代理模式优点</h4><ul>
<li>隐藏委托类的实现，调用者只需要和代理类进行交互即可。</li>
<li>解耦，在不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作</li>
</ul>
<h2 id="代理模式实现方式"><a href="#代理模式实现方式" class="headerlink" title="代理模式实现方式"></a>代理模式实现方式</h2><p>根据代理类的<strong>生成时间</strong>不同可以将代理分为静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>所谓静态代理也就是在程序运行前就已经存在代理类的.class文件，代理类和委托类的关系在运行前就确定了。</p>
<p>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被代理对象Car</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car2 extends Car &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		super.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="聚合方式"><a href="#聚合方式" class="headerlink" title="聚合方式"></a>聚合方式</h4><p>聚合：在代理中引用被代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Car3 implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public Car3(Car car) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.car &#x3D; car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Car car;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		car.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式与聚合方式对比"><a href="#继承方式与聚合方式对比" class="headerlink" title="继承方式与聚合方式对比"></a>继承方式与聚合方式对比</h4><p>聚合方式比继承方式更适合代理模式：适合功能的叠加（可灵活传递，组合）。</p>
<p>记录日志代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CarLogProxy implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public CarLogProxy(Moveable m) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.m &#x3D; m;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Moveable m;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;日志开始....&quot;);</span><br><span class="line">		m.move();</span><br><span class="line">		System.out.println(&quot;日志结束....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录时间代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Car car &#x3D; new Car();</span><br><span class="line">	CarLogProxy clp &#x3D; new CarLogProxy(car);</span><br><span class="line">	CarTimeProxy ctp &#x3D; new CarTimeProxy(clp);</span><br><span class="line">	ctp.move();&#x2F;&#x2F;先记录日志后记录时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通过动态代理可实现对不同类、不同方法的代理。动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件（.class）。代理类和委托类的关系在程序运行时确定。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>实现模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190601211348201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>
<p><strong>Interface InvocationHandler</strong></p>
<p>InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，每次生成动态代理对象都邀制定一个对应的调用处理器对象，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object invoke(Object obj,Method method,Object[] args)</span><br></pre></td></tr></table></figure>

<p>在实际使用时，obj指代理类的实例，method指被代理的方法，args是该方法的参数数组。这个抽象方法在代理类中动态实现。</p>
<p>该方法也是InvocationHandler接口所定义的唯一的一个方法，该方法负责集中处理动态代理类上的所有方法的调用。调用处理器根据这三个参数进行预处理或分派到委托类实例上执行。</p>
<p><strong>Proxy class动态代理类</strong></p>
<p>Proxy是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>

<p>返回代理类的一个实例，返回后的代理类可以当做被代理类使用（可使用被代理类在接口中声明过的方法）</p>
<p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>步骤1：创建一个实现接口InvocationHandler的调用处理器，它必须实现invoke方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TimeHandler implements InvocationHandler &#123;</span><br><span class="line">&#x2F;&#x2F;动态代理类对应的调用处理程序类（时间处理器）</span><br><span class="line">	public TimeHandler(Object target) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.target &#x3D; target;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;代理类持有一个委托类的对象引用</span><br><span class="line">	private Object target;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * 参数：</span><br><span class="line">	 * proxy  被代理对象</span><br><span class="line">	 * method  被代理对象的方法</span><br><span class="line">	 * args 方法的参数</span><br><span class="line">	 * </span><br><span class="line">	 * 返回值：</span><br><span class="line">	 * Object  方法的返回值</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		method.invoke(target);&#x2F;&#x2F;调用被代理对象的方法（Car的move方法）</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimeHandler实现了InvocationHandler的invoke方法，当代理对象的方法被调用时，invoke方法会被回调。其中proxy表示实现了公共代理方法的动态代理对象。</p>
<p><strong>步骤2：创建被代理的类以及接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：调用Proxy的静态方法newProxyInstance，提供ClassLoader和代理接口类型数组动态创建一个代理类，并通过代理调用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端，使用代理类和主题接口完成功能</span><br><span class="line">public class Test &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * JDK动态代理测试类</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Car car &#x3D; new Car();</span><br><span class="line">		InvocationHandler h &#x3D; new TimeHandler(car);</span><br><span class="line">		Class&lt;?&gt; cls &#x3D; car.getClass();</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * loader  类加载器</span><br><span class="line">		 * interfaces  实现接口</span><br><span class="line">		 * h InvocationHandler</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Moveable m &#x3D; (Moveable)Proxy.newProxyInstance(cls.getClassLoader(),</span><br><span class="line">												cls.getInterfaces(), h);&#x2F;&#x2F;获得动态代理对象，动态代理对象与代理对象实现同一接口</span><br><span class="line">		m.move();&#x2F;&#x2F;调用动态代理的move方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过InvocationHandler handler=new TimeHandler(target);将委托对象作为构造方法的参数传递给了TimeHandler来作为代理方法调用的对象。当我们调用代理对象的move()方法时，该调用将会被转发到TimeHandler对象的invoke上从而达到动态代理的效果。</p>
<p>所谓动态代理是这样一种class：它是运行时生成的class，该class需要实现一组interface，使用动态代理类时，必须实现InvocationHandler接口</p>
<h3 id="静态代理与动态代理对比"><a href="#静态代理与动态代理对比" class="headerlink" title="静态代理与动态代理对比"></a>静态代理与动态代理对比</h3><h4 id="静态代理-1"><a href="#静态代理-1" class="headerlink" title="静态代理"></a>静态代理</h4><ul>
<li>优点：<br>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。</li>
<li>缺点：<ul>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
<li>采用静态代理模式，那么真实角色（委托类）必须事先已经存在的，并将其作为代理对象代理对象内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀。</li>
</ul>
</li>
</ul>
<h4 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h4><ul>
<li>优点<ul>
<li>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</li>
<li>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</li>
</ul>
</li>
<li>缺点<ul>
<li>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/" itemprop="url">merge与rebase区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T22:46:17+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看merge，官方文档给的说明是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-merge - Join two or more development histories together</span><br></pre></td></tr></table></figure>

<p>顾名思义，当你想要两个分支交汇的时候应该使用merge。</p>
<p>根据官方文档给的例子，是master merge topic，如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C topic</span><br><span class="line">         &#x2F;         \</span><br><span class="line">    D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>然而在实践中，在H这个commit上的merge经常会出现merge conflict。为了避免解决冲突的时候引入一些不必要的问题，工程中一般都会规定no conflict merge。比如你在github上发pull request，如果有conflict就会禁止merge。</p>
<p>这种情况下用merge当然是一个选项。用merge代表了topic分支与master分支交汇，并解决了所有合并冲突。<strong>然而merge的缺点是引入了一次不必要的history join。</strong>如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A--B--C-X topic</span><br><span class="line">       &#x2F;       &#x2F; \</span><br><span class="line">  D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>其实仔细想一下就会发现，<strong>在</strong>引入master分支的F、G commit这个问题上，<strong>我们并没有要求两个分支必须进行交汇(join)，我们只是想避免最终的merge conflict而已。</strong></p>
<p>rebase是另一个选项。rebase的含义是改变当前分支branch out的位置。这个时候进行rebase其实意味着，将topic分支branch out的位置从E改为G，如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       A---B---C topic</span><br><span class="line">             &#x2F;         </span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>在这个过程中会解决引入F、G导致的冲突，同时没有多余的history join。但是rebase的缺点是，<strong>改变了当前分支branch out的节点。</strong>如果这个信息对你很重要的话，那么rebase应该不是你想要的。rebase过程中也会有多次解决同一个地方的冲突的问题，不过可以用squash之类的选项解决。个人并不认为这个是rebase的主要问题。</p>
<p>综上，其实选用merge还是rebase取决于你到底是以什么意图来避免merge conflict。实践上个人还是偏爱rebase。一个是因为branch out节点不能改变的情况实在太少。另外就是频繁从master merge导致的冗余的history join会提高所有人的认知成本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/" itemprop="url">CodeReview代码审查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T21:43:53+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">项目管理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h1><h2 id="什么是Code-Review"><a href="#什么是Code-Review" class="headerlink" title="什么是Code Review?"></a>什么是Code Review?</h2><p>Code Review, 意即代码审查,是指一种有意识和系统的召集其他程序员来检查彼此的代码是否有错误的地方.</p>
<p>通常进行Code Review会有以下效果:</p>
<ul>
<li>提高代码质量和可维护性, 可读性等.</li>
<li>查漏补缺, 发现一些潜在的问题点等.</li>
<li>最佳实践, 能够更好更快的完成任务的方法.</li>
<li>知识分享, Review他人代码时, 其实也是一个学习的过程, 自己也会反思&amp;总结.</li>
</ul>
<h2 id="为什么要-Code-Review"><a href="#为什么要-Code-Review" class="headerlink" title="为什么要 Code Review?"></a>为什么要 Code Review?</h2><p>要不要Code Review, 需要结合当前的环境和形势来决定. 如果项目组开发任务极其紧张, 此时再进行Code Review可能会收到不利的效果. 因势利导,求同存异是Code Review的核心所在。</p>
<p>Code Review尤其需要和项目组成员沟通和配合, 同时也在检验各成员的技术水平.</p>
<blockquote>
<p>尤其需要注意的是, 人都有惰性, 每个人都有自己的一套行为准则和规范, 要想把他们的行为或规范统一起来, 很容易使他们产生抗拒心理.</p>
</blockquote>
<p>在Code Review之前, 和项目成员沟通好, 有一个共同的愿景, 并辅助以相应的培训, 把部分人员的短板补齐. 会减轻项目成员的一些不适感, 也会使得项目运行更加顺畅。</p>
<h2 id="Code-Review的前提条件"><a href="#Code-Review的前提条件" class="headerlink" title="Code Review的前提条件"></a>Code Review的前提条件</h2><p>Code Review本身属于”事后”工作, 可以起到查漏被缺的作用.</p>
<p>在推行Code Review时, 需要先提前准备以下几个工作, 以便团队能够更快更好的接受和实施.</p>
<ul>
<li>建立规范, 包含:<ul>
<li>编码规范, 如变量命名, 文件命名规范等</li>
<li>设计原则, 如单一职责原则, 最少知识原则等</li>
<li>分支管理策略</li>
</ul>
</li>
<li>完善的文档, 方便查阅. 文档内容最好能共建, 千万不可出现”一言堂”</li>
<li>制定Code Review流程&amp;目标, 以及实施周期.</li>
</ul>
<p>根据困难程度, Code Review实施分为3个阶段：</p>
<ul>
<li>第一阶段, 重点关注, 恰到好处的函数注释, “硬编码”问题, 常见变量命名规则等, 预期实施周期为1~3个月</li>
<li>第二阶段, 重点关注, 代码耦合性, 单一职责、最少知识原则, 潜在隐患, 性能问题等, 预期实施周期为3~6个月</li>
<li>第三阶段, 重点关注, 模块实现方案, 设计模式, 最佳实践, 代码重构等.</li>
</ul>
<p>在实施过程中, 如果遇到比较大的阻力或困难, 推行Code Review所得到的收益较低时, 可以考虑适当”休息”一段时间.</p>
<h2 id="Code-Review如何实施"><a href="#Code-Review如何实施" class="headerlink" title="Code Review如何实施?"></a>Code Review如何实施?</h2><p>从当前项目的实施过程的体会, 以及结合其他人的一些经验来看, 在Code Review时建议:</p>
<ul>
<li>单次查看代码不多于500行, 人的精力有限, 一次审查太多的代码, 收益可能不理想.</li>
<li>单次审查建议不要超过30分钟</li>
</ul>
<h2 id="常见的Code-Review项"><a href="#常见的Code-Review项" class="headerlink" title="常见的Code Review项"></a>常见的Code Review项</h2><h3 id="git使用规范"><a href="#git使用规范" class="headerlink" title="git使用规范"></a>git使用规范</h3><p>git commit提交规范, 如:</p>
<ul>
<li>不标注信息</li>
<li>不及时commit</li>
<li>提交时标注的信息不规范等</li>
</ul>
<p>都是严重阻扰review的因素之一,除了常规的描述信息外,还可以按类型等备注:</p>
<ul>
<li>feat: 新特性</li>
<li>fix: 修改问题</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>chore: 其他修改</li>
<li>test: 测试用例修改</li>
<li>style: 代码格式修改等等</li>
</ul>
<p>当然, 也要以利用一些工具, 来协助我们完成基本的约束和检查. 如: <a href="https://juejin.im/post/5de280cfe51d450f0a2006f1" target="_blank" rel="noopener">优雅的使用Git</a></p>
<h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><h4 id="1-可读性"><a href="#1-可读性" class="headerlink" title="1. 可读性"></a>1. 可读性</h4><p>衡量可读性, 有很好的实践标准, 即Code Review时能否非常容易的理解代码逻辑, 如果不能, 那意味着代码的可读性要进行改进.</p>
<h4 id="2-命名"><a href="#2-命名" class="headerlink" title="2. 命名"></a>2. 命名</h4><ul>
<li>命名对可读性非常重要, 我个人倾向于函数名/类名长一点都没关系, 但必须能清晰的表明函数/类的作用.</li>
<li>英语用词尽量准确, 哪怕需要借助翻译工具, 也是值得的. 但有一点需要注意, 如果使用的单词很冷门, 都没人认识, 那就不要使用.</li>
</ul>
<h4 id="3-函数体长度-类长度"><a href="#3-函数体长度-类长度" class="headerlink" title="3. 函数体长度/类长度"></a>3. 函数体长度/类长度</h4><ul>
<li>函数体太长, 不好阅读, 一般建议不要超过50行</li>
<li>类太长, 如超过10000行, 那可能就要看下是否违反了”单一职责”原则.</li>
</ul>
<h4 id="4-参数个数"><a href="#4-参数个数" class="headerlink" title="4. 参数个数"></a>4. 参数个数</h4><p>不要太多, 一般不要超过5个, 超过5个, 建议使用对象</p>
<h4 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h4><p>恰到好处的注释, 能够帮助我们理解函数/类的作用。</p>
<h3 id="架构-设计"><a href="#架构-设计" class="headerlink" title="架构/设计"></a>架构/设计</h3><h4 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h4><p>这是经常被违背的原则, 也是最难运用好的原则.</p>
<ul>
<li>一个类只做一类相关的事情</li>
<li>一个函数/方法, 最好只做一件事情</li>
</ul>
<h4 id="2-行为是否统一"><a href="#2-行为是否统一" class="headerlink" title="2. 行为是否统一"></a>2. 行为是否统一</h4><p>什么是行为统一? 例如:</p>
<ul>
<li>错误处理是否统一</li>
<li>错误提示是否统一</li>
<li>弹出框是否统一</li>
<li>…</li>
</ul>
<p>同一逻辑/行为, 有没有执行同样的代码路径:</p>
<ul>
<li><strong>低质量</strong>的代码一个特征是, 同一逻辑/行为, 在不同的地方或不同的方式触发时, 没有执行同样的代码路径(产生出不同的结果), 或者是各处copy一份实现, 导致非常难以维护。</li>
</ul>
<h4 id="3-代码污染"><a href="#3-代码污染" class="headerlink" title="3. 代码污染"></a>3. 代码污染</h4><p>代码有没有对其他模块强耦合</p>
<h4 id="4-重复代码"><a href="#4-重复代码" class="headerlink" title="4. 重复代码"></a>4. 重复代码</h4><p>主要看有没有把公用组件, 可复用的代码、函数抽取出来</p>
<h4 id="5-开放-封闭原则"><a href="#5-开放-封闭原则" class="headerlink" title="5. 开放-封闭原则"></a>5. 开放-封闭原则</h4><p>简单理解是, 看代码好不好扩展</p>
<h4 id="6-健壮性"><a href="#6-健壮性" class="headerlink" title="6. 健壮性"></a>6. 健壮性</h4><ul>
<li>核心数据有没有强制校验?</li>
<li>对业务有没有考虑完整, 逻辑是否健壮</li>
<li>有没有潜在的bug?</li>
<li>有没有内存泄露?有没有循环依赖?</li>
</ul>
<h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h4><p>有没有很好的Error Handling? 如网络出错, IO出错等。</p>
<h4 id="8-面向接口编程-面向对象接口编程"><a href="#8-面向接口编程-面向对象接口编程" class="headerlink" title="8. 面向接口编程/面向对象接口编程"></a>8. 面向接口编程/面向对象接口编程</h4><p>主要看有没有进行合适的抽象, 把一些行为抽象为接口</p>
<h4 id="9-效率-性能"><a href="#9-效率-性能" class="headerlink" title="9. 效率/性能"></a>9. 效率/性能</h4><ul>
<li><p>客户端程序对频繁的消息和较大数据等耗时操作是否处理得当</p>
</li>
<li><p>关键算法的时间复杂度是多少? 有没有潜在的性能瓶颈? </p>
</li>
</ul>
<h4 id="10-代码重构"><a href="#10-代码重构" class="headerlink" title="10. 代码重构"></a>10. 代码重构</h4><ul>
<li>新的改动是打补丁, 让代码质量继续恶化, 还是对代码质量提升有帮助?</li>
</ul>
<h3 id="低质量代码的常见特征"><a href="#低质量代码的常见特征" class="headerlink" title="低质量代码的常见特征"></a>低质量代码的常见特征</h3><ul>
<li>违反”单一职责”原则</li>
<li>同一逻辑/行为, 通过不同的方式触发时, 不会执行同样的代码路径</li>
<li>缺少注释</li>
<li>函数/类命名乱, 词不达意, 或”挂羊头卖狗肉”, 例如</li>
</ul>
<h3 id="下面推荐一些-Code-Review-工具："><a href="#下面推荐一些-Code-Review-工具：" class="headerlink" title="下面推荐一些 Code Review 工具："></a>下面推荐一些 Code Review 工具：</h3><ul>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.atlassian.com/software/crucible">Crucible</a>：</strong>Atlassian 内部代码审查工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.gerritcodereview.com/">Gerrit</a>：</strong>Google 开源的 git 代码审查工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/">GitHub</a>：</strong>程序员应该很熟悉了，上面的 “Pull Request” 在代码审查这里很好用；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//lgtm.com/">LGTM</a>：</strong>可用于 GitHub 和 Bitbucket 的 PR 代码安全漏洞和代码质量审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.phacility.com/phabricator/">Phabricator</a>：</strong>Facebook 开源的 git/mercurial/svn 代码审查工具； </li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.pullrequest.com/">PullRequest</a>：</strong>GitHub pull requests 代码审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//pullreminders.com/">Pull Reminders</a>：</strong>GitHub 上有 PR 需要你审核，该插件自动通过 Slack 提醒你；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//reviewable.io/">Reviewable</a>：</strong>基于 GitHub pull requests 的代码审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//sider.review/">Sider</a>：</strong>GitHub 自动代码审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.jetbrains.com/upsource/">Upsource</a>：</strong>JetBrain 内部部署的 git/mercurial/perforce/svn 代码审查工具。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/" itemprop="url">git项目管理规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T17:13:54+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git项目管理规范"><a href="#git项目管理规范" class="headerlink" title="git项目管理规范"></a>git项目管理规范</h1><p>试想遇到以下这些问题，你会采取怎样的方式去解决：</p>
<ul>
<li>需要线上某个历史版本的源码，直接在 develop 分支根据提交记录和时间找对应的节点？</li>
<li>线上版本出现严重 bug 需要紧急修复发版本，而你的项目就一个分支，上个版本发布之后已经有大量改动了，怎么办？</li>
<li>某个提交改动了部分代码，涉及到 10 几个文件，现在这个改动不需要了，此时要一个个找出这些文件然后再改回去么？</li>
<li>出现了一个 bug，之前好像处理过，但是现在忘了当初怎么处理的了，在一堆写着 “fix bug”、“update” 的提交记录中，如何找到当初那笔的提交？</li>
<li>某个功能本来准备发布的，现在突然决定这个版本不上了，现在要一处处找到之前的代码，然后再改回去？</li>
<li>……</li>
</ul>
<p>既然认同需要一份 Git 规范，那么这个规范需要规范哪些内容，解决哪些问题，又带来哪些好处呢？有以下几点：</p>
<p> <strong>分支管理：</strong></p>
<ul>
<li>代码提交在应该提交的分支</li>
<li>随时可以切换到线上稳定版本代码</li>
<li>多个版本的开发工作同时进行</li>
</ul>
<p><strong>提交记录的可读性</strong></p>
<ul>
<li>准确的提交描述，具备可检索性</li>
<li>合理的提交范围，避免一个功能就一笔提交</li>
<li>分支间的合并保有提交历史，且合并后结果清晰明了</li>
<li>避免出现过多的分叉</li>
</ul>
<p><strong>团队协作</strong></p>
<ul>
<li><p>明确每个分支的功用，做到对应的分支执行对应的操作</p>
</li>
<li><p>合理的提交，每次提交有明确的改动范围和规范的提交信息</p>
</li>
<li><p>使用 Git 管理版本迭代、紧急线上 bug fix、功能开发等任务</p>
<p>以上就是一份 Git 规范的作用和使命。</p>
</li>
</ul>
<p>Git-Flow 的经典流程图：</p>
<p><img src="https://jaeger.itscoder.com/img/postimg/git-flow.png" alt="img"></p>
<p><img src="https://ourai.ws/assets/posts/20160418/working-with-gitflow-efa631445317065fd85a17b314e91907ec6ef5e380460dd77a68aa60f91d95c4.png" alt="基于 Git Flow 的开发流程"></p>
<h2 id="分支管理规范"><a href="#分支管理规范" class="headerlink" title="分支管理规范"></a>分支管理规范</h2><h3 id="分支操作和说明"><a href="#分支操作和说明" class="headerlink" title="分支操作和说明"></a>分支操作和说明</h3><p><strong>master 分支</strong></p>
<ul>
<li>主分支，永远处于稳定状态，对应当前线上版本</li>
<li>以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本</li>
<li>不允许在该分支直接提交代码</li>
</ul>
<p><strong>develop 分支</strong></p>
<ul>
<li>开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行</li>
<li>小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行</li>
</ul>
<p><strong>注：</strong> 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险</p>
<p><strong>feature 分支</strong></p>
<ul>
<li>功能分支，开发新功能的分支</li>
<li>开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 <code>feature/xxx</code></li>
<li>开发完成后合并回 develop 分支并且删除该 feature/xxx 分支</li>
</ul>
<p><strong>release 分支</strong></p>
<ul>
<li>发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支</li>
<li>当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为<code>release/xxx</code></li>
<li>发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支</li>
</ul>
<p><strong>hotfix 分支</strong></p>
<ul>
<li>紧急修复线上 bug 分支</li>
<li>当线上版本出现 bug 时，从 master 分支切出一个 <code>hotfix/xxx</code> 分支，完成 bug 修复，然后将 <code>hotfix/xxx</code> 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 <code>hotfix/xxx</code> 分支</li>
</ul>
<p>以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下：</p>
<p><strong>小结</strong></p>
<ul>
<li>master 分支: 线上稳定版本分支</li>
<li>develop 分支: 开发分支，衍生出 feature 分支和 release 分支</li>
<li>release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除</li>
<li>feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除</li>
<li>hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除</li>
</ul>
<h3 id="分支间操作注意事项"><a href="#分支间操作注意事项" class="headerlink" title="分支间操作注意事项"></a>分支间操作注意事项</h3><h4 id="同一分支-git-pull-使用-rebase"><a href="#同一分支-git-pull-使用-rebase" class="headerlink" title="同一分支 git pull 使用 rebase"></a>同一分支 <code>git pull</code> 使用 <code>rebase</code></h4><p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_no_rebase.jpg" alt="img"></p>
<p>看到这样的  提交线图，想从中看出一条清晰的提交线几乎是不可能的，充满了 <code>Merge remote-tracking branch &#39;origin/xxx&#39; into xxx</code> 这样的提交记录，同时也将提交线弄成了交错纵横的图，没有了可读性。</p>
<p>这里最大的原因就是因为默认的 <code>git pull</code> 使用的是 merge 行为，当你更新代码时，如果本地存在未推送到远程的提交，就会产生一个这样的 merge 提交记录。因此在同一个分支上更新代码时推荐使用 <code>git pull --rebase</code>。</p>
<p>下面这张图展示了默认的 <code>git pull</code> 和 <code>git pull --rebase</code> 的结果差异，使用 <code>git pull --rebase</code> 目的是修整提交线图，使其形成一条直线。</p>
<p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_rebase_diff.jpg" alt="img"></p>
<p>使用<code>git pull</code>会产生<code>H</code>这个没必要的提交记录。</p>
<p>如果是执行 <code>git pull --rebase</code>的话，<code>C</code>和<code>D</code>这两个提交通过 <code>rebase</code> 方式重新拼接在 <code>G</code> 之后，多余的分叉去掉了，更加简洁清晰。</p>
<p>默认的 <code>git pull</code> 行为是 merge，可以进行如下设置修改默认的 <code>git pull</code> 行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 为某个分支单独设置，这里是设置 dev 分支</span><br><span class="line">git config branch.dev.rebase true</span><br><span class="line"># 全局设置，所有的分支 git pull 均使用 --rebase</span><br><span class="line">git config --global pull.rebase true</span><br><span class="line">git config --global branch.autoSetupRebase always</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要说明一下，在我看来使用 <code>git pull --rebase</code> 操作是比较好的，能够得到一条很清晰的提交直线图，方便查看提交记录和 code review，但是由于 rebase 会改变提交历史，也存在一些不好的影响。这里就不做过多的讨论了，有兴趣的话可以移步知乎上的讨论：<a href="https://www.zhihu.com/question/36509119" target="_blank" rel="noopener">在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？</a></p>
</blockquote>
<p><strong>小结</strong></p>
<p>大多数时候，使用 <code>git pull --rebase</code>是为了使提交线图更好看，从而方便 code review。</p>
<p>不过，如果你对使用 git 还不是十分熟练的话，我的建议是 <code>git pull --rebase</code>多练习几次之后再使用，因为 <strong>rebase 在 git 中，算得上是『危险行为』</strong>。</p>
<p>另外，还需注意的是，使用 <code>git pull --rebase</code>比直接 pull 容易导致冲突的产生，如果预期冲突比较多的话，建议还是直接 pull。</p>
<h4 id="分支合并使用-merge-no-ff"><a href="#分支合并使用-merge-no-ff" class="headerlink" title="分支合并使用 merge --no-ff"></a>分支合并使用 <code>merge --no-ff</code></h4><p>上述的 <code>git pull --rebase</code> 策略目的是修整提交线图，使其形成一条直线，而 <code>git merge --no-ff</code> 策略偏偏是反行其道，刻意地弄出提交线图分叉出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 例如当前在 develop 分支，需要合并 feature&#x2F;xxx 分支</span><br><span class="line">git merge --no-ff feature&#x2F;xxx</span><br></pre></td></tr></table></figure>

<p>在解释这个命令之前，先解释下 Git 中的 fast-forward： 举例来说，开发一直在 <code>develop</code> 分支进行，此时有个新功能需要开发，新建一个 <code>feature/a</code> 分支，并在其上进行一系列开发和提交。当完成功能开发时，此时回到 <code>develop</code> 分支，此时 <code>develop</code> 分支在创建 <code>feature/a</code> 分支之后没有产生任何的 commit，那么此时的合并就叫做 fast-forward。</p>
<p>fast-forward 合并的结果如下图所示，这种 merge 的结果就是一条直线了，无法明确看到切出一个新的 feature 分支，并完成了一个新的功能开发，因此此时比较推荐使用 <code>git merge --no-ff</code>，得到的结果就很明确知道，新的一系列提交是完成了一个新的功能，如果需要对这个功能进行 code review，那么只需要检视叉的那条线上的提交即可。</p>
<p><img src="https://jaeger.itscoder.com/img/postimg/git_merge_diff.svg" alt="img"></p>
<h3 id="项目分支操作流程示例"><a href="#项目分支操作流程示例" class="headerlink" title="项目分支操作流程示例"></a>项目分支操作流程示例</h3><p>这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。</p>
<p><strong>1. 切到 develop 分支，更新 develop 最新代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>

<p><strong>2. 新建 feature 分支，开发新功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;xxx</span><br><span class="line">...</span><br><span class="line">git add &lt;files&gt;</span><br><span class="line">git commit -m &quot;feat(xxx): commit a&quot;</span><br><span class="line">git commit -m &quot;feat(xxx): commit b&quot;</span><br><span class="line"># 其他提交</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 切换到 develop 分支并更新 develop 分支代码</span><br><span class="line">git checkout develop</span><br><span class="line">git pull --rebase</span><br><span class="line"></span><br><span class="line"># 切回 feature 分支</span><br><span class="line">git checkout feature&#x2F;xxx</span><br><span class="line">git rebase develop</span><br><span class="line"></span><br><span class="line"># 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！)</span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>

<p>上述场景也可以通过 <code>git cherry-pick</code> 来实现，有兴趣的可以去了解一下这个指令。</p>
<p><strong>3. 完成 feature 分支，合并到 develop 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 切到 develop 分支，更新下代码</span><br><span class="line">git check develop</span><br><span class="line">git pull --rebase</span><br><span class="line"></span><br><span class="line"># 合并 feature 分支</span><br><span class="line">git merge feature&#x2F;xxx --no-ff</span><br><span class="line"></span><br><span class="line"># 删除 feature 分支</span><br><span class="line">git branch -d feature&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 推到远端</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure>

<p><strong>4. 当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当前在 develop 分支</span><br><span class="line">git checkout -b release&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 在 release&#x2F;xxx 分支进行 bug fix</span><br><span class="line">git commit -m &quot;fix(xxx): xxxxx&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>5. 所有 bug 修复完成，准备发布新版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># master 分支合并 release 分支并添加 tag</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release&#x2F;xxx --no-ff</span><br><span class="line"># 添加版本标记，这里可以使用版本发布日期或者具体的版本号</span><br><span class="line">git tag 1.0.0</span><br><span class="line"></span><br><span class="line"># develop 分支合并 release 分支</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 删除 release 分支</span><br><span class="line">git branch -d release&#x2F;xxx</span><br></pre></td></tr></table></figure>

<p>至此，一个新版本发布完成。</p>
<p><strong>6. 线上出现 bug，需要紧急发布修复版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 当前在 master 分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"># 切出 hotfix 分支</span><br><span class="line">git checkout -b hotfix&#x2F;xxx</span><br><span class="line"></span><br><span class="line">... 进行 bug fix 提交</span><br><span class="line"></span><br><span class="line"># master 分支合并 hotfix 分支并添加 tag(紧急版本)</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff hotfix&#x2F;xxx --no-ff</span><br><span class="line"># 添加版本标记，这里可以使用版本发布日期或者具体的版本号</span><br><span class="line">git tag 1.0.1</span><br><span class="line"></span><br><span class="line"># develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支)</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff hotfix&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 删除 hotfix 分支</span><br><span class="line">git branch -d hotfix&#x2F;xxx</span><br></pre></td></tr></table></figure>

<p>至此，紧急版本发布完成。</p>
<h2 id="提交信息规范"><a href="#提交信息规范" class="headerlink" title="提交信息规范"></a>提交信息规范</h2><h3 id="分支说明和操作"><a href="#分支说明和操作" class="headerlink" title="分支说明和操作"></a>分支说明和操作</h3><p>git commit 格式 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<p>各个部分的说明如下：</p>
<ul>
<li><strong>Type的类别说明：</strong><ul>
<li><strong>feat</strong>: 新功能</li>
<li><strong>fix</strong>: 修复 bug</li>
<li><strong>docs</strong>: 文档变动</li>
<li><strong>style</strong>: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等</li>
<li><strong>refactor</strong>: bug 修复和添加新功能之外的代码改动</li>
<li><strong>perf</strong>: 提升性能的改动</li>
<li><strong>test</strong>: 添加或修正测试代码</li>
<li><strong>chore</strong>: 构建过程或辅助工具和库（如文档生成）的更改</li>
</ul>
</li>
<li><strong>scope 修改范围：</strong><ul>
<li>主要是这次修改涉及到的部分，简单概括，例如 login、train-order</li>
</ul>
</li>
<li><strong>subject 修改的描述：</strong><ul>
<li>具体的修改描述信息</li>
</ul>
</li>
</ul>
<p><strong>范例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feat(detail): 详情页修改样式</span><br><span class="line">fix(login): 登录页面错误处理</span><br><span class="line">test(list): 列表页添加测试代码</span><br></pre></td></tr></table></figure>

<p>这里对提交规范加几点说明：</p>
<ul>
<li><code>type + scope</code> 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。</li>
<li><code>subject</code> 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。</li>
<li>避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 <code>git commit --amend</code> 指令追加改动，尽量避免重复的提交信息。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/" itemprop="url">git命令集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T14:32:33+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除</span></span><br><span class="line">git rm -r *  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line">#使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点，为了保证版本演进的清晰。</span><br><span class="line">git merge --no-ff</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"># 一次转移多个提交</span><br><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br><span class="line">#如果想要转移一系列的连续提交，可以使用下面的简便语法。不包括A</span><br><span class="line">$ git cherry-pick A..B </span><br><span class="line">#注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</span><br><span class="line">git cherry-pick A^..B </span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 查看所有暂存</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件 global是全局配置</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line"></span><br><span class="line"># 为某个分支单独设置，这里是设置 dev 分支</span><br><span class="line">git config branch.dev.rebase true</span><br><span class="line"># 全局设置，所有的分支 git pull 均使用 --rebase</span><br><span class="line">git config --global pull.rebase true</span><br><span class="line">git config --global branch.autoSetupRebase always</span><br><span class="line"></span><br><span class="line"># 删除全局代理</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="提交数统计"><a href="#提交数统计" class="headerlink" title="提交数统计"></a>提交数统计</h3><p>统计提交(commit)次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="统计每个人增删行数"><a href="#统计每个人增删行数" class="headerlink" title="统计每个人增删行数"></a>统计每个人增删行数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format&#x3D;&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author&#x3D;&quot;$name&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fengxing	added lines: 56705, removed lines: 21012, total lines: 35693</span><br><span class="line">jiaozhegang	added lines: 10477, removed lines: 10156, total lines: 321</span><br><span class="line">unknown	added lines: 10469, removed lines: 14, total lines: 10455</span><br><span class="line">wangkai	added lines: 5, removed lines: 4, total lines: 1</span><br><span class="line">zhangyun	added lines: 33495, removed lines: 8966, total lines: 24529</span><br><span class="line">zrj	added lines: 7841, removed lines: 15648, total lines: -7807</span><br><span class="line">冯海超	added lines: 2, removed lines: 1, total lines: 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">71012679	added lines: 2, removed lines: 2, total lines: 0</span><br><span class="line">chouyanhejiutangtou	added lines: 8979, removed lines: 1925, total lines: 7054</span><br><span class="line">fengxing	added lines: 26709, removed lines: 7520, total lines: 19189</span><br><span class="line">unknown	added lines: , removed lines: , total lines:</span><br><span class="line">wangkai	added lines: 17284, removed lines: 8779, total lines: 8505</span><br><span class="line">zhangyun	added lines: 22444, removed lines: 6506, total lines: 15938</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git log 参数说明：<br>–author 指定作者<br>–stat 显示每次更新的文件修改统计信息，会列出具体文件列表<br>–shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：<br>–numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：<br>-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新<br>例如：git log -p -2<br>–name-only 仅在提交信息后显示已修改的文件清单<br>–name-status 显示新增、修改、删除的文件清单<br>–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符<br>–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）<br>–graph 显示 ASCII 图形表示的分支合并历史<br>–pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）<br>例如： git log –pretty=oneline ; git log –pretty=short ; git log –pretty=full ; git log –pretty=fuller<br>–pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析<br>例如：git log –pretty=format:””%h - %an, %ar : %s””<br>下面列出了常用的格式占位符写法及其代表的意义。<br>选项 说明<br>%H 提交对象（commit）的完整哈希字串<br>%h 提交对象的简短哈希字串<br>%T 树对象（tree）的完整哈希字串<br>%t 树对象的简短哈希字串<br>%P 父对象（parent）的完整哈希字串<br>%p 父对象的简短哈希字串<br>%an 作者（author）的名字<br>%ae 作者的电子邮件地址<br>%ad 作者修订日期（可以用 -date= 选项定制格式）<br>%ar 作者修订日期，按多久以前的方式显示<br>%cn 提交者(committer)的名字<br>%ce 提交者的电子邮件地址<br>%cd 提交日期<br>%cr 提交日期，按多久以前的方式显示<br>%s 提交说明<br>–since 限制显示输出的范围，<br>例如： git log –since=2.weeks 显示最近两周的提交<br>选项 说明<br>-(n) 仅显示最近的 n 条提交<br>–since, –after 仅显示指定时间之后的提交。<br>–until, –before 仅显示指定时间之前的提交。<br>–author 仅显示指定作者相关的提交。<br>–committer 仅显示指定提交者相关的提交。</p>
</blockquote>
<h3 id="查看git上的个人代码量："><a href="#查看git上的个人代码量：" class="headerlink" title="查看git上的个人代码量："></a>查看git上的个人代码量：</h3><p>使用的使用把<code>fengxing</code>换成自己的用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;&quot;fengxing&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -</span><br></pre></td></tr></table></figure>

<h3 id="代码总行数"><a href="#代码总行数" class="headerlink" title="代码总行数"></a>代码总行数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . &quot;(&quot; -name &quot;*.java&quot; &quot;)&quot; -print | xargs wc -l</span><br></pre></td></tr></table></figure>

<h3 id="贡献者统计"><a href="#贡献者统计" class="headerlink" title="贡献者统计"></a>贡献者统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort -u | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="查看仓库提交者排名前-5"><a href="#查看仓库提交者排名前-5" class="headerlink" title="查看仓库提交者排名前 5"></a>查看仓库提交者排名前 5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure>

<h3 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -sn</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
