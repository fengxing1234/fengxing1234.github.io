<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git_md/git%E5%91%BD%E4%BB%A4%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git_md/git%E5%91%BD%E4%BB%A4%E9%9B%86/" itemprop="url">git命令集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T14:32:33+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git_md/git%E5%91%BD%E4%BB%A4%E9%9B%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git_md/git%E5%91%BD%E4%BB%A4%E9%9B%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>





<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>





<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="提交数统计"><a href="#提交数统计" class="headerlink" title="提交数统计"></a>提交数统计</h3><p>统计提交(commit)次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="统计每个人增删行数"><a href="#统计每个人增删行数" class="headerlink" title="统计每个人增删行数"></a>统计每个人增删行数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format&#x3D;&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author&#x3D;&quot;$name&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fengxing	added lines: 56705, removed lines: 21012, total lines: 35693</span><br><span class="line">jiaozhegang	added lines: 10477, removed lines: 10156, total lines: 321</span><br><span class="line">unknown	added lines: 10469, removed lines: 14, total lines: 10455</span><br><span class="line">wangkai	added lines: 5, removed lines: 4, total lines: 1</span><br><span class="line">zhangyun	added lines: 33495, removed lines: 8966, total lines: 24529</span><br><span class="line">zrj	added lines: 7841, removed lines: 15648, total lines: -7807</span><br><span class="line">冯海超	added lines: 2, removed lines: 1, total lines: 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">71012679	added lines: 2, removed lines: 2, total lines: 0</span><br><span class="line">chouyanhejiutangtou	added lines: 8979, removed lines: 1925, total lines: 7054</span><br><span class="line">fengxing	added lines: 26709, removed lines: 7520, total lines: 19189</span><br><span class="line">unknown	added lines: , removed lines: , total lines:</span><br><span class="line">wangkai	added lines: 17284, removed lines: 8779, total lines: 8505</span><br><span class="line">zhangyun	added lines: 22444, removed lines: 6506, total lines: 15938</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git log 参数说明：<br>–author 指定作者<br>–stat 显示每次更新的文件修改统计信息，会列出具体文件列表<br>–shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：<br>–numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：<br>-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新<br>例如：git log -p -2<br>–name-only 仅在提交信息后显示已修改的文件清单<br>–name-status 显示新增、修改、删除的文件清单<br>–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符<br>–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）<br>–graph 显示 ASCII 图形表示的分支合并历史<br>–pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）<br>例如： git log –pretty=oneline ; git log –pretty=short ; git log –pretty=full ; git log –pretty=fuller<br>–pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析<br>例如：git log –pretty=format:””%h - %an, %ar : %s””<br>下面列出了常用的格式占位符写法及其代表的意义。<br>选项 说明<br>%H 提交对象（commit）的完整哈希字串<br>%h 提交对象的简短哈希字串<br>%T 树对象（tree）的完整哈希字串<br>%t 树对象的简短哈希字串<br>%P 父对象（parent）的完整哈希字串<br>%p 父对象的简短哈希字串<br>%an 作者（author）的名字<br>%ae 作者的电子邮件地址<br>%ad 作者修订日期（可以用 -date= 选项定制格式）<br>%ar 作者修订日期，按多久以前的方式显示<br>%cn 提交者(committer)的名字<br>%ce 提交者的电子邮件地址<br>%cd 提交日期<br>%cr 提交日期，按多久以前的方式显示<br>%s 提交说明<br>–since 限制显示输出的范围，<br>例如： git log –since=2.weeks 显示最近两周的提交<br>选项 说明<br>-(n) 仅显示最近的 n 条提交<br>–since, –after 仅显示指定时间之后的提交。<br>–until, –before 仅显示指定时间之前的提交。<br>–author 仅显示指定作者相关的提交。<br>–committer 仅显示指定提交者相关的提交。</p>
</blockquote>
<h3 id="查看git上的个人代码量："><a href="#查看git上的个人代码量：" class="headerlink" title="查看git上的个人代码量："></a>查看git上的个人代码量：</h3><p>使用的使用把<code>fengxing</code>换成自己的用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;&quot;fengxing&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -</span><br></pre></td></tr></table></figure>

<h3 id="代码总行数"><a href="#代码总行数" class="headerlink" title="代码总行数"></a>代码总行数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . &quot;(&quot; -name &quot;*.java&quot; &quot;)&quot; -print | xargs wc -l</span><br></pre></td></tr></table></figure>

<h3 id="贡献者统计"><a href="#贡献者统计" class="headerlink" title="贡献者统计"></a>贡献者统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort -u | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="查看仓库提交者排名前-5"><a href="#查看仓库提交者排名前-5" class="headerlink" title="查看仓库提交者排名前 5"></a>查看仓库提交者排名前 5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure>






          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/%E7%BA%A2%E9%BB%91%E6%A0%91/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-08T22:14:09+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/08/%E7%BA%A2%E9%BB%91%E6%A0%91/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/08/%E7%BA%A2%E9%BB%91%E6%A0%91/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是特殊的二叉查找树，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/%E9%80%92%E5%BD%92/" itemprop="url">递归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-08T14:47:12+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/08/%E9%80%92%E5%BD%92/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/08/%E9%80%92%E5%BD%92/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>【版权申明】未经博主同意，不允许转载！（请尊重原创，博主保留追究权）<br><a href="http://blog.csdn.net/javazejian/article/details/53452971" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/53452971</a><br>出自<a href="http://blog.csdn.net/javazejian" target="_blank" rel="noopener">【zejian的博客】</a></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="# 递归"></a># 递归</h2><h2 id="汉诺塔的问题"><a href="#汉诺塔的问题" class="headerlink" title="汉诺塔的问题"></a>汉诺塔的问题</h2><p>游戏的规则如下，有三根细柱（A、B、C），A柱上套着6个圆盘，圆盘的大小都不一样，它们按照从大到小的顺序自下而上地摆放，现在我们需要把A柱上的圆盘全部移动到B柱上去，并且在移动时有如下约定：</p>
<ul>
<li><p>一次只能移动柱子最上端的一个圆盘。</p>
</li>
<li><p>小圆盘上不能放大圆盘</p>
</li>
<li><p>一次只能移动柱子最上端的一个圆盘。</p>
</li>
<li><p>小圆盘上不能放大圆盘</p>
</li>
</ul>
<p>此时约定将一个圆盘从一根柱子移动另一根柱子算移动“1”次，那么将6个圆盘全部从A移动到B至少需要移动多少次呢？模型如下图：</p>
<p><img src="https://img-blog.csdn.net/20161210103510175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  图虽然很清晰，但我们依然无法立即找到特别清晰的解法，既然如此，我们就尝试先把问题的规模缩小点，把6个圆盘改为3个圆盘，先找出3层汉诺塔的解法，模型变为下图:</p>
<p><img src="https://img-blog.csdn.net/20161210154208276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  3层汉诺塔的解法就相对来说简单多了，我们要把3个圆盘全部从A移动到B，只需要先将最小的圆盘从A移动到B，然后将次小的圆盘从A移动到C，接着再把最小的圆盘从B移动到C，然后把最大的圆盘从A移动到B，接着把最小盘从C移动到A，在把次小盘从C移动到B，最后把最小盘从A移动到B即可，这样我们就完成了3此汉诺塔的解法了。这里我们把3个圆盘从小到大分别设为a,b,c，那么其移动过程如下：</p>
<p><img src="https://img-blog.csdn.net/20161210164705998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="汉诺塔"></p>
<p>  从上图中，我们很容易理解3层汉诺塔的解法，但是细想一下会发现这7次动中我们好像在做重复的事情：移动圆盘，只不过方向时而不同罢了。重新回顾一下①②③④⑤⑥⑦的移动过程，然后把它们分为如下3种情况：</p>
<ul>
<li>在①②③中，移动了3次将2个圆盘从A柱移动到了C柱</li>
<li>在④中，将最大的圆盘从A柱移动到了B柱</li>
<li>在⑤⑥⑦中，移动了3次将2个圆盘从C柱移动到了B柱</li>
</ul>
<p>我们发现这个过程移动的操作是几乎一样的，只不过是移动的方向不同了，A-&gt;C和C-&gt;B两种，其过程如下图：</p>
<p><img src="https://img-blog.csdn.net/20161211122622873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="3层汉诺塔解法"></p>
<p>  从图确实可以看出虽然两次移动的目的地不相同，但是两次移动的操作却是非常相似的，而且我们发现如果把3次移动看成是“移动2个圆盘”的操作就是“2层汉诺塔的解法”，也就是说在解决3层汉诺塔的过程中，我们使用了“2层汉诺塔的解法“。既然如此，那是不是意味着解决”4层汉诺塔“的过程中可以使用解决”3层汉诺塔的解法“呢？嗯，确实是如此的，这就是汉诺塔的解法规律，没错，我们已经发现这种规律！这样的话，我们解决前面的6层汉诺塔的问题时，只需要先解决5层汉诺塔的问题，然后利用5层汉诺塔的解法来解决6层汉诺塔的问题即可！我们来看看利用5层汉诺塔解出6层汉诺塔的过程，如下：</p>
<p><img src="https://img-blog.csdn.net/20161211160052027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  从图中我们可以看出（a）和（c）就是5层汉诺塔的解法，为了解出6层汉诺塔需要使用到5层汉诺塔的解法，因此只要5层汉诺塔被解出，6层汉诺塔也就迎刃而解了。而5层汉诺塔的解法呢？没错利用我们前面发现的规律，用4层汉诺塔的解法去解出5层汉诺塔，如下过程：</p>
<ul>
<li>①.先将4个圆盘从A柱移动到C柱，即解出4层汉诺塔</li>
<li>②.然后再将最大的圆盘(5个中最大的圆盘)从A柱移动到B柱</li>
<li>③.最后将4个圆盘从C柱移动到B柱，即再次利用解出的4层汉诺塔</li>
</ul>
<p>这样5层汉诺塔就被解出了，而4层汉诺塔则可以利用同样的解法即使用3层汉诺塔的解法，3层汉诺塔再利用2层汉诺塔的解法……..依次类推即可，到此便已解出6层汉诺塔，实际上我们知道有了6层汉诺塔的解法自然就可以很轻松地解出7层汉诺塔，8层汉诺塔…….N层汉诺塔，也很容易发现这种利用已知的N-1层的解法来解决N层的问题的解题方式，它们每一层的解法结构都是相同即利用前一个已解决的问题结果来解决后一个问题。通过这种思考的方式，我们来总结一下N层汉诺塔的解法，不再使用具体的ABC三根柱子，而是将它们设为x、y、z。这样的话，x、y、z在不同的情况下会不固定对应ABC中的某一根。这里以x为起点柱，y为目标柱，z为中转柱，然后给出解出N层汉诺塔的过程。利用z柱将n个圆盘从x柱转移到y柱的解法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Blog :http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian[原文地址]</span><br><span class="line">&#x2F;**</span><br><span class="line">当 n&#x3D;0时，无需任何移动</span><br><span class="line">当 n&gt;0时，</span><br><span class="line">    ①将n-1个圆盘从x柱，经y柱中转，移动到z柱(即解出n-1层汉诺塔)</span><br><span class="line">    ②然后将1个圆盘从x柱移动到y柱(最大的圆盘)</span><br><span class="line">    ③最后将n-1个圆盘从z柱，经x中转移动到y柱(即解出n-1层汉诺塔) </span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure>

<p>  从上述过程可知为了解出n层汉诺塔，我们同样需要先解出n-1层汉诺塔，为更通用地表示解出n层汉诺塔的移动次数，将其设为H(n)。利用上述步骤，则有如下关系：</p>
<p><img src="https://img-blog.csdn.net/20161212091951958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  在数学上我们将这种H(n)和H(n-1)的关系式取了个名称，叫做递推公式，即已知H(0),由H(n-1)构成H(n)的方法也必然是已知的，只要依次计算便可以得出，如6层汉诺塔的递推过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Blog :http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian[原文地址]</span><br><span class="line">&#x2F;**</span><br><span class="line">    H(0)&#x3D;0                     &#x3D; 1-1</span><br><span class="line">    H(1)&#x3D;H(0)+1+H(0) &#x3D; 1       &#x3D; 2-1</span><br><span class="line">    H(2)&#x3D;H(1)+1+H(1) &#x3D; 3       &#x3D; 4-1</span><br><span class="line">    H(3)&#x3D;H(2)+1+H(2) &#x3D; 7       &#x3D; 8-1</span><br><span class="line">    H(4)&#x3D;H(3)+1+H(3) &#x3D; 15      &#x3D; 16-1</span><br><span class="line">    H(5)&#x3D;H(4)+1+H(4) &#x3D; 31      &#x3D; 32-1</span><br><span class="line">    H(6)&#x3D;H(5)+1+H(5) &#x3D; 63      &#x3D; 64-1</span><br><span class="line">    .......                    &#x3D; .........</span><br><span class="line">    H(n)&#x3D;H(n-1)+1+H(n-1)       &#x3D; 2^n -1</span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure>

<p>  这样我们也就知道了6层次汉诺塔的最少移动次数为63次（关于2^n-1的公式只是总结出更为简单的计算方式罢了）。到此我们来重新梳理一下汉诺塔的整个解题过程，在解出6层汉诺塔前，我们由于一时找不到解决的方法，因此先尝试解出更为简单3层汉诺塔的，而在这个过程中，我们慢慢发现了解决汉诺塔问题的通用规律，即使用n-1层的解法来解决n层汉诺塔的思考方式,通过这种思考方式最终成功地解决了6层汉诺塔的问题。而实际上我们利用的这种思考方式的本质就是<strong>将复杂的问题转换为较为简单的同类问题(回忆一下汉诺塔的问题解法)然后再找出解决方法最终利用简单同类问题解出复杂问题的过程，而这种思维的方式就是递归</strong>！！是的，没错！递归不是算法而是一种思考的思维方式，只不过我们将这种递归思维方式采用程序来解决时，该程序被称为递归算法罢了，而递归本身是一种思考问题的思维方式！到此我们对递归是否有些焕然大悟的感觉呢？或对递归有些许的理解了吧？</p>
<h1 id="递归的思维方式"><a href="#递归的思维方式" class="headerlink" title="递归的思维方式"></a>递归的思维方式</h1><p>  有了上述的分析，我们就可以这样去理解和使用递归，假设现在碰到了一个很复杂的难题，我们也明白‘简单问题易解’的道理，那么此时就可以利用类似于汉诺塔的解题的思考方式，即<strong>判断能否将目前复杂的问题转换为较为简单的同类问题呢？</strong>可以的话，就先转换为简单同类的问题来解决，然后再利用简单的同类问题解法来解决复杂的同类问题，这就恰恰就是递归思维方式的精髓所在，嗯，这就是递归！大家现在是不是已开始理解递归了呢？我们在回顾一下汉诺塔问题的解法，以便加深对递归的理解，如下图：</p>
<p><img src="https://img-blog.csdn.net/20161211190832510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  上图很清晰表现出n层汉诺塔的解法过程，通过复杂问题化为同类简单问题来求解，<strong>上述的图形还有一个名称叫做递归结构</strong>，根据该结构我们就可以建立起之前H(n)递推公式了，很显然发现递归结构并建立递推公式的过程十分重要，这样有助于我们把握本质问题即通过n-1层汉诺塔的解法来解决n层汉诺塔的问题，这样的发现能力需要我们有比较敏锐的洞察力和思维能力，这就需要我们再遇到复杂问题时，多采用递归的思维（复杂问题简单化）方式去思考，去挖掘规律。ok~，到此相信我们对递归已有比较清晰的了解了吧。接下来我们看看如何使用程序来实现递归算法并解决汉诺塔的问题。</p>
<h2 id="汉诺塔的递归算法程序实现"><a href="#汉诺塔的递归算法程序实现" class="headerlink" title="汉诺塔的递归算法程序实现"></a>汉诺塔的递归算法程序实现</h2><p>  通过前面的分析，我们明白所谓的递归不过就是把复杂问题简单化的思维方式，而这种思维方式从程序语言的角度出发则称为递归算法，它通过程序的函数方法直接或者间接调用函数自身的过程，回忆一下前面分析汉诺塔的递推公式：H(n)=H(n-1)+1+H(n+1)</p>
<p>我们通过程序的递归算法实现汉诺塔如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.zejian.structures.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Created by zejian on 2016&#x2F;12&#x2F;11.</span><br><span class="line">* Blog : http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian [原文地址,请尊重原创]</span><br><span class="line">* 汉诺塔的递归算法实现</span><br><span class="line">*&#x2F;</span><br><span class="line">public class HanoiRecursion &#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * @param n 汉诺塔的层数</span><br><span class="line">  * @param x x柱 起点柱(A)</span><br><span class="line">  * @param y y柱 目标柱(B)</span><br><span class="line">  * @param z z柱 中转柱(C)</span><br><span class="line">  * 其中 A B C 只是作为辅助思考</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public void hanoi(int n, char x ,char y ,char z)&#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;H(0)&#x3D;0</span><br><span class="line">     if (n&#x3D;&#x3D;0)&#123;</span><br><span class="line">         &#x2F;&#x2F;什么也不做</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         &#x2F;&#x2F;递推公式：H(n)&#x3D;H(n-1) + 1 + H(n-1)</span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从x移动到z,y为中转柱</span><br><span class="line">         hanoi(n-1,x,z,y); &#x2F;&#x2F;-----------------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;移动最大圆盘到目的柱</span><br><span class="line">         System.out.println(x+&quot;-&gt;&quot;+y);&#x2F;&#x2F;------------&gt; 1</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从z移动到y,x为中转柱</span><br><span class="line">         hanoi(n-1,z,y,x);&#x2F;&#x2F;------------------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * @param n 汉诺塔的层数</span><br><span class="line">  * @param x x柱 起点柱(A)</span><br><span class="line">  * @param y y柱 目标柱(B)</span><br><span class="line">  * @param z z柱 中转柱(C)</span><br><span class="line">  * 其中 A B C 只是作为辅助思考</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public int hanoiCount(int n, char x ,char y ,char z)&#123;</span><br><span class="line">     int moveCount&#x3D;0;</span><br><span class="line">     &#x2F;&#x2F;H(0)&#x3D;0</span><br><span class="line">     if (n&#x3D;&#x3D;0)&#123;</span><br><span class="line">         &#x2F;&#x2F;什么也不做</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         &#x2F;&#x2F;递推公式：H(n)&#x3D;H(n-1) + 1 + H(n-1)</span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从x移动到z,y为中转柱</span><br><span class="line">         moveCount +&#x3D; hanoiCount(n-1,x,z,y); &#x2F;&#x2F;-------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;移动最大圆盘到目的柱</span><br><span class="line">         moveCount +&#x3D; 1; &#x2F;&#x2F;---------------------------------&gt; 1</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从z移动到y,x为中转柱</span><br><span class="line">         moveCount +&#x3D;hanoiCount(n-1,z,y,x);&#x2F;&#x2F;---------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return moveCount;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;测试</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">     HanoiRecursion hanoi&#x3D;new HanoiRecursion();</span><br><span class="line">     System.out.println(&quot;moveCount&#x3D;&quot;+hanoi.hanoiCount(6,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;));</span><br><span class="line"></span><br><span class="line">     hanoi.hanoi(3,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以发现递归算法的踪影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*Blog : http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian [原文地址,请尊重原创]</span><br><span class="line">*&#x2F;</span><br><span class="line">public void hanoi(int n, char x ,char y ,char z)&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;H(0)&#x3D;0</span><br><span class="line">   if (n&#x3D;&#x3D;0)&#123;</span><br><span class="line">       &#x2F;&#x2F;什么也不做</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">       &#x2F;&#x2F;调用自身函数hanoi()</span><br><span class="line">       hanoi(n-1,x,z,y);</span><br><span class="line">       &#x2F;&#x2F;移动最大圆盘到目的柱</span><br><span class="line">       System.out.println(x+&quot;-&gt;&quot;+y);</span><br><span class="line">       &#x2F;&#x2F;调用自身函数hanoi()</span><br><span class="line">       hanoi(n-1,z,y,x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  因此到此我们也就明白了，<strong>递归思维在程序中的体现即为递归算法，而递归算法本身在程序内部的实现就是函数调用自身函数</strong>，这样大家总该理解递归算法了吧。这里有点要提醒大家的是，<strong>不要陷入程序递归的内部去思考递归算法，记住要从递归思维的本质(复杂问题简单化)出发去理解递归算法，千万不要去通过试图解析程序执行的每一个步骤来理解递归（解析程序的执行是指给函数一个真实值，然后自己一步步去推出结果，这样的思考方式是错误的！），那样只会让自己得到伪理解(没有真正理解)的结果</strong>。记住！<strong>递归并不是算法，是一种复杂问题简单化的思维方式，而这种思维方式在程序中的体现就递归算法</strong>！递归算法在实现上就是函数不断调用自身的过程！</p>
<h1 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h1><p>递归的定义(从数学的角度)：用一个概念的本身直接定义自己。如阶乘函数F(n)=n!可以定义为：</p>
<p><img src="https://img-blog.csdn.net/20161211210225754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p>关于阶乘这里简单说明一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">阶乘是什么？</span><br><span class="line">1 x 2 x 3 x 4 x 5 &#x3D; 5!</span><br><span class="line">这里的5!就称为5的阶乘，之所以称为阶乘是因为乘数呈阶梯状递减而得名，如下：</span><br><span class="line">5! &#x3D; 5 x 4 x 3 x 2 x 1 &#x3D; 120</span><br><span class="line">4! &#x3D; 4 x 3 x 2 x 1 &#x3D; 24</span><br><span class="line">3! &#x3D; 3 x 2 x 1 &#x3D; 6</span><br><span class="line">2! &#x3D; 2 x 1 &#x3D; 2</span><br><span class="line">1! &#x3D; 1 &#x3D; 1</span><br><span class="line">0! &#x3D; 1</span><br><span class="line">注意0的阶乘0！被定义为1，这是数学里的规定。</span><br><span class="line">n的阶乘如下：</span><br><span class="line">n!&#x3D; n x (n-1) x (n-2) x … x 2 x 1</span><br><span class="line">很显然n!是一种递推公式，也符合递归思维，因此有：</span><br><span class="line">当n&#x3D;0时，n! &#x3D; 1 ;</span><br><span class="line">当n&gt;&#x3D;1时，n x (n-1)!</span><br><span class="line">可以发现它使用了阶乘(n-1)!来定义阶乘n!，是不是跟汉诺塔很相似？没错，确实是递归思维的体现。</span><br><span class="line">ok~，关于阶乘我们就简单了解这些。</span><br></pre></td></tr></table></figure>

<p>  递归算法的定义(从程序的角度)：任何调用自身函数的过程都可以称为递归算法(前面实现的汉诺塔程序就是一个很好的例子)。这里需要注意的是递归必须满足以下两个条件：</p>
<ul>
<li><p>边界条件：至少有一条初始定义是非递归的，如汉诺塔的H(0)=0，阶乘的0!=1。</p>
</li>
<li><p>递归通式：由已知函数值逐步计算出未知函数值，如汉诺塔的H(0)=0，可以推算出H(1)=H(0)+1+H(0)。</p>
</li>
</ul>
<p><strong>边界条件和递推通式是递归定义的两个基本要素，缺一不可</strong>，并且递归通式必须在有限次数内运算完成达到边界条件以保证能够正常结束递归，得到运算结果。好~，以上便是递归的定义，还是那句话理解好递归思维(复杂问题简单化)才是重点！</p>
<h1 id="斐波那契数列中的递归思想"><a href="#斐波那契数列中的递归思想" class="headerlink" title="斐波那契数列中的递归思想"></a>斐波那契数列中的递归思想</h1><p>  如果上述的分析都明白了，那就说明你已掌握了递归，但为了加深对递归的理解，我们再来看一个思考题（来自程序员的数学思考题），题目是这样的，假如动物中有一种特殊的种类，它出生2天后就开始以每天1只的速度繁殖后代。假设第1天，有1只这样的动物（该动物刚出生，从第3天开始繁殖后代）。那么到第11天，共有多少只呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们先来按一般顺序思考，先不要考虑第11天，先从第1天开始，看能不能找出规律：</span><br><span class="line">【第1天】只有1只动物</span><br><span class="line">【第2天】只有1只动物，还没有繁殖后代，总量为1</span><br><span class="line">【第3天】第1天的1只动物，繁殖1个后代，总量为2</span><br><span class="line">【第4天】第1天的1只动物又繁殖1只，其他还没繁殖，总量为3</span><br><span class="line">【第5天】第1天和第3天出生的动物又繁殖1个后代，其他没有繁殖，总量为5</span><br><span class="line">【第n天】.....</span><br><span class="line"></span><br><span class="line"> 第1天 ------1</span><br><span class="line"> 第2天 ------1</span><br><span class="line"> 第3天 ------2 &#x3D; 1 + 1</span><br><span class="line"> 第4天 ------3 &#x3D; 1 + 2</span><br><span class="line"> 第5天 ------5 &#x3D; 2 + 3 </span><br><span class="line"> 第6天 ------8 &#x3D; 3 + 5</span><br><span class="line"> 第7天 ------13 &#x3D; 5 + 8</span><br></pre></td></tr></table></figure>

<p>   这个过程中貌似没发现什么规律，但我们发现从第3天开始动物的数量似乎前两天的总和，也就是第3天，是第1天的动物数量加上第2天的动物数量，而第4天则是第2天和第3天的动物数量的和。这样的话我们可以归纳一下，不去直接想”第n天有多少只动物“而是如下思考：</p>
<ul>
<li>第n-1天出生的动物，在第n天还存活着。</li>
<li>第n-2天以前出生的动物，在第n天繁殖了后代</li>
</ul>
<p>  因此可以总结出递推公式，假设在第n天时，第n-1天以前繁殖的动物都活着，并且第n-2天以前出生的动物会繁殖1个后代，设第n天的动物总数为F(n)，则有：F(n)=F(n-1)+F(n-2) 其中 n&gt;=3，如下图所示</p>
<p><img src="https://img-blog.csdn.net/20161211215025928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>注意为了让F(2)=F(1)+F(0)成立，定义F(0)=0,而F(1)则依然为1，因此有如下公式：</p>
<p><img src="/Users/fengxing/blogs/source/_posts/%E9%80%92%E5%BD%92/%E9%80%92%E5%BD%9210.png" alt="img"></p>
<p>我们来验证这个递推公式是否符合递归条件</p>
<ul>
<li>边界条件：至少有一条初始定义是非递归的，F(0)=0;F(1)=1。</li>
<li>递归通式：由已知函数值逐步计算出未知函数值，F(0)=0;F(1)=1,可以推算出F(2)=1,最终也可以推算F(n)的结束。</li>
</ul>
<p>显然两个条件都符合，说明该通用公式可以在有限的次数内运算完成并达到边界条件得出结果，因此我们可以利用递推公式求出第11天的动物的数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">F(0)&#x3D;0</span><br><span class="line">F(1)&#x3D;1</span><br><span class="line">F(2)&#x3D;F(0)+F(1)&#x3D;1</span><br><span class="line">F(3)&#x3D;F(2)+F(1)&#x3D;2</span><br><span class="line">F(4)&#x3D;F(3)+F(2)&#x3D;3</span><br><span class="line">F(5)&#x3D;F(4)+F(3)&#x3D;5</span><br><span class="line">F(6)&#x3D;F(5)+F(4)&#x3D;8</span><br><span class="line">F(7)&#x3D;F(6)+F(5)&#x3D;13</span><br><span class="line">F(8)&#x3D;F(7)+F(6)&#x3D;21</span><br><span class="line">F(9)&#x3D;F(8)+F(7)&#x3D;34</span><br><span class="line">F(10)&#x3D;F(9)+F(8)&#x3D;55</span><br><span class="line">F(11)&#x3D;F(10)+F(9)&#x3D;89</span><br><span class="line">也就是说第11天的动物总数为89只</span><br></pre></td></tr></table></figure>

<p>在这个问题中出现的数列就是著名的斐波那契数列，是由数学家斐波那契发现的，由此得名斐波那契数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ，1 ，1 ，2 ，3 ，5 ，8，13 ，21 ，34 ，55 ，89 ，…</span><br></pre></td></tr></table></figure>

<p>  到此我们也就知道斐波那契数列同样是用递归定义的，前面我们将求解第n天的动物数量分解为求第n-1天和第n-2天以前的动物繁殖后代数量，从把复杂的问题分解为较为简单的同类问题，而不去纠结第n天到此有多少只动物的问题，最终发现求解的规律，并通过递推公式求得第n天的结果，这个过程再次体现了递归的思维方式。既然斐波那契数列是递归思维的产物，那么也可以通过程序的递归算法来求解，接下来我们就看看如何使用程序中的递归算法来实现斐波那契数列。</p>
<h2 id="斐波那契数列的递归程序实现"><a href="#斐波那契数列的递归程序实现" class="headerlink" title="斐波那契数列的递归程序实现"></a>斐波那契数列的递归程序实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.zejian.structures.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by zejian on 2016&#x2F;12&#x2F;11.</span><br><span class="line"> * Blog : http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian [原文地址,请尊重原创]</span><br><span class="line"> * 斐波那契数列的实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Fibonacci  &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 斐波那契数列的实现</span><br><span class="line">     * 0,1,1,2,3,5,8,13,21......</span><br><span class="line">     * @param day</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public long fibonacci(int day)&#123;</span><br><span class="line"></span><br><span class="line">        if(day&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;F(0)&#x3D;0</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (day&#x3D;&#x3D;1||day&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;F(1)&#x3D;1</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">           return fibonacci(day-1)+fibonacci(day-2); &#x2F;&#x2F;F(n)&#x3D;F(n-1)+F(n-2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 更为简洁的写法</span><br><span class="line">     * @param day</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public long fib(int day) &#123;</span><br><span class="line">        return day&#x3D;&#x3D; 0 ? 0 : (day&#x3D;&#x3D; 1 || day&#x3D;&#x3D;2 ? 1 : fib(day - 1) + fib(day - 2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Fibonacci fibonacci&#x3D;new Fibonacci();</span><br><span class="line">        System.out.println(&quot;第11天动物数量为:&quot;+ fibonacci.fib(11));</span><br><span class="line">        System.out.println(&quot;第11天动物数量为:&quot;+ fibonacci.fibonacci(11));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归算法的效率问题"><a href="#递归算法的效率问题" class="headerlink" title="递归算法的效率问题"></a>递归算法的效率问题</h1><p>  到此我们已对递归分析完了，相信大家对递归已很熟悉了，通过递归的思维方式，在解决某些问题的时候确实使得我们思考的方式得以简化，同时代码也更加精炼，容易阅读。那么既然如此，那是不是什么问题都要用递归来解决呢？难道递归就没有缺点吗？下面我们就来讨论一下递归的不足之处也就是它的效率问题。我们这里以斐波那契数列的实现为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 更为简洁的写法</span><br><span class="line"> * @param day</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public long fib(int day) &#123;</span><br><span class="line">       return day&#x3D;&#x3D; 0 ? 0 : (day&#x3D;&#x3D; 1 || day&#x3D;&#x3D;2 ? 1 : fib(day - 1) + fib(day - 2));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  这段代码相当精简直观清晰,但是！如果用这段代码计算fib(500)时，我们就泪奔了，它的运行时间也许会让人抓狂呐。我们以fib(5)为例，计算过程如下：</p>
<p><img src="https://img-blog.csdn.net/20161211234844810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  从上图可以看出，在计算Fib(5)的过程中，Fib(1)计算了两次、Fib(2)计算了3次，Fib(3)计算了两次，原本只需要5次计算就可以完成的任务却计算了9次。更重要的是这个问题随着规模的增加会愈发明显，以至于Fib(500)的计算时间已相当恐怖。造成这种困境的原因是，当调用fib(n-1)时，还要调用fib(n-2)，也就是说fib(n-2)调用了两次，同样的道理，调用f(n-2)时f(n-3)也调用了两次，而这些多余的调用是完全没有必要的，还可预见的是这种计算方式随着数量的增加，计算量将呈指数级增长，这是一个相当严重的问题。那么如何改良这个计算过程呢？我们重新回顾一下斐波那契数列：</p>
<p><code>0 ，1 ，1 ，2 ，3 ，5 ，8，13 ，21 ，34 ，55 ，89 ，…</code></p>
<p>  为了减少函数重复调用提高效率，我们使用迭代的方式来实现斐波那契数列代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BigInteger可以防止数据异常</span><br><span class="line">&#x2F;&#x2F;BigInteger 任意大的整数，原则上是，只要你的计算机的内存足够大，可以有无限位的</span><br><span class="line">&#x2F;&#x2F; 递推实现方式（迭代的方式效率高，时间复杂度O(n)）</span><br><span class="line">public  BigInteger fibonacciN(int n)&#123;</span><br><span class="line">   if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">       return new BigInteger(&quot;0&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;f(0)&#x3D;0;</span><br><span class="line">   BigInteger n1 &#x3D; new BigInteger(&quot;0&quot;)；</span><br><span class="line">   &#x2F;&#x2F;f(1)&#x3D;1;</span><br><span class="line">   BigInteger n2 &#x3D; new BigInteger(&quot;1&quot;)；</span><br><span class="line">   &#x2F;&#x2F;记录最终值f(n)</span><br><span class="line">   BigInteger sn &#x3D; new BigInteger(&quot;0&quot;);</span><br><span class="line">   for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">       sn &#x3D; n1.add(n2);&#x2F;&#x2F;相加</span><br><span class="line">       n1 &#x3D; n2;</span><br><span class="line">       n2 &#x3D; sn;</span><br><span class="line">   &#125;</span><br><span class="line">   return sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 与上述相同的递推实现方式 ，使用long返回值，当n过大会造成数据溢出，计算结果可能是一个未知的负数，因此建议使用BigInteger</span><br><span class="line">public static long fibonacciNormal(int n)&#123;</span><br><span class="line">      if(n &lt;&#x3D; 2)&#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      long n1 &#x3D; 1, n2 &#x3D; 1, sn &#x3D; 0;</span><br><span class="line">      for(int i &#x3D; 0; i &lt; n - 2; i ++)&#123;</span><br><span class="line">          sn &#x3D; n1 + n2;</span><br><span class="line">          n1 &#x3D; n2;</span><br><span class="line">          n2 &#x3D; sn;</span><br><span class="line">      &#125;</span><br><span class="line">      return sn;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  这样我们就把问题的规模降低到O(n)级别了，运行时间也很快，那为什么使用迭代就快，而使用递归就会变得慢呢？我们都知道，递归调用实际上是函数自己在调用自己，而函数的调用开销是很大的（包括空间和时间），而系统要为每次函数调用分配存储空间，提供给函数进行运行。而在函数调用结束后，则需要释放空间，即所谓的弹栈复点。因此函数调用消耗的空间和时间并不是非常乐观的。但难度就不用递归了么？并非如此，当我们在遇到同一个问题时，如果递归解决的（时间和空间）复杂度不明显优于其它解决方案时，此时就不应该使用递归，否则可以使用递归。其实博主想说的是递归虽然有缺点，但在很多复杂的问题上我们使用递归的形式来解释或者求解时问题确实很容易被解释的更清楚，而使用迭代是无法实现的或者难以理解的（如汉诺塔问题，树的遍历等等），此时递归巨大的优势就显示出来了。同时我们更应该记住在相同的问题面前，如果使用递归的效果与迭代的效果相差不了多少，我们更应该倾向于使用迭代，毕竟运行效率上迭代还是相当有优势的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/%E6%A0%91/" itemprop="url">树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-07T17:13:36+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/07/%E6%A0%91/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/07/%E6%A0%91/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>在看TreeMap底层结构之前，必要先要了解下<strong>树</strong>！树是一种数据结构</p>
<p><strong>数组的特点是查询迅速</strong>，根据index可以快速定位到一个元素，如果要插入一个元素，就需要将这个元素位置之后的所有元素后移。序数组的插入的时间复杂度为O(N)，删除操作的时间复杂度也为O(N)。</p>
<p><strong>链表的插入和删除效率都很高</strong>，只要改变一些值的引用就行了，时间复杂度为O(1)。<strong>但是链表的查询效率很低，每次都要从头开始找，依次访问链表的每个数据项。</strong>时间复杂度为O(N)。</p>
<h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul>
<li><strong><img src="https://upload-images.jianshu.io/upload_images/4118241-538ccdaf6d9807ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树术语.png">路径</strong>：从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径。</li>
<li><strong>根</strong>：树顶端的节点被称为根。从根出发到达任意一个节点只有一条路径。</li>
<li><strong>父节点</strong>：除了根节点之外，每个节点都可以向上找到一个唯一的节点，这个节点就是当前节点的父节点。相应的，父节点下方的就是子节点。</li>
<li><strong>叶子节点</strong>：没有子节点的“光杆司令”就被称为叶子节点。</li>
<li><strong>子树</strong>：每个子节点作为根节点的树都是一个子树。</li>
<li><strong>层</strong>：一个树结构的代数就是这个树的层。</li>
<li><strong>度</strong>：一棵树中，最大的节点的度称为树的度。</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点。</li>
</ul>
<h2 id="树的两种实现"><a href="#树的两种实现" class="headerlink" title="树的两种实现"></a>树的两种实现</h2><p>树是一个递归的概念，从根节点开始，每个节点至多只有一个父节点，有多个子节点，每个子节点又是一棵树，以此递归。</p>
<ul>
<li>数组</li>
<li>链表</li>
</ul>
<h3 id="数组实现树"><a href="#数组实现树" class="headerlink" title="数组实现树"></a>数组实现树</h3><p>利用每个节点至多只有一个父节点这个特点，使用 <strong>父节点表示法</strong> 来实现一个节点</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-fe9e3345a43ee5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组实现树.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private Object mData;   &#x2F;&#x2F;存储的数据</span><br><span class="line">    private int mParent;   &#x2F;&#x2F;父亲节点的下标</span><br><span class="line"></span><br><span class="line">    public TreeNode(Object data, int parent) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return mData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getParent() &#123;</span><br><span class="line">        return mParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParent(int parent) &#123;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>角标</strong>来指明父亲节点的位置，使用这个节点组成的数组就可以表示一棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    TreeNode[] arrayTree &#x3D; new TreeNode[10];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表表示的节点"><a href="#链表表示的节点" class="headerlink" title="链表表示的节点"></a>链表表示的节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedTreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private Object mData;   &#x2F;&#x2F;存储的数据</span><br><span class="line">    private LinkedTreeNode mParent;   &#x2F;&#x2F;父亲节点的下标</span><br><span class="line">    private LinkedTreeNode mChild;  &#x2F;&#x2F;孩子节点的引用</span><br><span class="line"></span><br><span class="line">    public LinkedTreeNode(Object data, LinkedTreeNode parent) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return mData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getParent() &#123;</span><br><span class="line">        return mParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParent(LinkedTreeNode parent) &#123;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedTreeNode getChild() &#123;</span><br><span class="line">        return mChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChild(LinkedTreeNode child) &#123;</span><br><span class="line">        mChild &#x3D; child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用引用，而不是索引表示父亲与孩子节点。</p>
<p>使用一个 List, 元素是 LinkedTreeNode，就可以表示一棵链表树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    LinkedList&lt;LinkedTreeNode&gt; linkedTree &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只需知道 根节点就可以遍历整个树。知道某个节点也可以获取它的父亲和孩子。</p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>所谓树的遍历（Traversal），就是按照某种次序访问树中的节点，且每个节点恰好访问一次。</p>
<p>也就是说，按照被访问的次序，可以得到由树中所有节点排成的一个序列。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>对任一（子）树的前序遍历，将首先访问其根节点，然后再递归地对其下的各棵子树进行前序遍历。对于同一根节点下的各棵子树，遍历的次序通常是任意的；但若换成有序树，则可以按照兄弟间相应的次序对它们实施遍历。由前序遍历生成的节点序列，称作前序遍历序列。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-6fe19cea12167d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前序遍历.png"></p>
<h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><p>对称地，对任一（子）树的后序遍历将首先递归地对根节点下的各棵子树进行后序遍历，最后才访问根节点。由后序遍历生成的节点序列，称作后序遍历序列。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8c313650b8137069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后续遍历.png"></p>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>除了上述两种最常见的遍历算法，还有其它一些遍历算法，层次遍历（Traversal by level ）算法就是其中的一种。在这种遍历中，各节点被访问的次序取决于它们各自的深度，其策略可以总结为“深度小的节点优先访问”。对于同一深度的节点，访问的次序可以是随机的，通常取决于它们的存储次序，即首先访问由firstChild指定的长子，然后根据nextSibling确定后续节点的次序。当然，若是有序树，则同深度节点的访问次序将与有序树确定的次序一致。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-c5ddb4d82ccf5f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="层次遍历.png"></p>
<h2 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树（Binary Tree）是有限个节点的集合，这个集合可以是空集，也可以是一个根节点和两颗不相交的子二叉树组成的集合，其中一颗树叫根的左子树，另一颗树叫右子树。所以二叉树是一个递归地概念。二叉树作为一种重要的数据结构，它结合了数组和链表的优点，有很多重要的应用。</p>
<h4 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h4><p>每个节点最多只有两个子节点。其实，二叉树的每个左右子节点仍是一颗二叉树，因此，我们可以使用递归的方式来定义二叉树，二叉树的实现代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private int data;  &#x2F;&#x2F;数据</span><br><span class="line">    private BinaryTreeNode leftChild;  &#x2F;&#x2F;左孩子</span><br><span class="line">    private BinaryTreeNode rightChild; &#x2F;&#x2F;右孩子</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTreeNode getLeftChild() &#123;</span><br><span class="line">        return leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftChild(BinaryTreeNode leftChild) &#123;</span><br><span class="line">        this.leftChild &#x3D; leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTreeNode getRightChild() &#123;</span><br><span class="line">        return rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightChild(BinaryTreeNode rightChild) &#123;</span><br><span class="line">        this.rightChild &#x3D; rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        data &#x3D; -1;</span><br><span class="line">        name &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式称之为二叉树的左右链表表示法。</p>
<p><img src="https://segmentfault.com/img/bV91GF?w=1172&h=626" alt="图片描述"></p>
<h4 id="操作二叉树"><a href="#操作二叉树" class="headerlink" title="操作二叉树"></a>操作二叉树</h4><p><strong>创建二叉树</strong>，一般有两种情况：初始化一个根节点或者初始化一棵空二叉树。</p>
<p>对于<strong>二叉树的清空</strong>，首先提供一个清空某个节点为根节点的子树的方法，即递归的删除每个节点；接着提供删除一个删除树的方法：</p>
<p><strong>判断二叉树是否为空</strong>只需判断根节点是否存在即可。</p>
<p><strong>二叉树的高度</strong>：首先需要一种获取以某个节点为子树的高度方法，使用递归实现。如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；如果不为空，则遍历地比较它的左右子树高度，高的一个为这颗子树的最大高度，然后加上自身的高度即可</p>
<p><strong>求二叉树的节点数</strong>需要获取以某个节点为根的子树的节点数实现。<br>如果节点为空，则个数肯定为0；如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可。</p>
<p><strong>返回某节点的父亲节点</strong>：首先，同样需要通过一种方法来获取某个节点在某个子树中的父节点，这里使用递归实现，接着通过这种方法获取这个节点在二叉树中的父节点<br>事实上，以现有的这种二叉树的形式，我们并没有办法直接获取一个节点的父节点， 这里只能通过从根节点遍历来比较获取</p>
<p><strong>返回左右子树</strong>这个操作很简单，直接用节点的方法来获取即可</p>
<p><strong>二叉树的插入</strong>：分两种情况：插入某个节点的左子节点；插入某个节点的右子节点值得指出的是，当这个节点本身有子节点时，这样的插入也会覆盖原来在这个位置上的节点。另外，虽然插入的是子节点，但是子节点也可以代表一颗子树。因为单从这个节点来看并不知道这个节点是否有左右子树存在，所以虽然插入的是一个节点，但有可能插入可很多节点（插入的是一颗子树）</p>
<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>二叉树的遍历是按照一定的规律来顺序遍历各二叉树节点，使得每个节点都会被访问且仅访问一次。通常二叉树的遍历根据根节点的遍历次序分为：前序遍历、后序遍历、层次遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTree &#123;</span><br><span class="line">    private BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化二叉树</span><br><span class="line">    public BinaryTree() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTree(BinaryTreeNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(BinaryTreeNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTreeNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据name找到指定节点</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BinaryTreeNode findTreeNode(String name) &#123;</span><br><span class="line">        LinkedList&lt;BinaryTreeNode&gt; nodes &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        while (!nodes.isEmpty()) &#123;</span><br><span class="line">            BinaryTreeNode node &#x3D; nodes.poll();</span><br><span class="line">            if (node.getName().equals(name)) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">            BinaryTreeNode leftChild &#x3D; node.getLeftChild();</span><br><span class="line">            BinaryTreeNode rightChild &#x3D; node.getRightChild();</span><br><span class="line">            if (leftChild !&#x3D; null) &#123;</span><br><span class="line">                nodes.push(leftChild);</span><br><span class="line">            &#125;</span><br><span class="line">            if (rightChild !&#x3D; null) &#123;</span><br><span class="line">                nodes.push(rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 二叉树的清空：</span><br><span class="line">     * 首先提供一个清空以某个节点为根节点的子树的方法，既递归地删除每个节点；</span><br><span class="line">     * 接着提供一个删除树的方法，直接通过第一种方法删除到根节点即可</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;清除某个子树的所有节点</span><br><span class="line">    public void clear(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            clear(node.getLeftChild());</span><br><span class="line">            clear(node.getRightChild());</span><br><span class="line">            node.clear();</span><br><span class="line">            node &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;清空树</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        clear(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断二叉树是否为空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return root &#x3D;&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取整棵树的高度</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 求二叉树的高度：</span><br><span class="line">     * 首先要一种获取以某个节点为子树的高度的方法，使用递归调用。</span><br><span class="line">     * 如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；</span><br><span class="line">     * 如果不为空，那么我们要遍历地比较它的左子树高度和右子树高度，</span><br><span class="line">     * 高的一个为这个子树的最大高度，然后加上自己本身的高度就是了</span><br><span class="line">     * 获取二叉树的高度，只需要调用第一种方法，即传入根节点</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int treeHeight() &#123;</span><br><span class="line">        return treeHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取某个节点的高度</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int treeHeight(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int l &#x3D; treeHeight(node.getLeftChild());</span><br><span class="line">        int r &#x3D; treeHeight(node.getRightChild());</span><br><span class="line">        return l &gt; r ? l + 1 : r + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取所有节点个数</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 求二叉树的节点数：</span><br><span class="line">     * 求节点数时，我们看看获取某个节点为子树的节点数的实现。</span><br><span class="line">     * 首先节点为空，则个数肯定为0；</span><br><span class="line">     * 如果不为空，那就算上这个节点之后继续递归所有左右子树的子节点数，</span><br><span class="line">     * 全部相加就是以所给节点为根的子树的节点数</span><br><span class="line">     * 如果求二叉树的节点数，则输入根节点即可</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 思路：获取二叉树节点数，需要获取以某个节点为根的子树的节点数实现。</span><br><span class="line">     * 如果节点为空，则个数肯定为0；如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int nodeSize() &#123;</span><br><span class="line">        return nodeSize(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取某个节点下的所有节点个数</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 计算本节点 所以要+1</span><br><span class="line">     * 递归获取左子树节点数和右子树节点数，最终相加</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int nodeSize(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;计算本节点 所以要+1</span><br><span class="line">        &#x2F;&#x2F;递归获取左子树节点数和右子树节点数，最终相加</span><br><span class="line">        return 1 + nodeSize(node.getLeftChild()) + nodeSize(node.getRightChild());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找node节点在二叉树中的父节点</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 思路：首先，同样需要通过一种方法来获取某个节点在某个子树中的父节点，这里使用递归实现，接着通过这种方法获取这个节点在二叉树中的父节点</span><br><span class="line">     * 事实上，以现有的这种二叉树的形式，我们并没有办法直接获取一个节点的父节点， 这里只能通过从根节点遍历来比较获取</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BinaryTreeNode getParent(BinaryTreeNode node) &#123;</span><br><span class="line">        return (root &#x3D;&#x3D; null || root &#x3D;&#x3D; node) ? null : getParent(root, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * node节点在subTree子树中的父节点</span><br><span class="line">     *</span><br><span class="line">     * @param subTree</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BinaryTreeNode getParent(BinaryTreeNode subTree, BinaryTreeNode node) &#123;</span><br><span class="line">        if (subTree &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;   &#x2F;&#x2F;如果是空子树，则没有父节点</span><br><span class="line">        &#125;</span><br><span class="line">        if (subTree.getLeftChild() &#x3D;&#x3D; node || subTree.getRightChild() &#x3D;&#x3D; node) &#123;</span><br><span class="line">            return subTree;   &#x2F;&#x2F;如果子树的根节点的左右孩子之一是待查节点，则返回子树的根节点</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeNode parent &#x3D; null;</span><br><span class="line">        if (getParent(subTree.getLeftChild(), node) !&#x3D; null) &#123;</span><br><span class="line">            parent &#x3D; getParent(subTree.getLeftChild(), node);</span><br><span class="line">            return parent;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;递归左右子树</span><br><span class="line">            return getParent(subTree.getRightChild(), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取某个节点的左子树</span><br><span class="line">    public BinaryTreeNode getLeftTree(BinaryTreeNode node) &#123;</span><br><span class="line">        return node.getLeftChild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取某个节点的右子树</span><br><span class="line">    public BinaryTreeNode getRightTree(BinaryTreeNode node) &#123;</span><br><span class="line">        return node.getRightChild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 给某个节点插入左节点</span><br><span class="line">     * 分两种情况：插入某个节点的左子节点；插入某个节点的右子节点</span><br><span class="line">     * 值得指出的是，当这个节点本身有子节点时，这样的插入也会覆盖原来在这个位置上的节点。</span><br><span class="line">     * 另外，虽然插入的是子节点，但是子节点也可以代表一颗子树。</span><br><span class="line">     * 因为单从这个节点来看并不知道这个节点是否有左右子树存在，所以虽然插入的是一个节点，但有可能</span><br><span class="line">     * 插入可很多节点（插入的是一颗子树）</span><br><span class="line">     *</span><br><span class="line">     * @param parent</span><br><span class="line">     * @param newNode</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insertLeft(BinaryTreeNode parent, BinaryTreeNode newNode) &#123;</span><br><span class="line">        parent.setLeftChild(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;给某个节点插入右节点</span><br><span class="line">    public void insertRight(BinaryTreeNode parent, BinaryTreeNode newNode) &#123;</span><br><span class="line">        parent.setRightChild(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(node.getData()); &#x2F;&#x2F;先访问根节点</span><br><span class="line">            preOrder(node.getLeftChild());  &#x2F;&#x2F;先根遍历左子树</span><br><span class="line">            preOrder(node.getRightChild());  &#x2F;&#x2F;先根遍历右子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前序遍历实现"><a href="#前序遍历实现" class="headerlink" title="前序遍历实现"></a>前序遍历实现</h5><p>若二叉树为空，则退出，否则进行下面操作</p>
<ul>
<li>访问根节点</li>
<li>先根遍历左子树</li>
<li>先根遍历右子树</li>
<li>退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(node.getData()); &#x2F;&#x2F;先访问根节点</span><br><span class="line">            preOrder(node.getLeftChild());  &#x2F;&#x2F;先根遍历左子树</span><br><span class="line">            preOrder(node.getRightChild());  &#x2F;&#x2F;先根遍历右子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>若二叉树为空，则退出，否则进行下面操作</p>
<ul>
<li>后根遍历左子树</li>
<li>后根遍历右子树</li>
<li>访问根节点</li>
<li>退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void postOrder(BinaryTreeNode node)&#123;</span><br><span class="line">        if(node!&#x3D;null)&#123;</span><br><span class="line">            postOrder(node.getLeftChild());  &#x2F;&#x2F;后根遍历左子树</span><br><span class="line">            postOrder(node.getRightChild());  &#x2F;&#x2F;后根遍历右子树</span><br><span class="line">            System.out.println(node);   &#x2F;&#x2F;访问根节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="三叉链表存储结构"><a href="#三叉链表存储结构" class="headerlink" title="三叉链表存储结构"></a>三叉链表存储结构</h4><p>采用二叉链表存储结构，每个结点只存储了到其孩子结点的单向关系，而没有存储到父结点的关系，这样的话，每次要获取父结点时将消耗较多的时间，因为需要从root根结点开始查找，花费的时间是遍历部分二叉树的时间，而且与该结点的位置有关。为了更高效的获取父结点，三叉链表存储结构孕育而生了。</p>
<p>  三叉链表主要是在二叉链表的基础上多添加了一个指向父结点的域，这样我们就存储了父结点与孩子结点的双向关系，当然这样也增加了一定的空开销其结点。</p>
<p><img src="https://img-blog.csdn.net/20161218233740719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一棵满二叉树就是高度为k，且拥有(2^k)-1个节点的二叉树，一棵满二叉树每个节点，要么都有两棵子树，要么都没有子树；而且每一层所有的节点之间必须要么都有两棵子树，要么都没子树。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-80fc53a6b51246f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="满二叉树.png"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><img src="https://upload-images.jianshu.io/upload_images/4118241-152e50f7aaa10279.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/" itemprop="url">程序员都是如何看电影的？欢迎讨论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-04T13:54:48+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家都用什么看电影啊！资源在哪里找的？现在我看电影的方式是在Google上寻找百度网盘的资源，然后用百度网盘在线观看。欢迎大家把自己的观影方式告诉我！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="url">Java面试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>​        面向对象简称OO（Object Oriented），一种基于面向过程的新思想，该思想就是站在对象的角度思考问题，把多个功能合理的放在不同的对象中，强调的是具备某些功能的对象。</p>
<p>​        具备某种功能的实体，称之为对象。面向对象最小的程序单位是<strong>类</strong>。面向对象更加符合常规的思维方式<strong>稳定性好，可重用性强，有良好的可重用性</strong>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>所谓对象就是真实世界的实体，对象与实体一一对应，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>java中面向对象的三大特性：封装、继承、多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>隐藏内部实现，提供公共方法进行访问</strong>。所谓封装就是把数据和操作数据的方法封装起来，对数据的访问和操作只能通过已定义的接口进行访问。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类拥有父类的特征和行为，并可以对父类进行扩展。形容类的关系。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一种类型的对象，执行相同方法，有不同的表现。</p>
<p><strong>多态的必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>向上转型</li>
</ul>
<p><strong>向上转型</strong></p>
<p>父类指向子类的引用</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><p>JVM由三个主要的子系统构成：</p>
<ul>
<li>类加载子系统：负责加载类或者接口</li>
<li>运行时数据去（内存结构）：包含方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器</li>
<li>执行引擎：负责执行包含在已装载的类或接口中的指令</li>
</ul>
<h3 id="类加载系统"><a href="#类加载系统" class="headerlink" title="类加载系统"></a>类加载系统</h3><p><a href="https://zhuanlan.zhihu.com/p/54693308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54693308</a></p>
<h4 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h4><p>答：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>类的生命周期包括加载、连接、初始化、使用和卸载。</p>
<ul>
<li><p>加载：查找并加载类的二进制数据，并在堆内存中创建对象。</p>
</li>
<li><p>连接：连接又分为三步：验证、准备、解析</p>
<ul>
<li>验证：验证文件格式、元数据、字节码、符号引用。</li>
<li>准备：为类的静态变量分配内存并初始化默认值。</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li><p>初始化：为类的静态变量赋予正确的初始值</p>
</li>
<li><p>使用：new出对象程序中使用</p>
</li>
<li><p>卸载：执行垃圾回收</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="https://img-blog.csdnimg.cn/20190603164758648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li>
<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li>
</ul>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。双亲委派模型能保证基础类仅加载一次，不会让jvm中存在重名的类。</p>
<h5 id="ExtClassLoader为什么没有设置parent？"><a href="#ExtClassLoader为什么没有设置parent？" class="headerlink" title="ExtClassLoader为什么没有设置parent？"></a>ExtClassLoader为什么没有设置parent？</h5><p>因为BootstrapClassLoader是由c++实现的，所以并不存在一个Java的类。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="https://img-blog.csdnimg.cn/20190603165013168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>方法区和堆是<strong>所有线程共享</strong>的内存区域；而java栈、本地方法栈和程序计数器是<strong>运行时线程私有</strong>的内存区域。</p>
<p>JVM把内存划分成了如下几个区域：</p>
<ul>
<li><p>堆区（Heap）：存放<strong>通过new创建的对象实例</strong>，容易OutOfMemoryEroor。</p>
</li>
<li><p>方法区（Method Area）：存放类的信息（字段和方法的字节码、构造函数、接口定义等）、静态变量，常量，运行时常量池。</p>
</li>
<li><p>虚拟机栈（VM Stack）：用于存储局部变量表、操作数栈、动态链接、方法出口等。只要线程已结束栈就出栈，生命周期与线程一致，其内存管理如下：</p>
<ul>
<li>方法中的基础数据类型直接在栈空间分配</li>
<li>方法中的引用数据类型，需要new来创建，既在栈中分配空间，也在堆中分配对象，栈中的地址指向堆内对象</li>
<li>方法的形式参数直接在栈空间分配，方法调用完毕在栈空间回收</li>
<li>方法中的引用参数，在栈中分配空间指向堆中对象，方法执行完毕回收栈空间。</li>
<li>字符串常量,static静态变量在方法区分配空间。</li>
</ul>
</li>
<li><p>本地方法栈（Native Method Stack）：可理解为java中jni调用。用于支持native方法执行</p>
</li>
<li><p>程序计数器（Program Counter Register）：每个方法在运行时都存储着一个独立的程序计数器，程序计数器是指定程序运行的行数指针。</p>
</li>
</ul>
<h3 id="Object-o-new-Object"><a href="#Object-o-new-Object" class="headerlink" title="Object o=new Object()"></a>Object o=new Object()</h3><p><img src="https://pic4.zhimg.com/80/v2-eddc430b991c58039dfc79dd6f3139cc_1440w.jpg" alt="img"></p>
<h3 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h3><p><img src="https://img-blog.csdnimg.cn/20190604161655494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>内存分为:</p>
<ul>
<li>新生代(<strong>1/3堆空间</strong>)<ul>
<li>Eden(伊甸园区)</li>
<li>Survivor From（幸存者区）</li>
<li>Survivor To（幸存者区）</li>
</ul>
</li>
<li>老年代(<strong>2/3堆空间</strong>)</li>
<li>持久代。(<strong>直接内存JDK1.8后</strong>)</li>
</ul>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代中98%的对象都是”朝生夕死”的，所以并不需要按照1 : 1的比例来划分内存空间，而是将内存(新生代内存)分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间（8:1:1），每次使用Eden和其中一块Survivor（两个Survivor区域一个称为From区，另一个称为To区域）。</p>
<p><strong>当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。(复制算法)</strong></p>
<p>HotSpot实现的复制算法流程如下:</p>
<ul>
<li><p>当Eden区满的时候,会触发第一次Minor gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。</p>
</li>
<li><p>当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。</p>
</li>
<li><p>部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p>
</li>
</ul>
<p>也有例外出现，对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生。</p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象。</p>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>不属于堆内存，属于内存空间。真正与堆隔离。方法区是类逻辑上的一个抽象模板，而元空间是<strong>方法区的实现</strong>，是真实存在的内存。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul>
<li><p>虚拟机在进行MinorGC（新生代的GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC。</p>
</li>
<li><p>刚分配对象在Eden中，如果空间不足尝试进行GC，回收空间，如果进行了MinorGC空间依旧不够就放入Old Generation，如果OldGeneration空间还不够就OOM了。</p>
</li>
<li><p>比较大的对象，数组等，大于某值（可配置）就直接分配到老年代，（避免频繁内存拷贝）</p>
</li>
<li><p>年轻代和年老代属于Heap空间的，Permanent Generation（永久代）可以理解成方法区，（它属于方法区）也有可能发生GC，例如类的实例对象全部被GC了，同时它的类加载器也被GC掉了，这个时候就会触发永久代中对象的GC。</p>
</li>
<li><p>如果OldGeneration满了就会产生FullGC。老年代满原因：</p>
<ul>
<li>1、from survive中对象的生命周期到一定阈值</li>
<li>2、分配的对象直接是大对象</li>
<li>3、由于To 空间不够，进行GC直接把对象拷贝到年老代（年老代GC时候采用不同的算法）</li>
</ul>
</li>
<li><p>如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的时候速度是远远低于Young Generation回收速度。</p>
</li>
</ul>
<h4 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h4><ul>
<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值对象进入老年区。</li>
<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<h1 id="Java中的堆栈"><a href="#Java中的堆栈" class="headerlink" title="Java中的堆栈"></a>Java中的堆栈</h1><p><strong>栈内存</strong></p>
<p>在函数中定义的基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</p>
<p>当在一段代码块中声明了一个变量时，java就会在栈内存中为这个变量分配内存空间，当超过变量的作用域之后，java也会自动释放为该变量分配的空间，而这个回收的空间可以即刻用作他用。</p>
<p><strong>堆内存</strong></p>
<p>堆内存用于存放由new创建的对象和数组。</p>
<p>在堆内存中分配的内存空间，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，变量的值就等于数组或对象在堆内存中的首地址，而这个栈中的特殊变量，也就成为数组或对象的引用变量。以后可以在程序中使用栈内存中的引用变量访问堆内存中的数组或对象了。引用变量相当于是为数组或对象起的一个别名，或者是代号。</p>
<p>数组和对象在没有引用变量指向它的时候，才变成垃圾，不能被继续使用，但是仍然会占用堆内存空间，而后在一个不确定的时间内，由java虚拟机自动垃圾回收器回收，这也是java程序为什么会占用很大内存的原因。</p>
<h1 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h1><ul>
<li>垃圾：无任何对象引用的对象。</li>
<li>回收：清理“垃圾”占用的内存空间而非对象本身。</li>
<li>发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。</li>
<li>发生时间：程序空闲时间不定时回收。</li>
</ul>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><h3 id="创建阶段-Created"><a href="#创建阶段-Created" class="headerlink" title="创建阶段(Created)"></a>创建阶段(Created)</h3><p>在创建阶段系统通过下面的几个步骤来完成对象的创建过程：</p>
<ul>
<li><p>为对象分配存储空间</p>
<ul>
<li>开始构造对象</li>
<li>从超类到子类对static成员进行初始化</li>
<li>超累成员变量按顺序初始化，递归调用超累的构造方法</li>
<li>子类成员变量按顺序初始化，子类构造方法调用</li>
</ul>
</li>
<li><p>应用阶段(In Use)：对象至少被一个强引用持有。</p>
</li>
<li><p>不可见阶段(Invisible)：简单说就是程序的执行已经超出了该对象的作用域了。</p>
</li>
<li><p>不可达阶段(Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。</p>
</li>
<li><p>收集阶段(Collected)：</p>
</li>
<li><p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)：当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ul>
<h2 id="判断对象是否是垃圾算法"><a href="#判断对象是否是垃圾算法" class="headerlink" title="判断对象是否是垃圾算法"></a>判断对象是否是垃圾算法</h2><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<h4 id="根搜索算法（可达性分析算法）"><a href="#根搜索算法（可达性分析算法）" class="headerlink" title="根搜索算法（可达性分析算法）"></a>根搜索算法（可达性分析算法）</h4><p><img src="https://upload-images.jianshu.io/upload_images/4118241-bdc59e28c5775caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从一个GC ROOT节点开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<p><strong>所谓的GC根对象包括：</strong></p>
<ul>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常亮引用的对象</li>
<li>本地方法栈中引用的对象（Native对象）</li>
</ul>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-整理算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h3><p>标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象（<strong>这一过程在可达性分析过程中进行</strong>），标记完成之后统一清除对象。</p>
<p><strong>它的主要缺点：</strong></p>
<ul>
<li>标记和清除过程效率不高 。</li>
<li>标记清除之后会产生大量不连续的内存碎片。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-ab33b8257a3ed8bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记整理，标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。</p>
<p>主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-e02d7d3ebf1d75af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="复制算法-新生代算法"><a href="#复制算法-新生代算法" class="headerlink" title="复制算法(新生代算法)"></a>复制算法(新生代算法)</h3><p>复制算法，它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-98d9dff8f994e8bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p>
<h3 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h3><p>串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序（单CPU、新生代空间较小及对暂停时间要求不是非常高的应用）。是client级别默认的GC方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20190605151624561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h3><p>并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，当执行垃圾回收的时候它也会冻结所有的应用程序线程。</p>
<h3 id="并发标记扫描垃圾回收器"><a href="#并发标记扫描垃圾回收器" class="headerlink" title="并发标记扫描垃圾回收器"></a>并发标记扫描垃圾回收器</h3><p>并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。<br>（1）当标记的引用对象在Tenured区域；<br>（2）在进行垃圾回收的时候，堆内存的数据被并发的改变。<br>相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。</p>
<h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>JVM调优，调的是什么？<br>每一次Full GC都会使JVM停止运行–&gt;使Full GC不执行，使Minor GC尽可能少地执行</p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user&#x3D;0.17 sys&#x3D;0.08, real&#x3D;0.07 secs]</span><br><span class="line"></span><br><span class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user&#x3D;1.75 sys&#x3D;0.02, real&#x3D;0.68 secs]</span><br></pre></td></tr></table></figure>

<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p><img src="https://img-blog.csdnimg.cn/20190603181024771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190603181041398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h3><ul>
<li><strong>不要显式调用System.gc()</strong>：此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</li>
<li><strong>尽量减少临时对象的使用</strong>：临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</li>
<li><strong>对象不用时最好显式置为Null</strong>：一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</li>
<li><strong>尽量使用StringBuffer,而不用String来累加字符串</strong>：由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</li>
<li><strong>能用基本类型如Int,Long,就不用Integer,Long对象</strong>：基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</li>
<li><strong>尽量少用静态对象变量</strong></li>
<li>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</li>
<li><strong>分散对象创建或删除的时间</strong>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</li>
</ul>
<h2 id="Java代码编译和执行整个过程"><a href="#Java代码编译和执行整个过程" class="headerlink" title="Java代码编译和执行整个过程"></a>Java代码编译和执行整个过程</h2><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被类加载器装入内存，一旦字节码进入虚拟机，它就会被解释器（执行引擎）解释执行。</p>
<p><strong>步骤1：Java代码编译是由Java源码编译器来完成，也就是Java代码到JVM字节码（.class文件）的过程。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190605130338211.png" alt="在这里插入图片描述"></p>
<p><strong>步骤2：Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190605130355535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java代码编译和执行的整个过程包含了三个重要机制：</p>
<ul>
<li>Java源码编译机制</li>
<li>类加载机制</li>
<li>类执行机制</li>
</ul>
<h2 id="Java虚拟机和Dalvik虚拟机区别"><a href="#Java虚拟机和Dalvik虚拟机区别" class="headerlink" title="Java虚拟机和Dalvik虚拟机区别"></a>Java虚拟机和Dalvik虚拟机区别</h2><ul>
<li>java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</li>
<li>Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。</li>
<li>java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.</li>
</ul>
<h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><p><strong>基本数据类型</strong></p>
<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>char</li>
<li>float</li>
<li>double</li>
<li>boolean</li>
</ul>
<p><strong>引用数据类型</strong></p>
<ul>
<li>对象</li>
<li>数组</li>
</ul>
<p><img src="https://img-blog.csdn.net/20140531091306906" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190526183106748.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>区别:</strong></p>
<ul>
<li>基本数据类型保存的是值，引用类型保存的是内存地址</li>
<li>基本数据类型存储在栈中，引用数据类型首先在栈上给引用分配内存空间，对象的具体信息存储在堆中。</li>
<li>基本数据类型的赋值其实是创建新的拷贝，而引用类型的赋值是传递引用。</li>
<li>基本数据类型的==其实是比较值，而引用数据类型比较的是地址（引用）。</li>
<li>一个方法不能修改一个基本类型的参数；一个方法可以修改引用类型参数中对象所指向的值。</li>
</ul>
<p><a href="https://blog.csdn.net/javazejian/article/details/51192130?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5" target="_blank" rel="noopener">数据类型分析</a></p>
<p><strong>int与Integer不同</strong></p>
<ul>
<li>Integer是int的包装类，int则是java的一种基本数据类型</li>
<li>Integer变量必须实例化后才能使用，而int变量不需要</li>
<li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li>
<li>Integer的默认值是null，int的默认值是0</li>
</ul>
<p><strong>延伸：关于Integer和int的比较</strong></p>
<ul>
<li><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; new Integer(100);</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">int j &#x3D; 100；</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;public static Integer valueOf(int i)&#123;</span><br><span class="line">  assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">  if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">      return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  &#125;</span><br><span class="line">  return new Integer(i);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
<h2 id="数组与链表的区别"><a href="#数组与链表的区别" class="headerlink" title="数组与链表的区别"></a>数组与链表的区别</h2><ul>
<li>数组从栈中分配空间，对程序员方便快速，自由度小。</li>
<li>链表从堆中分配内存。自由度大但申请管理比较麻烦。</li>
<li>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减情况（数据插入、删除比较麻烦）。当数据增加时，可能会超出数组的最大空间（越界）；当数据减少时，造成内存浪费。</li>
<li>链表动态地进行存储分配，可以适应数据动态地增减情况（数据插入删除简单）（数组中插入、删除数据项时，需要移动其他项），但链表查找元素时需要遍历整个链表。</li>
</ul>
<h1 id="Java自动装箱与拆箱"><a href="#Java自动装箱与拆箱" class="headerlink" title="Java自动装箱与拆箱"></a>Java自动装箱与拆箱</h1><h2 id="什么是自动装箱、拆箱"><a href="#什么是自动装箱、拆箱" class="headerlink" title="什么是自动装箱、拆箱"></a>什么是自动装箱、拆箱</h2><p>装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h2 id="自动装箱的原理及使用场景"><a href="#自动装箱的原理及使用场景" class="headerlink" title="自动装箱的原理及使用场景"></a>自动装箱的原理及使用场景</h2><p>基本数据类型–&gt;封装类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10;</span><br></pre></td></tr></table></figure>

<p>执行时实际上系统执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; Integer.valueOf(10);</span><br></pre></td></tr></table></figure>

<p>分析Integer的valueOf源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if(i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; IntegerCache.high)　　&#x2F;&#x2F; 没有设置的话，IngegerCache.high 默认是127</span><br><span class="line">        return IntegerCache.cache[i + 128];</span><br><span class="line">    else</span><br><span class="line">        return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于–128到127（默认是127）之间的值，Integer.valueOf(int i) 返回的是缓存的Integer对象（并不是新建对象），而其他值，执行Integer.valueOf(int i) 返回的是一个新建的 Integer对象。装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响性能。</p>
<h2 id="自动拆箱的原理及使用场景"><a href="#自动拆箱的原理及使用场景" class="headerlink" title="自动拆箱的原理及使用场景"></a>自动拆箱的原理及使用场景</h2><p>封装类–&gt;基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10; &#x2F;&#x2F;装箱 </span><br><span class="line">int t &#x3D; i; &#x2F;&#x2F;拆箱，实际上执行了 int t &#x3D; i.intValue();</span><br></pre></td></tr></table></figure>

<p>进行运算时也可以进行拆箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10; </span><br><span class="line">System.out.println(i++);</span><br></pre></td></tr></table></figure>

<p>Integer与int运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 10;</span><br><span class="line">Integer integer1 &#x3D; new Integer(10); </span><br><span class="line">System.out.println(i&#x3D;&#x3D;integer1);&#x2F;&#x2F;true,integer1自动拆箱</span><br></pre></td></tr></table></figure>

<p>intValue函数很简单，直接返回value值即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int intValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h1><ul>
<li>final类说明是一个不可变对象</li>
<li>内部使用value[]数组实现</li>
<li>声明int类型hash</li>
</ul>
<p><strong>==与equals()</strong></p>
<p>答：</p>
<ul>
<li><p>==</p>
<ul>
<li>若操作数的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的值是否相等</li>
<li>若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。        </li>
</ul>
</li>
<li><p>equals</p>
<ul>
<li>在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</li>
<li>但是一般像String就重写了equels方法。</li>
</ul>
</li>
</ul>
<p><strong>定义为String类型的st1和st2是否相等，为什么</strong></p>
<p>答：常量池个特点，如果发现已经存在，就不在创建重复的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;abc&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2)); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：true</span><br><span class="line"></span><br><span class="line">第二行：true</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180409133349472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NDE5NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>内存过程：</p>
<ol>
<li>运行编译，当前类class文件加载进方法区</li>
<li>方法main压栈</li>
<li>常量池创建“abc”对象，产生一个内存地址</li>
<li>然后把内存地址执行st1，st1根据内存地址，指向了常量池中的“abc”。</li>
<li>当代码执行<code>Stringst2 =”abc”</code>,发现常量池中存在”abc”对象所以不会创建对象，直接把”abc”内存地址复制给st2。</li>
<li>最后st1和st2都指向了内存中同一个地址，所以两者是完全相同的。</li>
</ol>
<p><strong>下面这句话在内存中创建了几个对象</strong></p>
<p><code>String st1 = new String(“abc”);</code></p>
<p>答：两个对象。一个是常量池“abc”对象，一个是堆内存String对象。</p>
<p><img src="https://img-blog.csdn.net/20180409133238683?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NDE5NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>判定以下定义为String类型的st1和st2是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：false true</p>
<ul>
<li>==比较的是地址值，st1指向堆内存中的string对象，st2指向常量池的‘abc’对象。</li>
<li>equals默认也是比较地址值，但是String类中重写了此方法，实际比较的是值。（首先比较地址）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString &#x3D; (String)anObject;</span><br><span class="line">            int n &#x3D; length();</span><br><span class="line">            if (n &#x3D;&#x3D; anotherString.length()) &#123;</span><br><span class="line">                int i &#x3D; 0;</span><br><span class="line">                while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                    if (charAt(i) !&#x3D; anotherString.charAt(i))</span><br><span class="line">                            return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>判定以下定义为String类型的st1和st2是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：true 和 true</p>
<blockquote>
<p>“a”,”b”,”c”三个本来就是字符串常量，进行+符号拼接之后变成了“abc”，“abc”本身就是字符串常量（Java中有常量优化机制），所以常量池立马会创建一个“abc”的字符串常量对象，在进行st2=”abc”,这个时候，常量池存在“abc”，所以不再创建。所以，不管比较内存地址还是比较字符串序列，都相等。</p>
</blockquote>
<p><strong>判断以下st2和st3是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;ab&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     String st3 &#x3D; st1 + &quot;c&quot;;</span><br><span class="line">     System.out.println(st2 &#x3D;&#x3D; st3);</span><br><span class="line">     System.out.println(st2.equals(st3));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：false 和 true</p>
<blockquote>
<p>s1和s2都会在常量池中创建对象，st3在编译时期不能确定st3的值，只能在运行期间确定<code>st3=&quot;abc&quot;</code>,在运行期间就只能放在堆内存中。所以不是同一个引用。</p>
</blockquote>
<h1 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h1><p><img src="https://img-blog.csdnimg.cn/20190526180828781.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>不可变对象即对象一旦创建它的状态就不能发生改变（对象的数据，属性值），反之即为可变对象。</p>
<p>不可变对象的类即为不可变类，String、基本类型的包装类、BigInteger和BigDecimal等都是不可变类。</p>
<p><strong>不可变的对象必须满足的条件</strong></p>
<ul>
<li>将类声明为final</li>
<li>声明属性为private 和 final</li>
<li>不要提供任何会修改对象状态的方法</li>
</ul>
<p><strong>改变”不可变对象”</strong></p>
<p>现在我们已经知道了String的成员变量是private final 的，也就是初始化之后不可改变的。同时也提到value这个成员变量其实也是一个引用，指向真正的数组内存地址，不能改变它的引用指向，我们能不能直接改变内存数组中的数据呢，那么就需要获取到value，而value是私有的，可用反射获取</p>
<h1 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h1><p>java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p>
<ul>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li>
<li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。</p>
<p>序列化的作用就是为了保存java的类对象的状态，并将对象转换成可存储或者可传输的状态，用于不同jvm之间进行类实例间的共享。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>实现序列化的两种方式：</p>
<ul>
<li>实现Serializable接口：Java专用</li>
<li>实现Parcelable接口：Android专用</li>
</ul>
<h3 id="Serializable-和Parcelable的对比"><a href="#Serializable-和Parcelable的对比" class="headerlink" title="Serializable 和Parcelable的对比"></a>Serializable 和Parcelable的对比</h3><p>Android上应该尽量采用Parcelable，效率至上,Parcelable的速度比高十倍以上。</p>
<p><strong>Serializable</strong>的迷人之处在于你只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<p><strong>Parcelable</strong>方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>定义在类内部的类就被称为内部类。外部类按常规的类访问方式使用内部类，唯一的差别是内部类可以访问外部类的所有方法与属性，包括私有方法与属性。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>定义在类内部的静态类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public static class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner是静态内部类。静态内部类可以访问外部类所有静态变量和方法。静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out.Inner inner &#x3D; new Out.Inner();</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>



<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在类内部的非静态类称为成员内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和实例，私有和非私有。和静态内部类不同的是，每一个成员内部类的实例都依赖一个外部类的实例（成员内部类是依附外部类而存在的）。其它类使用内部类必须要先创建一个外部类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out out &#x3D; new Out();</span><br><span class="line">Out.Inner inner &#x3D; out.new Inner();</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>

<ul>
<li>成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</li>
<li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</li>
<li>成员内部类与外部类可以拥有同名的成员变量或方法，默认情况下访问的是成员内部类的成员。如果要外部类的同名成员，需用下面的形式访问：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutterClass(外部类).this.成员</span><br></pre></td></tr></table></figure>



<p><strong>为什么Java中成员内部类可以访问外部类成员？</strong></p>
<ul>
<li>成员内部类的创建需要外部类的对象</li>
<li>内部类对象持有指向外部类对象的引用。</li>
</ul>
<p><strong>静态内部类与成员内部类对比</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190528190801750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="局部内部类-amp-闭包"><a href="#局部内部类-amp-闭包" class="headerlink" title="局部内部类&amp;闭包"></a>局部内部类&amp;闭包</h3><p>定义在外部类方法中的类，叫局部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public void test(final int c) &#123;</span><br><span class="line">        final int d &#x3D; 1;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testStatic(final int c) &#123;</span><br><span class="line">        final int d &#x3D; 1;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                &#x2F;&#x2F;定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                &#x2F;&#x2F;System.out.println(b);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部类只能在定义该局部类的方法中使用。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。同时局部类还可以访问方法的参数和方法中的局部变量，这些参数和变量必须要声明为final的。否则会报错</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    private Object obj &#x3D; new Object() &#123;</span><br><span class="line">        private String name &#x3D; &quot;匿名内部类&quot;;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Object obj &#x3D; new Object() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String toString() &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                return String.valueOf(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类可以访问外部类所有的变量和方法。</p>
<h3 id="内部类特点"><a href="#内部类特点" class="headerlink" title="内部类特点"></a>内部类特点</h3><ul>
<li>非静态内部类对象不仅指向该内部类，还指向实例化该内部类的外部类对象的内存。</li>
<li>内部类和普通类一样可以重写Object类的方法，如toString方法；并且有构造函数，执行顺序依旧是先初始化属性，再执行构造函数</li>
<li>在编译完之后，会出现（外部类.class）和（外部类﹩内部类.class）两个类文件名。</li>
<li>内部类可以被修饰为private，只能被外部类所访问。事实上一般也都是如此书写。</li>
<li>内部类可以被写在外部类的任意位置，如成员位置，方法内。</li>
</ul>
<h4 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h4><ul>
<li>静态时，静态内部类只能访问外部类静态成员;非静态内部类都可以直接访问。（原因是：内部类有一个外部类名.this的指引）当访问外部类静态成员出现重名时，通过(外部类名.静态成员变量名)访问。如，Out.show();</li>
<li>重名情况下，非静态时，内部类访问自己内部类通过this.变量名。访问外部类通过（外部类名.this.变量名）访问 。如Out.this.show();</li>
<li>在没有重名的情况下，无论静态非静态，内部类直接通过变量名访问外部成员变量。</li>
</ul>
<h4 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h4><ul>
<li>内部类为非静态时，外部类访问内部类，必须建立内部类对象。建立对象方法，如前所述。</li>
<li>内部类为静态时，外部类访问非静态成员，通过（外部类对象名.内部类名.方法名）访问，如new Out().In.function();</li>
<li>内部类为静态时，外部类访问静态成员时，直接通过（外部类名.内部类名.方法名），如 Out.In.funchtion();</li>
<li>当内部类中定义了静态成员时，内部类必须是静态的；当外部静态方法访问内部类时，内部类也必须是静态的才能访问。</li>
</ul>
<h1 id="静态（static）"><a href="#静态（static）" class="headerlink" title="静态（static）"></a>静态（static）</h1><p>把一个变量声明为静态变量通常基于以下三个目的：</p>
<ul>
<li>作为共享变量</li>
<li>减少对象的创建</li>
<li>保留唯一副本</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul>
<li>静态变量在内存中只有一份拷贝，JVM只为静态分配一次内存，在类加载的过程中完成静态变量的内存分配。可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。</li>
<li>实例变量，每次创建实例，都会对实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</li>
</ul>
<h3 id="静态变量与实例变量区别"><a href="#静态变量与实例变量区别" class="headerlink" title="静态变量与实例变量区别"></a>静态变量与实例变量区别</h3><ul>
<li>所属不同，静态变量属于类，普通成员变量所有当前对象。</li>
<li>存储区域不同，静态变量存在方法区，普通成员变量存在堆（成员变量存储在堆中的对象里面）。</li>
<li>生命周期不同，静态变量生周期与类相同；普通成员变量与当前对象相同。</li>
<li>序列化时，静态变量会被拆除在外。</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法可以直接使用类名调用，静态方法中不能使用this、super，不能直接访问成员变量，成员方法，只能访问类下的静态变量、静态方法，因为实例成员和实例方法与当前对象关联，静态属于类。静态方法不能被抽象。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<h3 id="静态方法和静态代码块的区别"><a href="#静态方法和静态代码块的区别" class="headerlink" title="静态方法和静态代码块的区别"></a>静态方法和静态代码块的区别</h3><ul>
<li>如果有些代码必须在项目启动的时候就执行,就需要使用静态代码块,这种代码是主动执行的；</li>
<li>需要在项目启动的时候就初始化但是不执行,在不创建对象的情况下,可以供其他程序调用,而在调用的时候才执行，这需要使用静态方法,这种代码是被动执行的。 静态方法在类加载的时候 就已经加载 可以用类名直接调用。</li>
</ul>
<p>一句话：类加载时初始化，静态代码块是自动执行的；静态方法是被调用的时候才执行的。</p>
<h3 id="静态内部类和非静态内部类的区别"><a href="#静态内部类和非静态内部类的区别" class="headerlink" title="静态内部类和非静态内部类的区别"></a>静态内部类和非静态内部类的区别</h3><ul>
<li>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</li>
<li>非静态内部类会持有外部类的引用；静态内部类不会持有外部类的引用。</li>
</ul>
<h3 id="父类的静态方法能不能被子类重写"><a href="#父类的静态方法能不能被子类重写" class="headerlink" title="父类的静态方法能不能被子类重写"></a>父类的静态方法能不能被子类重写</h3><h4 id="重写-重载"><a href="#重写-重载" class="headerlink" title="重写/重载"></a>重写/重载</h4><ul>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</li>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li>
</ul>
<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。</p>
<p>在java中，所有的东西都是对象，对象的抽象就是类，对于一个类而言，如果要使用他的成员（类中的属性，方法等），一般情况下，必须先实例化对象后，通过对象的引用才能访问这些成员。但是，如果要使用的成员使用了static修饰，就可以不通过实例化获得该成员。</p>
<h4 id="父类的静态方法能不能被子类重写-1"><a href="#父类的静态方法能不能被子类重写-1" class="headerlink" title="父类的静态方法能不能被子类重写"></a>父类的静态方法能不能被子类重写</h4><p>不能</p>
<p>因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。</p>
<h1 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h1><p>异常知识体系树如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190530174605603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Error是程序代码无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止退出，其表示程序在运行期间出现了十分严重、不可恢复的错误，应用程序只能中止运行。</li>
<li>Exception分运行时异常和非运行时异常。<ul>
<li>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常也是不检查异常，程序代码中自行选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序代码应该从逻辑角度尽可能避免这类异常的发生。</li>
<li>所有继承Exception且不是RuntimeException的异常都是非运行时异常，也称检查异常，如上图中的IOException和ClassNotFoundException，编译器会对其作检查，故程序中一定会对该异常进行处理，处理方法要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。</li>
</ul>
</li>
</ul>
<h2 id="抛出异常的方式"><a href="#抛出异常的方式" class="headerlink" title="抛出异常的方式"></a>抛出异常的方式</h2><ul>
<li><p>使用 <code>throw</code> 抛出异常：throw<code>总是出现在**函数体**中，用来抛出一个</code>Throwable<code>类型的异常，例如抛出一个</code> <code>IOException</code> 类的异常对象。</p>
</li>
<li><p>使用 <code>throws</code> 抛出异常：如果一个方法可能会出现异常，但没有能力处理这种异常，可以在<strong>方法声明处</strong>用 <code>throws</code> 子句来声明抛出异常。</p>
</li>
</ul>
<p><strong>throw 和 throws 的区别？</strong></p>
<ul>
<li>throw用于方法内部，throws用于方法声明上</li>
<li>throw后跟异常对象，throws后跟异常类型</li>
<li>throw后只能跟一个异常对象，throws后可以一次声明多种异常类型</li>
</ul>
<h2 id="final、finally、finalize-有什么区别"><a href="#final、finally、finalize-有什么区别" class="headerlink" title="final、finally、finalize 有什么区别"></a>final、finally、finalize 有什么区别</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void omitFinally() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			int i &#x3D; 0;</span><br><span class="line">			i +&#x3D; 1;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void omitCatch() &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i +&#x3D; 1;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<p><strong>在以下 4 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ul>
<h2 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h2><ul>
<li>NullPointerException 当应用程序试图访问空对象时，则抛出该异常。</li>
<li>SQLException 提供关于数据库访问错误或其他错误信息的异常。</li>
<li>IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li>NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li>FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li>IOException当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>
<li>ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li>ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>
<li>NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li>NoSuchMethodException无法找到某一特定方法时，抛出该异常。</li>
<li>SecurityException由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li>UnsupportedOperationException当不支持请求的操作时，抛出该异常。</li>
<li>RuntimeExceptionRuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><a href="https://www.zhihu.com/question/24304289" target="_blank" rel="noopener">https://www.zhihu.com/question/24304289</a></p>
<p><img src="http://image.tengj.top/Javareflect.png" alt="img"></p>
<ul>
<li>java代码在计算机中经历的阶段（三阶段）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190901141812427.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170513133210763" alt="img"></p>
<p>Java反射机制是指在运行状态中，可以对任意类，都知道它的属性和方法并调用。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。一句话<strong>反射可以在运行时知道类的属性和方法</strong>。</p>
<p>反射就是把Java类中的各种成分映射成对象的Java类，然后对这个java类进行操作。（比如：类的成员属性Field、类的成员方法Method、类的构造方法）</p>
<ul>
<li>反射的好处<ul>
<li>可以在程序运行时操作这些对象。</li>
<li>可以解耦，提高程序可扩展性。</li>
</ul>
</li>
<li>反射的缺点<ul>
<li>反射的效率很低</li>
<li>会破坏封装，通过反射可以访问类的私有方法，不安全</li>
</ul>
</li>
</ul>
<h2 id="字节码Class对象"><a href="#字节码Class对象" class="headerlink" title="字节码Class对象"></a>字节码Class对象</h2><h3 id="Class类对象——描述-class字节码文件"><a href="#Class类对象——描述-class字节码文件" class="headerlink" title="Class类对象——描述.class字节码文件"></a>Class类对象——描述.class字节码文件</h3><p>将java文件经过编译后变成class字节码文件通过类加载器加载到内存，通过java.lang.Class类对象对字节码文件进行描述。每一个类都是一个class类对象的实例。<strong>class类对象是用来对类的描述，主要包括三个成员变量</strong>：</p>
<ul>
<li>类成员变量 Field[] fields</li>
<li>类成员方法 Method[] methods</li>
<li>类构造函数 Constructor[] constructors</li>
</ul>
<h3 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h3><p>Class类构造函数是私有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;*</span><br><span class="line">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span><br><span class="line">     * This constructor is not used and prevents the default constructor being</span><br><span class="line">     * generated.</span><br><span class="line">     *&#x2F;</span><br><span class="line">private Class() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Class.forName(“全类名”)</p>
<p><strong>在Source源代码阶段</strong>，此时java类仍位于硬盘上。多用于配置文件，将类名定义在配置文件中。读取文件，并触发类构造器加载类。Class.forName() 方法如果写错类的路径会报 ClassNotFoundException 的异常。</p>
</li>
<li><p>类名.class：通过类名的属性class获取</p>
<p><strong>在Class类对象阶段</strong>，此时java类位于内存中，但没有实际对象。多用于参数的传递。通过这种方式时，只会加载Dog类，并不会触发其类构造器的初始化。</p>
</li>
<li><p>对象.getClass()：getClass（）方法在Object类中定义</p>
<p><strong>在运行阶段</strong>，此时已经获取类的实例对象，多用于对象的获取字节码的方式。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法1：Class.forName(&quot;全类名&quot;)</span><br><span class="line">      try &#123;</span><br><span class="line">          Class cls1 &#x3D; Class.forName(&quot;com.test.demo.Dog&quot;);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">      &#x2F;&#x2F; 方法2：类名.class</span><br><span class="line">      Class cls2 &#x3D; Dog.class;</span><br><span class="line">      &#x2F;&#x2F; 方法3：对象.getClass()</span><br><span class="line">      Dog dog &#x3D; new Dog();</span><br><span class="line">  	Class cls3 &#x3D; dog.getClass();</span><br><span class="line">&#x2F;&#x2F; 用 &#x3D;&#x3D; 比较3个对象是否为同一个对象（指向同一物理地址）</span><br><span class="line">System.out.print(cls1 &#x3D;&#x3D; cls2);	&#x2F;&#x2F;	true</span><br><span class="line">System.out.print(cls1 &#x3D;&#x3D; cls3);	&#x2F;&#x2F;	true</span><br></pre></td></tr></table></figure>

<p>同一个字节码文件（<em>.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。*</em>也就是说在运行期间，一个类，只有一个Class对象产生。**</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h1 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h1><h2 id="什么是范型"><a href="#什么是范型" class="headerlink" title="什么是范型"></a>什么是范型</h2><p>用来规定类、接口、方法接受数据的类型。</p>
<p>泛型的本质就是利用编译器实现的Java语法糖，编译器将java文件转换为class文件前，会进行泛型擦除，所以在反编译的class文件中，是看不到泛型声明的</p>
<h2 id="范型的优缺点"><a href="#范型的优缺点" class="headerlink" title="范型的优缺点"></a>范型的优缺点</h2><p><strong>范型的优点：</strong></p>
<ul>
<li><strong>提高安全性:</strong> 将运行期的错误转换到编译期. 如果我们在对一个对象所赋的值不符合其泛型的规定, 就会编译报错.</li>
<li><strong>避免强转:</strong> 比如我们在使用List时, 如果我们不使用泛型, 当从List中取出元素时, 其类型会是默认的Object, 我们必须将其向下转型为String才能使用。</li>
</ul>
<p><strong>范型的缺点：</strong></p>
<ul>
<li>类型擦除问题</li>
</ul>
<h3 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a>范型擦除</h3><p>在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<h2 id="范型的使用"><a href="#范型的使用" class="headerlink" title="范型的使用"></a>范型的使用</h2><p>泛型有三种使用方式，分别为：</p>
<ul>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
</ul>
<p>范型使用规则：</p>
<ul>
<li>泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</li>
<li>泛型只在编译阶段有效。</li>
<li>在实例化泛型类时，必须指定具体类型，如果不传入泛型类型实参的话，不会起到限制的作用，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</li>
<li>不能对确切的泛型类型使用instanceof操作</li>
<li>当实现泛型接口的类，未传入泛型实参时，声明类需将泛型的声明也一起加到类中，如果不声明，编译器会报错。</li>
<li>public 与 返回值中间<T>，可以理解为声明此方法为泛型方法。</li>
<li>只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li>
</ul>
<h3 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h3><p>泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Base&lt;Double&gt; base &#x3D; new Base&lt;Double&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="范型接口"><a href="#范型接口" class="headerlink" title="范型接口"></a>范型接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化泛型类时，必须指定具体类型，如果不传入泛型类型实参的话，不会起到限制的作用，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] fruits &#x3D; new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand &#x3D; new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="范型方法"><a href="#范型方法" class="headerlink" title="范型方法"></a>范型方法</h3><p>print是范型方法，其它的get set 不是范型方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;E, K&gt; K print(E e, K k) &#123;</span><br><span class="line"></span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型中的通配符"><a href="#泛型中的通配符" class="headerlink" title="泛型中的通配符"></a>泛型中的通配符</h2><p>范型中的通配符规定只允许某一部分类作为泛型。</p>
<h3 id="通配符分类"><a href="#通配符分类" class="headerlink" title="通配符分类"></a>通配符分类</h3><ul>
<li>无边界通配符(&lt;?&gt;)：让泛型能够接受未知类型的数据</li>
<li>固定上边界通配符(&lt;? extends E&gt;),即传入的类型实参必须是指定类型的子类型。注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类.</li>
<li>固定下边界通配符（? super E）即传入的类型实参必须是指定类型的父类型</li>
</ul>
<h2 id="关于泛型数组"><a href="#关于泛型数组" class="headerlink" title="关于泛型数组"></a>关于泛型数组</h2><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。</p>
<p>也就是说下面的这个例子是不可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList&lt;String&gt;[10];</span><br></pre></td></tr></table></figure>

<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls &#x3D; new ArrayList&lt;?&gt;[10];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList[10];</span><br></pre></td></tr></table></figure>

<p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">的一篇文档</a>的一个例子来说明这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa &#x3D; new List&lt;String&gt;[10]; &#x2F;&#x2F; Not really allowed.    </span><br><span class="line">Object o &#x3D; lsa;    </span><br><span class="line">Object[] oa &#x3D; (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(new Integer(3));    </span><br><span class="line">oa[1] &#x3D; li; &#x2F;&#x2F; Unsound, but passes run time store check    </span><br><span class="line">String s &#x3D; lsa[1].get(0); &#x2F;&#x2F; Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
</blockquote>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
<p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa &#x3D; new List&lt;?&gt;[10]; &#x2F;&#x2F; OK, array of unbounded wildcard type.    </span><br><span class="line">Object o &#x3D; lsa;    </span><br><span class="line">Object[] oa &#x3D; (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(new Integer(3));    </span><br><span class="line">oa[1] &#x3D; li; &#x2F;&#x2F; Correct.    </span><br><span class="line">Integer i &#x3D; (Integer) lsa[1].get(0); &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>



<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解（Annotation），也叫元数据，一种代码级别的说明。JDK1.5引入的特性，与类、接口、枚举是在同一个层次，它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<strong>注解的本质就是一个继承了 Annotation 接口的接口</strong>，所有的注解类型都继承自Annotation。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p>
<ul>
<li><p>@Target：<strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    &#x2F;** 表示可以用来修饰类、接口、注解类型或枚举类型Class, interface (including annotation type), or enum declaration *&#x2F;</span><br><span class="line">    TYPE,</span><br><span class="line">    &#x2F;** 可以用来修饰属性（包括枚举常量）Field declaration (includes enum constants) *&#x2F;</span><br><span class="line">    FIELD,</span><br><span class="line">    &#x2F;** 可以用来修饰方法Method declaration *&#x2F;</span><br><span class="line">    METHOD,</span><br><span class="line">    &#x2F;** 可以用来修饰参数 Formal parameter declaration *&#x2F;</span><br><span class="line">    PARAMETER,</span><br><span class="line">    &#x2F;** 可以用来修饰构造器 Constructor declaration *&#x2F;</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    &#x2F;** 可用来修饰局部变量Local variable declaration *&#x2F;</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    &#x2F;** 可以用来修饰注解类型Annotation type declaration *&#x2F;</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    &#x2F;** 可以用来修饰包Package declaration *&#x2F;</span><br><span class="line">    PACKAGE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 标注在类型参数上Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于标注任意类型(不包括class)Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>@Retention：<strong>定义了<code>Annotation</code>的生命周期</strong></p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息）</p>
<p><strong>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</strong></p>
</li>
</ul>
</li>
<li><p>@Documented：<strong>用来描述注解是否被抽取到api文档中。在生成javadoc文档的时候将该Annotation也写入到文档中。</strong></p>
</li>
<li><p>@Inherited：<strong>如果一个使用了<code>@Inherited</code>修饰的<code>annotation</code>类型被用于一个class，则这个<code>annotation</code>将被用于该class的子类。并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</strong></p>
</li>
<li><p>@Repeatable：它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的。</p>
</li>
</ul>
<h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ul>
<li><p>@Override：用于标记该方法是复写的父类中的某个方法。属于标记注解，不需要设置属性值；只能添加在方法的前面。</p>
</li>
<li><p>@Deprecated：说明被修饰内容已被“废弃”，不再建议用户使用。</p>
</li>
<li><p>@SuppressWarnings：忽略警告。</p>
</li>
<li><p>@TargetApi：版本注解。</p>
</li>
<li><p>@SuppressLint：避免在lint检查时报错</p>
</li>
<li><p><strong>Nullable</strong>：用于标记方法参数或者返回值可以为空；</p>
</li>
<li><p><strong>@NonNull:</strong>用于标记方法参数或者返回值不能为空，如果为空编译器会报警告；</p>
</li>
<li><p>@IdRes：Android中一系列<strong>资源类型注解</strong>。</p>
</li>
<li><p>使用整型常量代替枚举类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class IceCreamFlavourManager &#123;</span><br><span class="line">    private int flavour;</span><br><span class="line"></span><br><span class="line">    public static final int VANILLA &#x3D; 0;</span><br><span class="line">    public static final int CHOCOLATE &#x3D; 1;</span><br><span class="line">    public static final int STRAWBERRY &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    @IntDef(&#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</span><br><span class="line">    public @interface Flavour &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Flavour</span><br><span class="line">    public int getFlavour() &#123;</span><br><span class="line">        return flavour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlavour(@Flavour int flavour) &#123;</span><br><span class="line">        this.flavour &#x3D; flavour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@UiThread :等线程注解</p>
</li>
<li><p>@Size、@IntRange、@FloatRange等值约束注解。</p>
</li>
<li><p>权限注解</p>
</li>
<li><p>@CheckResult：<strong>返回值注解</strong>。</p>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><h4 id="编译时期使用注解"><a href="#编译时期使用注解" class="headerlink" title="编译时期使用注解"></a>编译时期使用注解</h4><p>编译时注解指的是@Retention的值为CLASS的注解。对于这类注解的解析，我们只需做好以下两件事儿：</p>
<ul>
<li>自定义一个派生自 AbstractProcessor的“注解处理类”；</li>
<li>重写process 函数。</li>
</ul>
<p>实际上，javac中包含的注解处理器在编译时会自动查找所有继承自 AbstractProcessor 的类，然后调用它们的 process 方法。因此我们只要做好上面两件事，编译器就会主动去解析我们的编译时注解。现在，我们把上面定义的TestAnnotation的Retention改为CLASS，我们就可以按照以下代码来解析它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;com.zhyen.com.TestAnnotation&quot;)</span><br><span class="line">public class TestAnnotationClass extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (TypeElement element : annotations) &#123;</span><br><span class="line">            for (Element e : roundEnv.getElementsAnnotatedWith(element)) &#123;</span><br><span class="line">                TestAnnotation annotation&#x3D;e.getAnnotation(TestAnnotation.class);</span><br><span class="line">                map.put(e.getEnclosingElement().toString(),annotation.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SupportedAnnotationTypes注解指出了MyProcessor向要解析的注解的完整名字（全限定名称）。process+函数的annotations参数表示待处理的注解集，通过env我们可以得到被特定注解所修饰的程序元素。process函数的返回值表示annotations中的注解是否被这个Processor接受。&amp;oq=%40SupportedAnnotationTypes注解指出了MyProcessor向要解析的注解的完整名字（全限定名称）。process+函数的annotations参数表示待处理的注解集，通过env我们可以得到被特定注解所修饰的程序元素。process函数的返回值表示annotations中的注解是否被这个Processor接受</p>
<h4 id="运行时期使用直接"><a href="#运行时期使用直接" class="headerlink" title="运行时期使用直接"></a>运行时期使用直接</h4><p>Class 类中提供了以下一些方法用于反射注解：</p>
<ul>
<li><p>getAnnotation：返回指定的注解</p>
</li>
<li><p>isAnnotationPresent：判定当前元素是否被指定注解修饰</p>
</li>
<li><p>getAnnotations：返回所有的注解</p>
</li>
<li><p>getDeclaredAnnotation：返回本元素的指定注解</p>
</li>
<li><p>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</p>
</li>
</ul>
<p><strong>方法、字段中相关反射注解的方法基本是类似的</strong></p>
<h3 id="案例一个"><a href="#案例一个" class="headerlink" title="案例一个"></a>案例一个</h3><p>注解类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TestAnnotation &#123;</span><br><span class="line">    String value() default &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">    public String name() default &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    int index() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestAnnotationClass &#123;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;汪汪汪&quot;, name &#x3D; &quot;dog&quot;, index &#x3D; 100)</span><br><span class="line">    public String dog;</span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;喵喵喵&quot;, name &#x3D; &quot;cat&quot;, index &#x3D; 200)</span><br><span class="line">    public String cat;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;爱爆炸&quot;, index &#x3D; 10, name &#x3D; &quot;三星&quot;)</span><br><span class="line">    public void phone() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;细&quot;, index &#x3D;20, name &#x3D; &quot;ARM&quot;)</span><br><span class="line">    public void CPU() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取注解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TestAnnotationClass&gt; clazz &#x3D; TestAnnotationClass.class;</span><br><span class="line">        Field[] fields &#x3D; clazz.getFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            TestAnnotation annotation &#x3D; field.getAnnotation(TestAnnotation.class);</span><br><span class="line">            String name &#x3D; annotation.name();</span><br><span class="line">            int index &#x3D; annotation.index();</span><br><span class="line">            String value &#x3D; annotation.value();</span><br><span class="line">            Log.d(TAG, &quot;name &#x3D; &quot; + name + &quot; ,index &#x3D; &quot; + index + &quot;, value &#x3D; &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TestAnnotation annotation &#x3D; method.getAnnotation(TestAnnotation.class);</span><br><span class="line">            String name &#x3D; annotation.name();</span><br><span class="line">            int index &#x3D; annotation.index();</span><br><span class="line">            String value &#x3D; annotation.value();</span><br><span class="line">            Log.d(TAG, &quot;name &#x3D; &quot; + name + &quot; ,index &#x3D; &quot; + index + &quot;, value &#x3D; &quot; + value);</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; cat ,index &#x3D; 200, value &#x3D; 喵喵喵</span><br><span class="line">name &#x3D; dog ,index &#x3D; 100, value &#x3D; 汪汪汪</span><br><span class="line">方法名: CPU </span><br><span class="line">name &#x3D; ARM ,index &#x3D; 20, value &#x3D; 细</span><br><span class="line">equals</span><br><span class="line">方法名: getClass</span><br><span class="line">方法名: hashCode</span><br><span class="line">方法名: notify</span><br><span class="line">方法名: phone</span><br><span class="line">name &#x3D; 三星 ,index &#x3D; 10, value &#x3D; 爱爆炸</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h1 id="抽象类（Abstract-Class）"><a href="#抽象类（Abstract-Class）" class="headerlink" title="抽象类（Abstract Class）"></a>抽象类（Abstract Class）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。抽象类用abstract修饰。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>不能实例化，因为抽象类中含有无法具体实现的方法。</li>
<li>可在抽象类中定义公共成员变量、成员方法、构造方法等。</li>
<li>只要包含一个抽象方法的类，该类必须要定义成抽象类（抽象方法是一种特殊的方法，它只有声明但没有具体的实现，抽象方法必须为public或protected）。故可理解为抽象类是在普通类结构里增加抽象方法的组成部分。</li>
<li>如果子类继承于一个抽象类，则该子类可以有选择性决定是否覆写父类的抽象方法，如果子类没有实现父类的抽象方法，则必须将子类也定义为抽象类（抽象类可以继承抽象类）</li>
<li>继承只能单继承，一个子类只能继承一个抽象类。</li>
<li>abstract不能与final并列修饰同一个类。</li>
<li>abstract 不能与private、static、final或native并列修饰同一个方法。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;&#x2F;&#x2F;定义一个抽象类</span><br><span class="line">	</span><br><span class="line">	public void fun()&#123;&#x2F;&#x2F;普通方法</span><br><span class="line">		System.out.println(&quot;存在方法体的方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public abstract void print();&#x2F;&#x2F;抽象方法，没有方法体，有abstract关键字做修饰</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="抽象类必须有抽象方法吗"><a href="#抽象类必须有抽象方法吗" class="headerlink" title="抽象类必须有抽象方法吗"></a>抽象类必须有抽象方法吗</h3><p>不是</p>
<h3 id="抽象类可以继承普通类吗"><a href="#抽象类可以继承普通类吗" class="headerlink" title="抽象类可以继承普通类吗"></a>抽象类可以继承普通类吗</h3><p>可以</p>
<h3 id="抽象类有构造方法吗？"><a href="#抽象类有构造方法吗？" class="headerlink" title="抽象类有构造方法吗？"></a>抽象类有构造方法吗？</h3><p>有</p>
<h3 id="抽象类可以用final声明么？"><a href="#抽象类可以用final声明么？" class="headerlink" title="抽象类可以用final声明么？"></a>抽象类可以用final声明么？</h3><p>不能，因为抽象类必须有子类，而final定义的类不能有子类；</p>
<h3 id="抽象类能否使用static声明？"><a href="#抽象类能否使用static声明？" class="headerlink" title="抽象类能否使用static声明？"></a>抽象类能否使用static声明？</h3><p>外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p>
<h3 id="可以直接调用抽象类中用static声明的方法么？"><a href="#可以直接调用抽象类中用static声明的方法么？" class="headerlink" title="可以直接调用抽象类中用static声明的方法么？"></a>可以直接调用抽象类中用static声明的方法么？</h3><p>任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</p>
<h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。</li>
<li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li>
<li>一个接口可以继承于另一个接口，或者另一些接口，接口也可以继承，并且可以多继承。接口不能实现(implement)另一个接口</li>
<li>一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。</li>
<li>不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的</li>
<li>接口没有构造方法</li>
<li>接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的。</li>
<li>接口支持多继承（一个类可以实现多个接口）</li>
<li>一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。</li>
<li>接口也被用来实现解耦。</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Door&#123;</span><br><span class="line">void open ();</span><br><span class="line">void close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public class BigDoor implements Door &#123;</span><br><span class="line"></span><br><span class="line">void open ()&#123;</span><br><span class="line">System.out.println(&quot;BigDoor is opening...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void close()&#123;</span><br><span class="line">System.out.println(&quot;BigDoor is closing...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口的标识用法"><a href="#接口的标识用法" class="headerlink" title="接口的标识用法"></a>接口的标识用法</h2><p>虽然接口内部定义了一些抽象方法，但是并不是所有的接口内部都必须要有方法，比如Seriallizable接口，Seriallizable接口的作用是使对象能够“序列化”，但是Seriallizable接口中却没有任何内容，也就是说，如果有一个类需要实现“序列化”的功能，则这个类必须去实现Seriallizable接口，但是却并不用实现方法（因为接口中没有方法），此时，这个Serilizable接口就仅仅是一个“标识”接口，是用来标志一个类的，标志这个类具有这个“序列化”功能。</p>
<h1 id="抽象类与接口区别"><a href="#抽象类与接口区别" class="headerlink" title="抽象类与接口区别"></a>抽象类与接口区别</h1><ul>
<li>抽象类中可以有自己的方法实现。也可以有抽象方法。接口只有抽象方法。</li>
<li>一个子类只能继承一个父类，但可以实现多个接口。</li>
<li>子类使用extends关键字继承抽象类。子类可以选择性重写抽象类中需要使用的方法;子类使用implements关键字实现接口。子类需要提供接口中所有声明的方法的实现。</li>
<li>抽象类可以有构造方法，但接口没有构造方法。但抽象类的构造器不用于创造对象，而是让其子类调用这些构造器完成抽象类的初始化操作。</li>
<li>抽象方法比接口速度快。接口需要时间去寻找在类中实现的方法，故速度较慢。</li>
<li>抽象类是对事物的一种抽象，描述的是某一类特性的事物。表示 这个对象是什么。（is-a关系——强调所属关系）;接口是对行为功能的抽象，描述是否具备某种行为特征。表示 这个对象能做什么。（has-a关系——强调功能实现）</li>
</ul>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h2><h3 id="使用new操作符创建一个对象"><a href="#使用new操作符创建一个对象" class="headerlink" title="使用new操作符创建一个对象"></a>使用new操作符创建一个对象</h3><p>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p>
<h3 id="使用clone方法复制一个对象"><a href="#使用clone方法复制一个对象" class="headerlink" title="使用clone方法复制一个对象"></a>使用clone方法复制一个对象</h3><p>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p>
<h2 id="clone的使用"><a href="#clone的使用" class="headerlink" title="clone的使用"></a>clone的使用</h2><ul>
<li><p>实现Cloneable接口</p>
</li>
<li><p>重写Object中clone方法，定位为public</p>
</li>
<li><p>调用super.clone();</p>
</li>
<li><p>实现try catch 捕获异常</p>
</li>
<li><p>clone默认实现的是浅拷贝。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book implements Cloneable &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (Book)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone规则"><a href="#clone规则" class="headerlink" title="clone规则"></a>clone规则</h3><ul>
<li>如果变量是基本类型，克隆的是其<strong>值</strong>比如int、float等。</li>
<li>如果变量是实例对象，则拷贝其<strong>地址引用</strong>，也就是说新对象和原来对象是共用实例变量的。</li>
<li>若变量是string字符串，拷贝其地址引用，但是在修改时，它会从字符串池中重新生成一个新的字符串，原有的对象保持不变。</li>
<li>clone默认实现的是浅拷贝。</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<ul>
<li>如果原型对象的成员变量是值类型，将复制一份给克隆对象，</li>
<li>如果原型对象的成员变量是引用类型，则将引用类型的地址复制一份给克隆对象。<strong>也就是说原型对象和克隆对象的成员变量指向相同的内存地址</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8ec91452d46a20ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在深拷贝中无论值类型还是引用类型都会复制一份给克隆对象，深拷贝将原型对象的所有引用对象也复制一份给克隆对象。</p>
<p>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>如果想要深拷贝一个对象， 这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-c2b9f8dbacd2bffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-76e0e5813178abab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Java多线程之同步集合与并发集合"><a href="#Java多线程之同步集合与并发集合" class="headerlink" title="Java多线程之同步集合与并发集合"></a>Java多线程之同步集合与并发集合</h1><h2 id="同步集合类"><a href="#同步集合类" class="headerlink" title="同步集合类"></a>同步集合类</h2><p>包括<code>Hashtable</code>、<code>Vector</code>、同步集合包装类，<code>Collections.synchronizedMap()</code>和<code>Collections.synchronizedList()</code>。</p>
<h2 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h2><p>包括<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteHashSet</code></p>
<p>同步集合比并发集合会慢得多，主要原因是锁，同步集合会对整个Map或List加锁。</p>
<ul>
<li><strong>ConcurrentHashMap：</strong>把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。</li>
<li><strong>CopyOnWriteArrayList：</strong>允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。</li>
</ul>
<p>一般不需要多线程的情况，只用到HashMap、ArrayList，只要真正用到多线程的时候就一定要考虑同步。所以这时候才需要考虑同步集合或并发集合。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-cefab31cd3461494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="JDK1-7-amp-JDK1-8-对比"><a href="#JDK1-7-amp-JDK1-8-对比" class="headerlink" title="JDK1.7 &amp; JDK1.8 对比"></a>JDK1.7 &amp; JDK1.8 对比</h4><ol>
<li><p>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p>
</li>
<li><p>保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</p>
</li>
<li><p>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p>
</li>
<li><p>链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p>
</li>
<li><p>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
</li>
</ol>
<h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<h1 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-98c472afe493c25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-891a1d42c08637a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="wait-与-sleep-的区别与联系"><a href="#wait-与-sleep-的区别与联系" class="headerlink" title="wait 与 sleep 的区别与联系"></a>wait 与 sleep 的区别与联系</h2><p>wait和sleep均能使线程处于等待状态</p>
<ul>
<li>wait方法定义在Object里面，基于对象锁，所有的对象都能使用（Java里面每一个对象都有隐藏锁，也叫监视器(monitor)。当一个线程进入一个synchronized方法的时候它会获得一个当前对象的锁。）；sleep方法定义在Thread里面，是基于当前线程。</li>
<li>wait必须在同步环境（synchronized方法）下使用，否则会报IllegalMonitorStateException异常<br>sleep方法可在任意条件下使用</li>
<li>wait/notify一起使用，用于线程间的通信。wait用于让线程进入等待状态，notify则唤醒正在等待的线程；sleep用于暂停当前线程的执行，它会在一定时间内释放CPU资源给其他线程执行，超过睡眠时间则会正常唤醒。</li>
<li>在同步环境中调用wait方法会释放当前持有的锁；调用sleep则不会释放锁，一直持有锁（直到睡眠结束）</li>
</ul>
<h2 id="线程阻塞的原因"><a href="#线程阻塞的原因" class="headerlink" title="线程阻塞的原因"></a>线程阻塞的原因</h2><ul>
<li>Thread.sleep(int millsecond) 调用 sleep 的线程会在一定时间内将 CPU 资源给其他线程执行，超过睡眠事件后唤醒。与是否持有同步锁无关。进程处于 TIMED_WAITING 状态</li>
<li>线程执行一段同步代码（Synchronic）代码，但无法获取同步锁：同步锁用于实现线程同步执行，未获得同步锁而无法进入同步块的线程处于 BLOCKED 状态</li>
<li>线程对象调用 wait 方法，进入同步块的线程发现运行条件不满足，此时会释放锁，并释放CPU，等待其他线程norify。此时线程处于 WAITING 状态</li>
<li>执行阻塞式I/O操作，等待相关I/O设备（如键盘、网卡等），为了节省CPU资源，释放CPU。此时线程处于RUNNABLE状态。</li>
</ul>
<h2 id="线程控制方法"><a href="#线程控制方法" class="headerlink" title="线程控制方法"></a>线程控制方法</h2><p>JVM充分地利用现代多核处理器的强大性能。采用异步调用线程，提高使用性能，缺点就是会造成线程不安全。为了保证线程安全性，即确保Java内存模型的可见性、原子性和有序性。Java主要通过volatile、synchronized实现线程安全。</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized 规定了同一个时刻只允许一条线程可以进入临界区（互斥性），同时还保证了共享变量的内存可见性。此规则决定了持有同一个对象锁的多个同步块只能串行执行。</p>
<p>Java中的每个对象都可以为锁：</p>
<ul>
<li>普通同步方法，锁是当前实例对象。</li>
<li>静态同步方法，锁是当前类的class对象。</li>
<li>同步代码块，锁是括号中的对象。</li>
</ul>
<p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某个对象的监视器）。当某个线程并不持有监视器的使用权时，去wait或notify，会抛出java.lang.IllegalMonitorStateException。</p>
<p>当某个线程wait之后，其他执行该同步快的线程可以进入该同步块执行。</p>
<h4 id="锁的内部机制：从偏向锁到重量级锁"><a href="#锁的内部机制：从偏向锁到重量级锁" class="headerlink" title="锁的内部机制：从偏向锁到重量级锁"></a>锁的内部机制：从偏向锁到重量级锁</h4><h5 id="对象头和monitor"><a href="#对象头和monitor" class="headerlink" title="对象头和monitor"></a>对象头和monitor</h5><p>Java对象在内存中的存储结构主要有一下三个部分：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>填充数据</li>
</ul>
<p>monitor是线程私有的数据结构，每一个线程都有一个可用monitor列表，同时还有一个全局的可用列表，先来看monitor的内部。</p>
<p><img src="https://img-blog.csdnimg.cn/20190718141919602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li>EntryQ：关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor失败的线程。</li>
<li>RcThis：表示blocked或waiting在该monitor上的所有线程的个数。</li>
<li>Nest：用来实现重入锁的计数。</li>
<li>HashCode：保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li>Candidate：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值：0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。</li>
</ul>
<p>在 java 虚拟机中，线程一旦进入到被synchronized修饰的方法或代码块时，指定的锁对象通过某些操作将对象头中的LockWord指向monitor 的起始地址与之关联，同时monitor 中的Owner存放拥有该锁的线程的唯一标识，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>当线程执行到临界区（critical section）时，此时会利用CAS(Compare and Swap)操作，将线程ID插入到Markword中，同时修改偏向锁的标志位。</p>
<p>此时偏向锁标志位为1。</p>
<p><strong>偏向锁是jdk1.6引入的一项锁优化，其中的“偏”是偏心的偏。它的意思就是说，这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。</strong></p>
<p><strong>在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行加锁或者解锁操作，而是会做以下的步骤：</strong></p>
<ul>
<li>Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.</li>
<li>如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.</li>
<li>如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。</li>
<li>如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
<li>如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。</li>
</ul>
<p>即偏向锁是针对于一个线程而言的，线程获得锁之后就不会进行解锁操作，节省了很多开销。为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。在Jdk1.6中，偏向锁的开关是默认开启的，适用于只有一个线程访问同步块的场景。</p>
<p>下述代码中，当线程访问同步方法method1时，会在对象头（SynchronizedTest.class对象的对象头）和栈帧的锁记录中存储锁偏向的线程ID，下次该线程在进入method2，只需要判断对象头存储的线程ID是否为当前线程，而不需要进行CAS操作进行加锁和解锁（因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    private static Object lock &#x3D; new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method1();</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized static void method1() &#123;&#125;</span><br><span class="line">    synchronized static void method2() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。下面先简单描述下锁撤销之后，升级为轻量级锁的过程：</p>
<ul>
<li>线程在自己的栈桢中创建锁记录 LockRecord。</li>
<li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li>
<li>将锁记录中的Owner指针指向锁对象。</li>
<li>将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
</ul>
<p>轻量级锁主要是自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。注意，锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。自旋锁有一些问题：</p>
<ul>
<li>如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu。</li>
<li>本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。</li>
</ul>
<p>基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="url">Java容器类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java集合框架图"><a href="#java集合框架图" class="headerlink" title="java集合框架图"></a>java集合框架图</h1><p>java集合框架图</p>
<p><img src="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java集合的类结构图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>java集合继承关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。</p>
<p>简单来看，Collection代表的是单个元素对象的序列，（可以有序/无序，可重复/不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代表的是“键值对”对象的集合（同样可以有序/无序 等依据具体实现）</p>
<ul>
<li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li>
<li>Set：无序，不可重复；</li>
<li>Map：键值对，键唯一，值多个；</li>
</ul>
<h1 id="Collection-集合接口"><a href="#Collection-集合接口" class="headerlink" title="Collection 集合接口"></a>Collection 集合接口</h1><p>Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。有些容器允许重复元素有的不允许，有些有序有些无需。由Collection接口派生的两个接口是List和Set。这个接口的设计目的是希望能最大程度抽象出元素的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型即该Collection中元素对象的类型，继承的Iterable是定义的一个遍历操作接口，采用hasNext next的方式进行遍历。具体实现还是放在具体类中去实现。</p>
<p>主要方法</p>
<ul>
<li>boolean add(Object o) 添加对象到集合</li>
<li>boolean remove(Object o) 删除指定的对象</li>
<li>int size() 返回当前集合中元素的数量</li>
<li>boolean contains(Object o) 查找集合中是否有指定的对象</li>
<li>boolean isEmpty() 判断集合是否为空</li>
<li>Iterator iterator() 返回一个迭代器</li>
<li>boolean containsAll(Collection c) 查找集合中是否有集合c中的元素</li>
<li>boolean addAll(Collection c) 将集合c中所有的元素添加给该集合</li>
<li>void clear() 删除集合中所有元素</li>
<li>void removeAll(Collection c) 从集合中删除c集合中也有的元素</li>
<li>void retainAll(Collection c) 从集合中删除集合c中不包含的元素</li>
</ul>
<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><p>List是一个允许重复元素的指定索引、有序集合。</p>
<p>从List接口的方法来看，List接口增加了面向位置的操作，允许在指定位置上操作元素。用户可以使用这个接口精准掌控元素插入，还能够使用索引index（元素在List中的位置，类似于数组下标）来访问List中的元素。List接口有两个重要的实现类：ArrayList和LinkedList。</p>
<p><strong>Set里面和List最大的区别是Set里面的元素对象不可重复。</strong></p>
<h3 id="ArrayList-数组"><a href="#ArrayList-数组" class="headerlink" title="ArrayList 数组"></a>ArrayList 数组</h3><p>ArrayList的底层数据结构就是一个数组，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。默认列表长度10，也可以自己指定长度。ArrayList中的对象数组的最大数组容量为Integer.MAX_VALUE – 8。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>ArrayList实现了List接口的可变大小的数组。（数组可动态创建，如果元素个数超过数组容量，那么就创建一个更大的新数组）</li>
<li>它允许所有元素，包括null</li>
<li>它的size, isEmpty, get, set, iterator,add这些方法的时间复杂度是O(1),如果add n个数据则时间复杂度是O(n)</li>
<li>ArrayList没有同步方法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。</li>
<li>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。</li>
<li>根据下标遍历元素，效率高。</li>
<li>根据下标访问元素，效率高。</li>
<li>可以自动扩容，默认为每次扩容为原来的1.5倍。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除元素的效率不高。</li>
<li>根据元素下标查找元素需要遍历整个元素数组，效率不高。</li>
<li>线程不安全。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>Boolean add(Object o)将指定元素添加到列表的末尾</li>
<li>Boolean add(int index,Object element)在列表中指定位置加入指定元素</li>
<li>Boolean addAll(Collection c)将指定集合添加到列表末尾</li>
<li>Boolean addAll(int index,Collection c)在列表中指定位置加入指定集合</li>
<li>Boolean clear()删除列表中所有元素</li>
<li>Boolean clone()返回该列表实例的一个拷贝</li>
<li>Boolean contains(Object o)判断列表中是否包含元素</li>
<li>Boolean ensureCapacity(int m)增加列表的容量,如果必须,该列表能够容纳m个元素</li>
<li>Object get(int index)返回列表中指定位置的元素</li>
<li>Int indexOf(Object elem)在列表中查找指定元素的下标</li>
<li>Int size()返回当前列表的元素个数</li>
</ul>
<h4 id="常见源码分析"><a href="#常见源码分析" class="headerlink" title="常见源码分析"></a>常见源码分析</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">        elementData[size++] &#x3D; e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 确认能否装得下size+1的对象</span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;计算容量</span><br><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是默认长度，就比较默认长度和size+1,取最大值</span><br><span class="line">        if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;如果容量大于数组的长度</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;扩容</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;取数组的长度</span><br><span class="line">        int oldCapacity &#x3D; elementData.length;</span><br><span class="line">        &#x2F;&#x2F;计算新长度，新长度&#x3D;旧长度+旧长度&#x2F;2</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity &#x3D; minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">        &#x2F;&#x2F;最后按照新容量进行扩容，复制。</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在add()方法中主要完成了三件事：首先确保能够将希望添加到集合中的元素能够添加到集合中，即确保ArrayList的容量（判断是否需要扩容）；然后将元素添加到elementData数组的指定位置；最后将集合中实际的元素个数加1。</p>
<p>ArrayList的实际默认容量直到调用add()方法才会真正扩容到10，这里通过new ArrayList（）在内存分配的是一个空数组，并没有直接new Object[10],这样设计是很巧妙的，可以节省很多空间。</p>
<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F;判断是否越界</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">   &#x2F;&#x2F; 重新复制数组，把index+1位置往后的对象全部后移</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       &#x2F;&#x2F;覆盖index位置的对象                 </span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的指定位置添加对象方法，需要把指定位置后面的全部对象后移，所以这样也是ArrayList相对于linkList添加耗时的地方。</p>
<h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     return elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的get(int index) 方法比较简单，只有两步，第一，检查是否越界，第二，返回数组索引位置的数据。</p>
<h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;父类的属性，用来记录list修改的次数，后续迭代器中会用到</span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">      int numMoved &#x3D; size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">      &#x2F;&#x2F;把index位置后面的元素左移</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的remove（int index）方法主要分为 3步:</p>
<ul>
<li>第一步，判断下标是否越界</li>
<li>第二步，记录修改次数，并左移index位置后面的元素，</li>
<li>第三，把最后位置赋值为null，用于快速垃圾回收。</li>
</ul>
<h4 id="for循环问题"><a href="#for循环问题" class="headerlink" title="for循环问题"></a>for循环问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; new ArrayList&lt;&gt;(5);</span><br><span class="line">     integers.add(1);</span><br><span class="line">     integers.add(2);</span><br><span class="line">     integers.add(3);</span><br><span class="line">     integers.add(4);</span><br><span class="line">     integers.add(5);</span><br><span class="line"></span><br><span class="line">     for (int i &#x3D; 0; i &lt; integers.size(); i++) &#123;</span><br><span class="line">         integers.remove(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(integers.size());</span><br></pre></td></tr></table></figure>

<p>这里首先申明一个长度为5的ArrayList的集合，然后添加五个元素，最后通过循环遍历删除，理论结果输出0，但是输出的结果却是2，为什么呢？之前分析remove源码我们知道，ArrayList每删除一次就会把后面的全部元素左移，以这5个元素为例，第一个正常删除没问题，删除后，元素就只剩下[2,3,4,5],这个时候remove(1),还剩[2,4,5],再remove(2),剩下[2,4],后面再remove没有元素了，所以最后size为2。</p>
<h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a>LinkedList 链表</h3><p><strong><code>LinkedList</code> 保存链表的第一个节点和最后一个节点,每个节点上有三个字段：当前节点的数据字段（data）,指向上一个节点的字段（prev），和指向下一个节点的字段（next）。</strong></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p><strong><code>LinkedList</code> 集合底层实现的数据结构为双向链表</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 集合中元素允许为 null</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 允许存入重复的数据</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 中元素存放顺序为插入顺序。</strong></p>
</li>
<li><p><code>LinkedList</code>实现<code>Deque</code>接口使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<ul>
<li><strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong></li>
<li><strong>当<code>Deque</code> 作为栈使用的时候，遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的</strong>。</li>
</ul>
</li>
<li><p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。</p>
</li>
<li><p>分配内存空间不是连续的。</p>
</li>
<li><p>插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；</p>
</li>
<li><p>访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；</p>
</li>
</ul>
<h4 id="结点定义（双向链表）"><a href="#结点定义（双向链表）" class="headerlink" title="结点定义（双向链表）"></a>结点定义（双向链表）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前节点的元素值</span><br><span class="line">   E item;</span><br><span class="line">   &#x2F;&#x2F; 下一个节点的索引</span><br><span class="line">   Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; 上一个节点的索引</span><br><span class="line">   Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">       this.item &#x3D; element;</span><br><span class="line">       this.next &#x3D; next;</span><br><span class="line">       this.prev &#x3D; prev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h4><p>每个LinkedList中会持有链表的头指针和尾指针,LinkedList 主要成员变量有下边三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedList 中的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的第一个节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的最后一个节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p>之所以 LinkedList 要保存链表的第一个节点和最后一个节点是因为，我们都知道，链表数据结构相对于数组结构， 优点在于增删，缺点在于查找。如果我们保存了LinkedList 的头尾两端，当我们需要以索引来查找节点的时候，我们可以根据 <code>index</code> 和 <code>size/2</code> 的大小,来决定从头查找还是从尾部查找，这也算是一定程度上弥补了单链表数据结构的缺点。</p>
<h4 id="LinkedList-的构造函数"><a href="#LinkedList-的构造函数" class="headerlink" title="LinkedList 的构造函数"></a>LinkedList 的构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空参数的构造由于生成一个空链表 first &#x3D; last &#x3D; null</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入一个集合类，来构造一个具有一定元素的 LinkedList 集合</span><br><span class="line"> * @param  c  其内部的元素将按顺序作为 LinkedList 节点</span><br><span class="line"> * @throws NullPointerException 如果 参数 collection 为空将抛出空指针异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   this();</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在 index 节点前插入包含所有 c 集合元素的节点。</span><br><span class="line"> * 返回值表示是否成功添加了对应的元素.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   &#x2F;&#x2F; 查看索引是否满足 0 &#x3D;&lt; index &#x3D;&lt; size 的要求</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 调用对应 Collection 实现类的 toArray 方法将集合转为数组</span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   &#x2F;&#x2F;检查数组长度，如果为 0 则直接返回 false 表示没有添加任何元素</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">       return false;</span><br><span class="line">   &#x2F;&#x2F; 保存 index 当前的节点为 succ，当前节点的上一个节点为 pred</span><br><span class="line">   Node&lt;E&gt; pred, succ;</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 表示在链表尾部插入</span><br><span class="line">   if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">       succ &#x3D; null;</span><br><span class="line">       pred &#x3D; last;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       succ &#x3D; node(index);</span><br><span class="line">       pred &#x3D; succ.prev;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历数组将对应的元素包装成节点添加到链表中</span><br><span class="line">   for (Object o : a) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">       Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">       &#x2F;&#x2F;如果 pred 为空表示 LinkedList 集合中还没有元素</span><br><span class="line">       &#x2F;&#x2F;生成的第一个节点将作为头节点 赋值给 first 成员变量</span><br><span class="line">       if (pred &#x3D;&#x3D; null)</span><br><span class="line">           first &#x3D; newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next &#x3D; newNode;</span><br><span class="line">       pred &#x3D; newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果 index 位置的元素为 null 则遍历数组后 pred 所指向的节点即为新链表的末节点，赋值给 last 成员变量</span><br><span class="line">   if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; pred;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 否则将 pred 的 next 索引指向 succ ，succ 的 prev 索引指向 pred</span><br><span class="line">       pred.next &#x3D; succ;</span><br><span class="line">       succ.prev &#x3D; pred;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 更新当前链表的长度 size 并返回 true 表示添加成功</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   modCount++;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 批量添加节点的实现。大体分下面几个步骤：</p>
<ul>
<li>检查索引值是否合法，不合法将抛出角标越界异常</li>
<li>保存 index 位置的节点，和 index-1 位置的节点。</li>
<li>将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。</li>
<li>更新链表长度并返回添加 true 表示添加成功。</li>
</ul>
<p>越界检查最后都调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-添加节点的方法"><a href="#LinkedList-添加节点的方法" class="headerlink" title="LinkedList 添加节点的方法"></a>LinkedList 添加节点的方法</h4><p>LinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the beginning of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法默认调用<code>linkLast</code>添加到最后一个节点。</p>
<h5 id="linkXXX-方法：linkFirst、linkLast"><a href="#linkXXX-方法：linkFirst、linkLast" class="headerlink" title="linkXXX 方法：linkFirst、linkLast"></a><code>linkXXX</code> 方法：<code>linkFirst、linkLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 添加一个元素在链表的头节点位置</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加元素之前的头节点</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   &#x2F;&#x2F;以添加的元素为节点值构建新的头节点 并将 next 指针指向 之前的头节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">   &#x2F;&#x2F; first 索引指向将新的节点</span><br><span class="line">   first &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果添加之前链表空则新的节点也作为未节点</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       last &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       f.prev &#x3D; newNode;&#x2F;&#x2F;否则之前头节点的 prev 指针指向新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在链表末尾添加一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> void linkLast(E e) &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F;保存之前的未节点</span><br><span class="line">   &#x2F;&#x2F;构建新的未节点，并将新节点 prev 指针指向 之前的未节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">   &#x2F;&#x2F;last 索引指向末节点</span><br><span class="line">   last &#x3D; newNode;</span><br><span class="line">   if (l &#x3D;&#x3D; null)&#x2F;&#x2F;如果之前链表为空则新节点也作为头节点</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else&#x2F;&#x2F;否则将之前的未节点的 next 指针指向新节点</span><br><span class="line">       l.next &#x3D; newNode;</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-int-index-E-element-、addAll"><a href="#add-int-index-E-element-、addAll" class="headerlink" title="add(int index, E element)、addAll"></a>add(int index, E element)、addAll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在指定 index 位置插入节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 检查角标是否越界</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 代表是在尾部插入节点</span><br><span class="line">   if (index &#x3D;&#x3D; size)</span><br><span class="line">       linkLast(element);</span><br><span class="line">   else</span><br><span class="line">       linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="node-index-方法的实现"><a href="#node-index-方法的实现" class="headerlink" title="node(index) 方法的实现"></a>node(index) 方法的实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回一个非空节点，这个非空节点位于 index 位置</span><br><span class="line"> *&#x2F;</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 如果 index &lt; size&#x2F;2 则从0开始寻找指定角标的节点</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果 index &gt;&#x3D; size&#x2F;2 则从 size-1 开始寻找指定角标的节点</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会疑惑为什么这里注释为返回一个非空节点？其实仔细想下就明白了，这里的节点一定不为 null，如果一开始链表为空的时候，index 为 0 的位置肯定为 null，为什么不会产生异常情况呢？其实如果一开始链表中没有元素 size = 0，如果我们向 <code>index = 0</code> 的位置添加元素是不会走到 else 中的，而是会调用 <code>linkLast(element);</code> 方法去添加元素。 因此<strong>node 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;</strong></p>
<h6 id="linkBefore-E-e-Node-succ-实现"><a href="#linkBefore-E-e-Node-succ-实现" class="headerlink" title="linkBefore(E e, Node succ)实现"></a>linkBefore(E e, Node<E> succ)实现</h6><p>为什么要叫做 linkBefore 呢，因为在链表的中间位置添加节点，其实就是将 index 原来的节点前添加一个节点，添加节点我们需要知道该节点的前一个节点和当前节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; 由于 succ 一定不为空，所以可以直接获取 prev 节点</span><br><span class="line">   final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">   &#x2F;&#x2F; 新节点 prev 节点为 pred，next 节点为 succ</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">   &#x2F;&#x2F; 原节点的 prev 指向新节点</span><br><span class="line">   succ.prev &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果 pred 为空即头节点出插入了一个节点，则将新的节点赋值给 first 索引</span><br><span class="line">   if (pred &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       pred.next &#x3D; newNode;&#x2F;&#x2F;否则 pred 的下一个节点改为新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将构造的新节点前指针 prev 指向 index 的前一个元素，</p>
</li>
<li><p>新节点前指针 next 指针指向 index 位置的节点，</p>
</li>
<li><p>index 位置节点 prev 指针指向新节点</p>
</li>
<li><p>index 位置前节点（pred）的 next 指针指向新节点</p>
</li>
</ul>
<h4 id="LinkedList-删除节点的方法"><a href="#LinkedList-删除节点的方法" class="headerlink" title="LinkedList 删除节点的方法"></a>LinkedList 删除节点的方法</h4><h5 id="removeFirst、removeLast"><a href="#removeFirst、removeLast" class="headerlink" title="removeFirst、removeLast"></a><code>removeFirst</code>、<code>removeLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  删除头节点</span><br><span class="line"> * @return 删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  删除尾节点</span><br><span class="line"> *</span><br><span class="line"> * @return  删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException  如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="unlinkFirst、unlinkLast"><a href="#unlinkFirst、unlinkLast" class="headerlink" title="unlinkFirst、unlinkLast"></a><code>unlinkFirst</code>、<code>unlinkLast</code></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 移除头节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 头节点的 element 这里作为返回值使用</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    &#x2F;&#x2F; 头节点下个节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    &#x2F;&#x2F; 释放头节点的 next 指针，和 element 下次 gc 的时候回收这个内部类</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F; 将 first 索引指向新的节点</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    &#x2F;&#x2F; 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;否则 next 的 prev 指针指向 null</span><br><span class="line">    size--;&#x2F;&#x2F;改变链表长度</span><br><span class="line">    modCount++;&#x2F;&#x2F;修改操作数</span><br><span class="line">    return element;&#x2F;&#x2F;返回删除节点的值</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 移除未节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    &#x2F;&#x2F;未节点的前一个节点，</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    &#x2F;&#x2F;释放未节点的内容</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F;将 last 索引指向新的未节点</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    &#x2F;&#x2F; 链表只有一个节点的时候，first 指向 null</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刚才已经分析过node(index)方法了，就是找到index位置的节点。</p>
<h6 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Unlinks non-null node x.</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">   final E element &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F;保存 index 节点的前后两个节点</span><br><span class="line">   final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">   final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为头节点，则做 unlinkFirst 相同操作</span><br><span class="line">   if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">       first &#x3D; next;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则将上一个节点的 next 指针指向下个节点</span><br><span class="line">       prev.next &#x3D; next;</span><br><span class="line">       &#x2F;&#x2F; 释放 index 位置 prev 指针</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为尾节点，则将 last 索引指向上个节点</span><br><span class="line">   if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; prev;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则下个节点 prev 指针指向上个节点</span><br><span class="line">       next.prev &#x3D; prev;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   x.item &#x3D; null;</span><br><span class="line">   size--;</span><br><span class="line">   modCount++;</span><br><span class="line">   return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完 <code>unlink</code> 操作结合之前说的 <code>node(index)</code>，下边两种删除节点的操作，就很好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定索引位置的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *删除从头节点其第一个与 o 相同的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F; 区别对待 null 元素，比较元素时候使用 &#x3D;&#x3D; 而不是 equals</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item)) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完单个删除节点的方法 LinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Removes all of the elements from this list.</span><br><span class="line">* The list will be empty after this call returns.</span><br><span class="line">*&#x2F;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">   &#x2F;&#x2F; 依次清除节点，帮助释放内存空间</span><br><span class="line">   for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">       Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">       x.item &#x3D; null;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">       x &#x3D; next;</span><br><span class="line">   &#125;</span><br><span class="line">   first &#x3D; last &#x3D; null;</span><br><span class="line">   size &#x3D; 0;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-查询节点的方法"><a href="#LinkedList-查询节点的方法" class="headerlink" title="LinkedList 查询节点的方法"></a>LinkedList 查询节点的方法</h4><p>LinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 <code>ArrayList</code> 去替代。</p>
<h5 id="get-int-index-、getFirst-、getLast"><a href="#get-int-index-、getFirst-、getLast" class="headerlink" title="get(int index)、getFirst() 、getLast"></a><code>get(int index)、getFirst() 、getLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 根据索引查询</span><br><span class="line">*</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 first 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the first element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 last 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the last element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">   if (l &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexOf-Object-o-、lastIndexOf-Object-o"><a href="#indexOf-Object-o-、lastIndexOf-Object-o" class="headerlink" title="indexOf(Object o)、lastIndexOf(Object o)"></a><code>indexOf(Object o)、lastIndexOf(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">* 返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**头节点**起的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">* </span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return </span><br><span class="line">*&#x2F;</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 区别对待 null 元素，用 &#x3D;&#x3D; 判断，非空元素用 equels 方法判断 </span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">**返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**尾节点起**的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">*</span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return the index of the last occurrence of the specified element in</span><br><span class="line">*         this list, or -1 if this list does not contain the element</span><br><span class="line">*&#x2F;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; size;</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法分别返回从<strong>头节点起</strong>第一个与参数元素相同的节点索引，和从<strong>尾节点起</strong>第一个与参数元素相同的节点索引。</p>
<h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a><code>contains(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) !&#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 indexOf 从头结点开始查询元素位置遍历完成后若 返回值 !=-1 则表示存在，反之不存在</p>
<h4 id="LinkedList-的修改节点方法"><a href="#LinkedList-的修改节点方法" class="headerlink" title="LinkedList 的修改节点方法"></a>LinkedList 的修改节点方法</h4><p><code>LinkedList</code> 只提供了 <code>set(int index, E element)</code> 一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 判断角标是否越界</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 采用 node 方法查找对应索引的节点</span><br><span class="line">   Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">   &#x2F;&#x2F;保存节点原有的内容值</span><br><span class="line">   E oldVal &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F; 设置新值</span><br><span class="line">   x.item &#x3D; element;</span><br><span class="line">   &#x2F;&#x2F; 返回旧的值</span><br><span class="line">   return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-作为双向队列的增删改查"><a href="#LinkedList-作为双向队列的增删改查" class="headerlink" title="LinkedList 作为双向队列的增删改查"></a>LinkedList 作为双向队列的增删改查</h4><p><code>LinkedList</code>实现<code>Deque</code>接口，可实现双向队列。</p>
<h5 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h5><p><code>Queue</code> 是一个队列，遵循 FIFO 准则，我们也知道 <code>Stack</code> 是一个栈结构，遵循 FILO 准则。 而<code>Deque</code> 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。</p>
<p>Deque接口中的方法:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">头部</th>
<th align="center">头部</th>
<th align="center">尾部</th>
<th align="center">尾部</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="center">addFirst(e)</td>
<td align="center">offerFirst(e)</td>
<td align="center">addLast(e)</td>
<td align="center">offerLast(e)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="center">removeFirst()</td>
<td align="center">pollFirst()</td>
<td align="center">remveLast()</td>
<td align="center">pollLast</td>
</tr>
<tr>
<td align="left">获取</td>
<td align="center">getFirst()</td>
<td align="center">peekFirst()</td>
<td align="center">getLast()</td>
<td align="center">peekLast</td>
</tr>
</tbody></table>
<p>由于 <code>Deque</code> 接口继承 <code>Queue</code> 接口，<strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong>。我们现在复习下 <code>Queue</code> 中的方法及区别：</p>
<ul>
<li><code>Queue</code> 的 <code>offer</code> 和 <code>add</code> 都是在队列中插入一个元素，具体区别在于，对于一些 Queue 的实现的队列是有大小限制的，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。此时调用 <code>add()</code>方法会抛出异常，而 <code>offer()</code> 只是返回的 false。</li>
<li><code>remove()</code> 和 <code>poll()</code> 方法都是从队列中删除第一个元素。remove()也将抛出异常，而 <code>poll()</code> 则会返回 <code>null</code></li>
<li><code>element()</code> 和 <code>peek()</code> 用于在队列的头部查询元素。在队列为空时， <code>element()</code> 抛出一个异常，而 <code>peek()</code> 返回 <code>null</code>。</li>
</ul>
<h5 id="Deque-和-Queue-添加元素的方法"><a href="#Deque-和-Queue-添加元素的方法" class="headerlink" title="Deque 和 Queue 添加元素的方法"></a>Deque 和 Queue 添加元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">   return add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提及到 <code>Queue</code>的 <code>offer</code> 和 <code>add</code> 的区别针对容量有限制的实现，很明显 <code>LinkedList</code> 的大小并没有限制，所以在 <code>LinkedList</code> 中他们的实现并没有实质性不同。</p>
<h5 id="Deque-和-Queue-删除元素的方法"><a href="#Deque-和-Queue-删除元素的方法" class="headerlink" title="Deque 和 Queue 删除元素的方法"></a>Deque 和 Queue 删除元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 removeFirst 会抛出 NoSuchElement 异常</span><br><span class="line">public E remove() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的删除方法实现</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E poll() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deque-和-Queue-获取队列头部元素的实现"><a href="#Deque-和-Queue-获取队列头部元素的实现" class="headerlink" title="Deque 和 Queue 获取队列头部元素的实现"></a>Deque 和 Queue 获取队列头部元素的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line"> public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述我们分析了，双端队列作为队列使用的时候的各个方法的区别，也可是看出 <code>LinkedList</code> 对对应方法的实现，遵循了队列设计原则。</p>
<h4 id="LinkedList作为Stack使用"><a href="#LinkedList作为Stack使用" class="headerlink" title="LinkedList作为Stack使用"></a><code>LinkedList</code>作为<code>Stack</code>使用</h4><p>下面我们来看看下双端队列作为栈 <code>Stack</code>使用的时候方法对应关系，与 <code>Queue</code> 不同，<code>Stack</code> 本身就是实现类，他拥有 FILO 的原则， <code>Stack</code> 的入栈操作通过 <code>push</code> 方法进行，出栈操作通过 <code>pop</code> 方法进行，查询操作通过 <code>peek</code> 操作进行。 <strong><code>Deque</code> 作为栈使用的时候，也遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的。</strong></p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFist(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><code>LinkedList</code>中的<code>push</code>、<code>pop</code>、<code>peek</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在头部添加一个元素</span><br><span class="line">public void push(E e) &#123;</span><br><span class="line">   addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取并删除第一个元素</span><br><span class="line">public E pop() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取不删除第一个元素</span><br><span class="line">public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-的遍历"><a href="#LinkedList-的遍历" class="headerlink" title="LinkedList 的遍历"></a>LinkedList 的遍历</h4><p>在 <code>ArrayList</code> 分析的时候，我们就知道 <code>List</code> 的实现类，有4中遍历方式：for 循环，高级 for 循环，<code>Iterator</code> 迭代器方法， <code>ListIterator</code> 迭代方法。</p>
<p><code>LinkedList</code> 没有单独 <code>Iterator</code> 实现类，它的 <code>iterator</code> 和 <code>listIterator</code> 方法均返回 <code>ListItr</code>的一个对象。 LinkedList 作为双向链表数据结构，获取上个元素和下个元素很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 上一个遍历的节点</span><br><span class="line">   private Node&lt;E&gt; lastReturned;</span><br><span class="line">   &#x2F;&#x2F; 下一次遍历返回的节点</span><br><span class="line">   private Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; cursor 指针下一次遍历返回的节点</span><br><span class="line">   private int nextIndex;</span><br><span class="line">   &#x2F;&#x2F; 期望的操作数</span><br><span class="line">   private int expectedModCount &#x3D; modCount;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; 根据参数 index 确定生成的迭代器 cursor 的位置</span><br><span class="line">   ListItr(int index) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert isPositionIndex(index);</span><br><span class="line">       &#x2F;&#x2F; 如果 index &#x3D;&#x3D; size 则 next 为 null 否则寻找 index 位置的节点</span><br><span class="line">       next &#x3D; (index &#x3D;&#x3D; size) ? null : node(index);</span><br><span class="line">       nextIndex &#x3D; index;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 判断指针是否还可以移动</span><br><span class="line">   public boolean hasNext() &#123;</span><br><span class="line">       return nextIndex &lt; size;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 返回下一个带遍历的元素</span><br><span class="line">  public E next() &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查操作数是否合法</span><br><span class="line">       checkForComodification();</span><br><span class="line">       &#x2F;&#x2F; 如果 hasNext 返回 false 抛出异常，所以我们在调用 next 前应先调用 hasNext 检查</span><br><span class="line">       if (!hasNext())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 移动 lastReturned 指针</span><br><span class="line">       lastReturned &#x3D; next;</span><br><span class="line">        &#x2F;&#x2F; 移动 next 指针</span><br><span class="line">       next &#x3D; next.next;</span><br><span class="line">       &#x2F;&#x2F; 移动 nextIndex cursor</span><br><span class="line">       nextIndex++;</span><br><span class="line">       &#x2F;&#x2F; 返回移动后 lastReturned</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前游标位置是否还有前一个元素</span><br><span class="line">   public boolean hasPrevious() &#123;</span><br><span class="line">       return nextIndex &gt; 0;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 当前游标位置的前一个元素</span><br><span class="line">   public E previous() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (!hasPrevious())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 等同于 lastReturned &#x3D; next；next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">        &#x2F;&#x2F; 发生在 index &#x3D; size 时</span><br><span class="line">       lastReturned &#x3D; next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">       nextIndex--;</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public int nextIndex() &#123;</span><br><span class="line">       return nextIndex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int previousIndex() &#123;</span><br><span class="line">       return nextIndex - 1;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 删除链表当前节点也就是调用 next&#x2F;previous 返回的这节点，也就 lastReturned</span><br><span class="line">   public void remove() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; lastNext &#x3D; lastReturned.next;</span><br><span class="line">       &#x2F;&#x2F;调用LinkedList 的删除节点的方法</span><br><span class="line">       unlink(lastReturned);</span><br><span class="line">       if (next &#x3D;&#x3D; lastReturned)</span><br><span class="line">           next &#x3D; lastNext;</span><br><span class="line">       else</span><br><span class="line">           nextIndex--;</span><br><span class="line">       &#x2F;&#x2F;上一次所操作的 节点置位空    </span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置当前遍历的节点的值</span><br><span class="line">   public void set(E e) &#123;</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned.item &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 在 next 节点位置插入及节点</span><br><span class="line">   public void add(E e) &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       if (next &#x3D;&#x3D; null)</span><br><span class="line">           linkLast(e);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(e, next);</span><br><span class="line">       nextIndex++;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;简单哈操作数是否合法</span><br><span class="line">   final void checkForComodification() &#123;</span><br><span class="line">       if (modCount !&#x3D; expectedModCount)</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>链表LinkedList和数组ArrayList的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同。实际使用时根据特定的需求选用合适的类。</p>
<ul>
<li><p>ArrayList基于数组；LinkedList基于双向链表。</p>
</li>
<li><p>查找方面。数组的效率更高，可以直接索引出查找；而链表必须从头查找。</p>
</li>
<li><p>插入删除方面。特别是在中间进行插入删除，这时候链表体现出了极大的便利性，只需要在插入或者删除的地方断掉链然后插入或者移除元素，然后再将前后链重新组装；但是数组必须重新复制一份将所有数据后移或者前移。</p>
</li>
<li><p>在内存申请方面，当数组达到初始的申请长度后，需要重新申请一个更大的数组然后把数据迁移过去才行。而链表只需要动态创建即可。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Vector-向量"><a href="#Vector-向量" class="headerlink" title="Vector 向量"></a>Vector 向量</h3><p>Vector非常类似ArrayList。<strong>Vector是同步的</strong>。当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p>
<h4 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h4><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。</p>
<h2 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a>Set子接口</h2><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。</p>
<h3 id="HashSet-散列集"><a href="#HashSet-散列集" class="headerlink" title="HashSet 散列集"></a>HashSet 散列集</h3><p>HashSet实现了Set接口，基于HashMap进行存储。遍历时不保证顺序，并且不保证下次遍历的顺序和之前一样。HashSet中允许null元素。</p>
<p>在初始化中，创建HashMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法调用的也是HashMap中的方法，key就是传入的元素，value是Object对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>意思就是HashSet的集合其实就是HashMap的key的集合，然后HashMap的val默认都是PRESENT。HashMap的定义即是key不重复的集合。使用HashMap实现，这样HashSet就不需要再实现一遍。</p>
<p>所以所有的add，remove等操作其实都是HashMap的add、remove操作。遍历操作其实就是HashMap的keySet的遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void clear() &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LinkedHashSet-链式散列集"><a href="#LinkedHashSet-链式散列集" class="headerlink" title="LinkedHashSet 链式散列集"></a>LinkedHashSet 链式散列集</h3><p>LinkedHashSet的核心概念相对于HashSet来说就是一个可以保持顺序的Set集合。HashSet是无序的，LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。这个顺序不是元素的大小顺序，而是可以保证2次遍历的顺序是一样的。</p>
<p>类似HashSet基于HashMap的源码实现，LinkedHashSet的数据结构是基于LinkedHashMap。</p>
<h3 id="TreeSet-树形集"><a href="#TreeSet-树形集" class="headerlink" title="TreeSet 树形集"></a>TreeSet 树形集</h3><p>TreeSet即是一组有次序的集合，如果没有指定排序规则Comparator，则会按照自然排序。（自然排序即e1.compareTo(e2) == 0作为比较）</p>
<p>TreeSet源码的算法即基于TreeMap，扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20190607103330622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。</p>
<ul>
<li><p><code>boolean add(E e)</code>：</p>
</li>
<li><p><code>boolean offer(E e)</code>：向队列添加一个元素</p>
</li>
<li><p><code>E poll()</code>：移除队列头部元素（队列为空返回null）</p>
</li>
<li><p><code>E remove()</code>：移除队列头部元素（队列为空抛出异常）</p>
</li>
<li><p><code>E element();</code>：获取头部元素</p>
</li>
<li><p><code>E peek();</code>：获取头部元素</p>
</li>
</ul>
<h3 id="Deque-双端队列-1"><a href="#Deque-双端队列-1" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h3><p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。</p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it &#x3D; collection.iterator(); &#x2F;&#x2F; 获得一个迭代子  </span><br><span class="line">while(it.hasNext()) &#123;  </span><br><span class="line">Object obj &#x3D; it.next(); &#x2F;&#x2F; 得到下一个元素  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://user-gold-cdn.xitu.io/2018/5/21/1638145a2ead2bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="这里写图片描述"></p>
<p>Map是图接口，存储键值对映射的容器类。Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。</p>
<ul>
<li>Map 是<strong>映射接口</strong>，Map中存储的内容是<strong>键值对</strong>(key-value)</li>
<li>AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。</li>
<li>SortedMap 是继承于Map的接口。SortedMap中的内容是<strong>排序的键值对</strong>，排序的方法是通过比较器(Comparator)</li>
<li>NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。 </li>
<li>TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“<strong>有序的键值对”</strong>！</li>
<li>HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“<strong>键值对，但不保证次序</strong>”！</li>
<li>Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“<strong>键值对，也不保证次序”</strong>。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。</li>
<li>WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，<strong>WeakHashMap的键是“弱键</strong>”。</li>
</ul>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    interface Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型&lt;K,V&gt;分别代表key和value的类型。这时候注意到还定义了一个内部接口Entry，其实每一个键值对都是一个Entry的实例关系对象，所以Map实际其实就是Entry的一个Collection，然后Entry里面包含key，value。再设定key不重复的规则，自然就演化成了Map。</p>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map集合提供3种遍历访问方法：</p>
<ul>
<li><p>Set keySet() 获得所有key的集合然后通过key访问value会返回所有key的Set集合，因为key不可以重复，所以返回的是Set格式，而不是List格式。（之后会说明Set，List区别。这里先告诉一点Set集合内元素是不可以重复的，而List内是可以重复的） 获取到所有key的Set集合后，由于Set是Collection类型的，所以可以通过Iterator去遍历所有的key，然后再通过get方法获取value。</p>
</li>
<li><p>Collection values() 获得value的集合。直接获取values的集合，无法再获取到key。所以如果只需要value的场景可以用这个方法。获取到后使用Iterator去遍历所有的value。</p>
</li>
<li><p>Set&lt; Map.Entry&lt; K, V&gt;&gt; entrySet() 获得key-value键值对的集合。</p>
</li>
</ul>
<p>通过以上3种遍历方式我们可以知道，如果你只想获取key，建议使用keySet。如果只想获取value，建议使用values。如果key value希望遍历，建议使用entrySet。</p>
<p>Map的访问顺序取决于Map的遍历访问方法的遍历顺序。 有的Map，比如TreeMap可以保证访问顺序，但是有的比如HashMap，无法保证访问顺序。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>常见的哈希函数：</p>
<ul>
<li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</li>
<li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</li>
<li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</li>
<li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li>
<li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li>
<li>伪随机数法：采用一个伪随机数当作哈希函数。</li>
</ul>
<p>哈希表是一种通过哈希函数将特定的键映射到特定值的一种数据结构，他维护者键和值之间一一对应关系。</p>
<ul>
<li>键(key)：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分。</li>
<li>桶(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将键(key)映射(map)到数据应该存放的槽(slot)所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的键映射到同一个索引的情况。</li>
</ul>
<p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p>
<p><strong>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</strong></p>
<h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>哈希冲突后，用链表去延展来解决。将所有关键字为同义词的记录存储在同一线性链表中。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190725082450961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="开地址法"><a href="#开地址法" class="headerlink" title="开地址法"></a>开地址法</h4><p>哈希冲突后，并不会在本身之外开拓新的空间，而是继续顺延下去某个位置来存放。</p>
<p>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)</p>
<p>其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。</p>
<p>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。</p>
<p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>就是同时构造多个不同的哈希函数：<br> Hi = RHi(key)   i= 1,2,3 … k;<br> 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h4 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h4><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。哈希表为解决冲突，采用了链地址法,简单来说，就是数组加链表的结合,当哈希冲突时，数组上的数据采用链表的方式把新数据插到链尾。</p>
<p>当出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当<strong>链表长度太长（默认超过8）时，链表就转换为红黑树</strong></p>
<p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>从结构实现来讲，HashMap是:<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210635_58179.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">		&#x2F;&#x2F;默认容量</span><br><span class="line">		static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">		&#x2F;&#x2F;最大容量</span><br><span class="line">		static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">		&#x2F;&#x2F;默认加载因子</span><br><span class="line">		static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">		&#x2F;&#x2F;链表转成红黑树的阈值</span><br><span class="line">		static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">		&#x2F;&#x2F;红黑树转为链表的阈值</span><br><span class="line">		static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">		&#x2F;&#x2F;哈希桶数组</span><br><span class="line">		transient Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 存放具体元素的集</span><br><span class="line">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存储方式由链表转成红黑树的容量的最小阈值</span><br><span class="line">		static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">		&#x2F;&#x2F;HashMap中存储的键值对的数量</span><br><span class="line">		transient int size;</span><br><span class="line">		&#x2F;&#x2F;扩容阈值，当size&gt;&#x3D;threshold时，就会扩容</span><br><span class="line">		int threshold;</span><br><span class="line">		&#x2F;&#x2F;HashMap的加载因子</span><br><span class="line">		final float loadFactor;</span><br><span class="line">		</span><br><span class="line">		public HashMap() &#123;</span><br><span class="line">        &#x2F;&#x2F;默认构造函数，赋值加载因子为默认的0.75f</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;指定初始化容量的构造函数</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;同时指定初始化容量 以及 加载因子， 用的很少，一般不会修改loadFactor</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;初始容量最大不能超过2的30次方</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F;显然加载因子不能为负数</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;新建一个哈希表，同时将另一个map m 里的所有元素加入表中</span><br><span class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">		static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue &#x3D; value;</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o &#x3D;&#x3D; this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;根据期望容量cap，返回2的n次方形式的 哈希桶的实际容量 length。 返回值一般会&gt;&#x3D;cap </span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    &#x2F;&#x2F;经过下面的 或 和位移 运算， n最终各位都是1。</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        &#x2F;&#x2F;判断n是否越界，返回 2的n次方作为 table（哈希桶）的阈值</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>一些重要的参数：</p>
<ul>
<li>初始容量（initialCapacity，默认为16）</li>
<li>如果initialCapacity不为2的幂值，HashMap会自动选择比initialCapacity大的下一个2的幂值作为初始容量。</li>
<li>负载系数（loadFactor，默认为0.75）</li>
<li>当HashMap.size()大于<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。</li>
</ul>
<h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123; &#x2F;&#x2F;jdk1.8 &amp; jdk1.7</span><br><span class="line"> int h;</span><br><span class="line"> &#x2F;&#x2F; h &#x3D; key.hashCode() 为第一步 取hashCode值</span><br><span class="line"> &#x2F;&#x2F; h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算</span><br><span class="line"> return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么所计算得到的Hash码值总是相同的。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210658_66827.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<h3 id="存储数据-put"><a href="#存储数据-put" class="headerlink" title="存储数据 put"></a>存储数据 put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先根据key，取得hash值。再插入节点</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        &#x2F;&#x2F;tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        &#x2F;&#x2F;如果当前哈希表是空的，代表是初始化，执行扩容</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        		&#x2F;&#x2F;扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        &#x2F;&#x2F;如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span><br><span class="line">        &#x2F;&#x2F;index 是利用 哈希值 &amp; 哈希桶的长度-1，替代模运算</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;&#x2F;&#x2F;发生了哈希冲突。</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            &#x2F;&#x2F;如果哈希值相等，key也相等，则是覆盖value操作</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F;将当前节点引用赋值给e</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)&#x2F;&#x2F;此处代表红黑树</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;&#x2F;&#x2F;此处代表链表</span><br><span class="line">	           		 &#x2F;&#x2F;遍历链表</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">		                    &#x2F;&#x2F;遍历到尾部，追加新节点到尾部</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        &#x2F;&#x2F;如果追加节点后，链表数量&gt;&#x3D;8，则转化为红黑树</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        &#x2F;&#x2F;treeifyBin首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，</span><br><span class="line">                        &#x2F;&#x2F;如果达到64，那么将冲突的存储结构为红黑树</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;如果找到了要覆盖的节点,结束遍历</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             &#x2F;&#x2F;如果e不是null，链表上有相同的key值，</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">		            &#x2F;&#x2F;则覆盖节点值，并返回原oldValue</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                &#x2F;&#x2F;这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line">        &#x2F;&#x2F;修改modCount</span><br><span class="line">        ++modCount;</span><br><span class="line">    	  &#x2F;&#x2F;更新size，并判断是否需要扩容。</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        &#x2F;&#x2F;这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731210713_35028.jpg" alt="阿里P8架构师谈：深入探讨HashMap的底层结构、原理、扩容机制"></p>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ol>
<h3 id="获取数据-get"><a href="#获取数据-get" class="headerlink" title="获取数据 get"></a>获取数据 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F; 定位键值对所在桶的位置</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;直接命中</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            &#x2F;&#x2F; 桶中不止一个节点</span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果 first 是 TreeNode 类型，则调用黑红树查找方法</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">	                	&#x2F;&#x2F;对链表进行查找</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>get方法做了4件事：</p>
<ul>
<li>计算key的hash值；</li>
<li>找到key所在的桶及其第一个元素；</li>
<li>如果第一个元素的key等于待查找的key，直接返回；</li>
<li>如果第一个元素是树节点就按树的方式来查找，否则按链表方式查找；</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>扩容(resize)就是重新计算容量，Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        &#x2F;&#x2F;oldTab 为当前表的哈希桶</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;当前哈希桶的容量 length</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        &#x2F;&#x2F;当前的阈值</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        &#x2F;&#x2F;初始化新的容量和阈值为0</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;如果当前容量大于0</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果当前容量已经到达上限</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                &#x2F;&#x2F;则设置阈值是2的31次方-1</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                &#x2F;&#x2F;同时返回当前的哈希桶，不再扩容</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;&#x2F;&#x2F;否则新的容量为旧的容量的两倍。 </span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)&#x2F;&#x2F;如果旧的容量大于等于默认初始容量16</span><br><span class="line">                &#x2F;&#x2F;那么新的阈值也等于旧的阈值的两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;&#x2F;&#x2F;如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;&#x2F;&#x2F;那么新表的容量就等于旧的阈值</span><br><span class="line">        else &#123;&#125;&#x2F;&#x2F;如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量&#x2F;阈值参数的情况               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;&#x2F;&#x2F;此时新表的容量为默认的容量 16</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&#x2F;&#x2F;新的阈值为默认容量16 * 默认加载因子0.75f &#x3D; 12</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		        &#x2F;&#x2F;根据新表容量 和 加载因子 求出新的阈值</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            &#x2F;&#x2F;进行越界修复</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新阈值 </span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        		&#x2F;&#x2F;根据新的容量 构建新的哈希桶</span><br><span class="line">            Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        &#x2F;&#x2F;更新哈希桶引用</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        &#x2F;&#x2F;如果以前的哈希桶中有元素</span><br><span class="line">        &#x2F;&#x2F;下面开始将当前哈希桶中的所有节点转移到新的哈希桶中</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历老的哈希桶</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                &#x2F;&#x2F;取出当前的节点 e</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                &#x2F;&#x2F;如果当前桶中有元素,则将链表赋值给e</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;将原哈希桶置空以便GC</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;如果当前链表中就一个元素，（没有发生哈希碰撞）</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        &#x2F;&#x2F;直接将这个元素放置在新的哈希桶里。</span><br><span class="line">                        &#x2F;&#x2F;注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    &#x2F;&#x2F;如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        &#x2F;&#x2F;新计算在新表的位置，并进行搬运</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;                   </span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;&#x2F;&#x2F;临时节点 存放e的下一个节点</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;&#x2F;这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                &#x2F;&#x2F;给头尾节点指针赋值</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;&#x2F;&#x2F;高位也是相同的逻辑</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;&#x2F;&#x2F;循环直到链表结束</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        &#x2F;&#x2F;将低位链表存放在原index处，</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F;将高位链表存放在新index处</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，根据hash值重新计算下角标（newTab[e.hash &amp; (newCap - 1)]），并把它们放置到合适的位置上去。</p>
<p>源码做了三件事：</p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。</p>
<p><strong>在并发的多线程使用场景中使用HashMap可能造成死循环。</strong></p>
<h3 id="重点及面试题"><a href="#重点及面试题" class="headerlink" title="重点及面试题"></a>重点及面试题</h3><ul>
<li>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；</li>
<li>HashMap的默认初始容量为16（1&lt;&lt;4），默认装载因子为0.75f，容量总是2的n次方；</li>
<li>HashMap扩容时每次容量变为原来的两倍；</li>
<li>当桶的数量小于64时不会进行树化，只会扩容；</li>
<li>当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；</li>
<li>当单个桶中元素数量小于6时，进行反树化；</li>
<li>HashMap查找添加元素的时间复杂度都为O(1)；</li>
<li>HashMap是非线程安全的容器</li>
<li>允许使用null值和null键(HashMap最多只允许一条记录的键为null，允许多条记录的值为null)。</li>
<li>HashMap中不允许出现重复的键（Key）</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。</p>
<p>添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。HashTable是<strong>同步</strong>方法，线程安全但是效率低。</p>
<p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashTable使用数组+单向列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class Hashtable&lt;K,V&gt;</span><br><span class="line">    extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    		</span><br><span class="line">        &#x2F;&#x2F; Hashtable保存key-value的数组。</span><br><span class="line">		    &#x2F;&#x2F; Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表</span><br><span class="line">        private transient HashtableEntry&lt;?,?&gt;[] table;</span><br><span class="line">		    &#x2F;&#x2F; Hashtable中元素的实际数量</span><br><span class="line">				private transient int count;</span><br><span class="line">				&#x2F;&#x2F; 阈值，用于判断是否需要调整Hashtable的容量（threshold &#x3D; 容量*加载因子）</span><br><span class="line">				private int threshold;</span><br><span class="line">				&#x2F;&#x2F; 加载因子</span><br><span class="line">				private float loadFactor;</span><br><span class="line">				</span><br><span class="line">		    &#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数</span><br><span class="line">				public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">        if (initialCapacity&#x3D;&#x3D;0)</span><br><span class="line">            initialCapacity &#x3D; 1;</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;创建对象时创建数组并非像HashMap那样懒加载</span><br><span class="line">        table &#x3D; new HashtableEntry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">        &#x2F;&#x2F; Android-changed: Ignore loadFactor when calculating threshold from initialCapacity</span><br><span class="line">        &#x2F;&#x2F; threshold &#x3D; (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        threshold &#x3D; (int)Math.min(initialCapacity, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 指定“容量大小”的构造函数</span><br><span class="line">     public Hashtable(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 默认构造函数。</span><br><span class="line">    public Hashtable() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认构造函数，指定的容量大小是11；加载因子是0.75</span><br><span class="line">        this(11, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</span><br><span class="line">        this(Math.max(2*t.size(), 11), 0.75f);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static class HashtableEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    		final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        HashtableEntry&lt;K,V&gt; next;</span><br><span class="line">    		</span><br><span class="line">    		 protected HashtableEntry(int hash, K key, V value, HashtableEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">    		 		&#x2F;**hash值*&#x2F;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">             &#x2F;**key表示键*&#x2F;</span><br><span class="line">            this.key &#x3D;  key;</span><br><span class="line">            &#x2F;**value表示值*&#x2F;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">             &#x2F;**节点下一个元素*&#x2F;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>put() 的作用是<strong>对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F; Make sure the value is not null</span><br><span class="line">        &#x2F;&#x2F; Hashtable中不能插入value为null的元素！！！</span><br><span class="line">        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F; Makes sure the key is not already in the hashtable.</span><br><span class="line">         &#x2F;&#x2F; 若“Hashtable中已存在键为key的键值对”，</span><br><span class="line">		    &#x2F;&#x2F; 则用“新的value”替换“旧的value”</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">        int hash &#x3D; key.hashCode();</span><br><span class="line">        int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        HashtableEntry&lt;K,V&gt; entry &#x3D; (HashtableEntry&lt;K,V&gt;)tab[index];</span><br><span class="line">        for(; entry !&#x3D; null ; entry &#x3D; entry.next) &#123;</span><br><span class="line">            if ((entry.hash &#x3D;&#x3D; hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old &#x3D; entry.value;</span><br><span class="line">                entry.value &#x3D; value;</span><br><span class="line">                return old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				&#x2F;&#x2F;“Hashtable中不存在键为key的键值对”，</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    		&#x2F;&#x2F;将“修改统计数”+1</span><br><span class="line">        modCount++;</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;若“Hashtable实际容量” &gt; “阈值”(阈值&#x3D;总的容量 * 加载因子)</span><br><span class="line">        if (count &gt;&#x3D; threshold) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rehash the table if the threshold is exceeded</span><br><span class="line">            &#x2F;&#x2F;则调整Hashtable的大小</span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab &#x3D; table;</span><br><span class="line">            hash &#x3D; key.hashCode();</span><br><span class="line">            index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Creates the new entry.</span><br><span class="line">        &#x2F;&#x2F;将“Hashtable中index”位置的Entry(链表)保存到e中</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        HashtableEntry&lt;K,V&gt; e &#x3D; (HashtableEntry&lt;K,V&gt;) tab[index];</span><br><span class="line">        &#x2F;&#x2F;创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。       </span><br><span class="line">        tab[index] &#x3D; new HashtableEntry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        &#x2F;&#x2F;将“Hashtable的实际容量”+1</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/ebdd7991f4634d4393568b0632d769ab.jpg" alt="img"></p>
<p>put方法执行流程：</p>
<ol>
<li>校验null值，value不允许null值。</li>
<li>计算出key的哈希值，用哈希值和数组的长度得到index下角标。</li>
<li>根据index找到节点。</li>
<li>如果节点中有元素则遍历链表如果找到则替换旧值并返回旧值。</li>
<li>如果没找到旧值则执行<code>addEntry</code>方法，创建节点并加入哈希桶中。<code>addEntry</code>方法：<ol>
<li>首先判断是否需要扩容</li>
<li>创建节点</li>
<li>添加哈希桶中</li>
</ol>
</li>
</ol>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">        HashtableEntry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">         &#x2F;&#x2F; 计算索引值，</span><br><span class="line">        int hash &#x3D; key.hashCode();</span><br><span class="line">        int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#x2F;&#x2F; 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span><br><span class="line">        for (HashtableEntry&lt;?,?&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">            if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                return (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据index直接找到节点，并进行比较，找到了就返回value，没找到返回null。</p>
<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/82a5ff28b5c14da29f3081db4cc2cd23.jpg" alt="img"></p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>remove() 的作用就是<strong>删除Hashtable中键为key的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#x2F;&#x2F; 找到“key对应的Entry(链表)”</span><br><span class="line">    &#x2F;&#x2F; 然后在链表中找出要删除的节点，并删除该节点。</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; tab[index], prev &#x3D; null ; e !&#x3D; null ; prev &#x3D; e, e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            &#x2F;&#x2F;重新排列链表</span><br><span class="line">            if (prev !&#x3D; null) &#123;</span><br><span class="line">                prev.next &#x3D; e.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/7486b49ac2f4410099b5764082a6d352.jpg" alt="img"></p>
<h4 id="rehash-扩容"><a href="#rehash-扩容" class="headerlink" title="rehash 扩容"></a>rehash 扩容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">				&#x2F;&#x2F;旧数组的长度</span><br><span class="line">        int oldCapacity &#x3D; table.length;</span><br><span class="line">        &#x2F;&#x2F;旧数组</span><br><span class="line">        HashtableEntry&lt;?,?&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;新数组的长度是&#x3D;将长度变成原来的(2倍+1)</span><br><span class="line">        int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">        &#x2F;&#x2F;是否超过可存储数量的最大值</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        		&#x2F;&#x2F;已经到了最大值直接返回，不允许扩容</span><br><span class="line">            if (oldCapacity &#x3D;&#x3D; MAX_ARRAY_SIZE)</span><br><span class="line">                &#x2F;&#x2F; Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">                return;</span><br><span class="line">            &#x2F;&#x2F;没有达到最大值，直接把新数组赋值到最大值</span><br><span class="line">            newCapacity &#x3D; MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建新的数组</span><br><span class="line">        HashtableEntry&lt;?,?&gt;[] newMap &#x3D; new HashtableEntry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        &#x2F;&#x2F;计算阀值 newCapacity * loadFactor 如果到达最大存储容量，以后都不会触法</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        table &#x3D; newMap;</span><br><span class="line">				&#x2F;&#x2F;循环获取获取所有节点</span><br><span class="line">        for (int i &#x3D; oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        		&#x2F;&#x2F;循环获取节点下的所有元素</span><br><span class="line">            for (HashtableEntry&lt;K,V&gt; old &#x3D; (HashtableEntry&lt;K,V&gt;)oldMap[i] ; old !&#x3D; null ; ) &#123;</span><br><span class="line">                HashtableEntry&lt;K,V&gt; e &#x3D; old;</span><br><span class="line">                old &#x3D; old.next;</span><br><span class="line">								&#x2F;&#x2F;获取元素新的index，并存入对应的哈希桶中</span><br><span class="line">                int index &#x3D; (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">                e.next &#x3D; (HashtableEntry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有操作数据的方法都是<code>synchronized</code>线程安全的，尽管，Hashtable 虽然是线程安全的，但是我们一般不推荐使用它，因为有比它更高效、更好的选择 ConcurrentHashMap，在后面我们也会讲到它。</p>
<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul>
<li>HashMap线程不安全；Hashtable线程安全。</li>
<li>因为线程安全的问题，HashMap 要比 HashTable 效率高一点。</li>
<li>HashMap使用时候初始化哈希桶；Hashtable创建对象时创建哈希桶。</li>
<li>HashMap扩容是原来的两倍；Hashtable扩容是原来的两倍+1。</li>
<li>HashMap的初始容量为16；Hashtable初始容量为11，两者的填充因子默认都是0.75</li>
<li>HashMap允许有null值；Hashtable不允许有null值。</li>
<li>HashMap数组+链表+红黑树；Hashtable数组+链表。</li>
</ul>
<h2 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h2><ul>
<li>HashMap实现Map接口；HashSet实现Set接口。</li>
<li>HashMap储存键值对；HashSet仅存储对象（<code>value</code>是空<code>Object</code>对象）。</li>
<li>HashSet基于HashMap，内部持有HashMap引用，核心方法调用都是HashMap。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap实现了Map接口。基本实现同HashMap一样，不同之处在于HashMap是无序的而LinkedHashMap保证了迭代的有序性。其内部维护了一个双向链表，解决了 HashMap不能随时保持遍历顺序和插入顺序一致的问题。</p>
<p><strong>默认情况下，LinkedHashMap的迭代顺序是按照插入节点的顺序。也可以通过改变accessOrder参数的值，使得其遍历顺序按照访问顺序输出。</strong></p>
<p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构。该结构由数组和链表或红黑树组成。本质上，HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。在LinkedHashMapMap中，所有put进来的Entry都保存在如下面第一个图所示的哈希表中，但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166327271293.jpg" alt="img"></p>
<p>LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。其结构可能如下图：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="img"></p>
<p>上图中，淡蓝色的箭头表示前驱引用，红色箭头表示后继引用。每当有新键值对节点插入，新节点最终会接在 tail 引用指向的节点后面。而 tail 引用则会移动到新的节点上，这样一个双向链表就建立起来了。</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line"></span><br><span class="line">		static class LinkedHashMapEntry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line">        LinkedHashMapEntry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     transient LinkedHashMapEntry&lt;K,V&gt; head;</span><br><span class="line">     </span><br><span class="line">     transient LinkedHashMapEntry&lt;K,V&gt; tail;</span><br><span class="line">     </span><br><span class="line">     final boolean accessOrder;</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F;默认初始容量 (16)和默认负载因子(0.75)的空 LinkedHashMap</span><br><span class="line">     public LinkedHashMap() &#123;</span><br><span class="line">     		&#x2F;&#x2F; 调用HashMap对应的构造函数</span><br><span class="line">        super();</span><br><span class="line">        &#x2F;&#x2F; 迭代顺序的默认值</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">        super(initialCapacity);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder &#x3D; false;</span><br><span class="line">        putMapEntries(m, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder &#x3D; accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header、tail</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p>
<p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。</p>
<p>Map 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。那么，LinkedHashMap 是怎样建立链表的呢？在展开说明之前，我们先看一下 LinkedHashMap 插入操作相关的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;...&#125;</span><br><span class="line">    &#x2F;&#x2F; 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#123;...&#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        else if (p instanceof TreeNode) &#123;...&#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历链表，并统计链表长度</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 未在单链表中找到要插入的节点，将新节点接在单链表的后面</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#123;...&#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 插入的节点已经存在于单链表中</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null) &#123;...&#125;</span><br><span class="line">            afterNodeAccess(e);    &#x2F;&#x2F; 回调方法，后续说明</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold) &#123;...&#125;</span><br><span class="line">    afterNodeInsertion(evict);    &#x2F;&#x2F; 回调方法，后续说明</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    &#x2F;&#x2F; 将 Entry 接在双向链表的尾部</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中实现</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail;</span><br><span class="line">    tail &#x3D; p;</span><br><span class="line">    &#x2F;&#x2F; last 为 null，表明链表还未建立</span><br><span class="line">    if (last &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; p;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新节点 p 接在链表尾部</span><br><span class="line">        p.before &#x3D; last;</span><br><span class="line">        last.after &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是 LinkedHashMap 插入相关的源码，这里省略了部分非关键的代码。我根据上面的代码，可以知道 LinkedHashMap 插入操作的调用过程。如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166881843975.jpg" alt="img"></p>
<p>newNode()这一步比较关键。LinkedHashMap 覆写了该方法。在这个方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。</p>
<p>HashMap中有三个回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>根据这三个方法的注释可以看出，这些方法的用途是在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的。上一节最后提到 HashMap 中三个回调方法运行 LinkedHashMap 对一些操作做出响应。所以，在删除及节点后，回调方法 <code>afterNodeRemoval</code> 会被调用。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。相关源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap 中实现</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            node &#x3D; p;</span><br><span class="line">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">            if (p instanceof TreeNode) &#123;...&#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历单链表，寻找要删除的节点，并赋值给 node 变量</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                         (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node &#x3D; e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                             (value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode) &#123;...&#125;</span><br><span class="line">            &#x2F;&#x2F; 将要删除的节点从单链表中移除</span><br><span class="line">            else if (node &#x3D;&#x3D; p)</span><br><span class="line">                tab[index] &#x3D; node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next &#x3D; node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);    &#x2F;&#x2F; 调用删除回调方法进行后续操作</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">    &#x2F;&#x2F; 将 p 节点的前驱后后继引用置空</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; b 为 null，表明 p 是头节点</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    &#x2F;&#x2F; a 为 null，表明 p 是尾节点</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除的过程并不复杂，上面这么多代码其实就做了三件事：</p>
<ol>
<li>根据 hash 定位到桶位置</li>
<li>遍历链表或调用红黑树相关的删除方法</li>
<li>从 LinkedHashMap 维护的双链表中移除要删除的节点</li>
</ol>
<h3 id="访问顺序的维护过程"><a href="#访问顺序的维护过程" class="headerlink" title="访问顺序的维护过程"></a>访问顺序的维护过程</h3><p>默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。访问顺序的原理上并不复杂，当我们调用<code>get/getOrDefault/replace</code>等方法时，只需要将这些方法访问的节点移动到链表的尾部即可。相应的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    &#x2F;&#x2F; 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashMap 中覆写</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 如果 b 为 null，表明 p 为头节点</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">            </span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 这里存疑，父条件分支已经确保节点 e 不会是尾节点，</span><br><span class="line">         * 那么 e.after 必然不会为 null，不知道 else 分支有什么作用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">    </span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 将 p 接在链表的最后</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-LinkedHashMap-实现缓存"><a href="#基于-LinkedHashMap-实现缓存" class="headerlink" title="基于 LinkedHashMap 实现缓存"></a>基于 LinkedHashMap 实现缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    &#x2F;&#x2F; 根据条件判断是否移除最近最少被访问的节点</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是通过一些条件，判断是否移除最近最少被访问的节点。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写<code>removeEldestEntry</code>方法可以实现自定义策略的 LRU 缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等。本节所实现的缓存是基于判断节点数量是否超限的策略。在构造缓存对象时，传入最大节点数。当插入的节点数超过最大节点数时，移除最近最少被访问的节点。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_NODE_NUM &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    private int limit;</span><br><span class="line"></span><br><span class="line">    public SimpleCache() &#123;</span><br><span class="line">        this(MAX_NODE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SimpleCache(int limit) &#123;</span><br><span class="line">        super(limit, 0.75f, true);</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V save(K key, V val) &#123;</span><br><span class="line">        return put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V getOne(K key) &#123;</span><br><span class="line">        return get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean exists(K key) &#123;</span><br><span class="line">        return containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断节点数是否超限</span><br><span class="line">     * @param eldest</span><br><span class="line">     * @return 超限返回 true，否则返回 false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<p>举例：声明了两个Map对象，一个是HashMap，一个是WeakHashMap，同时向两个map中放入a、b两个对象，当HashMap remove掉a 并且将a、b都指向null时，WeakHashMap中的a将自动被回收掉。出现这个状况的原因是，对于a对象而言，当HashMap remove掉并且将a指向null后，除了WeakHashMap中还保存a外已经没有指向a的指针了，所以WeakHashMap会自动舍弃掉a，而对于b对象虽然指向了null，但HashMap中还有指向b的指针，所以WeakHashMap将会保留。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>内部红黑树实现</li>
<li>key-value不为空</li>
<li>TreeMap有序</li>
</ul>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;比较器，是自然排序，还是定制排序 ，使用final修饰，表明一旦赋值便不允许改变</span><br><span class="line">		private final Comparator&lt;? super K&gt; comparator;  </span><br><span class="line">		private transient Entry&lt;K,V&gt; root &#x3D; null;  &#x2F;&#x2F;红黑树的根节点</span><br><span class="line">		private transient int size &#x3D; 0;     &#x2F;&#x2F;TreeMap中存放的键值对的数量</span><br><span class="line">		private transient int modCount &#x3D; 0;   &#x2F;&#x2F;修改的次数</span><br><span class="line">    </span><br><span class="line">    private static final boolean RED   &#x3D; false;</span><br><span class="line">    private static final boolean BLACK &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;    &#x2F;&#x2F;键</span><br><span class="line">    V value;    &#x2F;&#x2F;值</span><br><span class="line">    Entry&lt;K,V&gt; left &#x3D; null;     &#x2F;&#x2F;左孩子节点</span><br><span class="line">    Entry&lt;K,V&gt; right &#x3D; null;    &#x2F;&#x2F;右孩子节点</span><br><span class="line">    Entry&lt;K,V&gt; parent;          &#x2F;&#x2F;父节点</span><br><span class="line">    boolean color &#x3D; BLACK;      &#x2F;&#x2F;节点的颜色，在红黑树种，只有两种颜色，红色和黑色</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造方法，用指定的key,value ,parent初始化，color默认为黑色</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;构造方法，comparator用键的顺序做比较</span><br><span class="line">		public TreeMap() &#123;</span><br><span class="line">		    comparator &#x3D; null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;构造方法，提供比较器，用指定比较器排序</span><br><span class="line">		public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">		    his.comparator &#x3D; comparator;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;将m中的元素转化daoTreeMap中，按照键的顺序做比较排序</span><br><span class="line">		public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">		    comparator &#x3D; null;</span><br><span class="line">		    putAll(m);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;构造方法，指定的参数为SortedMap</span><br><span class="line">		&#x2F;&#x2F;采用m的比较器排序</span><br><span class="line">		public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123;</span><br><span class="line">		    comparator &#x3D; m.comparator();</span><br><span class="line">		    try &#123;</span><br><span class="line">		        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</span><br><span class="line">		    &#125; catch (java.io.IOException cannotHappen) &#123;</span><br><span class="line">		    &#125; catch (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序.</p>
<ul>
<li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li>
<li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li>
</ul>
<h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">				&#x2F;&#x2F;&#x2F;&#x2F;红黑树的根节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; t &#x3D; root;</span><br><span class="line">        &#x2F;&#x2F;红黑树是否为空</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">            compare(key, key); &#x2F;&#x2F; type (and possibly null) check</span><br><span class="line">            &#x2F;&#x2F;构造根节点，因为根节点没有父节点，传入null值。</span><br><span class="line">            root &#x3D; new TreeMapEntry&lt;&gt;(key, value, null);</span><br><span class="line">            size &#x3D; 1;</span><br><span class="line">            modCount++;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp;</span><br><span class="line">         &#x2F;&#x2F;定义节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; parent;</span><br><span class="line">        &#x2F;&#x2F; split comparator and comparable paths</span><br><span class="line">        &#x2F;&#x2F;获取比较器</span><br><span class="line">        Comparator&lt;? super K&gt; cpr &#x3D; comparator;</span><br><span class="line">        &#x2F;&#x2F;如果定义了比较器，采用自定义比较器进行比较</span><br><span class="line">        if (cpr !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;do while 做循环排序 找到父节点</span><br><span class="line">            do &#123;</span><br><span class="line">             &#x2F;&#x2F;将红黑树根节点赋值给parent</span><br><span class="line">                parent &#x3D; t;</span><br><span class="line">                 &#x2F;&#x2F;比较key, 与根节点的大小</span><br><span class="line">                cmp &#x3D; cpr.compare(key, t.key);</span><br><span class="line">                &#x2F;&#x2F;如果key &lt; t.key , 指向左子树</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                &#x2F;&#x2F;t &#x3D; t.left  , t &#x3D;&#x3D; 它的左孩子节点</span><br><span class="line">                    t &#x3D; t.left;</span><br><span class="line">                else if (cmp &gt; 0)&#x2F;&#x2F;如果key &gt; t.key , 指向它的右孩子节点</span><br><span class="line">                    t &#x3D; t.right;</span><br><span class="line">                else &#x2F;&#x2F;如果它们相等，替换key的值</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;自然排序方式，没有指定比较器</span><br><span class="line">        		&#x2F;&#x2F;key &#x3D;&#x3D; null 抛出异常</span><br><span class="line">            if (key &#x3D;&#x3D; null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">            &#x2F;&#x2F;一样 循环排序 找到父节点</span><br><span class="line">                parent &#x3D; t;</span><br><span class="line">                cmp &#x3D; k.compareTo(t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t &#x3D; t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t &#x3D; t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建新节点，并制定父节点</span><br><span class="line">        TreeMapEntry&lt;K,V&gt; e &#x3D; new TreeMapEntry&lt;&gt;(key, value, parent);</span><br><span class="line">       &#x2F;&#x2F;根据比较结果，决定新节点为父节点的左孩子或者右孩子</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            parent.left &#x3D; e;</span><br><span class="line">        else</span><br><span class="line">            parent.right &#x3D; e;</span><br><span class="line">        &#x2F;&#x2F;新插入节点后重新调整红黑树</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="compare方法-比较器"><a href="#compare方法-比较器" class="headerlink" title="compare方法 比较器"></a>compare方法 比较器</h4><p>比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final int compare(Object k1, Object k2) &#123;</span><br><span class="line">        return comparator&#x3D;&#x3D;null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</span><br><span class="line">            : comparator.compare((K)k1, (K)k2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fixAfterInsertion-重新调整红黑树"><a href="#fixAfterInsertion-重新调整红黑树" class="headerlink" title="fixAfterInsertion 重新调整红黑树"></a>fixAfterInsertion 重新调整红黑树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void fixAfterInsertion(TreeMapEntry&lt;K,V&gt; x) &#123;</span><br><span class="line">		    &#x2F;&#x2F;插入的节点默认的颜色为红色</span><br><span class="line">        x.color &#x3D; RED;</span><br><span class="line">				 &#x2F;&#x2F;情形1：新节点x 是树的根节点，没有父节点不需要任何操作</span><br><span class="line">		    &#x2F;&#x2F;情形2：新节点x 的父节点颜色是黑色的，也不需要任何操作</span><br><span class="line">        while (x !&#x3D; null &amp;&amp; x !&#x3D; root &amp;&amp; x.parent.color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">            &#x2F;&#x2F;情形3：新节点x的父节点颜色是红色的</span><br><span class="line">				    &#x2F;&#x2F;判断x的节点的父节点位置，是否属于左孩子</span><br><span class="line">            if (parentOf(x) &#x3D;&#x3D; leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">              &#x2F;&#x2F;获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y &#x3D; rightOf(parentOf(parentOf(x)));</span><br><span class="line">               &#x2F;&#x2F;判断是否x节点的父节点的兄弟节点为红色。</span><br><span class="line">                if (colorOf(y) &#x3D;&#x3D; RED) &#123;</span><br><span class="line">		                &#x2F;&#x2F; x节点的父节点设置为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    &#x2F;&#x2F; y节点的颜色设置为黑色</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    &#x2F;&#x2F; x.parent.parent设置为红色</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    &#x2F;&#x2F; x &#x3D;&#x3D; x.parent.parent ,进行遍历。</span><br><span class="line">                    x &#x3D; parentOf(parentOf(x));</span><br><span class="line">                &#125; else &#123;&#x2F;&#x2F;x的父节点的兄弟节点是黑色或者缺少的</span><br><span class="line">	                  &#x2F;&#x2F;判断x节点是否为父节点的右孩子</span><br><span class="line">                    if (x &#x3D;&#x3D; rightOf(parentOf(x))) &#123;</span><br><span class="line">                   		 &#x2F;&#x2F;x &#x3D;&#x3D; 父节点</span><br><span class="line">                        x &#x3D; parentOf(x);</span><br><span class="line">                        &#x2F;&#x2F;左旋转操作</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;x节点是其父的左孩子</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    &#x2F;&#x2F;进行右旋转</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">		             &#x2F;&#x2F;y 是x 节点的祖父节点的左孩子</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y &#x3D; leftOf(parentOf(parentOf(x)));</span><br><span class="line">                if (colorOf(y) &#x3D;&#x3D; RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x &#x3D; parentOf(parentOf(x));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (x &#x3D;&#x3D; leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x &#x3D; parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色</span><br><span class="line">        root.color &#x3D; BLACK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>红黑树是一个更高效的检索二叉树，有如下特点：</p>
<ul>
<li>每个节点只能是红色或者黑色</li>
<li>根节点永远是黑色的</li>
<li>所有的叶子的子节点都是空节点，并且都是黑色的</li>
<li>每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点）</li>
<li>从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同）</li>
</ul>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>TreeMap底层是红黑树结构，而红黑树本质是一颗二叉查找树，所以在获取节点方面，使用二分查找算法性能最高；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过key获取对应的value：</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取TreeMap中对应的节点：</span><br><span class="line">    java.util.TreeMap.Entry&lt;K,V&gt; p &#x3D; getEntry(key);</span><br><span class="line">    &#x2F;&#x2F;获取节点的值：</span><br><span class="line">    return (p&#x3D;&#x3D;null ? null : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过key获取Entry对象：</span><br><span class="line">final java.util.TreeMap.Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F;TreeMap自定义比较器不为空，使用自定义比较器对象来获取节点：</span><br><span class="line">    if (comparator !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F;获取节点：</span><br><span class="line">        return getEntryUsingComparator(key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果key为null，则抛出异常，TreeMap中不允许存在为null的key：</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将传入的key转换成Comparable类型，传入的key必须实现Comparable接口</span><br><span class="line">    Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key;</span><br><span class="line">    &#x2F;&#x2F;获取根节点：</span><br><span class="line">    java.util.TreeMap.Entry&lt;K,V&gt; p &#x3D; root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用二分查找方式，首先判断传入的key与根节点的key哪个大：</span><br><span class="line">    while (p !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;传入的key与p节点的key进行大小比较：</span><br><span class="line">        int cmp &#x3D; k.compareTo(p.key);</span><br><span class="line">        &#x2F;&#x2F;传入的key小于p节点的key,则从根的左子树中搜索：</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            &#x2F;&#x2F;左边</span><br><span class="line">            p &#x3D; p.left;</span><br><span class="line">        else if (cmp &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;传入的key大于p节点的key,则从根的右边子树中搜索：</span><br><span class="line">            &#x2F;&#x2F;右边</span><br><span class="line">            p &#x3D; p.right;</span><br><span class="line">        else</span><br><span class="line">            &#x2F;&#x2F;传入的key等于p节点的key,则直接返回当前节点：</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;以上循环没有找对对应的节点，则返回null：</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用自定义比较器进行元素比较，获取对节点：</span><br><span class="line">final java.util.TreeMap.Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;</span><br><span class="line">    K k &#x3D; (K) key;</span><br><span class="line">    Comparator&lt;? super K&gt; cpr &#x3D; comparator;</span><br><span class="line">    if (cpr !&#x3D; null) &#123;</span><br><span class="line">        java.util.TreeMap.Entry&lt;K,V&gt; p &#x3D; root;</span><br><span class="line">        while (p !&#x3D; null) &#123;</span><br><span class="line">            int cmp &#x3D; cpr.compare(k, p.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                p &#x3D; p.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                p &#x3D; p.right;</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Removes the mapping for this key from this TreeMap if present.</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Entry p &#x3D; getEntry(key);</span><br><span class="line">        if (p &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        V oldValue &#x3D; p.value;</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  通过这段代码可以看出，TreeMap的remove()方法中执行删除的真正方式是deleteEntry()方法。deleteEntry()代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Delete node p, and then rebalance the tree.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void deleteEntry(Entry p) &#123;</span><br><span class="line">        modCount++;&#x2F;&#x2F;修改次数 +1；</span><br><span class="line">        size--;&#x2F;&#x2F;元素个数 -1</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If strictly internal, copy successor&#39;s element to p and then make p</span><br><span class="line">        &#x2F;&#x2F; point to successor.</span><br><span class="line">		&#x2F;*</span><br><span class="line">         * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span><br><span class="line">         * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点</span><br><span class="line">         * ---------------------（1）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (p.left !&#x3D; null &amp;&amp; p.right !&#x3D; null) &#123;</span><br><span class="line">            Entry s &#x3D; successor (p);</span><br><span class="line">            p.key &#x3D; s.key;</span><br><span class="line">            p.value &#x3D; s.value;</span><br><span class="line">            p &#x3D; s;</span><br><span class="line">        &#125; &#x2F;&#x2F; p has 2 children</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start fixup at replacement node, if it exists.</span><br><span class="line">		&#x2F;&#x2F;replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代</span><br><span class="line">        Entry replacement &#x3D; (p.left !&#x3D; null ? p.left : p.right);</span><br><span class="line">		&#x2F;*</span><br><span class="line">         * 删除节点，分为上面提到的三种情况</span><br><span class="line">         * -----------------------（2）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;如果替代节点不为空</span><br><span class="line">        if (replacement !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; Link replacement to parent</span><br><span class="line">			&#x2F;&#x2F;replacement来替代P节点</span><br><span class="line">            replacement.parent &#x3D; p.parent;</span><br><span class="line">            if (p.parent &#x3D;&#x3D; null)</span><br><span class="line">                root &#x3D; replacement;</span><br><span class="line">            else if (p &#x3D;&#x3D; p.parent.left)</span><br><span class="line">                p.parent.left  &#x3D; replacement;</span><br><span class="line">            else</span><br><span class="line">                p.parent.right &#x3D; replacement;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Null out links so they are OK to use by fixAfterDeletion.</span><br><span class="line">            p.left &#x3D; p.right &#x3D; p.parent &#x3D; null;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Fix replacement</span><br><span class="line">            if (p.color &#x3D;&#x3D; BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br><span class="line">        &#125; else if (p.parent &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; return if we are the only node.</span><br><span class="line">            root &#x3D; null;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;  No children. Use self as phantom replacement and unlink.</span><br><span class="line">            if (p.color &#x3D;&#x3D; BLACK)</span><br><span class="line">                fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">            if (p.parent !&#x3D; null) &#123;</span><br><span class="line">                if (p &#x3D;&#x3D; p.parent.left)</span><br><span class="line">                    p.parent.left &#x3D; null;</span><br><span class="line">                else if (p &#x3D;&#x3D; p.parent.right)</span><br><span class="line">                    p.parent.right &#x3D; null;</span><br><span class="line">                p.parent &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/2019060710430212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li>
<li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。</li>
<li>要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</li>
<li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="url">Android面试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android基础面试题详解"><a href="#Android基础面试题详解" class="headerlink" title="Android基础面试题详解"></a>Android基础面试题详解</h1><p><img src="https://img-blog.csdnimg.cn/2020041121370949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70#pic_center" alt="Android面试知识框架"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">Java设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>依赖是类与类之间的连接，依赖关系表示一个类依赖于另一个类的定义，通俗来讲就是需要。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>一个人(Person)可以买车(Car)和房子(House),Person类依赖于Car类和House类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String ... args)&#123;</span><br><span class="line">        &#x2F;&#x2F;TODO:</span><br><span class="line"></span><br><span class="line">    Person person &#x3D; new Person();</span><br><span class="line">    person.buy(new House());</span><br><span class="line">    person.buy(new Car());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Person&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;表示依赖House</span><br><span class="line">    public void buy(House house)&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;表示依赖Car</span><br><span class="line">    public void buy(Car car)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class House&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Car&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="依赖倒置-Dependence-Inversion-Principle"><a href="#依赖倒置-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置(Dependence Inversion Principle)"></a>依赖倒置(Dependence Inversion Principle)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>高层模块不应该依赖低层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；通俗来讲，依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。</p>
<p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。此时将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>不使用依赖倒置，每次出行都需要修改Person类代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private Bike mBike;</span><br><span class="line">    private Car mCar;</span><br><span class="line">    private Train mTrain;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;</span><br><span class="line">        mBike &#x3D; new Bike();</span><br><span class="line">        &#x2F;&#x2F;mCar &#x3D; new Car();</span><br><span class="line">&#x2F;&#x2F;        mTrain &#x3D; new Train();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mBike.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）使用依赖倒置，上层模块不应该依赖底层模块，它们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    private Bike mBike;</span><br><span class="line">    private Car mCar;</span><br><span class="line">    private Train mTrain;</span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;</span><br><span class="line">&#x2F;&#x2F;        mBike &#x3D; new Bike();</span><br><span class="line">        &#x2F;&#x2F;mCar &#x3D; new Car();</span><br><span class="line">       mDriveable &#x3D; new Train();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="控制反转-Inversion-of-Control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转(Inversion of Control)"></a>控制反转(Inversion of Control)</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>IoC 是一种新的设计模式，它对上层模块与底层模块进行了更进一步的解耦。控制反转的意思是反转了上层模块对于底层模块的依赖控制。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person2 &#123;</span><br><span class="line"></span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public Person2(Driveable driveable)&#123;</span><br><span class="line">        this.mDriveable &#x3D; driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:将 mDriveable 的实例化移到 Person 外面</span><br><span class="line">        Person2 person &#x3D; new Person2(new Car());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这样无论出行方式怎么变化，Person 这个类都不需要更改代码了。<br>在上面代码中，Person 把内部依赖的创建权力移交给了 Person2。也就是说 Person 只关心依赖提供的功能，但并不关心依赖的创建。<br>其中Person2称为IoC容器（依赖注入的地方）</p>
<h1 id="依赖注入-Dependency-injection"><a href="#依赖注入-Dependency-injection" class="headerlink" title="依赖注入(Dependency injection)"></a>依赖注入(Dependency injection)</h1><p>为了不因为依赖实现的变动而去修改 Person，也就是说以可能在 Driveable 实现类的改变下不改动 Person 这个类的代码，尽可能减少两者之间的耦合需要采用IoC 模式来进行改写代码。</p>
<p>这个需要我们移交出对于依赖实例化的控制权，Person 无法实例化依赖了，它就需要在外部（IoC 容器）赋值给它，这个赋值的动作有个专门的术语叫做注入（injection），需要注意的是在 IoC 概念中，这个注入依赖的地方被称为 IoC 容器，但在依赖注入概念中，一般被称为注射器 （injector)。</p>
<p>表达通俗一点就是：我不想自己实例化依赖，你（injector）创建它们，然后在合适的时候注入给我。</p>
<p>实现依赖注入有 3 种方式：</p>
<ul>
<li>构造函数中注入</li>
<li>setter 方式注入</li>
<li>接口注入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 接口方式注入</span><br><span class="line"> * 接口的存在，表明了一种依赖配置的能力。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface DepedencySetter &#123;</span><br><span class="line">    void set(Driveable driveable);</span><br><span class="line">&#125;</span><br><span class="line">public class Person2  implements DepedencySetter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接口方式注入</span><br><span class="line">    @Override</span><br><span class="line">    public void set(Driveable driveable) &#123;</span><br><span class="line">        this.mDriveable &#x3D; mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造函数注入</span><br><span class="line">    public Person2(Driveable driveable)&#123;</span><br><span class="line">        this.mDriveable &#x3D; driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;setter 方式注入</span><br><span class="line">    public void setDriveable(Driveable mDriveable) &#123;</span><br><span class="line">        this.mDriveable &#x3D; mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:</span><br><span class="line">        Person2 person &#x3D; new Person2(new Car());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><h2 id="代理模式基本概念及分类"><a href="#代理模式基本概念及分类" class="headerlink" title="代理模式基本概念及分类"></a>代理模式基本概念及分类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img-blog.csdnimg.cn/20190601204007375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为其他对象提供一种代理以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理对象起到中介的作用，可去掉功能服务或增加额外的服务。负责为委托类预处理消息，过滤消息并将请求分派给委托类处理，以及进行消息被委托类执行后的后续操作。</p>
<p>例如火车票代售处是火车站的代理，相对于火车站，可以提供额外的服务，如电话预约，提供额外服务的同时，会收取一定金额的手续费。也可以将原有的功能去掉，如代售处不能提供退票服务。</p>
<h3 id="代理模式模型"><a href="#代理模式模型" class="headerlink" title="代理模式模型"></a>代理模式模型</h3><p>代理模式一般设计到角色有4 种：</p>
<ul>
<li><strong>抽象角色</strong>：对应代理接口（&lt;&lt; interface &gt;&gt;Subject），用来定义代理类和委托类的公共对外方法/接口；</li>
<li><strong>真实角色</strong>：对应委托类（接口实现类RealSubject），真正实现业务逻辑的类，是代理角色所代表的真实对象，是最终要引用的对象；</li>
<li><strong>代理角色</strong>：对应代理类（Proxy），用来代理和封装真实角色。代理角色内部含有对真实对象的引用，从而可以操作真实对象。同时，代理对象可以在执行真是对象操作时，添加或去除其他操作，相当于对真实对象进行封装；</li>
<li><strong>客户角色</strong>：对应客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190601204859723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在代理模式中真实角色对于客户端角色来说的透明的，也就是客户端不知道也无需知道真实角色的存在。 为了保持行为的一致性，代理角色和真实角色通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</p>
<p>通过代理角色这中间一层，能有效控制对真实角色（委托类对象）的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p>
<h3 id="代理模式特点"><a href="#代理模式特点" class="headerlink" title="代理模式特点"></a>代理模式特点</h3><h4 id="代理模式优点"><a href="#代理模式优点" class="headerlink" title="代理模式优点"></a>代理模式优点</h4><ul>
<li>隐藏委托类的实现，调用者只需要和代理类进行交互即可。</li>
<li>解耦，在不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作</li>
</ul>
<h2 id="代理模式实现方式"><a href="#代理模式实现方式" class="headerlink" title="代理模式实现方式"></a>代理模式实现方式</h2><p>根据代理类的<strong>生成时间</strong>不同可以将代理分为静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>所谓静态代理也就是在程序运行前就已经存在代理类的.class文件，代理类和委托类的关系在运行前就确定了。</p>
<p>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被代理对象Car</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car2 extends Car &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		super.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="聚合方式"><a href="#聚合方式" class="headerlink" title="聚合方式"></a>聚合方式</h4><p>聚合：在代理中引用被代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Car3 implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public Car3(Car car) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.car &#x3D; car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Car car;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		car.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式与聚合方式对比"><a href="#继承方式与聚合方式对比" class="headerlink" title="继承方式与聚合方式对比"></a>继承方式与聚合方式对比</h4><p>聚合方式比继承方式更适合代理模式：适合功能的叠加（可灵活传递，组合）。</p>
<p>记录日志代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CarLogProxy implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public CarLogProxy(Moveable m) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.m &#x3D; m;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Moveable m;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;日志开始....&quot;);</span><br><span class="line">		m.move();</span><br><span class="line">		System.out.println(&quot;日志结束....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录时间代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Car car &#x3D; new Car();</span><br><span class="line">	CarLogProxy clp &#x3D; new CarLogProxy(car);</span><br><span class="line">	CarTimeProxy ctp &#x3D; new CarTimeProxy(clp);</span><br><span class="line">	ctp.move();&#x2F;&#x2F;先记录日志后记录时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通过动态代理可实现对不同类、不同方法的代理。动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件（.class）。代理类和委托类的关系在程序运行时确定。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>实现模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190601211348201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>
<p><strong>Interface InvocationHandler</strong></p>
<p>InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，每次生成动态代理对象都邀制定一个对应的调用处理器对象，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object invoke(Object obj,Method method,Object[] args)</span><br></pre></td></tr></table></figure>

<p>在实际使用时，obj指代理类的实例，method指被代理的方法，args是该方法的参数数组。这个抽象方法在代理类中动态实现。</p>
<p>该方法也是InvocationHandler接口所定义的唯一的一个方法，该方法负责集中处理动态代理类上的所有方法的调用。调用处理器根据这三个参数进行预处理或分派到委托类实例上执行。</p>
<p><strong>Proxy class动态代理类</strong></p>
<p>Proxy是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>

<p>返回代理类的一个实例，返回后的代理类可以当做被代理类使用（可使用被代理类在接口中声明过的方法）</p>
<p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p><strong>步骤1：创建一个实现接口InvocationHandler的调用处理器，它必须实现invoke方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TimeHandler implements InvocationHandler &#123;</span><br><span class="line">&#x2F;&#x2F;动态代理类对应的调用处理程序类（时间处理器）</span><br><span class="line">	public TimeHandler(Object target) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.target &#x3D; target;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;代理类持有一个委托类的对象引用</span><br><span class="line">	private Object target;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * 参数：</span><br><span class="line">	 * proxy  被代理对象</span><br><span class="line">	 * method  被代理对象的方法</span><br><span class="line">	 * args 方法的参数</span><br><span class="line">	 * </span><br><span class="line">	 * 返回值：</span><br><span class="line">	 * Object  方法的返回值</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		method.invoke(target);&#x2F;&#x2F;调用被代理对象的方法（Car的move方法）</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimeHandler实现了InvocationHandler的invoke方法，当代理对象的方法被调用时，invoke方法会被回调。其中proxy表示实现了公共代理方法的动态代理对象。</p>
<p><strong>步骤2：创建被代理的类以及接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：调用Proxy的静态方法newProxyInstance，提供ClassLoader和代理接口类型数组动态创建一个代理类，并通过代理调用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端，使用代理类和主题接口完成功能</span><br><span class="line">public class Test &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * JDK动态代理测试类</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Car car &#x3D; new Car();</span><br><span class="line">		InvocationHandler h &#x3D; new TimeHandler(car);</span><br><span class="line">		Class&lt;?&gt; cls &#x3D; car.getClass();</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * loader  类加载器</span><br><span class="line">		 * interfaces  实现接口</span><br><span class="line">		 * h InvocationHandler</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Moveable m &#x3D; (Moveable)Proxy.newProxyInstance(cls.getClassLoader(),</span><br><span class="line">												cls.getInterfaces(), h);&#x2F;&#x2F;获得动态代理对象，动态代理对象与代理对象实现同一接口</span><br><span class="line">		m.move();&#x2F;&#x2F;调用动态代理的move方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过InvocationHandler handler=new TimeHandler(target);将委托对象作为构造方法的参数传递给了TimeHandler来作为代理方法调用的对象。当我们调用代理对象的move()方法时，该调用将会被转发到TimeHandler对象的invoke上从而达到动态代理的效果。</p>
<p>所谓动态代理是这样一种class：它是运行时生成的class，该class需要实现一组interface，使用动态代理类时，必须实现InvocationHandler接口</p>
<h3 id="静态代理与动态代理对比"><a href="#静态代理与动态代理对比" class="headerlink" title="静态代理与动态代理对比"></a>静态代理与动态代理对比</h3><h4 id="静态代理-1"><a href="#静态代理-1" class="headerlink" title="静态代理"></a>静态代理</h4><ul>
<li>优点：<br>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。</li>
<li>缺点：<ul>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
<li>采用静态代理模式，那么真实角色（委托类）必须事先已经存在的，并将其作为代理对象代理对象内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀。</li>
</ul>
</li>
</ul>
<h4 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h4><ul>
<li>优点<ul>
<li>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</li>
<li>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</li>
</ul>
</li>
<li>缺点<ul>
<li>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/" itemprop="url">第一次测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-29T23:03:36+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标题"><a href="#这是一个三级标题" class="headerlink" title="这是一个三级标题"></a>这是一个三级标题</h3><h4 id="这是一个司机标题"><a href="#这是一个司机标题" class="headerlink" title="这是一个司机标题"></a>这是一个司机标题</h4><h5 id="这是一个五级标题"><a href="#这是一个五级标题" class="headerlink" title="这是一个五级标题"></a>这是一个五级标题</h5><h6 id="这是一个六级标题"><a href="#这是一个六级标题" class="headerlink" title="这是一个六级标题"></a>这是一个六级标题</h6><p>####### 有没有七级标题</p>
<p><strong>加粗</strong></p>
<p><em>斜体</em></p>
<p><strong><em>斜体加粗</em></strong></p>
<p><del>删除线</del></p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>正文<br>    段落没有啊</p>
<ul>
<li><ol>
<li>第一点</li>
</ol>
</li>
<li><ol start="2">
<li>第二点</li>
</ol>
</li>
<li><ol start="3">
<li>第三点</li>
</ol>
</li>
</ul>
<p>分割线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<hr>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
