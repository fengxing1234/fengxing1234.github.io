<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="url">设计模式中类的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T21:15:22+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>   在java以及其他的面向对象设计模式中，类与类之间主要有6种关系，他们分别是：</p>
<ul>
<li>依赖</li>
<li>关联</li>
<li>聚合</li>
<li>组合</li>
<li>继承</li>
<li>实现</li>
</ul>
<p>他们的耦合度依次增强</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" itemprop="url">代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T20:12:32+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><h2 id="代理模式基本概念及分类"><a href="#代理模式基本概念及分类" class="headerlink" title="代理模式基本概念及分类"></a>代理模式基本概念及分类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img-blog.csdnimg.cn/20190601204007375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为其他对象提供一种代理以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理对象起到中介的作用，可去掉功能服务或增加额外的服务。负责为委托类预处理消息，过滤消息并将请求分派给委托类处理，以及进行消息被委托类执行后的后续操作。</p>
<p>例如火车票代售处是火车站的代理，相对于火车站，可以提供额外的服务，如电话预约，提供额外服务的同时，会收取一定金额的手续费。也可以将原有的功能去掉，如代售处不能提供退票服务。</p>
<h3 id="代理模式模型"><a href="#代理模式模型" class="headerlink" title="代理模式模型"></a>代理模式模型</h3><p>代理模式一般设计到角色有4 种：</p>
<ul>
<li><strong>抽象角色</strong>：对应代理接口（&lt;&lt; interface &gt;&gt;Subject），用来定义代理类和委托类的公共对外方法/接口；</li>
<li><strong>真实角色</strong>：对应委托类（接口实现类RealSubject），真正实现业务逻辑的类，是代理角色所代表的真实对象，是最终要引用的对象；</li>
<li><strong>代理角色</strong>：对应代理类（Proxy），用来代理和封装真实角色。代理角色内部含有对真实对象的引用，从而可以操作真实对象。同时，代理对象可以在执行真是对象操作时，添加或去除其他操作，相当于对真实对象进行封装；</li>
<li><strong>客户角色</strong>：对应客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190601204859723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在代理模式中真实角色对于客户端角色来说的透明的，也就是客户端不知道也无需知道真实角色的存在。 为了保持行为的一致性，代理角色和真实角色通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</p>
<p>通过代理角色这中间一层，能有效控制对真实角色（委托类对象）的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p>
<h3 id="代理模式特点"><a href="#代理模式特点" class="headerlink" title="代理模式特点"></a>代理模式特点</h3><h4 id="代理模式优点"><a href="#代理模式优点" class="headerlink" title="代理模式优点"></a>代理模式优点</h4><ul>
<li>隐藏委托类的实现，调用者只需要和代理类进行交互即可。</li>
<li>解耦，在不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作</li>
</ul>
<h2 id="代理模式实现方式"><a href="#代理模式实现方式" class="headerlink" title="代理模式实现方式"></a>代理模式实现方式</h2><p>根据代理类的<strong>生成时间</strong>不同可以将代理分为静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>所谓静态代理也就是在程序运行前就已经存在代理类的.class文件，代理类和委托类的关系在运行前就确定了。</p>
<p>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被代理对象Car</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car2 extends Car &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		super.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="聚合方式"><a href="#聚合方式" class="headerlink" title="聚合方式"></a>聚合方式</h4><p>聚合：在代理中引用被代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Car3 implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public Car3(Car car) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.car &#x3D; car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Car car;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		car.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式与聚合方式对比"><a href="#继承方式与聚合方式对比" class="headerlink" title="继承方式与聚合方式对比"></a>继承方式与聚合方式对比</h4><p>聚合方式比继承方式更适合代理模式：适合功能的叠加（可灵活传递，组合）。</p>
<p>记录日志代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CarLogProxy implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public CarLogProxy(Moveable m) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.m &#x3D; m;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Moveable m;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;日志开始....&quot;);</span><br><span class="line">		m.move();</span><br><span class="line">		System.out.println(&quot;日志结束....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录时间代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Car car &#x3D; new Car();</span><br><span class="line">	CarLogProxy clp &#x3D; new CarLogProxy(car);</span><br><span class="line">	CarTimeProxy ctp &#x3D; new CarTimeProxy(clp);</span><br><span class="line">	ctp.move();&#x2F;&#x2F;先记录日志后记录时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通过动态代理可实现对不同类、不同方法的代理。动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件（.class）。代理类和委托类的关系在程序运行时确定。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>实现模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190601211348201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>
<p><strong>Interface InvocationHandler</strong></p>
<p>InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，每次生成动态代理对象都邀制定一个对应的调用处理器对象，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object invoke(Object obj,Method method,Object[] args)</span><br></pre></td></tr></table></figure>

<p>在实际使用时，obj指代理类的实例，method指被代理的方法，args是该方法的参数数组。这个抽象方法在代理类中动态实现。</p>
<p>该方法也是InvocationHandler接口所定义的唯一的一个方法，该方法负责集中处理动态代理类上的所有方法的调用。调用处理器根据这三个参数进行预处理或分派到委托类实例上执行。</p>
<p><strong>Proxy class动态代理类</strong></p>
<p>Proxy是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>

<p>返回代理类的一个实例，返回后的代理类可以当做被代理类使用（可使用被代理类在接口中声明过的方法）</p>
<p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>步骤1：创建一个实现接口InvocationHandler的调用处理器，它必须实现invoke方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TimeHandler implements InvocationHandler &#123;</span><br><span class="line">&#x2F;&#x2F;动态代理类对应的调用处理程序类（时间处理器）</span><br><span class="line">	public TimeHandler(Object target) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.target &#x3D; target;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;代理类持有一个委托类的对象引用</span><br><span class="line">	private Object target;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * 参数：</span><br><span class="line">	 * proxy  被代理对象</span><br><span class="line">	 * method  被代理对象的方法</span><br><span class="line">	 * args 方法的参数</span><br><span class="line">	 * </span><br><span class="line">	 * 返回值：</span><br><span class="line">	 * Object  方法的返回值</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		method.invoke(target);&#x2F;&#x2F;调用被代理对象的方法（Car的move方法）</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimeHandler实现了InvocationHandler的invoke方法，当代理对象的方法被调用时，invoke方法会被回调。其中proxy表示实现了公共代理方法的动态代理对象。</p>
<p><strong>步骤2：创建被代理的类以及接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：调用Proxy的静态方法newProxyInstance，提供ClassLoader和代理接口类型数组动态创建一个代理类，并通过代理调用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端，使用代理类和主题接口完成功能</span><br><span class="line">public class Test &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * JDK动态代理测试类</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Car car &#x3D; new Car();</span><br><span class="line">		InvocationHandler h &#x3D; new TimeHandler(car);</span><br><span class="line">		Class&lt;?&gt; cls &#x3D; car.getClass();</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * loader  类加载器</span><br><span class="line">		 * interfaces  实现接口</span><br><span class="line">		 * h InvocationHandler</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Moveable m &#x3D; (Moveable)Proxy.newProxyInstance(cls.getClassLoader(),</span><br><span class="line">												cls.getInterfaces(), h);&#x2F;&#x2F;获得动态代理对象，动态代理对象与代理对象实现同一接口</span><br><span class="line">		m.move();&#x2F;&#x2F;调用动态代理的move方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过InvocationHandler handler=new TimeHandler(target);将委托对象作为构造方法的参数传递给了TimeHandler来作为代理方法调用的对象。当我们调用代理对象的move()方法时，该调用将会被转发到TimeHandler对象的invoke上从而达到动态代理的效果。</p>
<p>所谓动态代理是这样一种class：它是运行时生成的class，该class需要实现一组interface，使用动态代理类时，必须实现InvocationHandler接口</p>
<h3 id="静态代理与动态代理对比"><a href="#静态代理与动态代理对比" class="headerlink" title="静态代理与动态代理对比"></a>静态代理与动态代理对比</h3><h4 id="静态代理-1"><a href="#静态代理-1" class="headerlink" title="静态代理"></a>静态代理</h4><ul>
<li>优点：<br>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。</li>
<li>缺点：<ul>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
<li>采用静态代理模式，那么真实角色（委托类）必须事先已经存在的，并将其作为代理对象代理对象内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀。</li>
</ul>
</li>
</ul>
<h4 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h4><ul>
<li>优点<ul>
<li>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</li>
<li>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</li>
</ul>
</li>
<li>缺点<ul>
<li>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/" itemprop="url">merge与rebase区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T22:46:17+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git/merge%E4%B8%8Erebase%E5%8C%BA%E5%88%AB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看merge，官方文档给的说明是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-merge - Join two or more development histories together</span><br></pre></td></tr></table></figure>

<p>顾名思义，当你想要两个分支交汇的时候应该使用merge。</p>
<p>根据官方文档给的例子，是master merge topic，如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C topic</span><br><span class="line">         &#x2F;         \</span><br><span class="line">    D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>然而在实践中，在H这个commit上的merge经常会出现merge conflict。为了避免解决冲突的时候引入一些不必要的问题，工程中一般都会规定no conflict merge。比如你在github上发pull request，如果有conflict就会禁止merge。</p>
<p>这种情况下用merge当然是一个选项。用merge代表了topic分支与master分支交汇，并解决了所有合并冲突。<strong>然而merge的缺点是引入了一次不必要的history join。</strong>如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A--B--C-X topic</span><br><span class="line">       &#x2F;       &#x2F; \</span><br><span class="line">  D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>其实仔细想一下就会发现，<strong>在</strong>引入master分支的F、G commit这个问题上，<strong>我们并没有要求两个分支必须进行交汇(join)，我们只是想避免最终的merge conflict而已。</strong></p>
<p>rebase是另一个选项。rebase的含义是改变当前分支branch out的位置。这个时候进行rebase其实意味着，将topic分支branch out的位置从E改为G，如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       A---B---C topic</span><br><span class="line">             &#x2F;         </span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>在这个过程中会解决引入F、G导致的冲突，同时没有多余的history join。但是rebase的缺点是，<strong>改变了当前分支branch out的节点。</strong>如果这个信息对你很重要的话，那么rebase应该不是你想要的。rebase过程中也会有多次解决同一个地方的冲突的问题，不过可以用squash之类的选项解决。个人并不认为这个是rebase的主要问题。</p>
<p>综上，其实选用merge还是rebase取决于你到底是以什么意图来避免merge conflict。实践上个人还是偏爱rebase。一个是因为branch out节点不能改变的情况实在太少。另外就是频繁从master merge导致的冗余的history join会提高所有人的认知成本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/" itemprop="url">CodeReview代码审查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T21:43:53+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">项目管理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/CodeReview%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h1><h2 id="什么是Code-Review"><a href="#什么是Code-Review" class="headerlink" title="什么是Code Review?"></a>什么是Code Review?</h2><p>Code Review, 意即代码审查,是指一种有意识和系统的召集其他程序员来检查彼此的代码是否有错误的地方.</p>
<p>通常进行Code Review会有以下效果:</p>
<ul>
<li>提高代码质量和可维护性, 可读性等.</li>
<li>查漏补缺, 发现一些潜在的问题点等.</li>
<li>最佳实践, 能够更好更快的完成任务的方法.</li>
<li>知识分享, Review他人代码时, 其实也是一个学习的过程, 自己也会反思&amp;总结.</li>
</ul>
<h2 id="为什么要-Code-Review"><a href="#为什么要-Code-Review" class="headerlink" title="为什么要 Code Review?"></a>为什么要 Code Review?</h2><p>要不要Code Review, 需要结合当前的环境和形势来决定. 如果项目组开发任务极其紧张, 此时再进行Code Review可能会收到不利的效果. 因势利导,求同存异是Code Review的核心所在。</p>
<p>Code Review尤其需要和项目组成员沟通和配合, 同时也在检验各成员的技术水平.</p>
<blockquote>
<p>尤其需要注意的是, 人都有惰性, 每个人都有自己的一套行为准则和规范, 要想把他们的行为或规范统一起来, 很容易使他们产生抗拒心理.</p>
</blockquote>
<p>在Code Review之前, 和项目成员沟通好, 有一个共同的愿景, 并辅助以相应的培训, 把部分人员的短板补齐. 会减轻项目成员的一些不适感, 也会使得项目运行更加顺畅。</p>
<h2 id="Code-Review的前提条件"><a href="#Code-Review的前提条件" class="headerlink" title="Code Review的前提条件"></a>Code Review的前提条件</h2><p>Code Review本身属于”事后”工作, 可以起到查漏被缺的作用.</p>
<p>在推行Code Review时, 需要先提前准备以下几个工作, 以便团队能够更快更好的接受和实施.</p>
<ul>
<li>建立规范, 包含:<ul>
<li>编码规范, 如变量命名, 文件命名规范等</li>
<li>设计原则, 如单一职责原则, 最少知识原则等</li>
<li>分支管理策略</li>
</ul>
</li>
<li>完善的文档, 方便查阅. 文档内容最好能共建, 千万不可出现”一言堂”</li>
<li>制定Code Review流程&amp;目标, 以及实施周期.</li>
</ul>
<p>根据困难程度, Code Review实施分为3个阶段：</p>
<ul>
<li>第一阶段, 重点关注, 恰到好处的函数注释, “硬编码”问题, 常见变量命名规则等, 预期实施周期为1~3个月</li>
<li>第二阶段, 重点关注, 代码耦合性, 单一职责、最少知识原则, 潜在隐患, 性能问题等, 预期实施周期为3~6个月</li>
<li>第三阶段, 重点关注, 模块实现方案, 设计模式, 最佳实践, 代码重构等.</li>
</ul>
<p>在实施过程中, 如果遇到比较大的阻力或困难, 推行Code Review所得到的收益较低时, 可以考虑适当”休息”一段时间.</p>
<h2 id="Code-Review如何实施"><a href="#Code-Review如何实施" class="headerlink" title="Code Review如何实施?"></a>Code Review如何实施?</h2><p>从当前项目的实施过程的体会, 以及结合其他人的一些经验来看, 在Code Review时建议:</p>
<ul>
<li>单次查看代码不多于500行, 人的精力有限, 一次审查太多的代码, 收益可能不理想.</li>
<li>单次审查建议不要超过30分钟</li>
</ul>
<h2 id="常见的Code-Review项"><a href="#常见的Code-Review项" class="headerlink" title="常见的Code Review项"></a>常见的Code Review项</h2><h3 id="git使用规范"><a href="#git使用规范" class="headerlink" title="git使用规范"></a>git使用规范</h3><p>git commit提交规范, 如:</p>
<ul>
<li>不标注信息</li>
<li>不及时commit</li>
<li>提交时标注的信息不规范等</li>
</ul>
<p>都是严重阻扰review的因素之一,除了常规的描述信息外,还可以按类型等备注:</p>
<ul>
<li>feat: 新特性</li>
<li>fix: 修改问题</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>chore: 其他修改</li>
<li>test: 测试用例修改</li>
<li>style: 代码格式修改等等</li>
</ul>
<p>当然, 也要以利用一些工具, 来协助我们完成基本的约束和检查. 如: <a href="https://juejin.im/post/5de280cfe51d450f0a2006f1" target="_blank" rel="noopener">优雅的使用Git</a></p>
<h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><h4 id="1-可读性"><a href="#1-可读性" class="headerlink" title="1. 可读性"></a>1. 可读性</h4><p>衡量可读性, 有很好的实践标准, 即Code Review时能否非常容易的理解代码逻辑, 如果不能, 那意味着代码的可读性要进行改进.</p>
<h4 id="2-命名"><a href="#2-命名" class="headerlink" title="2. 命名"></a>2. 命名</h4><ul>
<li>命名对可读性非常重要, 我个人倾向于函数名/类名长一点都没关系, 但必须能清晰的表明函数/类的作用.</li>
<li>英语用词尽量准确, 哪怕需要借助翻译工具, 也是值得的. 但有一点需要注意, 如果使用的单词很冷门, 都没人认识, 那就不要使用.</li>
</ul>
<h4 id="3-函数体长度-类长度"><a href="#3-函数体长度-类长度" class="headerlink" title="3. 函数体长度/类长度"></a>3. 函数体长度/类长度</h4><ul>
<li>函数体太长, 不好阅读, 一般建议不要超过50行</li>
<li>类太长, 如超过10000行, 那可能就要看下是否违反了”单一职责”原则.</li>
</ul>
<h4 id="4-参数个数"><a href="#4-参数个数" class="headerlink" title="4. 参数个数"></a>4. 参数个数</h4><p>不要太多, 一般不要超过5个, 超过5个, 建议使用对象</p>
<h4 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h4><p>恰到好处的注释, 能够帮助我们理解函数/类的作用。</p>
<h3 id="架构-设计"><a href="#架构-设计" class="headerlink" title="架构/设计"></a>架构/设计</h3><h4 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h4><p>这是经常被违背的原则, 也是最难运用好的原则.</p>
<ul>
<li>一个类只做一类相关的事情</li>
<li>一个函数/方法, 最好只做一件事情</li>
</ul>
<h4 id="2-行为是否统一"><a href="#2-行为是否统一" class="headerlink" title="2. 行为是否统一"></a>2. 行为是否统一</h4><p>什么是行为统一? 例如:</p>
<ul>
<li>错误处理是否统一</li>
<li>错误提示是否统一</li>
<li>弹出框是否统一</li>
<li>…</li>
</ul>
<p>同一逻辑/行为, 有没有执行同样的代码路径:</p>
<ul>
<li><strong>低质量</strong>的代码一个特征是, 同一逻辑/行为, 在不同的地方或不同的方式触发时, 没有执行同样的代码路径(产生出不同的结果), 或者是各处copy一份实现, 导致非常难以维护。</li>
</ul>
<h4 id="3-代码污染"><a href="#3-代码污染" class="headerlink" title="3. 代码污染"></a>3. 代码污染</h4><p>代码有没有对其他模块强耦合</p>
<h4 id="4-重复代码"><a href="#4-重复代码" class="headerlink" title="4. 重复代码"></a>4. 重复代码</h4><p>主要看有没有把公用组件, 可复用的代码、函数抽取出来</p>
<h4 id="5-开放-封闭原则"><a href="#5-开放-封闭原则" class="headerlink" title="5. 开放-封闭原则"></a>5. 开放-封闭原则</h4><p>简单理解是, 看代码好不好扩展</p>
<h4 id="6-健壮性"><a href="#6-健壮性" class="headerlink" title="6. 健壮性"></a>6. 健壮性</h4><ul>
<li>核心数据有没有强制校验?</li>
<li>对业务有没有考虑完整, 逻辑是否健壮</li>
<li>有没有潜在的bug?</li>
<li>有没有内存泄露?有没有循环依赖?</li>
</ul>
<h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h4><p>有没有很好的Error Handling? 如网络出错, IO出错等。</p>
<h4 id="8-面向接口编程-面向对象接口编程"><a href="#8-面向接口编程-面向对象接口编程" class="headerlink" title="8. 面向接口编程/面向对象接口编程"></a>8. 面向接口编程/面向对象接口编程</h4><p>主要看有没有进行合适的抽象, 把一些行为抽象为接口</p>
<h4 id="9-效率-性能"><a href="#9-效率-性能" class="headerlink" title="9. 效率/性能"></a>9. 效率/性能</h4><ul>
<li><p>客户端程序对频繁的消息和较大数据等耗时操作是否处理得当</p>
</li>
<li><p>关键算法的时间复杂度是多少? 有没有潜在的性能瓶颈? </p>
</li>
</ul>
<h4 id="10-代码重构"><a href="#10-代码重构" class="headerlink" title="10. 代码重构"></a>10. 代码重构</h4><ul>
<li>新的改动是打补丁, 让代码质量继续恶化, 还是对代码质量提升有帮助?</li>
</ul>
<h3 id="低质量代码的常见特征"><a href="#低质量代码的常见特征" class="headerlink" title="低质量代码的常见特征"></a>低质量代码的常见特征</h3><ul>
<li>违反”单一职责”原则</li>
<li>同一逻辑/行为, 通过不同的方式触发时, 不会执行同样的代码路径</li>
<li>缺少注释</li>
<li>函数/类命名乱, 词不达意, 或”挂羊头卖狗肉”, 例如</li>
</ul>
<h3 id="下面推荐一些-Code-Review-工具："><a href="#下面推荐一些-Code-Review-工具：" class="headerlink" title="下面推荐一些 Code Review 工具："></a>下面推荐一些 Code Review 工具：</h3><ul>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.atlassian.com/software/crucible">Crucible</a>：</strong>Atlassian 内部代码审查工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.gerritcodereview.com/">Gerrit</a>：</strong>Google 开源的 git 代码审查工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/">GitHub</a>：</strong>程序员应该很熟悉了，上面的 “Pull Request” 在代码审查这里很好用；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//lgtm.com/">LGTM</a>：</strong>可用于 GitHub 和 Bitbucket 的 PR 代码安全漏洞和代码质量审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.phacility.com/phabricator/">Phabricator</a>：</strong>Facebook 开源的 git/mercurial/svn 代码审查工具； </li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.pullrequest.com/">PullRequest</a>：</strong>GitHub pull requests 代码审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//pullreminders.com/">Pull Reminders</a>：</strong>GitHub 上有 PR 需要你审核，该插件自动通过 Slack 提醒你；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//reviewable.io/">Reviewable</a>：</strong>基于 GitHub pull requests 的代码审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//sider.review/">Sider</a>：</strong>GitHub 自动代码审查辅助工具；</li>
<li><strong><a href="https://link.zhihu.com/?target=https%3A//www.jetbrains.com/upsource/">Upsource</a>：</strong>JetBrain 内部部署的 git/mercurial/perforce/svn 代码审查工具。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/" itemprop="url">git项目管理规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T17:13:54+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git项目管理规范"><a href="#git项目管理规范" class="headerlink" title="git项目管理规范"></a>git项目管理规范</h1><p>试想遇到以下这些问题，你会采取怎样的方式去解决：</p>
<ul>
<li>需要线上某个历史版本的源码，直接在 develop 分支根据提交记录和时间找对应的节点？</li>
<li>线上版本出现严重 bug 需要紧急修复发版本，而你的项目就一个分支，上个版本发布之后已经有大量改动了，怎么办？</li>
<li>某个提交改动了部分代码，涉及到 10 几个文件，现在这个改动不需要了，此时要一个个找出这些文件然后再改回去么？</li>
<li>出现了一个 bug，之前好像处理过，但是现在忘了当初怎么处理的了，在一堆写着 “fix bug”、“update” 的提交记录中，如何找到当初那笔的提交？</li>
<li>某个功能本来准备发布的，现在突然决定这个版本不上了，现在要一处处找到之前的代码，然后再改回去？</li>
<li>……</li>
</ul>
<p>既然认同需要一份 Git 规范，那么这个规范需要规范哪些内容，解决哪些问题，又带来哪些好处呢？有以下几点：</p>
<p> <strong>分支管理：</strong></p>
<ul>
<li>代码提交在应该提交的分支</li>
<li>随时可以切换到线上稳定版本代码</li>
<li>多个版本的开发工作同时进行</li>
</ul>
<p><strong>提交记录的可读性</strong></p>
<ul>
<li>准确的提交描述，具备可检索性</li>
<li>合理的提交范围，避免一个功能就一笔提交</li>
<li>分支间的合并保有提交历史，且合并后结果清晰明了</li>
<li>避免出现过多的分叉</li>
</ul>
<p><strong>团队协作</strong></p>
<ul>
<li><p>明确每个分支的功用，做到对应的分支执行对应的操作</p>
</li>
<li><p>合理的提交，每次提交有明确的改动范围和规范的提交信息</p>
</li>
<li><p>使用 Git 管理版本迭代、紧急线上 bug fix、功能开发等任务</p>
<p>以上就是一份 Git 规范的作用和使命。</p>
</li>
</ul>
<p>Git-Flow 的经典流程图：</p>
<p><img src="https://jaeger.itscoder.com/img/postimg/git-flow.png" alt="img"></p>
<p><img src="https://ourai.ws/assets/posts/20160418/working-with-gitflow-efa631445317065fd85a17b314e91907ec6ef5e380460dd77a68aa60f91d95c4.png" alt="基于 Git Flow 的开发流程"></p>
<h2 id="分支管理规范"><a href="#分支管理规范" class="headerlink" title="分支管理规范"></a>分支管理规范</h2><h3 id="分支操作和说明"><a href="#分支操作和说明" class="headerlink" title="分支操作和说明"></a>分支操作和说明</h3><p><strong>master 分支</strong></p>
<ul>
<li>主分支，永远处于稳定状态，对应当前线上版本</li>
<li>以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本</li>
<li>不允许在该分支直接提交代码</li>
</ul>
<p><strong>develop 分支</strong></p>
<ul>
<li>开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行</li>
<li>小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行</li>
</ul>
<p><strong>注：</strong> 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险</p>
<p><strong>feature 分支</strong></p>
<ul>
<li>功能分支，开发新功能的分支</li>
<li>开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 <code>feature/xxx</code></li>
<li>开发完成后合并回 develop 分支并且删除该 feature/xxx 分支</li>
</ul>
<p><strong>release 分支</strong></p>
<ul>
<li>发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支</li>
<li>当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为<code>release/xxx</code></li>
<li>发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支</li>
</ul>
<p><strong>hotfix 分支</strong></p>
<ul>
<li>紧急修复线上 bug 分支</li>
<li>当线上版本出现 bug 时，从 master 分支切出一个 <code>hotfix/xxx</code> 分支，完成 bug 修复，然后将 <code>hotfix/xxx</code> 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 <code>hotfix/xxx</code> 分支</li>
</ul>
<p>以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下：</p>
<p><strong>小结</strong></p>
<ul>
<li>master 分支: 线上稳定版本分支</li>
<li>develop 分支: 开发分支，衍生出 feature 分支和 release 分支</li>
<li>release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除</li>
<li>feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除</li>
<li>hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除</li>
</ul>
<h3 id="分支间操作注意事项"><a href="#分支间操作注意事项" class="headerlink" title="分支间操作注意事项"></a>分支间操作注意事项</h3><h4 id="同一分支-git-pull-使用-rebase"><a href="#同一分支-git-pull-使用-rebase" class="headerlink" title="同一分支 git pull 使用 rebase"></a>同一分支 <code>git pull</code> 使用 <code>rebase</code></h4><p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_no_rebase.jpg" alt="img"></p>
<p>看到这样的  提交线图，想从中看出一条清晰的提交线几乎是不可能的，充满了 <code>Merge remote-tracking branch &#39;origin/xxx&#39; into xxx</code> 这样的提交记录，同时也将提交线弄成了交错纵横的图，没有了可读性。</p>
<p>这里最大的原因就是因为默认的 <code>git pull</code> 使用的是 merge 行为，当你更新代码时，如果本地存在未推送到远程的提交，就会产生一个这样的 merge 提交记录。因此在同一个分支上更新代码时推荐使用 <code>git pull --rebase</code>。</p>
<p>下面这张图展示了默认的 <code>git pull</code> 和 <code>git pull --rebase</code> 的结果差异，使用 <code>git pull --rebase</code> 目的是修整提交线图，使其形成一条直线。</p>
<p><img src="https://jaeger.itscoder.com/img/postimg/git_pull_rebase_diff.jpg" alt="img"></p>
<p>使用<code>git pull</code>会产生<code>H</code>这个没必要的提交记录。</p>
<p>如果是执行 <code>git pull --rebase</code>的话，<code>C</code>和<code>D</code>这两个提交通过 <code>rebase</code> 方式重新拼接在 <code>G</code> 之后，多余的分叉去掉了，更加简洁清晰。</p>
<p>默认的 <code>git pull</code> 行为是 merge，可以进行如下设置修改默认的 <code>git pull</code> 行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 为某个分支单独设置，这里是设置 dev 分支</span><br><span class="line">git config branch.dev.rebase true</span><br><span class="line"># 全局设置，所有的分支 git pull 均使用 --rebase</span><br><span class="line">git config --global pull.rebase true</span><br><span class="line">git config --global branch.autoSetupRebase always</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要说明一下，在我看来使用 <code>git pull --rebase</code> 操作是比较好的，能够得到一条很清晰的提交直线图，方便查看提交记录和 code review，但是由于 rebase 会改变提交历史，也存在一些不好的影响。这里就不做过多的讨论了，有兴趣的话可以移步知乎上的讨论：<a href="https://www.zhihu.com/question/36509119" target="_blank" rel="noopener">在开发过程中使用 git rebase 还是 git merge，优缺点分别是什么？</a></p>
</blockquote>
<p><strong>小结</strong></p>
<p>大多数时候，使用 <code>git pull --rebase</code>是为了使提交线图更好看，从而方便 code review。</p>
<p>不过，如果你对使用 git 还不是十分熟练的话，我的建议是 <code>git pull --rebase</code>多练习几次之后再使用，因为 <strong>rebase 在 git 中，算得上是『危险行为』</strong>。</p>
<p>另外，还需注意的是，使用 <code>git pull --rebase</code>比直接 pull 容易导致冲突的产生，如果预期冲突比较多的话，建议还是直接 pull。</p>
<h4 id="分支合并使用-merge-no-ff"><a href="#分支合并使用-merge-no-ff" class="headerlink" title="分支合并使用 merge --no-ff"></a>分支合并使用 <code>merge --no-ff</code></h4><p>上述的 <code>git pull --rebase</code> 策略目的是修整提交线图，使其形成一条直线，而 <code>git merge --no-ff</code> 策略偏偏是反行其道，刻意地弄出提交线图分叉出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 例如当前在 develop 分支，需要合并 feature&#x2F;xxx 分支</span><br><span class="line">git merge --no-ff feature&#x2F;xxx</span><br></pre></td></tr></table></figure>

<p>在解释这个命令之前，先解释下 Git 中的 fast-forward： 举例来说，开发一直在 <code>develop</code> 分支进行，此时有个新功能需要开发，新建一个 <code>feature/a</code> 分支，并在其上进行一系列开发和提交。当完成功能开发时，此时回到 <code>develop</code> 分支，此时 <code>develop</code> 分支在创建 <code>feature/a</code> 分支之后没有产生任何的 commit，那么此时的合并就叫做 fast-forward。</p>
<p>fast-forward 合并的结果如下图所示，这种 merge 的结果就是一条直线了，无法明确看到切出一个新的 feature 分支，并完成了一个新的功能开发，因此此时比较推荐使用 <code>git merge --no-ff</code>，得到的结果就很明确知道，新的一系列提交是完成了一个新的功能，如果需要对这个功能进行 code review，那么只需要检视叉的那条线上的提交即可。</p>
<p><img src="https://jaeger.itscoder.com/img/postimg/git_merge_diff.svg" alt="img"></p>
<h3 id="项目分支操作流程示例"><a href="#项目分支操作流程示例" class="headerlink" title="项目分支操作流程示例"></a>项目分支操作流程示例</h3><p>这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。</p>
<p><strong>1. 切到 develop 分支，更新 develop 最新代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>

<p><strong>2. 新建 feature 分支，开发新功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;xxx</span><br><span class="line">...</span><br><span class="line">git add &lt;files&gt;</span><br><span class="line">git commit -m &quot;feat(xxx): commit a&quot;</span><br><span class="line">git commit -m &quot;feat(xxx): commit b&quot;</span><br><span class="line"># 其他提交</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 切换到 develop 分支并更新 develop 分支代码</span><br><span class="line">git checkout develop</span><br><span class="line">git pull --rebase</span><br><span class="line"></span><br><span class="line"># 切回 feature 分支</span><br><span class="line">git checkout feature&#x2F;xxx</span><br><span class="line">git rebase develop</span><br><span class="line"></span><br><span class="line"># 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！)</span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>

<p>上述场景也可以通过 <code>git cherry-pick</code> 来实现，有兴趣的可以去了解一下这个指令。</p>
<p><strong>3. 完成 feature 分支，合并到 develop 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 切到 develop 分支，更新下代码</span><br><span class="line">git check develop</span><br><span class="line">git pull --rebase</span><br><span class="line"></span><br><span class="line"># 合并 feature 分支</span><br><span class="line">git merge feature&#x2F;xxx --no-ff</span><br><span class="line"></span><br><span class="line"># 删除 feature 分支</span><br><span class="line">git branch -d feature&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 推到远端</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure>

<p><strong>4. 当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当前在 develop 分支</span><br><span class="line">git checkout -b release&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 在 release&#x2F;xxx 分支进行 bug fix</span><br><span class="line">git commit -m &quot;fix(xxx): xxxxx&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>5. 所有 bug 修复完成，准备发布新版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># master 分支合并 release 分支并添加 tag</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release&#x2F;xxx --no-ff</span><br><span class="line"># 添加版本标记，这里可以使用版本发布日期或者具体的版本号</span><br><span class="line">git tag 1.0.0</span><br><span class="line"></span><br><span class="line"># develop 分支合并 release 分支</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 删除 release 分支</span><br><span class="line">git branch -d release&#x2F;xxx</span><br></pre></td></tr></table></figure>

<p>至此，一个新版本发布完成。</p>
<p><strong>6. 线上出现 bug，需要紧急发布修复版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 当前在 master 分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"># 切出 hotfix 分支</span><br><span class="line">git checkout -b hotfix&#x2F;xxx</span><br><span class="line"></span><br><span class="line">... 进行 bug fix 提交</span><br><span class="line"></span><br><span class="line"># master 分支合并 hotfix 分支并添加 tag(紧急版本)</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff hotfix&#x2F;xxx --no-ff</span><br><span class="line"># 添加版本标记，这里可以使用版本发布日期或者具体的版本号</span><br><span class="line">git tag 1.0.1</span><br><span class="line"></span><br><span class="line"># develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支)</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff hotfix&#x2F;xxx</span><br><span class="line"></span><br><span class="line"># 删除 hotfix 分支</span><br><span class="line">git branch -d hotfix&#x2F;xxx</span><br></pre></td></tr></table></figure>

<p>至此，紧急版本发布完成。</p>
<h2 id="提交信息规范"><a href="#提交信息规范" class="headerlink" title="提交信息规范"></a>提交信息规范</h2><h3 id="分支说明和操作"><a href="#分支说明和操作" class="headerlink" title="分支说明和操作"></a>分支说明和操作</h3><p>git commit 格式 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<p>各个部分的说明如下：</p>
<ul>
<li><strong>Type的类别说明：</strong><ul>
<li><strong>feat</strong>: 新功能</li>
<li><strong>fix</strong>: 修复 bug</li>
<li><strong>docs</strong>: 文档变动</li>
<li><strong>style</strong>: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等</li>
<li><strong>refactor</strong>: bug 修复和添加新功能之外的代码改动</li>
<li><strong>perf</strong>: 提升性能的改动</li>
<li><strong>test</strong>: 添加或修正测试代码</li>
<li><strong>chore</strong>: 构建过程或辅助工具和库（如文档生成）的更改</li>
</ul>
</li>
<li><strong>scope 修改范围：</strong><ul>
<li>主要是这次修改涉及到的部分，简单概括，例如 login、train-order</li>
</ul>
</li>
<li><strong>subject 修改的描述：</strong><ul>
<li>具体的修改描述信息</li>
</ul>
</li>
</ul>
<p><strong>范例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feat(detail): 详情页修改样式</span><br><span class="line">fix(login): 登录页面错误处理</span><br><span class="line">test(list): 列表页添加测试代码</span><br></pre></td></tr></table></figure>

<p>这里对提交规范加几点说明：</p>
<ul>
<li><code>type + scope</code> 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。</li>
<li><code>subject</code> 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。</li>
<li>避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 <code>git commit --amend</code> 指令追加改动，尽量避免重复的提交信息。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/" itemprop="url">git命令集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T14:32:33+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/09/git/git%E5%91%BD%E4%BB%A4%E9%9B%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除</span></span><br><span class="line">git rm -r *  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line">#使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点，为了保证版本演进的清晰。</span><br><span class="line">git merge --no-ff</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"># 一次转移多个提交</span><br><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br><span class="line">#如果想要转移一系列的连续提交，可以使用下面的简便语法。不包括A</span><br><span class="line">$ git cherry-pick A..B </span><br><span class="line">#注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</span><br><span class="line">git cherry-pick A^..B </span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 查看所有暂存</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件 global是全局配置</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line"></span><br><span class="line"># 为某个分支单独设置，这里是设置 dev 分支</span><br><span class="line">git config branch.dev.rebase true</span><br><span class="line"># 全局设置，所有的分支 git pull 均使用 --rebase</span><br><span class="line">git config --global pull.rebase true</span><br><span class="line">git config --global branch.autoSetupRebase always</span><br><span class="line"></span><br><span class="line"># 删除全局代理</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="提交数统计"><a href="#提交数统计" class="headerlink" title="提交数统计"></a>提交数统计</h3><p>统计提交(commit)次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="统计每个人增删行数"><a href="#统计每个人增删行数" class="headerlink" title="统计每个人增删行数"></a>统计每个人增删行数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format&#x3D;&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author&#x3D;&quot;$name&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fengxing	added lines: 56705, removed lines: 21012, total lines: 35693</span><br><span class="line">jiaozhegang	added lines: 10477, removed lines: 10156, total lines: 321</span><br><span class="line">unknown	added lines: 10469, removed lines: 14, total lines: 10455</span><br><span class="line">wangkai	added lines: 5, removed lines: 4, total lines: 1</span><br><span class="line">zhangyun	added lines: 33495, removed lines: 8966, total lines: 24529</span><br><span class="line">zrj	added lines: 7841, removed lines: 15648, total lines: -7807</span><br><span class="line">冯海超	added lines: 2, removed lines: 1, total lines: 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">71012679	added lines: 2, removed lines: 2, total lines: 0</span><br><span class="line">chouyanhejiutangtou	added lines: 8979, removed lines: 1925, total lines: 7054</span><br><span class="line">fengxing	added lines: 26709, removed lines: 7520, total lines: 19189</span><br><span class="line">unknown	added lines: , removed lines: , total lines:</span><br><span class="line">wangkai	added lines: 17284, removed lines: 8779, total lines: 8505</span><br><span class="line">zhangyun	added lines: 22444, removed lines: 6506, total lines: 15938</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git log 参数说明：<br>–author 指定作者<br>–stat 显示每次更新的文件修改统计信息，会列出具体文件列表<br>–shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：<br>–numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：<br>-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新<br>例如：git log -p -2<br>–name-only 仅在提交信息后显示已修改的文件清单<br>–name-status 显示新增、修改、删除的文件清单<br>–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符<br>–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）<br>–graph 显示 ASCII 图形表示的分支合并历史<br>–pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）<br>例如： git log –pretty=oneline ; git log –pretty=short ; git log –pretty=full ; git log –pretty=fuller<br>–pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析<br>例如：git log –pretty=format:””%h - %an, %ar : %s””<br>下面列出了常用的格式占位符写法及其代表的意义。<br>选项 说明<br>%H 提交对象（commit）的完整哈希字串<br>%h 提交对象的简短哈希字串<br>%T 树对象（tree）的完整哈希字串<br>%t 树对象的简短哈希字串<br>%P 父对象（parent）的完整哈希字串<br>%p 父对象的简短哈希字串<br>%an 作者（author）的名字<br>%ae 作者的电子邮件地址<br>%ad 作者修订日期（可以用 -date= 选项定制格式）<br>%ar 作者修订日期，按多久以前的方式显示<br>%cn 提交者(committer)的名字<br>%ce 提交者的电子邮件地址<br>%cd 提交日期<br>%cr 提交日期，按多久以前的方式显示<br>%s 提交说明<br>–since 限制显示输出的范围，<br>例如： git log –since=2.weeks 显示最近两周的提交<br>选项 说明<br>-(n) 仅显示最近的 n 条提交<br>–since, –after 仅显示指定时间之后的提交。<br>–until, –before 仅显示指定时间之前的提交。<br>–author 仅显示指定作者相关的提交。<br>–committer 仅显示指定提交者相关的提交。</p>
</blockquote>
<h3 id="查看git上的个人代码量："><a href="#查看git上的个人代码量：" class="headerlink" title="查看git上的个人代码量："></a>查看git上的个人代码量：</h3><p>使用的使用把<code>fengxing</code>换成自己的用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;&quot;fengxing&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -</span><br></pre></td></tr></table></figure>

<h3 id="代码总行数"><a href="#代码总行数" class="headerlink" title="代码总行数"></a>代码总行数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . &quot;(&quot; -name &quot;*.java&quot; &quot;)&quot; -print | xargs wc -l</span><br></pre></td></tr></table></figure>

<h3 id="贡献者统计"><a href="#贡献者统计" class="headerlink" title="贡献者统计"></a>贡献者统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort -u | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="查看仓库提交者排名前-5"><a href="#查看仓库提交者排名前-5" class="headerlink" title="查看仓库提交者排名前 5"></a>查看仓库提交者排名前 5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure>

<h3 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -sn</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/Java/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/Java/%E7%BA%A2%E9%BB%91%E6%A0%91/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-08T22:14:09+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/08/Java/%E7%BA%A2%E9%BB%91%E6%A0%91/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/08/Java/%E7%BA%A2%E9%BB%91%E6%A0%91/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是特殊的二叉查找树，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/" itemprop="url">递归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-08T14:47:12+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/08/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/08/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>【版权申明】未经博主同意，不允许转载！（请尊重原创，博主保留追究权）<br><a href="http://blog.csdn.net/javazejian/article/details/53452971" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/53452971</a><br>出自<a href="http://blog.csdn.net/javazejian" target="_blank" rel="noopener">【zejian的博客】</a></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="# 递归"></a># 递归</h2><h2 id="汉诺塔的问题"><a href="#汉诺塔的问题" class="headerlink" title="汉诺塔的问题"></a>汉诺塔的问题</h2><p>游戏的规则如下，有三根细柱（A、B、C），A柱上套着6个圆盘，圆盘的大小都不一样，它们按照从大到小的顺序自下而上地摆放，现在我们需要把A柱上的圆盘全部移动到B柱上去，并且在移动时有如下约定：</p>
<ul>
<li><p>一次只能移动柱子最上端的一个圆盘。</p>
</li>
<li><p>小圆盘上不能放大圆盘</p>
</li>
<li><p>一次只能移动柱子最上端的一个圆盘。</p>
</li>
<li><p>小圆盘上不能放大圆盘</p>
</li>
</ul>
<p>此时约定将一个圆盘从一根柱子移动另一根柱子算移动“1”次，那么将6个圆盘全部从A移动到B至少需要移动多少次呢？模型如下图：</p>
<p><img src="https://img-blog.csdn.net/20161210103510175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  图虽然很清晰，但我们依然无法立即找到特别清晰的解法，既然如此，我们就尝试先把问题的规模缩小点，把6个圆盘改为3个圆盘，先找出3层汉诺塔的解法，模型变为下图:</p>
<p><img src="https://img-blog.csdn.net/20161210154208276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  3层汉诺塔的解法就相对来说简单多了，我们要把3个圆盘全部从A移动到B，只需要先将最小的圆盘从A移动到B，然后将次小的圆盘从A移动到C，接着再把最小的圆盘从B移动到C，然后把最大的圆盘从A移动到B，接着把最小盘从C移动到A，在把次小盘从C移动到B，最后把最小盘从A移动到B即可，这样我们就完成了3此汉诺塔的解法了。这里我们把3个圆盘从小到大分别设为a,b,c，那么其移动过程如下：</p>
<p><img src="https://img-blog.csdn.net/20161210164705998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="汉诺塔"></p>
<p>  从上图中，我们很容易理解3层汉诺塔的解法，但是细想一下会发现这7次动中我们好像在做重复的事情：移动圆盘，只不过方向时而不同罢了。重新回顾一下①②③④⑤⑥⑦的移动过程，然后把它们分为如下3种情况：</p>
<ul>
<li>在①②③中，移动了3次将2个圆盘从A柱移动到了C柱</li>
<li>在④中，将最大的圆盘从A柱移动到了B柱</li>
<li>在⑤⑥⑦中，移动了3次将2个圆盘从C柱移动到了B柱</li>
</ul>
<p>我们发现这个过程移动的操作是几乎一样的，只不过是移动的方向不同了，A-&gt;C和C-&gt;B两种，其过程如下图：</p>
<p><img src="https://img-blog.csdn.net/20161211122622873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="3层汉诺塔解法"></p>
<p>  从图确实可以看出虽然两次移动的目的地不相同，但是两次移动的操作却是非常相似的，而且我们发现如果把3次移动看成是“移动2个圆盘”的操作就是“2层汉诺塔的解法”，也就是说在解决3层汉诺塔的过程中，我们使用了“2层汉诺塔的解法“。既然如此，那是不是意味着解决”4层汉诺塔“的过程中可以使用解决”3层汉诺塔的解法“呢？嗯，确实是如此的，这就是汉诺塔的解法规律，没错，我们已经发现这种规律！这样的话，我们解决前面的6层汉诺塔的问题时，只需要先解决5层汉诺塔的问题，然后利用5层汉诺塔的解法来解决6层汉诺塔的问题即可！我们来看看利用5层汉诺塔解出6层汉诺塔的过程，如下：</p>
<p><img src="https://img-blog.csdn.net/20161211160052027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  从图中我们可以看出（a）和（c）就是5层汉诺塔的解法，为了解出6层汉诺塔需要使用到5层汉诺塔的解法，因此只要5层汉诺塔被解出，6层汉诺塔也就迎刃而解了。而5层汉诺塔的解法呢？没错利用我们前面发现的规律，用4层汉诺塔的解法去解出5层汉诺塔，如下过程：</p>
<ul>
<li>①.先将4个圆盘从A柱移动到C柱，即解出4层汉诺塔</li>
<li>②.然后再将最大的圆盘(5个中最大的圆盘)从A柱移动到B柱</li>
<li>③.最后将4个圆盘从C柱移动到B柱，即再次利用解出的4层汉诺塔</li>
</ul>
<p>这样5层汉诺塔就被解出了，而4层汉诺塔则可以利用同样的解法即使用3层汉诺塔的解法，3层汉诺塔再利用2层汉诺塔的解法……..依次类推即可，到此便已解出6层汉诺塔，实际上我们知道有了6层汉诺塔的解法自然就可以很轻松地解出7层汉诺塔，8层汉诺塔…….N层汉诺塔，也很容易发现这种利用已知的N-1层的解法来解决N层的问题的解题方式，它们每一层的解法结构都是相同即利用前一个已解决的问题结果来解决后一个问题。通过这种思考的方式，我们来总结一下N层汉诺塔的解法，不再使用具体的ABC三根柱子，而是将它们设为x、y、z。这样的话，x、y、z在不同的情况下会不固定对应ABC中的某一根。这里以x为起点柱，y为目标柱，z为中转柱，然后给出解出N层汉诺塔的过程。利用z柱将n个圆盘从x柱转移到y柱的解法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Blog :http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian[原文地址]</span><br><span class="line">&#x2F;**</span><br><span class="line">当 n&#x3D;0时，无需任何移动</span><br><span class="line">当 n&gt;0时，</span><br><span class="line">    ①将n-1个圆盘从x柱，经y柱中转，移动到z柱(即解出n-1层汉诺塔)</span><br><span class="line">    ②然后将1个圆盘从x柱移动到y柱(最大的圆盘)</span><br><span class="line">    ③最后将n-1个圆盘从z柱，经x中转移动到y柱(即解出n-1层汉诺塔) </span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure>

<p>  从上述过程可知为了解出n层汉诺塔，我们同样需要先解出n-1层汉诺塔，为更通用地表示解出n层汉诺塔的移动次数，将其设为H(n)。利用上述步骤，则有如下关系：</p>
<p><img src="https://img-blog.csdn.net/20161212091951958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  在数学上我们将这种H(n)和H(n-1)的关系式取了个名称，叫做递推公式，即已知H(0),由H(n-1)构成H(n)的方法也必然是已知的，只要依次计算便可以得出，如6层汉诺塔的递推过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Blog :http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian[原文地址]</span><br><span class="line">&#x2F;**</span><br><span class="line">    H(0)&#x3D;0                     &#x3D; 1-1</span><br><span class="line">    H(1)&#x3D;H(0)+1+H(0) &#x3D; 1       &#x3D; 2-1</span><br><span class="line">    H(2)&#x3D;H(1)+1+H(1) &#x3D; 3       &#x3D; 4-1</span><br><span class="line">    H(3)&#x3D;H(2)+1+H(2) &#x3D; 7       &#x3D; 8-1</span><br><span class="line">    H(4)&#x3D;H(3)+1+H(3) &#x3D; 15      &#x3D; 16-1</span><br><span class="line">    H(5)&#x3D;H(4)+1+H(4) &#x3D; 31      &#x3D; 32-1</span><br><span class="line">    H(6)&#x3D;H(5)+1+H(5) &#x3D; 63      &#x3D; 64-1</span><br><span class="line">    .......                    &#x3D; .........</span><br><span class="line">    H(n)&#x3D;H(n-1)+1+H(n-1)       &#x3D; 2^n -1</span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure>

<p>  这样我们也就知道了6层次汉诺塔的最少移动次数为63次（关于2^n-1的公式只是总结出更为简单的计算方式罢了）。到此我们来重新梳理一下汉诺塔的整个解题过程，在解出6层汉诺塔前，我们由于一时找不到解决的方法，因此先尝试解出更为简单3层汉诺塔的，而在这个过程中，我们慢慢发现了解决汉诺塔问题的通用规律，即使用n-1层的解法来解决n层汉诺塔的思考方式,通过这种思考方式最终成功地解决了6层汉诺塔的问题。而实际上我们利用的这种思考方式的本质就是<strong>将复杂的问题转换为较为简单的同类问题(回忆一下汉诺塔的问题解法)然后再找出解决方法最终利用简单同类问题解出复杂问题的过程，而这种思维的方式就是递归</strong>！！是的，没错！递归不是算法而是一种思考的思维方式，只不过我们将这种递归思维方式采用程序来解决时，该程序被称为递归算法罢了，而递归本身是一种思考问题的思维方式！到此我们对递归是否有些焕然大悟的感觉呢？或对递归有些许的理解了吧？</p>
<h1 id="递归的思维方式"><a href="#递归的思维方式" class="headerlink" title="递归的思维方式"></a>递归的思维方式</h1><p>  有了上述的分析，我们就可以这样去理解和使用递归，假设现在碰到了一个很复杂的难题，我们也明白‘简单问题易解’的道理，那么此时就可以利用类似于汉诺塔的解题的思考方式，即<strong>判断能否将目前复杂的问题转换为较为简单的同类问题呢？</strong>可以的话，就先转换为简单同类的问题来解决，然后再利用简单的同类问题解法来解决复杂的同类问题，这就恰恰就是递归思维方式的精髓所在，嗯，这就是递归！大家现在是不是已开始理解递归了呢？我们在回顾一下汉诺塔问题的解法，以便加深对递归的理解，如下图：</p>
<p><img src="https://img-blog.csdn.net/20161211190832510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  上图很清晰表现出n层汉诺塔的解法过程，通过复杂问题化为同类简单问题来求解，<strong>上述的图形还有一个名称叫做递归结构</strong>，根据该结构我们就可以建立起之前H(n)递推公式了，很显然发现递归结构并建立递推公式的过程十分重要，这样有助于我们把握本质问题即通过n-1层汉诺塔的解法来解决n层汉诺塔的问题，这样的发现能力需要我们有比较敏锐的洞察力和思维能力，这就需要我们再遇到复杂问题时，多采用递归的思维（复杂问题简单化）方式去思考，去挖掘规律。ok~，到此相信我们对递归已有比较清晰的了解了吧。接下来我们看看如何使用程序来实现递归算法并解决汉诺塔的问题。</p>
<h2 id="汉诺塔的递归算法程序实现"><a href="#汉诺塔的递归算法程序实现" class="headerlink" title="汉诺塔的递归算法程序实现"></a>汉诺塔的递归算法程序实现</h2><p>  通过前面的分析，我们明白所谓的递归不过就是把复杂问题简单化的思维方式，而这种思维方式从程序语言的角度出发则称为递归算法，它通过程序的函数方法直接或者间接调用函数自身的过程，回忆一下前面分析汉诺塔的递推公式：H(n)=H(n-1)+1+H(n+1)</p>
<p>我们通过程序的递归算法实现汉诺塔如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.zejian.structures.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Created by zejian on 2016&#x2F;12&#x2F;11.</span><br><span class="line">* Blog : http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian [原文地址,请尊重原创]</span><br><span class="line">* 汉诺塔的递归算法实现</span><br><span class="line">*&#x2F;</span><br><span class="line">public class HanoiRecursion &#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * @param n 汉诺塔的层数</span><br><span class="line">  * @param x x柱 起点柱(A)</span><br><span class="line">  * @param y y柱 目标柱(B)</span><br><span class="line">  * @param z z柱 中转柱(C)</span><br><span class="line">  * 其中 A B C 只是作为辅助思考</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public void hanoi(int n, char x ,char y ,char z)&#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;H(0)&#x3D;0</span><br><span class="line">     if (n&#x3D;&#x3D;0)&#123;</span><br><span class="line">         &#x2F;&#x2F;什么也不做</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         &#x2F;&#x2F;递推公式：H(n)&#x3D;H(n-1) + 1 + H(n-1)</span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从x移动到z,y为中转柱</span><br><span class="line">         hanoi(n-1,x,z,y); &#x2F;&#x2F;-----------------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;移动最大圆盘到目的柱</span><br><span class="line">         System.out.println(x+&quot;-&gt;&quot;+y);&#x2F;&#x2F;------------&gt; 1</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从z移动到y,x为中转柱</span><br><span class="line">         hanoi(n-1,z,y,x);&#x2F;&#x2F;------------------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * @param n 汉诺塔的层数</span><br><span class="line">  * @param x x柱 起点柱(A)</span><br><span class="line">  * @param y y柱 目标柱(B)</span><br><span class="line">  * @param z z柱 中转柱(C)</span><br><span class="line">  * 其中 A B C 只是作为辅助思考</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public int hanoiCount(int n, char x ,char y ,char z)&#123;</span><br><span class="line">     int moveCount&#x3D;0;</span><br><span class="line">     &#x2F;&#x2F;H(0)&#x3D;0</span><br><span class="line">     if (n&#x3D;&#x3D;0)&#123;</span><br><span class="line">         &#x2F;&#x2F;什么也不做</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         &#x2F;&#x2F;递推公式：H(n)&#x3D;H(n-1) + 1 + H(n-1)</span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从x移动到z,y为中转柱</span><br><span class="line">         moveCount +&#x3D; hanoiCount(n-1,x,z,y); &#x2F;&#x2F;-------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;移动最大圆盘到目的柱</span><br><span class="line">         moveCount +&#x3D; 1; &#x2F;&#x2F;---------------------------------&gt; 1</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;将n-1个圆盘从z移动到y,x为中转柱</span><br><span class="line">         moveCount +&#x3D;hanoiCount(n-1,z,y,x);&#x2F;&#x2F;---------------&gt;解出n-1层汉诺塔:H(n-1)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return moveCount;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;测试</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">     HanoiRecursion hanoi&#x3D;new HanoiRecursion();</span><br><span class="line">     System.out.println(&quot;moveCount&#x3D;&quot;+hanoi.hanoiCount(6,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;));</span><br><span class="line"></span><br><span class="line">     hanoi.hanoi(3,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以发现递归算法的踪影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*Blog : http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian [原文地址,请尊重原创]</span><br><span class="line">*&#x2F;</span><br><span class="line">public void hanoi(int n, char x ,char y ,char z)&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;H(0)&#x3D;0</span><br><span class="line">   if (n&#x3D;&#x3D;0)&#123;</span><br><span class="line">       &#x2F;&#x2F;什么也不做</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">       &#x2F;&#x2F;调用自身函数hanoi()</span><br><span class="line">       hanoi(n-1,x,z,y);</span><br><span class="line">       &#x2F;&#x2F;移动最大圆盘到目的柱</span><br><span class="line">       System.out.println(x+&quot;-&gt;&quot;+y);</span><br><span class="line">       &#x2F;&#x2F;调用自身函数hanoi()</span><br><span class="line">       hanoi(n-1,z,y,x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  因此到此我们也就明白了，<strong>递归思维在程序中的体现即为递归算法，而递归算法本身在程序内部的实现就是函数调用自身函数</strong>，这样大家总该理解递归算法了吧。这里有点要提醒大家的是，<strong>不要陷入程序递归的内部去思考递归算法，记住要从递归思维的本质(复杂问题简单化)出发去理解递归算法，千万不要去通过试图解析程序执行的每一个步骤来理解递归（解析程序的执行是指给函数一个真实值，然后自己一步步去推出结果，这样的思考方式是错误的！），那样只会让自己得到伪理解(没有真正理解)的结果</strong>。记住！<strong>递归并不是算法，是一种复杂问题简单化的思维方式，而这种思维方式在程序中的体现就递归算法</strong>！递归算法在实现上就是函数不断调用自身的过程！</p>
<h1 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h1><p>递归的定义(从数学的角度)：用一个概念的本身直接定义自己。如阶乘函数F(n)=n!可以定义为：</p>
<p><img src="https://img-blog.csdn.net/20161211210225754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p>关于阶乘这里简单说明一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">阶乘是什么？</span><br><span class="line">1 x 2 x 3 x 4 x 5 &#x3D; 5!</span><br><span class="line">这里的5!就称为5的阶乘，之所以称为阶乘是因为乘数呈阶梯状递减而得名，如下：</span><br><span class="line">5! &#x3D; 5 x 4 x 3 x 2 x 1 &#x3D; 120</span><br><span class="line">4! &#x3D; 4 x 3 x 2 x 1 &#x3D; 24</span><br><span class="line">3! &#x3D; 3 x 2 x 1 &#x3D; 6</span><br><span class="line">2! &#x3D; 2 x 1 &#x3D; 2</span><br><span class="line">1! &#x3D; 1 &#x3D; 1</span><br><span class="line">0! &#x3D; 1</span><br><span class="line">注意0的阶乘0！被定义为1，这是数学里的规定。</span><br><span class="line">n的阶乘如下：</span><br><span class="line">n!&#x3D; n x (n-1) x (n-2) x … x 2 x 1</span><br><span class="line">很显然n!是一种递推公式，也符合递归思维，因此有：</span><br><span class="line">当n&#x3D;0时，n! &#x3D; 1 ;</span><br><span class="line">当n&gt;&#x3D;1时，n x (n-1)!</span><br><span class="line">可以发现它使用了阶乘(n-1)!来定义阶乘n!，是不是跟汉诺塔很相似？没错，确实是递归思维的体现。</span><br><span class="line">ok~，关于阶乘我们就简单了解这些。</span><br></pre></td></tr></table></figure>

<p>  递归算法的定义(从程序的角度)：任何调用自身函数的过程都可以称为递归算法(前面实现的汉诺塔程序就是一个很好的例子)。这里需要注意的是递归必须满足以下两个条件：</p>
<ul>
<li><p>边界条件：至少有一条初始定义是非递归的，如汉诺塔的H(0)=0，阶乘的0!=1。</p>
</li>
<li><p>递归通式：由已知函数值逐步计算出未知函数值，如汉诺塔的H(0)=0，可以推算出H(1)=H(0)+1+H(0)。</p>
</li>
</ul>
<p><strong>边界条件和递推通式是递归定义的两个基本要素，缺一不可</strong>，并且递归通式必须在有限次数内运算完成达到边界条件以保证能够正常结束递归，得到运算结果。好~，以上便是递归的定义，还是那句话理解好递归思维(复杂问题简单化)才是重点！</p>
<h1 id="斐波那契数列中的递归思想"><a href="#斐波那契数列中的递归思想" class="headerlink" title="斐波那契数列中的递归思想"></a>斐波那契数列中的递归思想</h1><p>  如果上述的分析都明白了，那就说明你已掌握了递归，但为了加深对递归的理解，我们再来看一个思考题（来自程序员的数学思考题），题目是这样的，假如动物中有一种特殊的种类，它出生2天后就开始以每天1只的速度繁殖后代。假设第1天，有1只这样的动物（该动物刚出生，从第3天开始繁殖后代）。那么到第11天，共有多少只呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们先来按一般顺序思考，先不要考虑第11天，先从第1天开始，看能不能找出规律：</span><br><span class="line">【第1天】只有1只动物</span><br><span class="line">【第2天】只有1只动物，还没有繁殖后代，总量为1</span><br><span class="line">【第3天】第1天的1只动物，繁殖1个后代，总量为2</span><br><span class="line">【第4天】第1天的1只动物又繁殖1只，其他还没繁殖，总量为3</span><br><span class="line">【第5天】第1天和第3天出生的动物又繁殖1个后代，其他没有繁殖，总量为5</span><br><span class="line">【第n天】.....</span><br><span class="line"></span><br><span class="line"> 第1天 ------1</span><br><span class="line"> 第2天 ------1</span><br><span class="line"> 第3天 ------2 &#x3D; 1 + 1</span><br><span class="line"> 第4天 ------3 &#x3D; 1 + 2</span><br><span class="line"> 第5天 ------5 &#x3D; 2 + 3 </span><br><span class="line"> 第6天 ------8 &#x3D; 3 + 5</span><br><span class="line"> 第7天 ------13 &#x3D; 5 + 8</span><br></pre></td></tr></table></figure>

<p>   这个过程中貌似没发现什么规律，但我们发现从第3天开始动物的数量似乎前两天的总和，也就是第3天，是第1天的动物数量加上第2天的动物数量，而第4天则是第2天和第3天的动物数量的和。这样的话我们可以归纳一下，不去直接想”第n天有多少只动物“而是如下思考：</p>
<ul>
<li>第n-1天出生的动物，在第n天还存活着。</li>
<li>第n-2天以前出生的动物，在第n天繁殖了后代</li>
</ul>
<p>  因此可以总结出递推公式，假设在第n天时，第n-1天以前繁殖的动物都活着，并且第n-2天以前出生的动物会繁殖1个后代，设第n天的动物总数为F(n)，则有：F(n)=F(n-1)+F(n-2) 其中 n&gt;=3，如下图所示</p>
<p><img src="https://img-blog.csdn.net/20161211215025928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>注意为了让F(2)=F(1)+F(0)成立，定义F(0)=0,而F(1)则依然为1，因此有如下公式：</p>
<p><img src="/Users/fengxing/blogs/source/_posts/%E9%80%92%E5%BD%92/%E9%80%92%E5%BD%9210.png" alt="img"></p>
<p>我们来验证这个递推公式是否符合递归条件</p>
<ul>
<li>边界条件：至少有一条初始定义是非递归的，F(0)=0;F(1)=1。</li>
<li>递归通式：由已知函数值逐步计算出未知函数值，F(0)=0;F(1)=1,可以推算出F(2)=1,最终也可以推算F(n)的结束。</li>
</ul>
<p>显然两个条件都符合，说明该通用公式可以在有限的次数内运算完成并达到边界条件得出结果，因此我们可以利用递推公式求出第11天的动物的数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">F(0)&#x3D;0</span><br><span class="line">F(1)&#x3D;1</span><br><span class="line">F(2)&#x3D;F(0)+F(1)&#x3D;1</span><br><span class="line">F(3)&#x3D;F(2)+F(1)&#x3D;2</span><br><span class="line">F(4)&#x3D;F(3)+F(2)&#x3D;3</span><br><span class="line">F(5)&#x3D;F(4)+F(3)&#x3D;5</span><br><span class="line">F(6)&#x3D;F(5)+F(4)&#x3D;8</span><br><span class="line">F(7)&#x3D;F(6)+F(5)&#x3D;13</span><br><span class="line">F(8)&#x3D;F(7)+F(6)&#x3D;21</span><br><span class="line">F(9)&#x3D;F(8)+F(7)&#x3D;34</span><br><span class="line">F(10)&#x3D;F(9)+F(8)&#x3D;55</span><br><span class="line">F(11)&#x3D;F(10)+F(9)&#x3D;89</span><br><span class="line">也就是说第11天的动物总数为89只</span><br></pre></td></tr></table></figure>

<p>在这个问题中出现的数列就是著名的斐波那契数列，是由数学家斐波那契发现的，由此得名斐波那契数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ，1 ，1 ，2 ，3 ，5 ，8，13 ，21 ，34 ，55 ，89 ，…</span><br></pre></td></tr></table></figure>

<p>  到此我们也就知道斐波那契数列同样是用递归定义的，前面我们将求解第n天的动物数量分解为求第n-1天和第n-2天以前的动物繁殖后代数量，从把复杂的问题分解为较为简单的同类问题，而不去纠结第n天到此有多少只动物的问题，最终发现求解的规律，并通过递推公式求得第n天的结果，这个过程再次体现了递归的思维方式。既然斐波那契数列是递归思维的产物，那么也可以通过程序的递归算法来求解，接下来我们就看看如何使用程序中的递归算法来实现斐波那契数列。</p>
<h2 id="斐波那契数列的递归程序实现"><a href="#斐波那契数列的递归程序实现" class="headerlink" title="斐波那契数列的递归程序实现"></a>斐波那契数列的递归程序实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.zejian.structures.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by zejian on 2016&#x2F;12&#x2F;11.</span><br><span class="line"> * Blog : http:&#x2F;&#x2F;blog.csdn.net&#x2F;javazejian [原文地址,请尊重原创]</span><br><span class="line"> * 斐波那契数列的实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Fibonacci  &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 斐波那契数列的实现</span><br><span class="line">     * 0,1,1,2,3,5,8,13,21......</span><br><span class="line">     * @param day</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public long fibonacci(int day)&#123;</span><br><span class="line"></span><br><span class="line">        if(day&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;F(0)&#x3D;0</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (day&#x3D;&#x3D;1||day&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;F(1)&#x3D;1</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">           return fibonacci(day-1)+fibonacci(day-2); &#x2F;&#x2F;F(n)&#x3D;F(n-1)+F(n-2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 更为简洁的写法</span><br><span class="line">     * @param day</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public long fib(int day) &#123;</span><br><span class="line">        return day&#x3D;&#x3D; 0 ? 0 : (day&#x3D;&#x3D; 1 || day&#x3D;&#x3D;2 ? 1 : fib(day - 1) + fib(day - 2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Fibonacci fibonacci&#x3D;new Fibonacci();</span><br><span class="line">        System.out.println(&quot;第11天动物数量为:&quot;+ fibonacci.fib(11));</span><br><span class="line">        System.out.println(&quot;第11天动物数量为:&quot;+ fibonacci.fibonacci(11));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归算法的效率问题"><a href="#递归算法的效率问题" class="headerlink" title="递归算法的效率问题"></a>递归算法的效率问题</h1><p>  到此我们已对递归分析完了，相信大家对递归已很熟悉了，通过递归的思维方式，在解决某些问题的时候确实使得我们思考的方式得以简化，同时代码也更加精炼，容易阅读。那么既然如此，那是不是什么问题都要用递归来解决呢？难道递归就没有缺点吗？下面我们就来讨论一下递归的不足之处也就是它的效率问题。我们这里以斐波那契数列的实现为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 更为简洁的写法</span><br><span class="line"> * @param day</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public long fib(int day) &#123;</span><br><span class="line">       return day&#x3D;&#x3D; 0 ? 0 : (day&#x3D;&#x3D; 1 || day&#x3D;&#x3D;2 ? 1 : fib(day - 1) + fib(day - 2));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  这段代码相当精简直观清晰,但是！如果用这段代码计算fib(500)时，我们就泪奔了，它的运行时间也许会让人抓狂呐。我们以fib(5)为例，计算过程如下：</p>
<p><img src="https://img-blog.csdn.net/20161211234844810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  从上图可以看出，在计算Fib(5)的过程中，Fib(1)计算了两次、Fib(2)计算了3次，Fib(3)计算了两次，原本只需要5次计算就可以完成的任务却计算了9次。更重要的是这个问题随着规模的增加会愈发明显，以至于Fib(500)的计算时间已相当恐怖。造成这种困境的原因是，当调用fib(n-1)时，还要调用fib(n-2)，也就是说fib(n-2)调用了两次，同样的道理，调用f(n-2)时f(n-3)也调用了两次，而这些多余的调用是完全没有必要的，还可预见的是这种计算方式随着数量的增加，计算量将呈指数级增长，这是一个相当严重的问题。那么如何改良这个计算过程呢？我们重新回顾一下斐波那契数列：</p>
<p><code>0 ，1 ，1 ，2 ，3 ，5 ，8，13 ，21 ，34 ，55 ，89 ，…</code></p>
<p>  为了减少函数重复调用提高效率，我们使用迭代的方式来实现斐波那契数列代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BigInteger可以防止数据异常</span><br><span class="line">&#x2F;&#x2F;BigInteger 任意大的整数，原则上是，只要你的计算机的内存足够大，可以有无限位的</span><br><span class="line">&#x2F;&#x2F; 递推实现方式（迭代的方式效率高，时间复杂度O(n)）</span><br><span class="line">public  BigInteger fibonacciN(int n)&#123;</span><br><span class="line">   if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">       return new BigInteger(&quot;0&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;f(0)&#x3D;0;</span><br><span class="line">   BigInteger n1 &#x3D; new BigInteger(&quot;0&quot;)；</span><br><span class="line">   &#x2F;&#x2F;f(1)&#x3D;1;</span><br><span class="line">   BigInteger n2 &#x3D; new BigInteger(&quot;1&quot;)；</span><br><span class="line">   &#x2F;&#x2F;记录最终值f(n)</span><br><span class="line">   BigInteger sn &#x3D; new BigInteger(&quot;0&quot;);</span><br><span class="line">   for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">       sn &#x3D; n1.add(n2);&#x2F;&#x2F;相加</span><br><span class="line">       n1 &#x3D; n2;</span><br><span class="line">       n2 &#x3D; sn;</span><br><span class="line">   &#125;</span><br><span class="line">   return sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 与上述相同的递推实现方式 ，使用long返回值，当n过大会造成数据溢出，计算结果可能是一个未知的负数，因此建议使用BigInteger</span><br><span class="line">public static long fibonacciNormal(int n)&#123;</span><br><span class="line">      if(n &lt;&#x3D; 2)&#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      long n1 &#x3D; 1, n2 &#x3D; 1, sn &#x3D; 0;</span><br><span class="line">      for(int i &#x3D; 0; i &lt; n - 2; i ++)&#123;</span><br><span class="line">          sn &#x3D; n1 + n2;</span><br><span class="line">          n1 &#x3D; n2;</span><br><span class="line">          n2 &#x3D; sn;</span><br><span class="line">      &#125;</span><br><span class="line">      return sn;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  这样我们就把问题的规模降低到O(n)级别了，运行时间也很快，那为什么使用迭代就快，而使用递归就会变得慢呢？我们都知道，递归调用实际上是函数自己在调用自己，而函数的调用开销是很大的（包括空间和时间），而系统要为每次函数调用分配存储空间，提供给函数进行运行。而在函数调用结束后，则需要释放空间，即所谓的弹栈复点。因此函数调用消耗的空间和时间并不是非常乐观的。但难度就不用递归了么？并非如此，当我们在遇到同一个问题时，如果递归解决的（时间和空间）复杂度不明显优于其它解决方案时，此时就不应该使用递归，否则可以使用递归。其实博主想说的是递归虽然有缺点，但在很多复杂的问题上我们使用递归的形式来解释或者求解时问题确实很容易被解释的更清楚，而使用迭代是无法实现的或者难以理解的（如汉诺塔问题，树的遍历等等），此时递归巨大的优势就显示出来了。同时我们更应该记住在相同的问题面前，如果使用递归的效果与迭代的效果相差不了多少，我们更应该倾向于使用迭代，毕竟运行效率上迭代还是相当有优势的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/Java/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/Java/%E6%A0%91/" itemprop="url">树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-07T17:13:36+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/07/Java/%E6%A0%91/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/07/Java/%E6%A0%91/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>在看TreeMap底层结构之前，必要先要了解下<strong>树</strong>！树是一种数据结构</p>
<p><strong>数组的特点是查询迅速</strong>，根据index可以快速定位到一个元素，如果要插入一个元素，就需要将这个元素位置之后的所有元素后移。序数组的插入的时间复杂度为O(N)，删除操作的时间复杂度也为O(N)。</p>
<p><strong>链表的插入和删除效率都很高</strong>，只要改变一些值的引用就行了，时间复杂度为O(1)。<strong>但是链表的查询效率很低，每次都要从头开始找，依次访问链表的每个数据项。</strong>时间复杂度为O(N)。</p>
<h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul>
<li><strong><img src="https://upload-images.jianshu.io/upload_images/4118241-538ccdaf6d9807ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树术语.png">路径</strong>：从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径。</li>
<li><strong>根</strong>：树顶端的节点被称为根。从根出发到达任意一个节点只有一条路径。</li>
<li><strong>父节点</strong>：除了根节点之外，每个节点都可以向上找到一个唯一的节点，这个节点就是当前节点的父节点。相应的，父节点下方的就是子节点。</li>
<li><strong>叶子节点</strong>：没有子节点的“光杆司令”就被称为叶子节点。</li>
<li><strong>子树</strong>：每个子节点作为根节点的树都是一个子树。</li>
<li><strong>层</strong>：一个树结构的代数就是这个树的层。</li>
<li><strong>度</strong>：一棵树中，最大的节点的度称为树的度。</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点。</li>
</ul>
<h2 id="树的两种实现"><a href="#树的两种实现" class="headerlink" title="树的两种实现"></a>树的两种实现</h2><p>树是一个递归的概念，从根节点开始，每个节点至多只有一个父节点，有多个子节点，每个子节点又是一棵树，以此递归。</p>
<ul>
<li>数组</li>
<li>链表</li>
</ul>
<h3 id="数组实现树"><a href="#数组实现树" class="headerlink" title="数组实现树"></a>数组实现树</h3><p>利用每个节点至多只有一个父节点这个特点，使用 <strong>父节点表示法</strong> 来实现一个节点</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-fe9e3345a43ee5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组实现树.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private Object mData;   &#x2F;&#x2F;存储的数据</span><br><span class="line">    private int mParent;   &#x2F;&#x2F;父亲节点的下标</span><br><span class="line"></span><br><span class="line">    public TreeNode(Object data, int parent) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return mData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getParent() &#123;</span><br><span class="line">        return mParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParent(int parent) &#123;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>角标</strong>来指明父亲节点的位置，使用这个节点组成的数组就可以表示一棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    TreeNode[] arrayTree &#x3D; new TreeNode[10];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表表示的节点"><a href="#链表表示的节点" class="headerlink" title="链表表示的节点"></a>链表表示的节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedTreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private Object mData;   &#x2F;&#x2F;存储的数据</span><br><span class="line">    private LinkedTreeNode mParent;   &#x2F;&#x2F;父亲节点的下标</span><br><span class="line">    private LinkedTreeNode mChild;  &#x2F;&#x2F;孩子节点的引用</span><br><span class="line"></span><br><span class="line">    public LinkedTreeNode(Object data, LinkedTreeNode parent) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return mData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        mData &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getParent() &#123;</span><br><span class="line">        return mParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParent(LinkedTreeNode parent) &#123;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedTreeNode getChild() &#123;</span><br><span class="line">        return mChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChild(LinkedTreeNode child) &#123;</span><br><span class="line">        mChild &#x3D; child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用引用，而不是索引表示父亲与孩子节点。</p>
<p>使用一个 List, 元素是 LinkedTreeNode，就可以表示一棵链表树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    LinkedList&lt;LinkedTreeNode&gt; linkedTree &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只需知道 根节点就可以遍历整个树。知道某个节点也可以获取它的父亲和孩子。</p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>所谓树的遍历（Traversal），就是按照某种次序访问树中的节点，且每个节点恰好访问一次。</p>
<p>也就是说，按照被访问的次序，可以得到由树中所有节点排成的一个序列。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>对任一（子）树的前序遍历，将首先访问其根节点，然后再递归地对其下的各棵子树进行前序遍历。对于同一根节点下的各棵子树，遍历的次序通常是任意的；但若换成有序树，则可以按照兄弟间相应的次序对它们实施遍历。由前序遍历生成的节点序列，称作前序遍历序列。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-6fe19cea12167d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前序遍历.png"></p>
<h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><p>对称地，对任一（子）树的后序遍历将首先递归地对根节点下的各棵子树进行后序遍历，最后才访问根节点。由后序遍历生成的节点序列，称作后序遍历序列。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8c313650b8137069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后续遍历.png"></p>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>除了上述两种最常见的遍历算法，还有其它一些遍历算法，层次遍历（Traversal by level ）算法就是其中的一种。在这种遍历中，各节点被访问的次序取决于它们各自的深度，其策略可以总结为“深度小的节点优先访问”。对于同一深度的节点，访问的次序可以是随机的，通常取决于它们的存储次序，即首先访问由firstChild指定的长子，然后根据nextSibling确定后续节点的次序。当然，若是有序树，则同深度节点的访问次序将与有序树确定的次序一致。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-c5ddb4d82ccf5f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="层次遍历.png"></p>
<h2 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树（Binary Tree）是有限个节点的集合，这个集合可以是空集，也可以是一个根节点和两颗不相交的子二叉树组成的集合，其中一颗树叫根的左子树，另一颗树叫右子树。所以二叉树是一个递归地概念。二叉树作为一种重要的数据结构，它结合了数组和链表的优点，有很多重要的应用。</p>
<h4 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h4><p>每个节点最多只有两个子节点。其实，二叉树的每个左右子节点仍是一颗二叉树，因此，我们可以使用递归的方式来定义二叉树，二叉树的实现代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private int data;  &#x2F;&#x2F;数据</span><br><span class="line">    private BinaryTreeNode leftChild;  &#x2F;&#x2F;左孩子</span><br><span class="line">    private BinaryTreeNode rightChild; &#x2F;&#x2F;右孩子</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTreeNode getLeftChild() &#123;</span><br><span class="line">        return leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftChild(BinaryTreeNode leftChild) &#123;</span><br><span class="line">        this.leftChild &#x3D; leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTreeNode getRightChild() &#123;</span><br><span class="line">        return rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightChild(BinaryTreeNode rightChild) &#123;</span><br><span class="line">        this.rightChild &#x3D; rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        data &#x3D; -1;</span><br><span class="line">        name &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式称之为二叉树的左右链表表示法。</p>
<p><img src="https://segmentfault.com/img/bV91GF?w=1172&h=626" alt="图片描述"></p>
<h4 id="操作二叉树"><a href="#操作二叉树" class="headerlink" title="操作二叉树"></a>操作二叉树</h4><p><strong>创建二叉树</strong>，一般有两种情况：初始化一个根节点或者初始化一棵空二叉树。</p>
<p>对于<strong>二叉树的清空</strong>，首先提供一个清空某个节点为根节点的子树的方法，即递归的删除每个节点；接着提供删除一个删除树的方法：</p>
<p><strong>判断二叉树是否为空</strong>只需判断根节点是否存在即可。</p>
<p><strong>二叉树的高度</strong>：首先需要一种获取以某个节点为子树的高度方法，使用递归实现。如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；如果不为空，则遍历地比较它的左右子树高度，高的一个为这颗子树的最大高度，然后加上自身的高度即可</p>
<p><strong>求二叉树的节点数</strong>需要获取以某个节点为根的子树的节点数实现。<br>如果节点为空，则个数肯定为0；如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可。</p>
<p><strong>返回某节点的父亲节点</strong>：首先，同样需要通过一种方法来获取某个节点在某个子树中的父节点，这里使用递归实现，接着通过这种方法获取这个节点在二叉树中的父节点<br>事实上，以现有的这种二叉树的形式，我们并没有办法直接获取一个节点的父节点， 这里只能通过从根节点遍历来比较获取</p>
<p><strong>返回左右子树</strong>这个操作很简单，直接用节点的方法来获取即可</p>
<p><strong>二叉树的插入</strong>：分两种情况：插入某个节点的左子节点；插入某个节点的右子节点值得指出的是，当这个节点本身有子节点时，这样的插入也会覆盖原来在这个位置上的节点。另外，虽然插入的是子节点，但是子节点也可以代表一颗子树。因为单从这个节点来看并不知道这个节点是否有左右子树存在，所以虽然插入的是一个节点，但有可能插入可很多节点（插入的是一颗子树）</p>
<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>二叉树的遍历是按照一定的规律来顺序遍历各二叉树节点，使得每个节点都会被访问且仅访问一次。通常二叉树的遍历根据根节点的遍历次序分为：前序遍历、后序遍历、层次遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryTree &#123;</span><br><span class="line">    private BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化二叉树</span><br><span class="line">    public BinaryTree() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTree(BinaryTreeNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(BinaryTreeNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BinaryTreeNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据name找到指定节点</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BinaryTreeNode findTreeNode(String name) &#123;</span><br><span class="line">        LinkedList&lt;BinaryTreeNode&gt; nodes &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        while (!nodes.isEmpty()) &#123;</span><br><span class="line">            BinaryTreeNode node &#x3D; nodes.poll();</span><br><span class="line">            if (node.getName().equals(name)) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">            BinaryTreeNode leftChild &#x3D; node.getLeftChild();</span><br><span class="line">            BinaryTreeNode rightChild &#x3D; node.getRightChild();</span><br><span class="line">            if (leftChild !&#x3D; null) &#123;</span><br><span class="line">                nodes.push(leftChild);</span><br><span class="line">            &#125;</span><br><span class="line">            if (rightChild !&#x3D; null) &#123;</span><br><span class="line">                nodes.push(rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 二叉树的清空：</span><br><span class="line">     * 首先提供一个清空以某个节点为根节点的子树的方法，既递归地删除每个节点；</span><br><span class="line">     * 接着提供一个删除树的方法，直接通过第一种方法删除到根节点即可</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;清除某个子树的所有节点</span><br><span class="line">    public void clear(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            clear(node.getLeftChild());</span><br><span class="line">            clear(node.getRightChild());</span><br><span class="line">            node.clear();</span><br><span class="line">            node &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;清空树</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        clear(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断二叉树是否为空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return root &#x3D;&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取整棵树的高度</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 求二叉树的高度：</span><br><span class="line">     * 首先要一种获取以某个节点为子树的高度的方法，使用递归调用。</span><br><span class="line">     * 如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；</span><br><span class="line">     * 如果不为空，那么我们要遍历地比较它的左子树高度和右子树高度，</span><br><span class="line">     * 高的一个为这个子树的最大高度，然后加上自己本身的高度就是了</span><br><span class="line">     * 获取二叉树的高度，只需要调用第一种方法，即传入根节点</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int treeHeight() &#123;</span><br><span class="line">        return treeHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取某个节点的高度</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int treeHeight(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int l &#x3D; treeHeight(node.getLeftChild());</span><br><span class="line">        int r &#x3D; treeHeight(node.getRightChild());</span><br><span class="line">        return l &gt; r ? l + 1 : r + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取所有节点个数</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 求二叉树的节点数：</span><br><span class="line">     * 求节点数时，我们看看获取某个节点为子树的节点数的实现。</span><br><span class="line">     * 首先节点为空，则个数肯定为0；</span><br><span class="line">     * 如果不为空，那就算上这个节点之后继续递归所有左右子树的子节点数，</span><br><span class="line">     * 全部相加就是以所给节点为根的子树的节点数</span><br><span class="line">     * 如果求二叉树的节点数，则输入根节点即可</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 思路：获取二叉树节点数，需要获取以某个节点为根的子树的节点数实现。</span><br><span class="line">     * 如果节点为空，则个数肯定为0；如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int nodeSize() &#123;</span><br><span class="line">        return nodeSize(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取某个节点下的所有节点个数</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 计算本节点 所以要+1</span><br><span class="line">     * 递归获取左子树节点数和右子树节点数，最终相加</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int nodeSize(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;计算本节点 所以要+1</span><br><span class="line">        &#x2F;&#x2F;递归获取左子树节点数和右子树节点数，最终相加</span><br><span class="line">        return 1 + nodeSize(node.getLeftChild()) + nodeSize(node.getRightChild());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找node节点在二叉树中的父节点</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 思路：首先，同样需要通过一种方法来获取某个节点在某个子树中的父节点，这里使用递归实现，接着通过这种方法获取这个节点在二叉树中的父节点</span><br><span class="line">     * 事实上，以现有的这种二叉树的形式，我们并没有办法直接获取一个节点的父节点， 这里只能通过从根节点遍历来比较获取</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BinaryTreeNode getParent(BinaryTreeNode node) &#123;</span><br><span class="line">        return (root &#x3D;&#x3D; null || root &#x3D;&#x3D; node) ? null : getParent(root, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * node节点在subTree子树中的父节点</span><br><span class="line">     *</span><br><span class="line">     * @param subTree</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BinaryTreeNode getParent(BinaryTreeNode subTree, BinaryTreeNode node) &#123;</span><br><span class="line">        if (subTree &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;   &#x2F;&#x2F;如果是空子树，则没有父节点</span><br><span class="line">        &#125;</span><br><span class="line">        if (subTree.getLeftChild() &#x3D;&#x3D; node || subTree.getRightChild() &#x3D;&#x3D; node) &#123;</span><br><span class="line">            return subTree;   &#x2F;&#x2F;如果子树的根节点的左右孩子之一是待查节点，则返回子树的根节点</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeNode parent &#x3D; null;</span><br><span class="line">        if (getParent(subTree.getLeftChild(), node) !&#x3D; null) &#123;</span><br><span class="line">            parent &#x3D; getParent(subTree.getLeftChild(), node);</span><br><span class="line">            return parent;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;递归左右子树</span><br><span class="line">            return getParent(subTree.getRightChild(), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取某个节点的左子树</span><br><span class="line">    public BinaryTreeNode getLeftTree(BinaryTreeNode node) &#123;</span><br><span class="line">        return node.getLeftChild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取某个节点的右子树</span><br><span class="line">    public BinaryTreeNode getRightTree(BinaryTreeNode node) &#123;</span><br><span class="line">        return node.getRightChild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 给某个节点插入左节点</span><br><span class="line">     * 分两种情况：插入某个节点的左子节点；插入某个节点的右子节点</span><br><span class="line">     * 值得指出的是，当这个节点本身有子节点时，这样的插入也会覆盖原来在这个位置上的节点。</span><br><span class="line">     * 另外，虽然插入的是子节点，但是子节点也可以代表一颗子树。</span><br><span class="line">     * 因为单从这个节点来看并不知道这个节点是否有左右子树存在，所以虽然插入的是一个节点，但有可能</span><br><span class="line">     * 插入可很多节点（插入的是一颗子树）</span><br><span class="line">     *</span><br><span class="line">     * @param parent</span><br><span class="line">     * @param newNode</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insertLeft(BinaryTreeNode parent, BinaryTreeNode newNode) &#123;</span><br><span class="line">        parent.setLeftChild(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;给某个节点插入右节点</span><br><span class="line">    public void insertRight(BinaryTreeNode parent, BinaryTreeNode newNode) &#123;</span><br><span class="line">        parent.setRightChild(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(node.getData()); &#x2F;&#x2F;先访问根节点</span><br><span class="line">            preOrder(node.getLeftChild());  &#x2F;&#x2F;先根遍历左子树</span><br><span class="line">            preOrder(node.getRightChild());  &#x2F;&#x2F;先根遍历右子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前序遍历实现"><a href="#前序遍历实现" class="headerlink" title="前序遍历实现"></a>前序遍历实现</h5><p>若二叉树为空，则退出，否则进行下面操作</p>
<ul>
<li>访问根节点</li>
<li>先根遍历左子树</li>
<li>先根遍历右子树</li>
<li>退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(node.getData()); &#x2F;&#x2F;先访问根节点</span><br><span class="line">            preOrder(node.getLeftChild());  &#x2F;&#x2F;先根遍历左子树</span><br><span class="line">            preOrder(node.getRightChild());  &#x2F;&#x2F;先根遍历右子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>若二叉树为空，则退出，否则进行下面操作</p>
<ul>
<li>后根遍历左子树</li>
<li>后根遍历右子树</li>
<li>访问根节点</li>
<li>退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void postOrder(BinaryTreeNode node)&#123;</span><br><span class="line">        if(node!&#x3D;null)&#123;</span><br><span class="line">            postOrder(node.getLeftChild());  &#x2F;&#x2F;后根遍历左子树</span><br><span class="line">            postOrder(node.getRightChild());  &#x2F;&#x2F;后根遍历右子树</span><br><span class="line">            System.out.println(node);   &#x2F;&#x2F;访问根节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="三叉链表存储结构"><a href="#三叉链表存储结构" class="headerlink" title="三叉链表存储结构"></a>三叉链表存储结构</h4><p>采用二叉链表存储结构，每个结点只存储了到其孩子结点的单向关系，而没有存储到父结点的关系，这样的话，每次要获取父结点时将消耗较多的时间，因为需要从root根结点开始查找，花费的时间是遍历部分二叉树的时间，而且与该结点的位置有关。为了更高效的获取父结点，三叉链表存储结构孕育而生了。</p>
<p>  三叉链表主要是在二叉链表的基础上多添加了一个指向父结点的域，这样我们就存储了父结点与孩子结点的双向关系，当然这样也增加了一定的空开销其结点。</p>
<p><img src="https://img-blog.csdn.net/20161218233740719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一棵满二叉树就是高度为k，且拥有(2^k)-1个节点的二叉树，一棵满二叉树每个节点，要么都有两棵子树，要么都没有子树；而且每一层所有的节点之间必须要么都有两棵子树，要么都没子树。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-80fc53a6b51246f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="满二叉树.png"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><img src="https://upload-images.jianshu.io/upload_images/4118241-152e50f7aaa10279.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/" itemprop="url">程序员都是如何看电影的？欢迎讨论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-04T13:54:48+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家都用什么看电影啊！资源在哪里找的？现在我看电影的方式是在Google上寻找百度网盘的资源，然后用百度网盘在线观看。欢迎大家把自己的观影方式告诉我！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
