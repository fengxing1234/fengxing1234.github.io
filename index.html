<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/" itemprop="url">程序员都是如何看电影的？欢迎讨论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-04T13:54:48+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E7%94%B5%E5%BD%B1%E7%9A%84%EF%BC%9F%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家都用什么看电影啊！资源在哪里找的？现在我看电影的方式是在Google上寻找百度网盘的资源，然后用百度网盘在线观看。欢迎大家把自己的观影方式告诉我！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="url">Android面试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android基础面试题详解"><a href="#Android基础面试题详解" class="headerlink" title="Android基础面试题详解"></a>Android基础面试题详解</h1><p><img src="https://img-blog.csdnimg.cn/2020041121370949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70#pic_center" alt="Android面试知识框架"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="url">Java面试基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>​        面向对象简称OO（Object Oriented），一种基于面向过程的新思想，该思想就是站在对象的角度思考问题，把多个功能合理的放在不同的对象中，强调的是具备某些功能的对象。</p>
<p>​        具备某种功能的实体，称之为对象。面向对象最小的程序单位是<strong>类</strong>。面向对象更加符合常规的思维方式<strong>稳定性好，可重用性强，有良好的可重用性</strong>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>所谓对象就是真实世界的实体，对象与实体一一对应，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>java中面向对象的三大特性：封装、继承、多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>隐藏内部实现，提供公共方法进行访问</strong>。所谓封装就是把数据和操作数据的方法封装起来，对数据的访问和操作只能通过已定义的接口进行访问。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类拥有父类的特征和行为，并可以对父类进行扩展。形容类的关系。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一种类型的对象，执行相同方法，有不同的表现。</p>
<p><strong>多态的必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>向上转型</li>
</ul>
<p><strong>向上转型</strong></p>
<p>父类指向子类的引用</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><p>JVM由三个主要的子系统构成：</p>
<ul>
<li>类加载子系统：负责加载类或者接口</li>
<li>运行时数据去（内存结构）：包含方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器</li>
<li>执行引擎：负责执行包含在已装载的类或接口中的指令</li>
</ul>
<h3 id="类加载系统"><a href="#类加载系统" class="headerlink" title="类加载系统"></a>类加载系统</h3><p><a href="https://zhuanlan.zhihu.com/p/54693308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54693308</a></p>
<h4 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h4><p>答：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>类的生命周期包括加载、连接、初始化、使用和卸载。</p>
<ul>
<li><p>加载：查找并加载类的二进制数据，并在堆内存中创建对象。</p>
</li>
<li><p>连接：连接又分为三步：验证、准备、解析</p>
<ul>
<li>验证：验证文件格式、元数据、字节码、符号引用。</li>
<li>准备：为类的静态变量分配内存并初始化默认值。</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li><p>初始化：为类的静态变量赋予正确的初始值</p>
</li>
<li><p>使用：new出对象程序中使用</p>
</li>
<li><p>卸载：执行垃圾回收</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="https://img-blog.csdnimg.cn/20190603164758648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li>
<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li>
</ul>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。双亲委派模型能保证基础类仅加载一次，不会让jvm中存在重名的类。</p>
<h5 id="ExtClassLoader为什么没有设置parent？"><a href="#ExtClassLoader为什么没有设置parent？" class="headerlink" title="ExtClassLoader为什么没有设置parent？"></a>ExtClassLoader为什么没有设置parent？</h5><p>因为BootstrapClassLoader是由c++实现的，所以并不存在一个Java的类。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="https://img-blog.csdnimg.cn/20190603165013168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>方法区和堆是<strong>所有线程共享</strong>的内存区域；而java栈、本地方法栈和程序计数器是<strong>运行时线程私有</strong>的内存区域。</p>
<p>JVM把内存划分成了如下几个区域：</p>
<ul>
<li><p>堆区（Heap）：存放<strong>通过new创建的对象实例</strong>，容易OutOfMemoryEroor。</p>
</li>
<li><p>方法区（Method Area）：存放类的信息（字段和方法的字节码、构造函数、接口定义等）、静态变量，常量，运行时常量池。</p>
</li>
<li><p>虚拟机栈（VM Stack）：用于存储局部变量表、操作数栈、动态链接、方法出口等。只要线程已结束栈就出栈，生命周期与线程一致，其内存管理如下：</p>
<ul>
<li>方法中的基础数据类型直接在栈空间分配</li>
<li>方法中的引用数据类型，需要new来创建，既在栈中分配空间，也在堆中分配对象，栈中的地址指向堆内对象</li>
<li>方法的形式参数直接在栈空间分配，方法调用完毕在栈空间回收</li>
<li>方法中的引用参数，在栈中分配空间指向堆中对象，方法执行完毕回收栈空间。</li>
<li>字符串常量,static静态变量在方法区分配空间。</li>
</ul>
</li>
<li><p>本地方法栈（Native Method Stack）：可理解为java中jni调用。用于支持native方法执行</p>
</li>
<li><p>程序计数器（Program Counter Register）：每个方法在运行时都存储着一个独立的程序计数器，程序计数器是指定程序运行的行数指针。</p>
</li>
</ul>
<h3 id="Object-o-new-Object"><a href="#Object-o-new-Object" class="headerlink" title="Object o=new Object()"></a>Object o=new Object()</h3><p><img src="https://pic4.zhimg.com/80/v2-eddc430b991c58039dfc79dd6f3139cc_1440w.jpg" alt="img"></p>
<h3 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h3><p><img src="https://img-blog.csdnimg.cn/20190604161655494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>内存分为:</p>
<ul>
<li>新生代(<strong>1/3堆空间</strong>)<ul>
<li>Eden(伊甸园区)</li>
<li>Survivor From（幸存者区）</li>
<li>Survivor To（幸存者区）</li>
</ul>
</li>
<li>老年代(<strong>2/3堆空间</strong>)</li>
<li>持久代。(<strong>直接内存JDK1.8后</strong>)</li>
</ul>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代中98%的对象都是”朝生夕死”的，所以并不需要按照1 : 1的比例来划分内存空间，而是将内存(新生代内存)分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间（8:1:1），每次使用Eden和其中一块Survivor（两个Survivor区域一个称为From区，另一个称为To区域）。</p>
<p><strong>当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。(复制算法)</strong></p>
<p>HotSpot实现的复制算法流程如下:</p>
<ul>
<li><p>当Eden区满的时候,会触发第一次Minor gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。</p>
</li>
<li><p>当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。</p>
</li>
<li><p>部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p>
</li>
</ul>
<p>也有例外出现，对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生。</p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象。</p>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>不属于堆内存，属于内存空间。真正与堆隔离。方法区是类逻辑上的一个抽象模板，而元空间是<strong>方法区的实现</strong>，是真实存在的内存。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul>
<li><p>虚拟机在进行MinorGC（新生代的GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC。</p>
</li>
<li><p>刚分配对象在Eden中，如果空间不足尝试进行GC，回收空间，如果进行了MinorGC空间依旧不够就放入Old Generation，如果OldGeneration空间还不够就OOM了。</p>
</li>
<li><p>比较大的对象，数组等，大于某值（可配置）就直接分配到老年代，（避免频繁内存拷贝）</p>
</li>
<li><p>年轻代和年老代属于Heap空间的，Permanent Generation（永久代）可以理解成方法区，（它属于方法区）也有可能发生GC，例如类的实例对象全部被GC了，同时它的类加载器也被GC掉了，这个时候就会触发永久代中对象的GC。</p>
</li>
<li><p>如果OldGeneration满了就会产生FullGC。老年代满原因：</p>
<ul>
<li>1、from survive中对象的生命周期到一定阈值</li>
<li>2、分配的对象直接是大对象</li>
<li>3、由于To 空间不够，进行GC直接把对象拷贝到年老代（年老代GC时候采用不同的算法）</li>
</ul>
</li>
<li><p>如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的时候速度是远远低于Young Generation回收速度。</p>
</li>
</ul>
<h4 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h4><ul>
<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值对象进入老年区。</li>
<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<h1 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h1><ul>
<li>垃圾：无任何对象引用的对象。</li>
<li>回收：清理“垃圾”占用的内存空间而非对象本身。</li>
<li>发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。</li>
<li>发生时间：程序空闲时间不定时回收。</li>
</ul>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><h3 id="创建阶段-Created"><a href="#创建阶段-Created" class="headerlink" title="创建阶段(Created)"></a>创建阶段(Created)</h3><p>在创建阶段系统通过下面的几个步骤来完成对象的创建过程：</p>
<ul>
<li><p>为对象分配存储空间</p>
<ul>
<li>开始构造对象</li>
<li>从超类到子类对static成员进行初始化</li>
<li>超累成员变量按顺序初始化，递归调用超累的构造方法</li>
<li>子类成员变量按顺序初始化，子类构造方法调用</li>
</ul>
</li>
<li><p>应用阶段(In Use)：对象至少被一个强引用持有。</p>
</li>
<li><p>不可见阶段(Invisible)：简单说就是程序的执行已经超出了该对象的作用域了。</p>
</li>
<li><p>不可达阶段(Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。</p>
</li>
<li><p>收集阶段(Collected)：</p>
</li>
<li><p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)：当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ul>
<h2 id="判断对象是否是垃圾算法"><a href="#判断对象是否是垃圾算法" class="headerlink" title="判断对象是否是垃圾算法"></a>判断对象是否是垃圾算法</h2><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<h4 id="根搜索算法（可达性分析算法）"><a href="#根搜索算法（可达性分析算法）" class="headerlink" title="根搜索算法（可达性分析算法）"></a>根搜索算法（可达性分析算法）</h4><p><img src="https://upload-images.jianshu.io/upload_images/4118241-bdc59e28c5775caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从一个GC ROOT节点开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<p><strong>所谓的GC根对象包括：</strong></p>
<ul>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常亮引用的对象</li>
<li>本地方法栈中引用的对象（Native对象）</li>
</ul>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-整理算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h3><p>标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象（<strong>这一过程在可达性分析过程中进行</strong>），标记完成之后统一清除对象。</p>
<p><strong>它的主要缺点：</strong></p>
<ul>
<li>标记和清除过程效率不高 。</li>
<li>标记清除之后会产生大量不连续的内存碎片。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-ab33b8257a3ed8bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记整理，标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。</p>
<p>主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-e02d7d3ebf1d75af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="复制算法-新生代算法"><a href="#复制算法-新生代算法" class="headerlink" title="复制算法(新生代算法)"></a>复制算法(新生代算法)</h3><p>复制算法，它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-98d9dff8f994e8bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p>
<h3 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h3><p>串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序（单CPU、新生代空间较小及对暂停时间要求不是非常高的应用）。是client级别默认的GC方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20190605151624561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h3><p>并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，当执行垃圾回收的时候它也会冻结所有的应用程序线程。</p>
<h3 id="并发标记扫描垃圾回收器"><a href="#并发标记扫描垃圾回收器" class="headerlink" title="并发标记扫描垃圾回收器"></a>并发标记扫描垃圾回收器</h3><p>并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。<br>（1）当标记的引用对象在Tenured区域；<br>（2）在进行垃圾回收的时候，堆内存的数据被并发的改变。<br>相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。</p>
<h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>JVM调优，调的是什么？<br>每一次Full GC都会使JVM停止运行–&gt;使Full GC不执行，使Minor GC尽可能少地执行</p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user&#x3D;0.17 sys&#x3D;0.08, real&#x3D;0.07 secs]</span><br><span class="line"></span><br><span class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user&#x3D;1.75 sys&#x3D;0.02, real&#x3D;0.68 secs]</span><br></pre></td></tr></table></figure>

<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p><img src="https://img-blog.csdnimg.cn/20190603181024771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190603181041398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h3><ul>
<li><strong>不要显式调用System.gc()</strong>：此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</li>
<li><strong>尽量减少临时对象的使用</strong>：临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</li>
<li><strong>对象不用时最好显式置为Null</strong>：一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</li>
<li><strong>尽量使用StringBuffer,而不用String来累加字符串</strong>：由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</li>
<li><strong>能用基本类型如Int,Long,就不用Integer,Long对象</strong>：基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</li>
<li><strong>尽量少用静态对象变量</strong></li>
<li>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</li>
<li><strong>分散对象创建或删除的时间</strong>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</li>
</ul>
<h2 id="Java代码编译和执行整个过程"><a href="#Java代码编译和执行整个过程" class="headerlink" title="Java代码编译和执行整个过程"></a>Java代码编译和执行整个过程</h2><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被类加载器装入内存，一旦字节码进入虚拟机，它就会被解释器（执行引擎）解释执行。</p>
<p><strong>步骤1：Java代码编译是由Java源码编译器来完成，也就是Java代码到JVM字节码（.class文件）的过程。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190605130338211.png" alt="在这里插入图片描述"></p>
<p><strong>步骤2：Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190605130355535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java代码编译和执行的整个过程包含了三个重要机制：</p>
<ul>
<li>Java源码编译机制</li>
<li>类加载机制</li>
<li>类执行机制</li>
</ul>
<h2 id="Java虚拟机和Dalvik虚拟机区别"><a href="#Java虚拟机和Dalvik虚拟机区别" class="headerlink" title="Java虚拟机和Dalvik虚拟机区别"></a>Java虚拟机和Dalvik虚拟机区别</h2><ul>
<li>java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</li>
<li>Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。</li>
<li>java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.</li>
</ul>
<h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><p><strong>基本数据类型</strong></p>
<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>char</li>
<li>float</li>
<li>double</li>
<li>boolean</li>
</ul>
<p><strong>引用数据类型</strong></p>
<ul>
<li>对象</li>
<li>数组</li>
</ul>
<p><img src="https://img-blog.csdn.net/20140531091306906" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190526183106748.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>区别:</strong></p>
<ul>
<li>基本数据类型保存的是值，引用类型保存的是内存地址</li>
<li>基本数据类型存储在栈中，引用数据类型首先在栈上给引用分配内存空间，对象的具体信息存储在堆中。</li>
<li>基本数据类型的赋值其实是创建新的拷贝，而引用类型的赋值是传递引用。</li>
<li>基本数据类型的==其实是比较值，而引用数据类型比较的是地址（引用）。</li>
<li>一个方法不能修改一个基本类型的参数；一个方法可以修改引用类型参数中对象所指向的值。</li>
</ul>
<p><a href="https://blog.csdn.net/javazejian/article/details/51192130?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5" target="_blank" rel="noopener">数据类型分析</a></p>
<p><strong>int与Integer不同</strong></p>
<ul>
<li>Integer是int的包装类，int则是java的一种基本数据类型</li>
<li>Integer变量必须实例化后才能使用，而int变量不需要</li>
<li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li>
<li>Integer的默认值是null，int的默认值是0</li>
</ul>
<p><strong>延伸：关于Integer和int的比较</strong></p>
<ul>
<li><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; new Integer(100);</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">int j &#x3D; 100；</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; new Integer(100);</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;public static Integer valueOf(int i)&#123;</span><br><span class="line">  assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">  if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">      return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  &#125;</span><br><span class="line">  return new Integer(i);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
</ul>
<h1 id="Java自动装箱与拆箱"><a href="#Java自动装箱与拆箱" class="headerlink" title="Java自动装箱与拆箱"></a>Java自动装箱与拆箱</h1><h2 id="什么是自动装箱、拆箱"><a href="#什么是自动装箱、拆箱" class="headerlink" title="什么是自动装箱、拆箱"></a>什么是自动装箱、拆箱</h2><p>装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h2 id="自动装箱的原理及使用场景"><a href="#自动装箱的原理及使用场景" class="headerlink" title="自动装箱的原理及使用场景"></a>自动装箱的原理及使用场景</h2><p>基本数据类型–&gt;封装类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10;</span><br></pre></td></tr></table></figure>

<p>执行时实际上系统执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; Integer.valueOf(10);</span><br></pre></td></tr></table></figure>

<p>分析Integer的valueOf源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if(i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; IntegerCache.high)　　&#x2F;&#x2F; 没有设置的话，IngegerCache.high 默认是127</span><br><span class="line">        return IntegerCache.cache[i + 128];</span><br><span class="line">    else</span><br><span class="line">        return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于–128到127（默认是127）之间的值，Integer.valueOf(int i) 返回的是缓存的Integer对象（并不是新建对象），而其他值，执行Integer.valueOf(int i) 返回的是一个新建的 Integer对象。装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响性能。</p>
<h2 id="自动拆箱的原理及使用场景"><a href="#自动拆箱的原理及使用场景" class="headerlink" title="自动拆箱的原理及使用场景"></a>自动拆箱的原理及使用场景</h2><p>封装类–&gt;基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10; &#x2F;&#x2F;装箱 </span><br><span class="line">int t &#x3D; i; &#x2F;&#x2F;拆箱，实际上执行了 int t &#x3D; i.intValue();</span><br></pre></td></tr></table></figure>

<p>进行运算时也可以进行拆箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i &#x3D; 10; </span><br><span class="line">System.out.println(i++);</span><br></pre></td></tr></table></figure>

<p>Integer与int运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 10;</span><br><span class="line">Integer integer1 &#x3D; new Integer(10); </span><br><span class="line">System.out.println(i&#x3D;&#x3D;integer1);&#x2F;&#x2F;true,integer1自动拆箱</span><br></pre></td></tr></table></figure>

<p>intValue函数很简单，直接返回value值即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int intValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h1><ul>
<li>final类说明是一个不可变对象</li>
<li>内部使用value[]数组实现</li>
<li>声明int类型hash</li>
</ul>
<p><strong>==与equals()</strong></p>
<p>答：</p>
<ul>
<li><p>==</p>
<ul>
<li>若操作数的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的值是否相等</li>
<li>若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。        </li>
</ul>
</li>
<li><p>equals</p>
<ul>
<li>在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</li>
<li>但是一般像String就重写了equels方法。</li>
</ul>
</li>
</ul>
<p><strong>定义为String类型的st1和st2是否相等，为什么</strong></p>
<p>答：常量池个特点，如果发现已经存在，就不在创建重复的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;abc&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2)); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：true</span><br><span class="line"></span><br><span class="line">第二行：true</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180409133349472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NDE5NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>内存过程：</p>
<ol>
<li>运行编译，当前类class文件加载进方法区</li>
<li>方法main压栈</li>
<li>常量池创建“abc”对象，产生一个内存地址</li>
<li>然后把内存地址执行st1，st1根据内存地址，指向了常量池中的“abc”。</li>
<li>当代码执行<code>Stringst2 =”abc”</code>,发现常量池中存在”abc”对象所以不会创建对象，直接把”abc”内存地址复制给st2。</li>
<li>最后st1和st2都指向了内存中同一个地址，所以两者是完全相同的。</li>
</ol>
<p><strong>下面这句话在内存中创建了几个对象</strong></p>
<p><code>String st1 = new String(“abc”);</code></p>
<p>答：两个对象。一个是常量池“abc”对象，一个是堆内存String对象。</p>
<p><img src="https://img-blog.csdn.net/20180409133238683?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE1NDE5NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>判定以下定义为String类型的st1和st2是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：false true</p>
<ul>
<li>==比较的是地址值，st1指向堆内存中的string对象，st2指向常量池的‘abc’对象。</li>
<li>equals默认也是比较地址值，但是String类中重写了此方法，实际比较的是值。（首先比较地址）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString &#x3D; (String)anObject;</span><br><span class="line">            int n &#x3D; length();</span><br><span class="line">            if (n &#x3D;&#x3D; anotherString.length()) &#123;</span><br><span class="line">                int i &#x3D; 0;</span><br><span class="line">                while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                    if (charAt(i) !&#x3D; anotherString.charAt(i))</span><br><span class="line">                            return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>判定以下定义为String类型的st1和st2是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     System.out.println(st1 &#x3D;&#x3D; st2);</span><br><span class="line">     System.out.println(st1.equals(st2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：true 和 true</p>
<blockquote>
<p>“a”,”b”,”c”三个本来就是字符串常量，进行+符号拼接之后变成了“abc”，“abc”本身就是字符串常量（Java中有常量优化机制），所以常量池立马会创建一个“abc”的字符串常量对象，在进行st2=”abc”,这个时候，常量池存在“abc”，所以不再创建。所以，不管比较内存地址还是比较字符串序列，都相等。</p>
</blockquote>
<p><strong>判断以下st2和st3是否相等</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package string;</span><br><span class="line"> </span><br><span class="line">public class Demo2_String &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     String st1 &#x3D; &quot;ab&quot;;</span><br><span class="line">     String st2 &#x3D; &quot;abc&quot;;</span><br><span class="line">     String st3 &#x3D; st1 + &quot;c&quot;;</span><br><span class="line">     System.out.println(st2 &#x3D;&#x3D; st3);</span><br><span class="line">     System.out.println(st2.equals(st3));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：false 和 true</p>
<blockquote>
<p>s1和s2都会在常量池中创建对象，st3在编译时期不能确定st3的值，只能在运行期间确定<code>st3=&quot;abc&quot;</code>,在运行期间就只能放在堆内存中。所以不是同一个引用。</p>
</blockquote>
<h1 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h1><p><img src="https://img-blog.csdnimg.cn/20190526180828781.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>不可变对象即对象一旦创建它的状态就不能发生改变（对象的数据，属性值），反之即为可变对象。</p>
<p>不可变对象的类即为不可变类，String、基本类型的包装类、BigInteger和BigDecimal等都是不可变类。</p>
<p><strong>不可变的对象必须满足的条件</strong></p>
<ul>
<li>将类声明为final</li>
<li>声明属性为private 和 final</li>
<li>不要提供任何会修改对象状态的方法</li>
</ul>
<p><strong>改变”不可变对象”</strong></p>
<p>现在我们已经知道了String的成员变量是private final 的，也就是初始化之后不可改变的。同时也提到value这个成员变量其实也是一个引用，指向真正的数组内存地址，不能改变它的引用指向，我们能不能直接改变内存数组中的数据呢，那么就需要获取到value，而value是私有的，可用反射获取</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。</p>
<p>序列化的作用就是为了保存java的类对象的状态，并将对象转换成可存储或者可传输的状态，用于不同jvm之间进行类实例间的共享。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>实现序列化的两种方式：</p>
<ul>
<li>实现Serializable接口：Java专用</li>
<li>实现Parcelable接口：Android专用</li>
</ul>
<h3 id="Serializable-和Parcelable的对比"><a href="#Serializable-和Parcelable的对比" class="headerlink" title="Serializable 和Parcelable的对比"></a>Serializable 和Parcelable的对比</h3><p>Android上应该尽量采用Parcelable，效率至上,Parcelable的速度比高十倍以上。</p>
<p><strong>Serializable</strong>的迷人之处在于你只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<p><strong>Parcelable</strong>方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>定义在类内部的类就被称为内部类。外部类按常规的类访问方式使用内部类，唯一的差别是内部类可以访问外部类的所有方法与属性，包括私有方法与属性。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>定义在类内部的静态类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public static class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner是静态内部类。静态内部类可以访问外部类所有静态变量和方法。静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out.Inner inner &#x3D; new Out.Inner();</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>



<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在类内部的非静态类称为成员内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和实例，私有和非私有。和静态内部类不同的是，每一个成员内部类的实例都依赖一个外部类的实例（成员内部类是依附外部类而存在的）。其它类使用内部类必须要先创建一个外部类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Out out &#x3D; new Out();</span><br><span class="line">Out.Inner inner &#x3D; out.new Inner();</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>

<ul>
<li>成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</li>
<li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</li>
<li>成员内部类与外部类可以拥有同名的成员变量或方法，默认情况下访问的是成员内部类的成员。如果要外部类的同名成员，需用下面的形式访问：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutterClass(外部类).this.成员</span><br></pre></td></tr></table></figure>



<p><strong>为什么Java中成员内部类可以访问外部类成员？</strong></p>
<ul>
<li>成员内部类的创建需要外部类的对象</li>
<li>内部类对象持有指向外部类对象的引用。</li>
</ul>
<p><strong>静态内部类与成员内部类对比</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190528190801750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="局部内部类-amp-闭包"><a href="#局部内部类-amp-闭包" class="headerlink" title="局部内部类&amp;闭包"></a>局部内部类&amp;闭包</h3><p>定义在外部类方法中的类，叫局部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public void test(final int c) &#123;</span><br><span class="line">        final int d &#x3D; 1;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testStatic(final int c) &#123;</span><br><span class="line">        final int d &#x3D; 1;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                &#x2F;&#x2F;定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                &#x2F;&#x2F;System.out.println(b);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部类只能在定义该局部类的方法中使用。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。同时局部类还可以访问方法的参数和方法中的局部变量，这些参数和变量必须要声明为final的。否则会报错</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    private Object obj &#x3D; new Object() &#123;</span><br><span class="line">        private String name &#x3D; &quot;匿名内部类&quot;;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Object obj &#x3D; new Object() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String toString() &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                return String.valueOf(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类可以访问外部类所有的变量和方法。</p>
<h3 id="内部类特点"><a href="#内部类特点" class="headerlink" title="内部类特点"></a>内部类特点</h3><ul>
<li>非静态内部类对象不仅指向该内部类，还指向实例化该内部类的外部类对象的内存。</li>
<li>内部类和普通类一样可以重写Object类的方法，如toString方法；并且有构造函数，执行顺序依旧是先初始化属性，再执行构造函数</li>
<li>在编译完之后，会出现（外部类.class）和（外部类﹩内部类.class）两个类文件名。</li>
<li>内部类可以被修饰为private，只能被外部类所访问。事实上一般也都是如此书写。</li>
<li>内部类可以被写在外部类的任意位置，如成员位置，方法内。</li>
</ul>
<h4 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h4><ul>
<li>静态时，静态内部类只能访问外部类静态成员;非静态内部类都可以直接访问。（原因是：内部类有一个外部类名.this的指引）当访问外部类静态成员出现重名时，通过(外部类名.静态成员变量名)访问。如，Out.show();</li>
<li>重名情况下，非静态时，内部类访问自己内部类通过this.变量名。访问外部类通过（外部类名.this.变量名）访问 。如Out.this.show();</li>
<li>在没有重名的情况下，无论静态非静态，内部类直接通过变量名访问外部成员变量。</li>
</ul>
<h4 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h4><ul>
<li>内部类为非静态时，外部类访问内部类，必须建立内部类对象。建立对象方法，如前所述。</li>
<li>内部类为静态时，外部类访问非静态成员，通过（外部类对象名.内部类名.方法名）访问，如new Out().In.function();</li>
<li>内部类为静态时，外部类访问静态成员时，直接通过（外部类名.内部类名.方法名），如 Out.In.funchtion();</li>
<li>当内部类中定义了静态成员时，内部类必须是静态的；当外部静态方法访问内部类时，内部类也必须是静态的才能访问。</li>
</ul>
<h1 id="静态（static）"><a href="#静态（static）" class="headerlink" title="静态（static）"></a>静态（static）</h1><p>把一个变量声明为静态变量通常基于以下三个目的：</p>
<ul>
<li>作为共享变量</li>
<li>减少对象的创建</li>
<li>保留唯一副本</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul>
<li>静态变量在内存中只有一份拷贝，JVM只为静态分配一次内存，在类加载的过程中完成静态变量的内存分配。可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。</li>
<li>实例变量，每次创建实例，都会对实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</li>
</ul>
<h3 id="静态变量与实例变量区别"><a href="#静态变量与实例变量区别" class="headerlink" title="静态变量与实例变量区别"></a>静态变量与实例变量区别</h3><ul>
<li>所属不同，静态变量属于类，普通成员变量所有当前对象。</li>
<li>存储区域不同，静态变量存在方法区，普通成员变量存在堆（成员变量存储在堆中的对象里面）。</li>
<li>生命周期不同，静态变量生周期与类相同；普通成员变量与当前对象相同。</li>
<li>序列化时，静态变量会被拆除在外。</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法可以直接使用类名调用，静态方法中不能使用this、super，不能直接访问成员变量，成员方法，只能访问类下的静态变量、静态方法，因为实例成员和实例方法与当前对象关联，静态属于类。静态方法不能被抽象。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<h3 id="静态方法和静态代码块的区别"><a href="#静态方法和静态代码块的区别" class="headerlink" title="静态方法和静态代码块的区别"></a>静态方法和静态代码块的区别</h3><ul>
<li>如果有些代码必须在项目启动的时候就执行,就需要使用静态代码块,这种代码是主动执行的；</li>
<li>需要在项目启动的时候就初始化但是不执行,在不创建对象的情况下,可以供其他程序调用,而在调用的时候才执行，这需要使用静态方法,这种代码是被动执行的。 静态方法在类加载的时候 就已经加载 可以用类名直接调用。</li>
</ul>
<p>一句话：类加载时初始化，静态代码块是自动执行的；静态方法是被调用的时候才执行的。</p>
<h3 id="静态内部类和非静态内部类的区别"><a href="#静态内部类和非静态内部类的区别" class="headerlink" title="静态内部类和非静态内部类的区别"></a>静态内部类和非静态内部类的区别</h3><ul>
<li>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</li>
<li>非静态内部类会持有外部类的引用；静态内部类不会持有外部类的引用。</li>
</ul>
<h3 id="父类的静态方法能不能被子类重写"><a href="#父类的静态方法能不能被子类重写" class="headerlink" title="父类的静态方法能不能被子类重写"></a>父类的静态方法能不能被子类重写</h3><h4 id="重写-重载"><a href="#重写-重载" class="headerlink" title="重写/重载"></a>重写/重载</h4><ul>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</li>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li>
</ul>
<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。</p>
<p>在java中，所有的东西都是对象，对象的抽象就是类，对于一个类而言，如果要使用他的成员（类中的属性，方法等），一般情况下，必须先实例化对象后，通过对象的引用才能访问这些成员。但是，如果要使用的成员使用了static修饰，就可以不通过实例化获得该成员。</p>
<h4 id="父类的静态方法能不能被子类重写-1"><a href="#父类的静态方法能不能被子类重写-1" class="headerlink" title="父类的静态方法能不能被子类重写"></a>父类的静态方法能不能被子类重写</h4><p>不能</p>
<p>因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。</p>
<h1 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h1><p>异常知识体系树如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190530174605603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Error是程序代码无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止退出，其表示程序在运行期间出现了十分严重、不可恢复的错误，应用程序只能中止运行。</li>
<li>Exception分运行时异常和非运行时异常。<ul>
<li>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常也是不检查异常，程序代码中自行选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序代码应该从逻辑角度尽可能避免这类异常的发生。</li>
<li>所有继承Exception且不是RuntimeException的异常都是非运行时异常，也称检查异常，如上图中的IOException和ClassNotFoundException，编译器会对其作检查，故程序中一定会对该异常进行处理，处理方法要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。</li>
</ul>
</li>
</ul>
<h2 id="抛出异常的方式"><a href="#抛出异常的方式" class="headerlink" title="抛出异常的方式"></a>抛出异常的方式</h2><ul>
<li><p>使用 <code>throw</code> 抛出异常：throw<code>总是出现在**函数体**中，用来抛出一个</code>Throwable<code>类型的异常，例如抛出一个</code> <code>IOException</code> 类的异常对象。</p>
</li>
<li><p>使用 <code>throws</code> 抛出异常：如果一个方法可能会出现异常，但没有能力处理这种异常，可以在<strong>方法声明处</strong>用 <code>throws</code> 子句来声明抛出异常。</p>
</li>
</ul>
<p><strong>throw 和 throws 的区别？</strong></p>
<ul>
<li>throw用于方法内部，throws用于方法声明上</li>
<li>throw后跟异常对象，throws后跟异常类型</li>
<li>throw后只能跟一个异常对象，throws后可以一次声明多种异常类型</li>
</ul>
<h2 id="final、finally、finalize-有什么区别"><a href="#final、finally、finalize-有什么区别" class="headerlink" title="final、finally、finalize 有什么区别"></a>final、finally、finalize 有什么区别</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h2><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void omitFinally() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			int i &#x3D; 0;</span><br><span class="line">			i +&#x3D; 1;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void omitCatch() &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i +&#x3D; 1;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<p><strong>在以下 4 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ul>
<h2 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h2><ul>
<li>NullPointerException 当应用程序试图访问空对象时，则抛出该异常。</li>
<li>SQLException 提供关于数据库访问错误或其他错误信息的异常。</li>
<li>IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li>NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li>FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li>IOException当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>
<li>ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li>ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>
<li>NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li>NoSuchMethodException无法找到某一特定方法时，抛出该异常。</li>
<li>SecurityException由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li>UnsupportedOperationException当不支持请求的操作时，抛出该异常。</li>
<li>RuntimeExceptionRuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><a href="https://www.zhihu.com/question/24304289" target="_blank" rel="noopener">https://www.zhihu.com/question/24304289</a></p>
<p><img src="http://image.tengj.top/Javareflect.png" alt="img"></p>
<ul>
<li>java代码在计算机中经历的阶段（三阶段）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190901141812427.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170513133210763" alt="img"></p>
<p>Java反射机制是指在运行状态中，可以对任意类，都知道它的属性和方法并调用。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。一句话<strong>反射可以在运行时知道类的属性和方法</strong>。</p>
<p>反射就是把Java类中的各种成分映射成对象的Java类，然后对这个java类进行操作。（比如：类的成员属性Field、类的成员方法Method、类的构造方法）</p>
<ul>
<li>反射的好处<ul>
<li>可以在程序运行时操作这些对象。</li>
<li>可以解耦，提高程序可扩展性。</li>
</ul>
</li>
<li>反射的缺点<ul>
<li>反射的效率很低</li>
<li>会破坏封装，通过反射可以访问类的私有方法，不安全</li>
</ul>
</li>
</ul>
<h2 id="字节码Class对象"><a href="#字节码Class对象" class="headerlink" title="字节码Class对象"></a>字节码Class对象</h2><h3 id="Class类对象——描述-class字节码文件"><a href="#Class类对象——描述-class字节码文件" class="headerlink" title="Class类对象——描述.class字节码文件"></a>Class类对象——描述.class字节码文件</h3><p>将java文件经过编译后变成class字节码文件通过类加载器加载到内存，通过java.lang.Class类对象对字节码文件进行描述。每一个类都是一个class类对象的实例。<strong>class类对象是用来对类的描述，主要包括三个成员变量</strong>：</p>
<ul>
<li>类成员变量 Field[] fields</li>
<li>类成员方法 Method[] methods</li>
<li>类构造函数 Constructor[] constructors</li>
</ul>
<h3 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h3><p>Class类构造函数是私有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;*</span><br><span class="line">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span><br><span class="line">     * This constructor is not used and prevents the default constructor being</span><br><span class="line">     * generated.</span><br><span class="line">     *&#x2F;</span><br><span class="line">private Class() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Class.forName(“全类名”)</p>
<p><strong>在Source源代码阶段</strong>，此时java类仍位于硬盘上。多用于配置文件，将类名定义在配置文件中。读取文件，并触发类构造器加载类。Class.forName() 方法如果写错类的路径会报 ClassNotFoundException 的异常。</p>
</li>
<li><p>类名.class：通过类名的属性class获取</p>
<p><strong>在Class类对象阶段</strong>，此时java类位于内存中，但没有实际对象。多用于参数的传递。通过这种方式时，只会加载Dog类，并不会触发其类构造器的初始化。</p>
</li>
<li><p>对象.getClass()：getClass（）方法在Object类中定义</p>
<p><strong>在运行阶段</strong>，此时已经获取类的实例对象，多用于对象的获取字节码的方式。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法1：Class.forName(&quot;全类名&quot;)</span><br><span class="line">      try &#123;</span><br><span class="line">          Class cls1 &#x3D; Class.forName(&quot;com.test.demo.Dog&quot;);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">      &#x2F;&#x2F; 方法2：类名.class</span><br><span class="line">      Class cls2 &#x3D; Dog.class;</span><br><span class="line">      &#x2F;&#x2F; 方法3：对象.getClass()</span><br><span class="line">      Dog dog &#x3D; new Dog();</span><br><span class="line">  	Class cls3 &#x3D; dog.getClass();</span><br><span class="line">&#x2F;&#x2F; 用 &#x3D;&#x3D; 比较3个对象是否为同一个对象（指向同一物理地址）</span><br><span class="line">System.out.print(cls1 &#x3D;&#x3D; cls2);	&#x2F;&#x2F;	true</span><br><span class="line">System.out.print(cls1 &#x3D;&#x3D; cls3);	&#x2F;&#x2F;	true</span><br></pre></td></tr></table></figure>

<p>同一个字节码文件（<em>.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。*</em>也就是说在运行期间，一个类，只有一个Class对象产生。**</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h1 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h1><h2 id="什么是范型"><a href="#什么是范型" class="headerlink" title="什么是范型"></a>什么是范型</h2><p>用来规定类、接口、方法接受数据的类型。</p>
<p>泛型的本质就是利用编译器实现的Java语法糖，编译器将java文件转换为class文件前，会进行泛型擦除，所以在反编译的class文件中，是看不到泛型声明的</p>
<h2 id="范型的优缺点"><a href="#范型的优缺点" class="headerlink" title="范型的优缺点"></a>范型的优缺点</h2><p><strong>范型的优点：</strong></p>
<ul>
<li><strong>提高安全性:</strong> 将运行期的错误转换到编译期. 如果我们在对一个对象所赋的值不符合其泛型的规定, 就会编译报错.</li>
<li><strong>避免强转:</strong> 比如我们在使用List时, 如果我们不使用泛型, 当从List中取出元素时, 其类型会是默认的Object, 我们必须将其向下转型为String才能使用。</li>
</ul>
<p><strong>范型的缺点：</strong></p>
<ul>
<li>类型擦除问题</li>
</ul>
<h3 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a>范型擦除</h3><p>在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<h2 id="范型的使用"><a href="#范型的使用" class="headerlink" title="范型的使用"></a>范型的使用</h2><p>泛型有三种使用方式，分别为：</p>
<ul>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
</ul>
<p>范型使用规则：</p>
<ul>
<li>泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</li>
<li>泛型只在编译阶段有效。</li>
<li>在实例化泛型类时，必须指定具体类型，如果不传入泛型类型实参的话，不会起到限制的作用，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</li>
<li>不能对确切的泛型类型使用instanceof操作</li>
<li>当实现泛型接口的类，未传入泛型实参时，声明类需将泛型的声明也一起加到类中，如果不声明，编译器会报错。</li>
<li>public 与 返回值中间<T>，可以理解为声明此方法为泛型方法。</li>
<li>只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li>
</ul>
<h3 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h3><p>泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Base&lt;Double&gt; base &#x3D; new Base&lt;Double&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="范型接口"><a href="#范型接口" class="headerlink" title="范型接口"></a>范型接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化泛型类时，必须指定具体类型，如果不传入泛型类型实参的话，不会起到限制的作用，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] fruits &#x3D; new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand &#x3D; new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="范型方法"><a href="#范型方法" class="headerlink" title="范型方法"></a>范型方法</h3><p>print是范型方法，其它的get set 不是范型方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;E, K&gt; K print(E e, K k) &#123;</span><br><span class="line"></span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型中的通配符"><a href="#泛型中的通配符" class="headerlink" title="泛型中的通配符"></a>泛型中的通配符</h2><p>范型中的通配符规定只允许某一部分类作为泛型。</p>
<h3 id="通配符分类"><a href="#通配符分类" class="headerlink" title="通配符分类"></a>通配符分类</h3><ul>
<li>无边界通配符(&lt;?&gt;)：让泛型能够接受未知类型的数据</li>
<li>固定上边界通配符(&lt;? extends E&gt;),即传入的类型实参必须是指定类型的子类型。注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类.</li>
<li>固定下边界通配符（? super E）即传入的类型实参必须是指定类型的父类型</li>
</ul>
<h2 id="关于泛型数组"><a href="#关于泛型数组" class="headerlink" title="关于泛型数组"></a>关于泛型数组</h2><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。</p>
<p>也就是说下面的这个例子是不可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList&lt;String&gt;[10];</span><br></pre></td></tr></table></figure>

<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls &#x3D; new ArrayList&lt;?&gt;[10];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls &#x3D; new ArrayList[10];</span><br></pre></td></tr></table></figure>

<p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">的一篇文档</a>的一个例子来说明这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa &#x3D; new List&lt;String&gt;[10]; &#x2F;&#x2F; Not really allowed.    </span><br><span class="line">Object o &#x3D; lsa;    </span><br><span class="line">Object[] oa &#x3D; (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(new Integer(3));    </span><br><span class="line">oa[1] &#x3D; li; &#x2F;&#x2F; Unsound, but passes run time store check    </span><br><span class="line">String s &#x3D; lsa[1].get(0); &#x2F;&#x2F; Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
</blockquote>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
<p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa &#x3D; new List&lt;?&gt;[10]; &#x2F;&#x2F; OK, array of unbounded wildcard type.    </span><br><span class="line">Object o &#x3D; lsa;    </span><br><span class="line">Object[] oa &#x3D; (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li &#x3D; new ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(new Integer(3));    </span><br><span class="line">oa[1] &#x3D; li; &#x2F;&#x2F; Correct.    </span><br><span class="line">Integer i &#x3D; (Integer) lsa[1].get(0); &#x2F;&#x2F; OK</span><br></pre></td></tr></table></figure>



<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解（Annotation），也叫元数据，一种代码级别的说明。JDK1.5引入的特性，与类、接口、枚举是在同一个层次，它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<strong>注解的本质就是一个继承了 Annotation 接口的接口</strong>，所有的注解类型都继承自Annotation。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p>
<ul>
<li><p>@Target：<strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    &#x2F;** 表示可以用来修饰类、接口、注解类型或枚举类型Class, interface (including annotation type), or enum declaration *&#x2F;</span><br><span class="line">    TYPE,</span><br><span class="line">    &#x2F;** 可以用来修饰属性（包括枚举常量）Field declaration (includes enum constants) *&#x2F;</span><br><span class="line">    FIELD,</span><br><span class="line">    &#x2F;** 可以用来修饰方法Method declaration *&#x2F;</span><br><span class="line">    METHOD,</span><br><span class="line">    &#x2F;** 可以用来修饰参数 Formal parameter declaration *&#x2F;</span><br><span class="line">    PARAMETER,</span><br><span class="line">    &#x2F;** 可以用来修饰构造器 Constructor declaration *&#x2F;</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    &#x2F;** 可用来修饰局部变量Local variable declaration *&#x2F;</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    &#x2F;** 可以用来修饰注解类型Annotation type declaration *&#x2F;</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    &#x2F;** 可以用来修饰包Package declaration *&#x2F;</span><br><span class="line">    PACKAGE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 标注在类型参数上Type parameter declaration</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于标注任意类型(不包括class)Use of a type</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>@Retention：<strong>定义了<code>Annotation</code>的生命周期</strong></p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息）</p>
<p><strong>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</strong></p>
</li>
</ul>
</li>
<li><p>@Documented：<strong>用来描述注解是否被抽取到api文档中。在生成javadoc文档的时候将该Annotation也写入到文档中。</strong></p>
</li>
<li><p>@Inherited：<strong>如果一个使用了<code>@Inherited</code>修饰的<code>annotation</code>类型被用于一个class，则这个<code>annotation</code>将被用于该class的子类。并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</strong></p>
</li>
<li><p>@Repeatable：它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的。</p>
</li>
</ul>
<h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ul>
<li><p>@Override：用于标记该方法是复写的父类中的某个方法。属于标记注解，不需要设置属性值；只能添加在方法的前面。</p>
</li>
<li><p>@Deprecated：说明被修饰内容已被“废弃”，不再建议用户使用。</p>
</li>
<li><p>@SuppressWarnings：忽略警告。</p>
</li>
<li><p>@TargetApi：版本注解。</p>
</li>
<li><p>@SuppressLint：避免在lint检查时报错</p>
</li>
<li><p><strong>Nullable</strong>：用于标记方法参数或者返回值可以为空；</p>
</li>
<li><p><strong>@NonNull:</strong>用于标记方法参数或者返回值不能为空，如果为空编译器会报警告；</p>
</li>
<li><p>@IdRes：Android中一系列<strong>资源类型注解</strong>。</p>
</li>
<li><p>使用整型常量代替枚举类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class IceCreamFlavourManager &#123;</span><br><span class="line">    private int flavour;</span><br><span class="line"></span><br><span class="line">    public static final int VANILLA &#x3D; 0;</span><br><span class="line">    public static final int CHOCOLATE &#x3D; 1;</span><br><span class="line">    public static final int STRAWBERRY &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    @IntDef(&#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</span><br><span class="line">    public @interface Flavour &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Flavour</span><br><span class="line">    public int getFlavour() &#123;</span><br><span class="line">        return flavour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlavour(@Flavour int flavour) &#123;</span><br><span class="line">        this.flavour &#x3D; flavour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@UiThread :等线程注解</p>
</li>
<li><p>@Size、@IntRange、@FloatRange等值约束注解。</p>
</li>
<li><p>权限注解</p>
</li>
<li><p>@CheckResult：<strong>返回值注解</strong>。</p>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名 &#123;定义体&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><h4 id="编译时期使用注解"><a href="#编译时期使用注解" class="headerlink" title="编译时期使用注解"></a>编译时期使用注解</h4><p>编译时注解指的是@Retention的值为CLASS的注解。对于这类注解的解析，我们只需做好以下两件事儿：</p>
<ul>
<li>自定义一个派生自 AbstractProcessor的“注解处理类”；</li>
<li>重写process 函数。</li>
</ul>
<p>实际上，javac中包含的注解处理器在编译时会自动查找所有继承自 AbstractProcessor 的类，然后调用它们的 process 方法。因此我们只要做好上面两件事，编译器就会主动去解析我们的编译时注解。现在，我们把上面定义的TestAnnotation的Retention改为CLASS，我们就可以按照以下代码来解析它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;com.zhyen.com.TestAnnotation&quot;)</span><br><span class="line">public class TestAnnotationClass extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (TypeElement element : annotations) &#123;</span><br><span class="line">            for (Element e : roundEnv.getElementsAnnotatedWith(element)) &#123;</span><br><span class="line">                TestAnnotation annotation&#x3D;e.getAnnotation(TestAnnotation.class);</span><br><span class="line">                map.put(e.getEnclosingElement().toString(),annotation.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SupportedAnnotationTypes注解指出了MyProcessor向要解析的注解的完整名字（全限定名称）。process+函数的annotations参数表示待处理的注解集，通过env我们可以得到被特定注解所修饰的程序元素。process函数的返回值表示annotations中的注解是否被这个Processor接受。&amp;oq=%40SupportedAnnotationTypes注解指出了MyProcessor向要解析的注解的完整名字（全限定名称）。process+函数的annotations参数表示待处理的注解集，通过env我们可以得到被特定注解所修饰的程序元素。process函数的返回值表示annotations中的注解是否被这个Processor接受</p>
<h4 id="运行时期使用直接"><a href="#运行时期使用直接" class="headerlink" title="运行时期使用直接"></a>运行时期使用直接</h4><p>Class 类中提供了以下一些方法用于反射注解：</p>
<ul>
<li><p>getAnnotation：返回指定的注解</p>
</li>
<li><p>isAnnotationPresent：判定当前元素是否被指定注解修饰</p>
</li>
<li><p>getAnnotations：返回所有的注解</p>
</li>
<li><p>getDeclaredAnnotation：返回本元素的指定注解</p>
</li>
<li><p>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</p>
</li>
</ul>
<p><strong>方法、字段中相关反射注解的方法基本是类似的</strong></p>
<h3 id="案例一个"><a href="#案例一个" class="headerlink" title="案例一个"></a>案例一个</h3><p>注解类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TestAnnotation &#123;</span><br><span class="line">    String value() default &quot;null&quot;;</span><br><span class="line"></span><br><span class="line">    public String name() default &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    int index() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestAnnotationClass &#123;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;汪汪汪&quot;, name &#x3D; &quot;dog&quot;, index &#x3D; 100)</span><br><span class="line">    public String dog;</span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;喵喵喵&quot;, name &#x3D; &quot;cat&quot;, index &#x3D; 200)</span><br><span class="line">    public String cat;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;爱爆炸&quot;, index &#x3D; 10, name &#x3D; &quot;三星&quot;)</span><br><span class="line">    public void phone() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @TestAnnotation(value &#x3D; &quot;细&quot;, index &#x3D;20, name &#x3D; &quot;ARM&quot;)</span><br><span class="line">    public void CPU() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取注解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;TestAnnotationClass&gt; clazz &#x3D; TestAnnotationClass.class;</span><br><span class="line">        Field[] fields &#x3D; clazz.getFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            TestAnnotation annotation &#x3D; field.getAnnotation(TestAnnotation.class);</span><br><span class="line">            String name &#x3D; annotation.name();</span><br><span class="line">            int index &#x3D; annotation.index();</span><br><span class="line">            String value &#x3D; annotation.value();</span><br><span class="line">            Log.d(TAG, &quot;name &#x3D; &quot; + name + &quot; ,index &#x3D; &quot; + index + &quot;, value &#x3D; &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TestAnnotation annotation &#x3D; method.getAnnotation(TestAnnotation.class);</span><br><span class="line">            String name &#x3D; annotation.name();</span><br><span class="line">            int index &#x3D; annotation.index();</span><br><span class="line">            String value &#x3D; annotation.value();</span><br><span class="line">            Log.d(TAG, &quot;name &#x3D; &quot; + name + &quot; ,index &#x3D; &quot; + index + &quot;, value &#x3D; &quot; + value);</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; cat ,index &#x3D; 200, value &#x3D; 喵喵喵</span><br><span class="line">name &#x3D; dog ,index &#x3D; 100, value &#x3D; 汪汪汪</span><br><span class="line">方法名: CPU </span><br><span class="line">name &#x3D; ARM ,index &#x3D; 20, value &#x3D; 细</span><br><span class="line">equals</span><br><span class="line">方法名: getClass</span><br><span class="line">方法名: hashCode</span><br><span class="line">方法名: notify</span><br><span class="line">方法名: phone</span><br><span class="line">name &#x3D; 三星 ,index &#x3D; 10, value &#x3D; 爱爆炸</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h1 id="抽象类（Abstract-Class）"><a href="#抽象类（Abstract-Class）" class="headerlink" title="抽象类（Abstract Class）"></a>抽象类（Abstract Class）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。抽象类用abstract修饰。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>不能实例化，因为抽象类中含有无法具体实现的方法。</li>
<li>可在抽象类中定义公共成员变量、成员方法、构造方法等。</li>
<li>只要包含一个抽象方法的类，该类必须要定义成抽象类（抽象方法是一种特殊的方法，它只有声明但没有具体的实现，抽象方法必须为public或protected）。故可理解为抽象类是在普通类结构里增加抽象方法的组成部分。</li>
<li>如果子类继承于一个抽象类，则该子类可以有选择性决定是否覆写父类的抽象方法，如果子类没有实现父类的抽象方法，则必须将子类也定义为抽象类（抽象类可以继承抽象类）</li>
<li>继承只能单继承，一个子类只能继承一个抽象类。</li>
<li>abstract不能与final并列修饰同一个类。</li>
<li>abstract 不能与private、static、final或native并列修饰同一个方法。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;&#x2F;&#x2F;定义一个抽象类</span><br><span class="line">	</span><br><span class="line">	public void fun()&#123;&#x2F;&#x2F;普通方法</span><br><span class="line">		System.out.println(&quot;存在方法体的方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public abstract void print();&#x2F;&#x2F;抽象方法，没有方法体，有abstract关键字做修饰</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="抽象类必须有抽象方法吗"><a href="#抽象类必须有抽象方法吗" class="headerlink" title="抽象类必须有抽象方法吗"></a>抽象类必须有抽象方法吗</h3><p>不是</p>
<h3 id="抽象类可以继承普通类吗"><a href="#抽象类可以继承普通类吗" class="headerlink" title="抽象类可以继承普通类吗"></a>抽象类可以继承普通类吗</h3><p>可以</p>
<h3 id="抽象类有构造方法吗？"><a href="#抽象类有构造方法吗？" class="headerlink" title="抽象类有构造方法吗？"></a>抽象类有构造方法吗？</h3><p>有</p>
<h3 id="抽象类可以用final声明么？"><a href="#抽象类可以用final声明么？" class="headerlink" title="抽象类可以用final声明么？"></a>抽象类可以用final声明么？</h3><p>不能，因为抽象类必须有子类，而final定义的类不能有子类；</p>
<h3 id="抽象类能否使用static声明？"><a href="#抽象类能否使用static声明？" class="headerlink" title="抽象类能否使用static声明？"></a>抽象类能否使用static声明？</h3><p>外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p>
<h3 id="可以直接调用抽象类中用static声明的方法么？"><a href="#可以直接调用抽象类中用static声明的方法么？" class="headerlink" title="可以直接调用抽象类中用static声明的方法么？"></a>可以直接调用抽象类中用static声明的方法么？</h3><p>任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</p>
<h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。</li>
<li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li>
<li>一个接口可以继承于另一个接口，或者另一些接口，接口也可以继承，并且可以多继承。接口不能实现(implement)另一个接口</li>
<li>一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。</li>
<li>不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的</li>
<li>接口没有构造方法</li>
<li>接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的。</li>
<li>接口支持多继承（一个类可以实现多个接口）</li>
<li>一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。</li>
<li>接口也被用来实现解耦。</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Door&#123;</span><br><span class="line">void open ();</span><br><span class="line">void close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public class BigDoor implements Door &#123;</span><br><span class="line"></span><br><span class="line">void open ()&#123;</span><br><span class="line">System.out.println(&quot;BigDoor is opening...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void close()&#123;</span><br><span class="line">System.out.println(&quot;BigDoor is closing...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口的标识用法"><a href="#接口的标识用法" class="headerlink" title="接口的标识用法"></a>接口的标识用法</h2><p>虽然接口内部定义了一些抽象方法，但是并不是所有的接口内部都必须要有方法，比如Seriallizable接口，Seriallizable接口的作用是使对象能够“序列化”，但是Seriallizable接口中却没有任何内容，也就是说，如果有一个类需要实现“序列化”的功能，则这个类必须去实现Seriallizable接口，但是却并不用实现方法（因为接口中没有方法），此时，这个Serilizable接口就仅仅是一个“标识”接口，是用来标志一个类的，标志这个类具有这个“序列化”功能。</p>
<h1 id="抽象类与接口区别"><a href="#抽象类与接口区别" class="headerlink" title="抽象类与接口区别"></a>抽象类与接口区别</h1><ul>
<li>抽象类中可以有自己的方法实现。也可以有抽象方法。接口只有抽象方法。</li>
<li>一个子类只能继承一个父类，但可以实现多个接口。</li>
<li>子类使用extends关键字继承抽象类。子类可以选择性重写抽象类中需要使用的方法;子类使用implements关键字实现接口。子类需要提供接口中所有声明的方法的实现。</li>
<li>抽象类可以有构造方法，但接口没有构造方法。但抽象类的构造器不用于创造对象，而是让其子类调用这些构造器完成抽象类的初始化操作。</li>
<li>抽象方法比接口速度快。接口需要时间去寻找在类中实现的方法，故速度较慢。</li>
<li>抽象类是对事物的一种抽象，描述的是某一类特性的事物。表示 这个对象是什么。（is-a关系——强调所属关系）;接口是对行为功能的抽象，描述是否具备某种行为特征。表示 这个对象能做什么。（has-a关系——强调功能实现）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">Java设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>依赖是类与类之间的连接，依赖关系表示一个类依赖于另一个类的定义，通俗来讲就是需要。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>一个人(Person)可以买车(Car)和房子(House),Person类依赖于Car类和House类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String ... args)&#123;</span><br><span class="line">        &#x2F;&#x2F;TODO:</span><br><span class="line"></span><br><span class="line">    Person person &#x3D; new Person();</span><br><span class="line">    person.buy(new House());</span><br><span class="line">    person.buy(new Car());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Person&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;表示依赖House</span><br><span class="line">    public void buy(House house)&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;表示依赖Car</span><br><span class="line">    public void buy(Car car)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class House&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Car&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="依赖倒置-Dependence-Inversion-Principle"><a href="#依赖倒置-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置(Dependence Inversion Principle)"></a>依赖倒置(Dependence Inversion Principle)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>高层模块不应该依赖低层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；通俗来讲，依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。</p>
<p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。此时将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>不使用依赖倒置，每次出行都需要修改Person类代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private Bike mBike;</span><br><span class="line">    private Car mCar;</span><br><span class="line">    private Train mTrain;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;</span><br><span class="line">        mBike &#x3D; new Bike();</span><br><span class="line">        &#x2F;&#x2F;mCar &#x3D; new Car();</span><br><span class="line">&#x2F;&#x2F;        mTrain &#x3D; new Train();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mBike.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）使用依赖倒置，上层模块不应该依赖底层模块，它们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    private Bike mBike;</span><br><span class="line">    private Car mCar;</span><br><span class="line">    private Train mTrain;</span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;</span><br><span class="line">&#x2F;&#x2F;        mBike &#x3D; new Bike();</span><br><span class="line">        &#x2F;&#x2F;mCar &#x3D; new Car();</span><br><span class="line">       mDriveable &#x3D; new Train();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="控制反转-Inversion-of-Control"><a href="#控制反转-Inversion-of-Control" class="headerlink" title="控制反转(Inversion of Control)"></a>控制反转(Inversion of Control)</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>IoC 是一种新的设计模式，它对上层模块与底层模块进行了更进一步的解耦。控制反转的意思是反转了上层模块对于底层模块的依赖控制。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person2 &#123;</span><br><span class="line"></span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    public Person2(Driveable driveable)&#123;</span><br><span class="line">        this.mDriveable &#x3D; driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:将 mDriveable 的实例化移到 Person 外面</span><br><span class="line">        Person2 person &#x3D; new Person2(new Car());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这样无论出行方式怎么变化，Person 这个类都不需要更改代码了。<br>在上面代码中，Person 把内部依赖的创建权力移交给了 Person2。也就是说 Person 只关心依赖提供的功能，但并不关心依赖的创建。<br>其中Person2称为IoC容器（依赖注入的地方）</p>
<h1 id="依赖注入-Dependency-injection"><a href="#依赖注入-Dependency-injection" class="headerlink" title="依赖注入(Dependency injection)"></a>依赖注入(Dependency injection)</h1><p>为了不因为依赖实现的变动而去修改 Person，也就是说以可能在 Driveable 实现类的改变下不改动 Person 这个类的代码，尽可能减少两者之间的耦合需要采用IoC 模式来进行改写代码。</p>
<p>这个需要我们移交出对于依赖实例化的控制权，Person 无法实例化依赖了，它就需要在外部（IoC 容器）赋值给它，这个赋值的动作有个专门的术语叫做注入（injection），需要注意的是在 IoC 概念中，这个注入依赖的地方被称为 IoC 容器，但在依赖注入概念中，一般被称为注射器 （injector)。</p>
<p>表达通俗一点就是：我不想自己实例化依赖，你（injector）创建它们，然后在合适的时候注入给我。</p>
<p>实现依赖注入有 3 种方式：</p>
<ul>
<li>构造函数中注入</li>
<li>setter 方式注入</li>
<li>接口注入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 接口方式注入</span><br><span class="line"> * 接口的存在，表明了一种依赖配置的能力。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface DepedencySetter &#123;</span><br><span class="line">    void set(Driveable driveable);</span><br><span class="line">&#125;</span><br><span class="line">public class Person2  implements DepedencySetter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接口方式注入</span><br><span class="line">    @Override</span><br><span class="line">    public void set(Driveable driveable) &#123;</span><br><span class="line">        this.mDriveable &#x3D; mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造函数注入</span><br><span class="line">    public Person2(Driveable driveable)&#123;</span><br><span class="line">        this.mDriveable &#x3D; driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;setter 方式注入</span><br><span class="line">    public void setDriveable(Driveable mDriveable) &#123;</span><br><span class="line">        this.mDriveable &#x3D; mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void goOut()&#123;</span><br><span class="line">        System.out.println(&quot;出门啦&quot;);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        &#x2F;&#x2F;mCar.drive();</span><br><span class="line">&#x2F;&#x2F;        mTrain.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String ... args)&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO:</span><br><span class="line">        Person2 person &#x3D; new Person2(new Car());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><h2 id="代理模式基本概念及分类"><a href="#代理模式基本概念及分类" class="headerlink" title="代理模式基本概念及分类"></a>代理模式基本概念及分类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img-blog.csdnimg.cn/20190601204007375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为其他对象提供一种代理以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理对象起到中介的作用，可去掉功能服务或增加额外的服务。负责为委托类预处理消息，过滤消息并将请求分派给委托类处理，以及进行消息被委托类执行后的后续操作。</p>
<p>例如火车票代售处是火车站的代理，相对于火车站，可以提供额外的服务，如电话预约，提供额外服务的同时，会收取一定金额的手续费。也可以将原有的功能去掉，如代售处不能提供退票服务。</p>
<h3 id="代理模式模型"><a href="#代理模式模型" class="headerlink" title="代理模式模型"></a>代理模式模型</h3><p>代理模式一般设计到角色有4 种：</p>
<ul>
<li><strong>抽象角色</strong>：对应代理接口（&lt;&lt; interface &gt;&gt;Subject），用来定义代理类和委托类的公共对外方法/接口；</li>
<li><strong>真实角色</strong>：对应委托类（接口实现类RealSubject），真正实现业务逻辑的类，是代理角色所代表的真实对象，是最终要引用的对象；</li>
<li><strong>代理角色</strong>：对应代理类（Proxy），用来代理和封装真实角色。代理角色内部含有对真实对象的引用，从而可以操作真实对象。同时，代理对象可以在执行真是对象操作时，添加或去除其他操作，相当于对真实对象进行封装；</li>
<li><strong>客户角色</strong>：对应客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190601204859723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在代理模式中真实角色对于客户端角色来说的透明的，也就是客户端不知道也无需知道真实角色的存在。 为了保持行为的一致性，代理角色和真实角色通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。</p>
<p>通过代理角色这中间一层，能有效控制对真实角色（委托类对象）的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p>
<h3 id="代理模式特点"><a href="#代理模式特点" class="headerlink" title="代理模式特点"></a>代理模式特点</h3><h4 id="代理模式优点"><a href="#代理模式优点" class="headerlink" title="代理模式优点"></a>代理模式优点</h4><ul>
<li>隐藏委托类的实现，调用者只需要和代理类进行交互即可。</li>
<li>解耦，在不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作</li>
</ul>
<h2 id="代理模式实现方式"><a href="#代理模式实现方式" class="headerlink" title="代理模式实现方式"></a>代理模式实现方式</h2><p>根据代理类的<strong>生成时间</strong>不同可以将代理分为静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>所谓静态代理也就是在程序运行前就已经存在代理类的.class文件，代理类和委托类的关系在运行前就确定了。</p>
<p>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被代理对象Car</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car2 extends Car &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		super.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="聚合方式"><a href="#聚合方式" class="headerlink" title="聚合方式"></a>聚合方式</h4><p>聚合：在代理中引用被代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Car3 implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public Car3(Car car) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.car &#x3D; car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Car car;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		car.move();</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承方式与聚合方式对比"><a href="#继承方式与聚合方式对比" class="headerlink" title="继承方式与聚合方式对比"></a>继承方式与聚合方式对比</h4><p>聚合方式比继承方式更适合代理模式：适合功能的叠加（可灵活传递，组合）。</p>
<p>记录日志代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CarLogProxy implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	public CarLogProxy(Moveable m) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.m &#x3D; m;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Moveable m;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		System.out.println(&quot;日志开始....&quot;);</span><br><span class="line">		m.move();</span><br><span class="line">		System.out.println(&quot;日志结束....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录时间代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Car car &#x3D; new Car();</span><br><span class="line">	CarLogProxy clp &#x3D; new CarLogProxy(car);</span><br><span class="line">	CarTimeProxy ctp &#x3D; new CarTimeProxy(clp);</span><br><span class="line">	ctp.move();&#x2F;&#x2F;先记录日志后记录时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通过动态代理可实现对不同类、不同方法的代理。动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件（.class）。代理类和委托类的关系在程序运行时确定。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>实现模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190601211348201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>
<p><strong>Interface InvocationHandler</strong></p>
<p>InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，每次生成动态代理对象都邀制定一个对应的调用处理器对象，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object invoke(Object obj,Method method,Object[] args)</span><br></pre></td></tr></table></figure>

<p>在实际使用时，obj指代理类的实例，method指被代理的方法，args是该方法的参数数组。这个抽象方法在代理类中动态实现。</p>
<p>该方法也是InvocationHandler接口所定义的唯一的一个方法，该方法负责集中处理动态代理类上的所有方法的调用。调用处理器根据这三个参数进行预处理或分派到委托类实例上执行。</p>
<p><strong>Proxy class动态代理类</strong></p>
<p>Proxy是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>

<p>返回代理类的一个实例，返回后的代理类可以当做被代理类使用（可使用被代理类在接口中声明过的方法）</p>
<p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p><strong>步骤1：创建一个实现接口InvocationHandler的调用处理器，它必须实现invoke方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TimeHandler implements InvocationHandler &#123;</span><br><span class="line">&#x2F;&#x2F;动态代理类对应的调用处理程序类（时间处理器）</span><br><span class="line">	public TimeHandler(Object target) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.target &#x3D; target;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;代理类持有一个委托类的对象引用</span><br><span class="line">	private Object target;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * 参数：</span><br><span class="line">	 * proxy  被代理对象</span><br><span class="line">	 * method  被代理对象的方法</span><br><span class="line">	 * args 方法的参数</span><br><span class="line">	 * </span><br><span class="line">	 * 返回值：</span><br><span class="line">	 * Object  方法的返回值</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line">		long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车开始行驶....&quot;);</span><br><span class="line">		method.invoke(target);&#x2F;&#x2F;调用被代理对象的方法（Car的move方法）</span><br><span class="line">		long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot; </span><br><span class="line">				+ (endtime - starttime) + &quot;毫秒！&quot;);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimeHandler实现了InvocationHandler的invoke方法，当代理对象的方法被调用时，invoke方法会被回调。其中proxy表示实现了公共代理方法的动态代理对象。</p>
<p><strong>步骤2：创建被代理的类以及接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">	void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Moveable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void move() &#123;</span><br><span class="line">		&#x2F;&#x2F;实现开车</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">			System.out.println(&quot;汽车行驶中....&quot;);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：调用Proxy的静态方法newProxyInstance，提供ClassLoader和代理接口类型数组动态创建一个代理类，并通过代理调用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端，使用代理类和主题接口完成功能</span><br><span class="line">public class Test &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * JDK动态代理测试类</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Car car &#x3D; new Car();</span><br><span class="line">		InvocationHandler h &#x3D; new TimeHandler(car);</span><br><span class="line">		Class&lt;?&gt; cls &#x3D; car.getClass();</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * loader  类加载器</span><br><span class="line">		 * interfaces  实现接口</span><br><span class="line">		 * h InvocationHandler</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Moveable m &#x3D; (Moveable)Proxy.newProxyInstance(cls.getClassLoader(),</span><br><span class="line">												cls.getInterfaces(), h);&#x2F;&#x2F;获得动态代理对象，动态代理对象与代理对象实现同一接口</span><br><span class="line">		m.move();&#x2F;&#x2F;调用动态代理的move方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过InvocationHandler handler=new TimeHandler(target);将委托对象作为构造方法的参数传递给了TimeHandler来作为代理方法调用的对象。当我们调用代理对象的move()方法时，该调用将会被转发到TimeHandler对象的invoke上从而达到动态代理的效果。</p>
<p>所谓动态代理是这样一种class：它是运行时生成的class，该class需要实现一组interface，使用动态代理类时，必须实现InvocationHandler接口</p>
<h3 id="静态代理与动态代理对比"><a href="#静态代理与动态代理对比" class="headerlink" title="静态代理与动态代理对比"></a>静态代理与动态代理对比</h3><h4 id="静态代理-1"><a href="#静态代理-1" class="headerlink" title="静态代理"></a>静态代理</h4><ul>
<li>优点：<br>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。</li>
<li>缺点：<ul>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
<li>采用静态代理模式，那么真实角色（委托类）必须事先已经存在的，并将其作为代理对象代理对象内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀。</li>
</ul>
</li>
</ul>
<h4 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h4><ul>
<li>优点<ul>
<li>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</li>
<li>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</li>
</ul>
</li>
<li>缺点<ul>
<li>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="url">Java容器类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T23:03:36+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java集合框架图"><a href="#java集合框架图" class="headerlink" title="java集合框架图"></a>java集合框架图</h1><p>java集合框架图</p>
<p><img src="https://img-blog.csdnimg.cn/20190606105558630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Java集合的类结构图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-8af2a357fe900055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>java集合继承关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20190607095910509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。</p>
<p>简单来看，Collection代表的是单个元素对象的序列，（可以有序/无序，可重复/不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代表的是“键值对”对象的集合（同样可以有序/无序 等依据具体实现）</p>
<ul>
<li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li>
<li>Set：无序，不可重复；</li>
<li>Map：键值对，键唯一，值多个；</li>
</ul>
<h1 id="Collection-集合接口"><a href="#Collection-集合接口" class="headerlink" title="Collection 集合接口"></a>Collection 集合接口</h1><p>Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。有些容器允许重复元素有的不允许，有些有序有些无需。由Collection接口派生的两个接口是List和Set。这个接口的设计目的是希望能最大程度抽象出元素的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型即该Collection中元素对象的类型，继承的Iterable是定义的一个遍历操作接口，采用hasNext next的方式进行遍历。具体实现还是放在具体类中去实现。</p>
<p>主要方法</p>
<ul>
<li>boolean add(Object o) 添加对象到集合</li>
<li>boolean remove(Object o) 删除指定的对象</li>
<li>int size() 返回当前集合中元素的数量</li>
<li>boolean contains(Object o) 查找集合中是否有指定的对象</li>
<li>boolean isEmpty() 判断集合是否为空</li>
<li>Iterator iterator() 返回一个迭代器</li>
<li>boolean containsAll(Collection c) 查找集合中是否有集合c中的元素</li>
<li>boolean addAll(Collection c) 将集合c中所有的元素添加给该集合</li>
<li>void clear() 删除集合中所有元素</li>
<li>void removeAll(Collection c) 从集合中删除c集合中也有的元素</li>
<li>void retainAll(Collection c) 从集合中删除集合c中不包含的元素</li>
</ul>
<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><p>List是一个允许重复元素的指定索引、有序集合。</p>
<p>从List接口的方法来看，List接口增加了面向位置的操作，允许在指定位置上操作元素。用户可以使用这个接口精准掌控元素插入，还能够使用索引index（元素在List中的位置，类似于数组下标）来访问List中的元素。List接口有两个重要的实现类：ArrayList和LinkedList。</p>
<p><strong>Set里面和List最大的区别是Set里面的元素对象不可重复。</strong></p>
<h3 id="ArrayList-数组"><a href="#ArrayList-数组" class="headerlink" title="ArrayList 数组"></a>ArrayList 数组</h3><p>ArrayList的底层数据结构就是一个数组，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。默认列表长度10，也可以自己指定长度。ArrayList中的对象数组的最大数组容量为Integer.MAX_VALUE – 8。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>ArrayList实现了List接口的可变大小的数组。（数组可动态创建，如果元素个数超过数组容量，那么就创建一个更大的新数组）</li>
<li>它允许所有元素，包括null</li>
<li>它的size, isEmpty, get, set, iterator,add这些方法的时间复杂度是O(1),如果add n个数据则时间复杂度是O(n)</li>
<li>ArrayList没有同步方法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。</li>
<li>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。</li>
<li>根据下标遍历元素，效率高。</li>
<li>根据下标访问元素，效率高。</li>
<li>可以自动扩容，默认为每次扩容为原来的1.5倍。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>插入和删除元素的效率不高。</li>
<li>根据元素下标查找元素需要遍历整个元素数组，效率不高。</li>
<li>线程不安全。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>Boolean add(Object o)将指定元素添加到列表的末尾</li>
<li>Boolean add(int index,Object element)在列表中指定位置加入指定元素</li>
<li>Boolean addAll(Collection c)将指定集合添加到列表末尾</li>
<li>Boolean addAll(int index,Collection c)在列表中指定位置加入指定集合</li>
<li>Boolean clear()删除列表中所有元素</li>
<li>Boolean clone()返回该列表实例的一个拷贝</li>
<li>Boolean contains(Object o)判断列表中是否包含元素</li>
<li>Boolean ensureCapacity(int m)增加列表的容量,如果必须,该列表能够容纳m个元素</li>
<li>Object get(int index)返回列表中指定位置的元素</li>
<li>Int indexOf(Object elem)在列表中查找指定元素的下标</li>
<li>Int size()返回当前列表的元素个数</li>
</ul>
<h4 id="常见源码分析"><a href="#常见源码分析" class="headerlink" title="常见源码分析"></a>常见源码分析</h4><h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">        elementData[size++] &#x3D; e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 确认能否装得下size+1的对象</span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;计算容量</span><br><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是默认长度，就比较默认长度和size+1,取最大值</span><br><span class="line">        if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        return minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        &#x2F;&#x2F;如果容量大于数组的长度</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            &#x2F;&#x2F;扩容</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F;取数组的长度</span><br><span class="line">        int oldCapacity &#x3D; elementData.length;</span><br><span class="line">        &#x2F;&#x2F;计算新长度，新长度&#x3D;旧长度+旧长度&#x2F;2</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity &#x3D; minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">        &#x2F;&#x2F;最后按照新容量进行扩容，复制。</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在add()方法中主要完成了三件事：首先确保能够将希望添加到集合中的元素能够添加到集合中，即确保ArrayList的容量（判断是否需要扩容）；然后将元素添加到elementData数组的指定位置；最后将集合中实际的元素个数加1。</p>
<p>ArrayList的实际默认容量直到调用add()方法才会真正扩容到10，这里通过new ArrayList（）在内存分配的是一个空数组，并没有直接new Object[10],这样设计是很巧妙的，可以节省很多空间。</p>
<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F;判断是否越界</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">   &#x2F;&#x2F; 重新复制数组，把index+1位置往后的对象全部后移</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       &#x2F;&#x2F;覆盖index位置的对象                 </span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的指定位置添加对象方法，需要把指定位置后面的全部对象后移，所以这样也是ArrayList相对于linkList添加耗时的地方。</p>
<h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     return elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList的get(int index) 方法比较简单，只有两步，第一，检查是否越界，第二，返回数组索引位置的数据。</p>
<h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;父类的属性，用来记录list修改的次数，后续迭代器中会用到</span><br><span class="line">      modCount++;</span><br><span class="line">      E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">      int numMoved &#x3D; size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">      &#x2F;&#x2F;把index位置后面的元素左移</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的remove（int index）方法主要分为 3步:</p>
<ul>
<li>第一步，判断下标是否越界</li>
<li>第二步，记录修改次数，并左移index位置后面的元素，</li>
<li>第三，把最后位置赋值为null，用于快速垃圾回收。</li>
</ul>
<h4 id="for循环问题"><a href="#for循环问题" class="headerlink" title="for循环问题"></a>for循环问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; new ArrayList&lt;&gt;(5);</span><br><span class="line">     integers.add(1);</span><br><span class="line">     integers.add(2);</span><br><span class="line">     integers.add(3);</span><br><span class="line">     integers.add(4);</span><br><span class="line">     integers.add(5);</span><br><span class="line"></span><br><span class="line">     for (int i &#x3D; 0; i &lt; integers.size(); i++) &#123;</span><br><span class="line">         integers.remove(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(integers.size());</span><br></pre></td></tr></table></figure>

<p>这里首先申明一个长度为5的ArrayList的集合，然后添加五个元素，最后通过循环遍历删除，理论结果输出0，但是输出的结果却是2，为什么呢？之前分析remove源码我们知道，ArrayList每删除一次就会把后面的全部元素左移，以这5个元素为例，第一个正常删除没问题，删除后，元素就只剩下[2,3,4,5],这个时候remove(1),还剩[2,4,5],再remove(2),剩下[2,4],后面再remove没有元素了，所以最后size为2。</p>
<h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a>LinkedList 链表</h3><p><strong><code>LinkedList</code> 保存链表的第一个节点和最后一个节点,每个节点上有三个字段：当前节点的数据字段（data）,指向上一个节点的字段（prev），和指向下一个节点的字段（next）。</strong></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p><strong><code>LinkedList</code> 集合底层实现的数据结构为双向链表</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 集合中元素允许为 null</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 允许存入重复的数据</strong></p>
</li>
<li><p><strong><code>LinkedList</code> 中元素存放顺序为插入顺序。</strong></p>
</li>
<li><p><code>LinkedList</code>实现<code>Deque</code>接口使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<ul>
<li><strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong></li>
<li><strong>当<code>Deque</code> 作为栈使用的时候，遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的</strong>。</li>
</ul>
</li>
<li><p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。</p>
</li>
<li><p>分配内存空间不是连续的。</p>
</li>
<li><p>插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；</p>
</li>
<li><p>访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；</p>
</li>
</ul>
<h4 id="结点定义（双向链表）"><a href="#结点定义（双向链表）" class="headerlink" title="结点定义（双向链表）"></a>结点定义（双向链表）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前节点的元素值</span><br><span class="line">   E item;</span><br><span class="line">   &#x2F;&#x2F; 下一个节点的索引</span><br><span class="line">   Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; 上一个节点的索引</span><br><span class="line">   Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">       this.item &#x3D; element;</span><br><span class="line">       this.next &#x3D; next;</span><br><span class="line">       this.prev &#x3D; prev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h4><p>每个LinkedList中会持有链表的头指针和尾指针,LinkedList 主要成员变量有下边三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedList 中的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的第一个节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">&#x2F;&#x2F;LinkedList 链表的最后一个节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p>之所以 LinkedList 要保存链表的第一个节点和最后一个节点是因为，我们都知道，链表数据结构相对于数组结构， 优点在于增删，缺点在于查找。如果我们保存了LinkedList 的头尾两端，当我们需要以索引来查找节点的时候，我们可以根据 <code>index</code> 和 <code>size/2</code> 的大小,来决定从头查找还是从尾部查找，这也算是一定程度上弥补了单链表数据结构的缺点。</p>
<h4 id="LinkedList-的构造函数"><a href="#LinkedList-的构造函数" class="headerlink" title="LinkedList 的构造函数"></a>LinkedList 的构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空参数的构造由于生成一个空链表 first &#x3D; last &#x3D; null</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入一个集合类，来构造一个具有一定元素的 LinkedList 集合</span><br><span class="line"> * @param  c  其内部的元素将按顺序作为 LinkedList 节点</span><br><span class="line"> * @throws NullPointerException 如果 参数 collection 为空将抛出空指针异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   this();</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在 index 节点前插入包含所有 c 集合元素的节点。</span><br><span class="line"> * 返回值表示是否成功添加了对应的元素.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   &#x2F;&#x2F; 查看索引是否满足 0 &#x3D;&lt; index &#x3D;&lt; size 的要求</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 调用对应 Collection 实现类的 toArray 方法将集合转为数组</span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   &#x2F;&#x2F;检查数组长度，如果为 0 则直接返回 false 表示没有添加任何元素</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">       return false;</span><br><span class="line">   &#x2F;&#x2F; 保存 index 当前的节点为 succ，当前节点的上一个节点为 pred</span><br><span class="line">   Node&lt;E&gt; pred, succ;</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 表示在链表尾部插入</span><br><span class="line">   if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">       succ &#x3D; null;</span><br><span class="line">       pred &#x3D; last;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       succ &#x3D; node(index);</span><br><span class="line">       pred &#x3D; succ.prev;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历数组将对应的元素包装成节点添加到链表中</span><br><span class="line">   for (Object o : a) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">       Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">       &#x2F;&#x2F;如果 pred 为空表示 LinkedList 集合中还没有元素</span><br><span class="line">       &#x2F;&#x2F;生成的第一个节点将作为头节点 赋值给 first 成员变量</span><br><span class="line">       if (pred &#x3D;&#x3D; null)</span><br><span class="line">           first &#x3D; newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next &#x3D; newNode;</span><br><span class="line">       pred &#x3D; newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果 index 位置的元素为 null 则遍历数组后 pred 所指向的节点即为新链表的末节点，赋值给 last 成员变量</span><br><span class="line">   if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; pred;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 否则将 pred 的 next 索引指向 succ ，succ 的 prev 索引指向 pred</span><br><span class="line">       pred.next &#x3D; succ;</span><br><span class="line">       succ.prev &#x3D; pred;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 更新当前链表的长度 size 并返回 true 表示添加成功</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   modCount++;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 批量添加节点的实现。大体分下面几个步骤：</p>
<ul>
<li>检查索引值是否合法，不合法将抛出角标越界异常</li>
<li>保存 index 位置的节点，和 index-1 位置的节点。</li>
<li>将参数集合转化为数组，循环将数组中的元素封装为节点添加到链表中。</li>
<li>更新链表长度并返回添加 true 表示添加成功。</li>
</ul>
<p>越界检查最后都调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean isPositionIndex(int index) &#123;</span><br><span class="line">        return index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-添加节点的方法"><a href="#LinkedList-添加节点的方法" class="headerlink" title="LinkedList 添加节点的方法"></a>LinkedList 添加节点的方法</h4><p>LinkedList 作为链表数据结构的实现，不同于数组，它可以方便的在头尾插入一个节点，而 add 方法默认在链表尾部添加节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Inserts the specified element at the beginning of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>添加方法默认调用<code>linkLast</code>添加到最后一个节点。</p>
<h5 id="linkXXX-方法：linkFirst、linkLast"><a href="#linkXXX-方法：linkFirst、linkLast" class="headerlink" title="linkXXX 方法：linkFirst、linkLast"></a><code>linkXXX</code> 方法：<code>linkFirst、linkLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 添加一个元素在链表的头节点位置</span><br><span class="line">  *&#x2F;</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加元素之前的头节点</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   &#x2F;&#x2F;以添加的元素为节点值构建新的头节点 并将 next 指针指向 之前的头节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">   &#x2F;&#x2F; first 索引指向将新的节点</span><br><span class="line">   first &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果添加之前链表空则新的节点也作为未节点</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       last &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       f.prev &#x3D; newNode;&#x2F;&#x2F;否则之前头节点的 prev 指针指向新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 在链表末尾添加一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> void linkLast(E e) &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F;保存之前的未节点</span><br><span class="line">   &#x2F;&#x2F;构建新的未节点，并将新节点 prev 指针指向 之前的未节点</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">   &#x2F;&#x2F;last 索引指向末节点</span><br><span class="line">   last &#x3D; newNode;</span><br><span class="line">   if (l &#x3D;&#x3D; null)&#x2F;&#x2F;如果之前链表为空则新节点也作为头节点</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else&#x2F;&#x2F;否则将之前的未节点的 next 指针指向新节点</span><br><span class="line">       l.next &#x3D; newNode;</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;&#x2F;&#x2F;操作数++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-int-index-E-element-、addAll"><a href="#add-int-index-E-element-、addAll" class="headerlink" title="add(int index, E element)、addAll"></a>add(int index, E element)、addAll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在指定 index 位置插入节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 检查角标是否越界</span><br><span class="line">   checkPositionIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 如果 index &#x3D; size 代表是在尾部插入节点</span><br><span class="line">   if (index &#x3D;&#x3D; size)</span><br><span class="line">       linkLast(element);</span><br><span class="line">   else</span><br><span class="line">       linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="node-index-方法的实现"><a href="#node-index-方法的实现" class="headerlink" title="node(index) 方法的实现"></a>node(index) 方法的实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回一个非空节点，这个非空节点位于 index 位置</span><br><span class="line"> *&#x2F;</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line">    &#x2F;&#x2F; 如果 index &lt; size&#x2F;2 则从0开始寻找指定角标的节点</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果 index &gt;&#x3D; size&#x2F;2 则从 size-1 开始寻找指定角标的节点</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会疑惑为什么这里注释为返回一个非空节点？其实仔细想下就明白了，这里的节点一定不为 null，如果一开始链表为空的时候，index 为 0 的位置肯定为 null，为什么不会产生异常情况呢？其实如果一开始链表中没有元素 size = 0，如果我们向 <code>index = 0</code> 的位置添加元素是不会走到 else 中的，而是会调用 <code>linkLast(element);</code> 方法去添加元素。 因此<strong>node 方法可以用于根据指定 index 去以 size/2 为界限搜索index 位置的 Node;</strong></p>
<h6 id="linkBefore-E-e-Node-succ-实现"><a href="#linkBefore-E-e-Node-succ-实现" class="headerlink" title="linkBefore(E e, Node succ)实现"></a>linkBefore(E e, Node<E> succ)实现</h6><p>为什么要叫做 linkBefore 呢，因为在链表的中间位置添加节点，其实就是将 index 原来的节点前添加一个节点，添加节点我们需要知道该节点的前一个节点和当前节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; 由于 succ 一定不为空，所以可以直接获取 prev 节点</span><br><span class="line">   final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">   &#x2F;&#x2F; 新节点 prev 节点为 pred，next 节点为 succ</span><br><span class="line">   final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">   &#x2F;&#x2F; 原节点的 prev 指向新节点</span><br><span class="line">   succ.prev &#x3D; newNode;</span><br><span class="line">   &#x2F;&#x2F; 如果 pred 为空即头节点出插入了一个节点，则将新的节点赋值给 first 索引</span><br><span class="line">   if (pred &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; newNode;</span><br><span class="line">   else</span><br><span class="line">       pred.next &#x3D; newNode;&#x2F;&#x2F;否则 pred 的下一个节点改为新节点</span><br><span class="line">   size++;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将构造的新节点前指针 prev 指向 index 的前一个元素，</p>
</li>
<li><p>新节点前指针 next 指针指向 index 位置的节点，</p>
</li>
<li><p>index 位置节点 prev 指针指向新节点</p>
</li>
<li><p>index 位置前节点（pred）的 next 指针指向新节点</p>
</li>
</ul>
<h4 id="LinkedList-删除节点的方法"><a href="#LinkedList-删除节点的方法" class="headerlink" title="LinkedList 删除节点的方法"></a>LinkedList 删除节点的方法</h4><h5 id="removeFirst、removeLast"><a href="#removeFirst、removeLast" class="headerlink" title="removeFirst、removeLast"></a><code>removeFirst</code>、<code>removeLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  删除头节点</span><br><span class="line"> * @return 删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  删除尾节点</span><br><span class="line"> *</span><br><span class="line"> * @return  删除的节点的值 即 节点的 element</span><br><span class="line"> * @throws NoSuchElementException  如果链表为空则抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="unlinkFirst、unlinkLast"><a href="#unlinkFirst、unlinkLast" class="headerlink" title="unlinkFirst、unlinkLast"></a><code>unlinkFirst</code>、<code>unlinkLast</code></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 移除头节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 头节点的 element 这里作为返回值使用</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    &#x2F;&#x2F; 头节点下个节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    &#x2F;&#x2F; 释放头节点的 next 指针，和 element 下次 gc 的时候回收这个内部类</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F; 将 first 索引指向新的节点</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    &#x2F;&#x2F; 如果 next 节点为空，即链表只有一个节点的时候，last 指向 null</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;否则 next 的 prev 指针指向 null</span><br><span class="line">    size--;&#x2F;&#x2F;改变链表长度</span><br><span class="line">    modCount++;&#x2F;&#x2F;修改操作数</span><br><span class="line">    return element;&#x2F;&#x2F;返回删除节点的值</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 移除未节点</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    &#x2F;&#x2F;未节点的前一个节点，</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    &#x2F;&#x2F;释放未节点的内容</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    &#x2F;&#x2F;将 last 索引指向新的未节点</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    &#x2F;&#x2F; 链表只有一个节点的时候，first 指向 null</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">       first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刚才已经分析过node(index)方法了，就是找到index位置的节点。</p>
<h6 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Unlinks non-null node x.</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">   &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">   final E element &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F;保存 index 节点的前后两个节点</span><br><span class="line">   final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">   final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为头节点，则做 unlinkFirst 相同操作</span><br><span class="line">   if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">       first &#x3D; next;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则将上一个节点的 next 指针指向下个节点</span><br><span class="line">       prev.next &#x3D; next;</span><br><span class="line">       &#x2F;&#x2F; 释放 index 位置 prev 指针</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果节点为尾节点，则将 last 索引指向上个节点</span><br><span class="line">   if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">       last &#x3D; prev;</span><br><span class="line">   &#125; else &#123;&#x2F;&#x2F;否则下个节点 prev 指针指向上个节点</span><br><span class="line">       next.prev &#x3D; prev;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   x.item &#x3D; null;</span><br><span class="line">   size--;</span><br><span class="line">   modCount++;</span><br><span class="line">   return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完 <code>unlink</code> 操作结合之前说的 <code>node(index)</code>，下边两种删除节点的操作，就很好理解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定索引位置的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *删除从头节点其第一个与 o 相同的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F; 区别对待 null 元素，比较元素时候使用 &#x3D;&#x3D; 而不是 equals</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item)) &#123;</span><br><span class="line">               unlink(x);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完单个删除节点的方法 LinkedList 实现了 List 接口的 clear 操作，用于删除链表所有的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Removes all of the elements from this list.</span><br><span class="line">* The list will be empty after this call returns.</span><br><span class="line">*&#x2F;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">   &#x2F;&#x2F; 依次清除节点，帮助释放内存空间</span><br><span class="line">   for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">       Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">       x.item &#x3D; null;</span><br><span class="line">       x.next &#x3D; null;</span><br><span class="line">       x.prev &#x3D; null;</span><br><span class="line">       x &#x3D; next;</span><br><span class="line">   &#125;</span><br><span class="line">   first &#x3D; last &#x3D; null;</span><br><span class="line">   size &#x3D; 0;</span><br><span class="line">   modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-查询节点的方法"><a href="#LinkedList-查询节点的方法" class="headerlink" title="LinkedList 查询节点的方法"></a>LinkedList 查询节点的方法</h4><p>LinkedList 查询节点的方法，可分为根据指定的索引查询，获取头节点，获取未节点三种。值得注意的是，根据索引去获取节点内容的效率并不高，所以如果查询操作多余增删操作的时候建议用 <code>ArrayList</code> 去替代。</p>
<h5 id="get-int-index-、getFirst-、getLast"><a href="#get-int-index-、getFirst-、getLast" class="headerlink" title="get(int index)、getFirst() 、getLast"></a><code>get(int index)、getFirst() 、getLast</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 根据索引查询</span><br><span class="line">*</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 first 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the first element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 返回 last 索引指向的节点的内容</span><br><span class="line">*</span><br><span class="line">* @return the last element in this list</span><br><span class="line">* @throws NoSuchElementException 如果链表为空则抛出异常</span><br><span class="line">*&#x2F;</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">   final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">   if (l &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="indexOf-Object-o-、lastIndexOf-Object-o"><a href="#indexOf-Object-o-、lastIndexOf-Object-o" class="headerlink" title="indexOf(Object o)、lastIndexOf(Object o)"></a><code>indexOf(Object o)、lastIndexOf(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">* 返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**头节点**起的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">* </span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return </span><br><span class="line">*&#x2F;</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 区别对待 null 元素，用 &#x3D;&#x3D; 判断，非空元素用 equels 方法判断 </span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">**返回参数元素在链表的节点索引，如果有重复元素，那么返回值为从**尾节点起**的第一相同的元素节点索引，</span><br><span class="line">* 如果没有值为该元素的节点，则返回 -1；</span><br><span class="line">*</span><br><span class="line">* @param o element to search for</span><br><span class="line">* @return the index of the last occurrence of the specified element in</span><br><span class="line">*         this list, or -1 if this list does not contain the element</span><br><span class="line">*&#x2F;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">   int index &#x3D; size;</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (x.item &#x3D;&#x3D; null)</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">           index--;</span><br><span class="line">           if (o.equals(x.item))</span><br><span class="line">               return index;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法分别返回从<strong>头节点起</strong>第一个与参数元素相同的节点索引，和从<strong>尾节点起</strong>第一个与参数元素相同的节点索引。</p>
<h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a><code>contains(Object o)</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) !&#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 indexOf 从头结点开始查询元素位置遍历完成后若 返回值 !=-1 则表示存在，反之不存在</p>
<h4 id="LinkedList-的修改节点方法"><a href="#LinkedList-的修改节点方法" class="headerlink" title="LinkedList 的修改节点方法"></a>LinkedList 的修改节点方法</h4><p><code>LinkedList</code> 只提供了 <code>set(int index, E element)</code> 一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">   &#x2F;&#x2F; 判断角标是否越界</span><br><span class="line">   checkElementIndex(index);</span><br><span class="line">   &#x2F;&#x2F; 采用 node 方法查找对应索引的节点</span><br><span class="line">   Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">   &#x2F;&#x2F;保存节点原有的内容值</span><br><span class="line">   E oldVal &#x3D; x.item;</span><br><span class="line">   &#x2F;&#x2F; 设置新值</span><br><span class="line">   x.item &#x3D; element;</span><br><span class="line">   &#x2F;&#x2F; 返回旧的值</span><br><span class="line">   return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-作为双向队列的增删改查"><a href="#LinkedList-作为双向队列的增删改查" class="headerlink" title="LinkedList 作为双向队列的增删改查"></a>LinkedList 作为双向队列的增删改查</h4><p><code>LinkedList</code>实现<code>Deque</code>接口，可实现双向队列。</p>
<h5 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h5><p><code>Queue</code> 是一个队列，遵循 FIFO 准则，我们也知道 <code>Stack</code> 是一个栈结构，遵循 FILO 准则。 而<code>Deque</code> 这个双端队列就厉害了,它既可以实现栈的操作，也可以实现队列的操作，换句话说，实现了这个接口的类，既可以作为栈使用也可以作为队列使用。</p>
<p>Deque接口中的方法:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">头部</th>
<th align="center">头部</th>
<th align="center">尾部</th>
<th align="center">尾部</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="center">addFirst(e)</td>
<td align="center">offerFirst(e)</td>
<td align="center">addLast(e)</td>
<td align="center">offerLast(e)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="center">removeFirst()</td>
<td align="center">pollFirst()</td>
<td align="center">remveLast()</td>
<td align="center">pollLast</td>
</tr>
<tr>
<td align="left">获取</td>
<td align="center">getFirst()</td>
<td align="center">peekFirst()</td>
<td align="center">getLast()</td>
<td align="center">peekLast</td>
</tr>
</tbody></table>
<p>由于 <code>Deque</code> 接口继承 <code>Queue</code> 接口，<strong>当 <code>Deque</code> 当做队列使用时（FIFO），只需要在头部删除，尾部添加即可</strong>。我们现在复习下 <code>Queue</code> 中的方法及区别：</p>
<ul>
<li><code>Queue</code> 的 <code>offer</code> 和 <code>add</code> 都是在队列中插入一个元素，具体区别在于，对于一些 Queue 的实现的队列是有大小限制的，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。此时调用 <code>add()</code>方法会抛出异常，而 <code>offer()</code> 只是返回的 false。</li>
<li><code>remove()</code> 和 <code>poll()</code> 方法都是从队列中删除第一个元素。remove()也将抛出异常，而 <code>poll()</code> 则会返回 <code>null</code></li>
<li><code>element()</code> 和 <code>peek()</code> 用于在队列的头部查询元素。在队列为空时， <code>element()</code> 抛出一个异常，而 <code>peek()</code> 返回 <code>null</code>。</li>
</ul>
<h5 id="Deque-和-Queue-添加元素的方法"><a href="#Deque-和-Queue-添加元素的方法" class="headerlink" title="Deque 和 Queue 添加元素的方法"></a>Deque 和 Queue 添加元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">   linkLast(e);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; queue 的添加方法实现，</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">   return add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的添加方法实现，</span><br><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提及到 <code>Queue</code>的 <code>offer</code> 和 <code>add</code> 的区别针对容量有限制的实现，很明显 <code>LinkedList</code> 的大小并没有限制，所以在 <code>LinkedList</code> 中他们的实现并没有实质性不同。</p>
<h5 id="Deque-和-Queue-删除元素的方法"><a href="#Deque-和-Queue-删除元素的方法" class="headerlink" title="Deque 和 Queue 删除元素的方法"></a>Deque 和 Queue 删除元素的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 removeFirst 会抛出 NoSuchElement 异常</span><br><span class="line">public E remove() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 的删除方法实现</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Queue 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E poll() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 删除元素的实现 不会抛出异常 如果链表为空则返回 null </span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deque-和-Queue-获取队列头部元素的实现"><a href="#Deque-和-Queue-获取队列头部元素的实现" class="headerlink" title="Deque 和 Queue 获取队列头部元素的实现"></a>Deque 和 Queue 获取队列头部元素的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line"> public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候回抛出异常</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   if (f &#x3D;&#x3D; null)</span><br><span class="line">       throw new NoSuchElementException();</span><br><span class="line">   return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Queue 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deque 获取队列头部的实现 队列为空的时候返回 null</span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">   final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">   return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述我们分析了，双端队列作为队列使用的时候的各个方法的区别，也可是看出 <code>LinkedList</code> 对对应方法的实现，遵循了队列设计原则。</p>
<h4 id="LinkedList作为Stack-使用"><a href="#LinkedList作为Stack-使用" class="headerlink" title="LinkedList作为Stack`使用"></a>LinkedList<code>作为</code>Stack`使用</h4><p>下面我们来看看下双端队列作为栈 <code>Stack</code>使用的时候方法对应关系，与 <code>Queue</code> 不同，<code>Stack</code> 本身就是实现类，他拥有 FILO 的原则， <code>Stack</code> 的入栈操作通过 <code>push</code> 方法进行，出栈操作通过 <code>pop</code> 方法进行，查询操作通过 <code>peek</code> 操作进行。 <strong><code>Deque</code> 作为栈使用的时候，也遵循 FILO 准则，入栈和出栈是通过添加和移除头节点实现的。</strong></p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFist(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><code>LinkedList</code>中的<code>push</code>、<code>pop</code>、<code>peek</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void push(E e) &#123;</span><br><span class="line">   addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pop() &#123;</span><br><span class="line">   return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList-的遍历"><a href="#LinkedList-的遍历" class="headerlink" title="LinkedList 的遍历"></a>LinkedList 的遍历</h4><p>在 <code>ArrayList</code> 分析的时候，我们就知道 <code>List</code> 的实现类，有4中遍历方式：for 循环，高级 for 循环，<code>Iterator</code> 迭代器方法， <code>ListIterator</code> 迭代方法。</p>
<p><code>LinkedList</code> 没有单独 <code>Iterator</code> 实现类，它的 <code>iterator</code> 和 <code>listIterator</code> 方法均返回 <code>ListItr</code>的一个对象。 LinkedList 作为双向链表数据结构，获取上个元素和下个元素很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 上一个遍历的节点</span><br><span class="line">   private Node&lt;E&gt; lastReturned;</span><br><span class="line">   &#x2F;&#x2F; 下一次遍历返回的节点</span><br><span class="line">   private Node&lt;E&gt; next;</span><br><span class="line">   &#x2F;&#x2F; cursor 指针下一次遍历返回的节点</span><br><span class="line">   private int nextIndex;</span><br><span class="line">   &#x2F;&#x2F; 期望的操作数</span><br><span class="line">   private int expectedModCount &#x3D; modCount;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; 根据参数 index 确定生成的迭代器 cursor 的位置</span><br><span class="line">   ListItr(int index) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert isPositionIndex(index);</span><br><span class="line">       &#x2F;&#x2F; 如果 index &#x3D;&#x3D; size 则 next 为 null 否则寻找 index 位置的节点</span><br><span class="line">       next &#x3D; (index &#x3D;&#x3D; size) ? null : node(index);</span><br><span class="line">       nextIndex &#x3D; index;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 判断指针是否还可以移动</span><br><span class="line">   public boolean hasNext() &#123;</span><br><span class="line">       return nextIndex &lt; size;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F; 返回下一个带遍历的元素</span><br><span class="line">  public E next() &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查操作数是否合法</span><br><span class="line">       checkForComodification();</span><br><span class="line">       &#x2F;&#x2F; 如果 hasNext 返回 false 抛出异常，所以我们在调用 next 前应先调用 hasNext 检查</span><br><span class="line">       if (!hasNext())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 移动 lastReturned 指针</span><br><span class="line">       lastReturned &#x3D; next;</span><br><span class="line">        &#x2F;&#x2F; 移动 next 指针</span><br><span class="line">       next &#x3D; next.next;</span><br><span class="line">       &#x2F;&#x2F; 移动 nextIndex cursor</span><br><span class="line">       nextIndex++;</span><br><span class="line">       &#x2F;&#x2F; 返回移动后 lastReturned</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前游标位置是否还有前一个元素</span><br><span class="line">   public boolean hasPrevious() &#123;</span><br><span class="line">       return nextIndex &gt; 0;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 当前游标位置的前一个元素</span><br><span class="line">   public E previous() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (!hasPrevious())</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">        &#x2F;&#x2F; 等同于 lastReturned &#x3D; next；next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">        &#x2F;&#x2F; 发生在 index &#x3D; size 时</span><br><span class="line">       lastReturned &#x3D; next &#x3D; (next &#x3D;&#x3D; null) ? last : next.prev;</span><br><span class="line">       nextIndex--;</span><br><span class="line">       return lastReturned.item;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public int nextIndex() &#123;</span><br><span class="line">       return nextIndex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int previousIndex() &#123;</span><br><span class="line">       return nextIndex - 1;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 删除链表当前节点也就是调用 next&#x2F;previous 返回的这节点，也就 lastReturned</span><br><span class="line">   public void remove() &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">       Node&lt;E&gt; lastNext &#x3D; lastReturned.next;</span><br><span class="line">       &#x2F;&#x2F;调用LinkedList 的删除节点的方法</span><br><span class="line">       unlink(lastReturned);</span><br><span class="line">       if (next &#x3D;&#x3D; lastReturned)</span><br><span class="line">           next &#x3D; lastNext;</span><br><span class="line">       else</span><br><span class="line">           nextIndex--;</span><br><span class="line">       &#x2F;&#x2F;上一次所操作的 节点置位空    </span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置当前遍历的节点的值</span><br><span class="line">   public void set(E e) &#123;</span><br><span class="line">       if (lastReturned &#x3D;&#x3D; null)</span><br><span class="line">           throw new IllegalStateException();</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned.item &#x3D; e;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 在 next 节点位置插入及节点</span><br><span class="line">   public void add(E e) &#123;</span><br><span class="line">       checkForComodification();</span><br><span class="line">       lastReturned &#x3D; null;</span><br><span class="line">       if (next &#x3D;&#x3D; null)</span><br><span class="line">           linkLast(e);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(e, next);</span><br><span class="line">       nextIndex++;</span><br><span class="line">       expectedModCount++;</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F;简单哈操作数是否合法</span><br><span class="line">   final void checkForComodification() &#123;</span><br><span class="line">       if (modCount !&#x3D; expectedModCount)</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>链表LinkedList和数组ArrayList的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同。实际使用时根据特定的需求选用合适的类。</p>
<ul>
<li><p>ArrayList基于数组；LinkedList基于双向链表。</p>
</li>
<li><p>查找方面。数组的效率更高，可以直接索引出查找；而链表必须从头查找。</p>
</li>
<li><p>插入删除方面。特别是在中间进行插入删除，这时候链表体现出了极大的便利性，只需要在插入或者删除的地方断掉链然后插入或者移除元素，然后再将前后链重新组装；但是数组必须重新复制一份将所有数据后移或者前移。</p>
</li>
<li><p>在内存申请方面，当数组达到初始的申请长度后，需要重新申请一个更大的数组然后把数据迁移过去才行。而链表只需要动态创建即可。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190607102647638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Vector-向量"><a href="#Vector-向量" class="headerlink" title="Vector 向量"></a>Vector 向量</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/" itemprop="url">第一次测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-29T23:03:36+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8B%E8%AF%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标题"><a href="#这是一个三级标题" class="headerlink" title="这是一个三级标题"></a>这是一个三级标题</h3><h4 id="这是一个司机标题"><a href="#这是一个司机标题" class="headerlink" title="这是一个司机标题"></a>这是一个司机标题</h4><h5 id="这是一个五级标题"><a href="#这是一个五级标题" class="headerlink" title="这是一个五级标题"></a>这是一个五级标题</h5><h6 id="这是一个六级标题"><a href="#这是一个六级标题" class="headerlink" title="这是一个六级标题"></a>这是一个六级标题</h6><p>####### 有没有七级标题</p>
<p><strong>加粗</strong></p>
<p><em>斜体</em></p>
<p><strong><em>斜体加粗</em></strong></p>
<p><del>删除线</del></p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>正文<br>    段落没有啊</p>
<ul>
<li><ol>
<li>第一点</li>
</ol>
</li>
<li><ol start="2">
<li>第二点</li>
</ol>
</li>
<li><ol start="3">
<li>第三点</li>
</ol>
</li>
</ul>
<p>分割线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<hr>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-29T18:48:29+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/29/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/29/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
