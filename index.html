<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:type" content="website">
<meta property="og:title" content="冯星的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="冯星的博客">
<meta property="og:description" content="人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="冯星">
<meta property="article:tag" content="Java，Android，Flutter">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>冯星的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冯星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Life is like a Markov chain, your future only depends on what you are doing now, and independent of your past.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/" itemprop="url">Android进程创建流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-26T13:53:34+08:00">
                2020-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/26/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android进程创建流程"><a href="#Android进程创建流程" class="headerlink" title="Android进程创建流程"></a>Android进程创建流程</h1><h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</span><br><span class="line">    - ZygoteInit.java</span><br><span class="line">    - ZygoteConnection.java</span><br><span class="line">    - RuntimeInit.java</span><br><span class="line">    - Zygote.java</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Process.java</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;com_android_internal_os_Zygote.cpp</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;App_main.cpp （内含AppRuntime类）</span><br><span class="line"></span><br><span class="line">&#x2F;bionic&#x2F;libc&#x2F;bionic&#x2F;fork.cpp</span><br><span class="line">&#x2F;bionic&#x2F;libc&#x2F;bionic&#x2F;pthread_atfork.cpp</span><br><span class="line"></span><br><span class="line">&#x2F;libcore&#x2F;dalvik&#x2F;src&#x2F;main&#x2F;java&#x2F;dalvik&#x2F;system&#x2F;ZygoteHooks.java</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;native&#x2F;dalvik_system_ZygoteHooks.cc</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;Runtime.cc</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;Thread.cc</span><br><span class="line">&#x2F;art&#x2F;runtime&#x2F;signal_catcher.cc</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程：</strong>每个<code>App</code>在启动前必须先创建一个进程，该进程是由<code>Zygote</code> fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个<code>App</code>就运行在一个进程中，除非在AndroidManifest.xml中配置<code>Android:process</code>属性，或通过native代码fork进程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程：</strong>线程对应用开发者来说非常熟悉，比如每次<code>new Thread().start()</code>都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从Linux角度来说进程与线程都是一个task_struct结构体，除了是否共享资源外，并没有其他本质的区别。</p>
<p>在接下来的文章，会涉及到system_server进程和Zygote进程，下面简要这两个进程：</p>
<ul>
<li><code>system_server</code>进程：是用于管理整个Java framework层，包含ActivityManager，PowerManager等各种系统服务;</li>
<li><code>Zygote</code>进程：是Android系统的首个Java进程，Zygote是所有Java进程的父进程，包括 <code>system_server</code>进程以及所有的App进程都是Zygote的子进程，注意这里说的是子进程，而非子线程。</li>
</ul>
<p>如果想更进一步了解system_server进程和Zygote进程在整个Android系统所处的地位，可查看我的另一个文章<a href="http://gityuan.com/android" target="_blank" rel="noopener">Android系统-开篇</a>。</p>
<h2 id="进程创建图"><a href="#进程创建图" class="headerlink" title="进程创建图"></a>进程创建图</h2><p>对于大多数的应用开发者来说创建线程比较熟悉，而对于创建进程并没有太多的概念。对于系统工程师或者高级开发者，还是有很必要了解Android系统是如何一步步地创建出一个进程的。先来看一张进程创建过程的简要图：</p>
<p><img src="http://gityuan.com/images/android-process/start_app_process.jpg" alt="start_app_process"></p>
<p>图解：</p>
<ol>
<li><strong>App发起进程</strong>：当从桌面启动应用，则发起进程便是Launcher所在进程；当从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过binder发送消息给system_server进程；</li>
<li><strong>system_server进程</strong>：调用Process.start()方法，通过socket向zygote进程发送创建新进程的请求；</li>
<li><strong>zygote进程</strong>：在执行<code>ZygoteInit.main()</code>后便进入<code>runSelectLoop()</code>循环体内，当有客户端连接时便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程；</li>
<li><strong>新进程</strong>：执行handleChildProc方法，最后调用ActivityThread.main()方法。</li>
</ol>
<p>接下来，依次从<code>system_server进程发起请求</code>到<code>Zygote创建进程</code>，再到<code>新进程的运行</code>这3大块展开讲解进程创建是一个怎样的过程。</p>
<h2 id="system-server发起请求"><a href="#system-server发起请求" class="headerlink" title="system_server发起请求"></a>system_server发起请求</h2><h3 id="Process-start"><a href="#Process-start" class="headerlink" title="Process.start"></a>Process.start</h3><p>[-&gt; Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">         &#x2F;&#x2F;【见小节2】</span><br><span class="line">        return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startViaZygote"><a href="#startViaZygote" class="headerlink" title="startViaZygote"></a>startViaZygote</h3><p>[-&gt; Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    synchronized(Process.class) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">        argsForZygote.add(&quot;--setuid&#x3D;&quot; + uid);</span><br><span class="line">        argsForZygote.add(&quot;--setgid&#x3D;&quot; + gid);</span><br><span class="line">        argsForZygote.add(&quot;--target-sdk-version&#x3D;&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        if (niceName !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--nice-name&#x3D;&quot; + niceName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (appDataDir !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--app-data-dir&#x3D;&quot; + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        if (extraArgs !&#x3D; null) &#123;</span><br><span class="line">            for (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         &#x2F;&#x2F;【见小节3】</span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程主要工作是生成<code>argsForZygote</code>数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。</p>
<h3 id="zygoteSendArgsAndGetResult"><a href="#zygoteSendArgsAndGetResult" class="headerlink" title="zygoteSendArgsAndGetResult"></a>zygoteSendArgsAndGetResult</h3><p>[-&gt; Process.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;其中zygoteState 【见小节3.1】</span><br><span class="line">        final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">        final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        int sz &#x3D; args.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg &#x3D; args.get(i);</span><br><span class="line">            if (arg.indexOf(&#39;\n&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(</span><br><span class="line">                        &quot;embedded newlines not allowed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        ProcessStartResult result &#x3D; new ProcessStartResult();</span><br><span class="line">        &#x2F;&#x2F;等待socket服务端（即zygote）返回新创建的进程pid;</span><br><span class="line">        &#x2F;&#x2F;对于等待时长问题，Google正在考虑此处是否应该有一个timeout，但目前是没有的。</span><br><span class="line">        result.pid &#x3D; inputStream.readInt();</span><br><span class="line">        if (result.pid &lt; 0) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。</p>
<h3 id="openZygoteSocketIfNeeded"><a href="#openZygoteSocketIfNeeded" class="headerlink" title="openZygoteSocketIfNeeded"></a>openZygoteSocketIfNeeded</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    if (primaryZygoteState &#x3D;&#x3D; null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;向主zygote发起connect()操作</span><br><span class="line">            primaryZygoteState &#x3D; ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState &#x3D;&#x3D; null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        &#x2F;&#x2F;当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span><br><span class="line">        secondaryZygoteState &#x3D; ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>openZygoteSocketIfNeeded(abi)</code>方法是根据当前的abi来选择与zygote还是zygote64来进行通信。</p>
<p>既然system_server进程的zygoteSendArgsAndGetResult()方法通过socket向Zygote进程发送消息，这是便会唤醒Zygote进程，来响应socket客户端的请求（即system_server端），接下来的操作便是在Zygote来创建进程【见小节4】</p>
<h2 id="Zygote创建进程"><a href="#Zygote创建进程" class="headerlink" title="Zygote创建进程"></a>Zygote创建进程</h2><p>文章<a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Android系统启动-zygote篇</a>已介绍，简单来说就是Zygote进程是由由init进程而创建的，进程启动之后调用ZygoteInit.main()方法，经过创建socket管道，预加载资源后，便进程runSelectLoop()方法。</p>
<h3 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        runSelectLoop(abiList); &#x2F;&#x2F;【见小节5】</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); &#x2F;&#x2F;【见小节16】</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续会讲到runSelectLoop()方法会抛出异常<code>MethodAndArgsCaller</code>，从而进入caller.run()方法。</p>
<h3 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    &#x2F;&#x2F;sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">            pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">            pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">             &#x2F;&#x2F;处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span><br><span class="line">            Os.poll(pollFds, -1);</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；</span><br><span class="line">            &#x2F;&#x2F; 否则进入continue，跳出本次循环。</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；</span><br><span class="line">                &#x2F;&#x2F; 则创建ZygoteConnection对象,并添加到fds。&#x2F;&#x2F;【见小节5.1】</span><br><span class="line">                ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);&#x2F;&#x2F;内部执行accept方法</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor()); &#x2F;&#x2F;添加到fds.</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作【见小节6】</span><br><span class="line">                boolean done &#x3D; peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i); &#x2F;&#x2F;处理完则从fds中移除该文件描述符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要功能：</p>
<ul>
<li>客户端通过openZygoteSocketIfNeeded()来跟zygote进程建立连接。zygote进程收到客户端连接请求后执行accept()；然后再创建ZygoteConnection对象,并添加到fds数组列表；</li>
<li>建立连接之后，可以跟客户端通信，进入runOnce()方法来接收客户端数据，并执行进程创建工作。</li>
</ul>
<h3 id="acceptCommandPeer"><a href="#acceptCommandPeer" class="headerlink" title="acceptCommandPeer"></a>acceptCommandPeer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static ZygoteConnection acceptCommandPeer(String abiList) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return new ZygoteConnection(sServerSocket.accept(), abiList);</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收客户端发送过来的connect()操作，Zygote作为服务端执行accept()操作。 再后面客户端调用write()写数据，Zygote进程调用read()读数据。</p>
<p>没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒Zygote进程，创建Socket通道ZygoteConnection，然后执行ZygoteConnection的runOnce()方法。</p>
<h3 id="runOnce"><a href="#runOnce" class="headerlink" title="runOnce"></a>runOnce</h3><p>[-&gt; ZygoteConnection.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs &#x3D; null;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;读取socket客户端发送过来的参数列表</span><br><span class="line">        args &#x3D; readArgumentList();</span><br><span class="line">        descriptors &#x3D; mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        closeSocket();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintStream newStderr &#x3D; null;</span><br><span class="line">    if (descriptors !&#x3D; null &amp;&amp; descriptors.length &gt;&#x3D; 3) &#123;</span><br><span class="line">        newStderr &#x3D; new PrintStream(new FileOutputStream(descriptors[2]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pid &#x3D; -1;</span><br><span class="line">    FileDescriptor childPipeFd &#x3D; null;</span><br><span class="line">    FileDescriptor serverPipeFd &#x3D; null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;将binder客户端传递过来的参数，解析成Arguments对象格式</span><br><span class="line">        parsedArgs &#x3D; new Arguments(args);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        int [] fdsToClose &#x3D; &#123; -1, -1 &#125;;</span><br><span class="line">        FileDescriptor fd &#x3D; mSocket.getFileDescriptor();</span><br><span class="line">        if (fd !&#x3D; null) &#123;</span><br><span class="line">            fdsToClose[0] &#x3D; fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd &#x3D; ZygoteInit.getServerSocketFileDescriptor();</span><br><span class="line">        if (fd !&#x3D; null) &#123;</span><br><span class="line">            fdsToClose[1] &#x3D; fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line">        fd &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;【见小节7】</span><br><span class="line">        pid &#x3D; Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;子进程执行</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F;【见小节13】</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 不应到达此处，子进程预期的是抛出异常ZygoteInit.MethodAndArgsCaller或者执行exec().</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;父进程执行</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd &#x3D; null;</span><br><span class="line">            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forkAndSpecialize"><a href="#forkAndSpecialize" class="headerlink" title="forkAndSpecialize"></a>forkAndSpecialize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, String instructionSet, String appDataDir) &#123;</span><br><span class="line">    VM_HOOKS.preFork(); &#x2F;&#x2F;【见小节8】</span><br><span class="line">    int pid &#x3D; nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir); &#x2F;&#x2F;【见小节9】</span><br><span class="line">    ...</span><br><span class="line">    VM_HOOKS.postForkCommon(); &#x2F;&#x2F;【见小节11】</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS是Zygote对象的静态成员变量：VM_HOOKS = new ZygoteHooks();</p>
<h3 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h3><p>先说说Zygote进程，如下图：</p>
<p><img src="http://gityuan.com/images/android-process/zygote_sub_thread.png" alt="zygote_sub_thread"></p>
<p>从图中可知Zygote进程有4个Daemon子线程分别是ReferenceQueueDaemon，FinalizerDaemon，FinalizerWatchdogDaemon，HeapTaskDaemon。图中线程名显示的并不完整是由于底层的进程结构体<code>task_struct</code>是由长度为16的char型数组保存，超过15个字符便会截断。</p>
<p>可能有人会问zygote64进程不是还有system_server，com.android.phone等子线程，怎么会只有4个呢？那是因为这些并不是Zygote子线程，而是Zygote的子进程。在图中用红色圈起来的是进程的<a href="http://gityuan.com/2015/10/11/ps-command/" target="_blank" rel="noopener">VSIZE，virtual size)</a>，代表的是进程虚拟地址空间大小。线程与进程的最为本质的区别便是是否共享内存空间，图中VSIZE和Zygote进程相同的才是Zygote的子线程，否则就是Zygote的子进程。</p>
<h3 id="preFork"><a href="#preFork" class="headerlink" title="preFork"></a>preFork</h3><p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public void preFork() &#123;</span><br><span class="line">    Daemons.stop(); &#x2F;&#x2F;停止4个Daemon子线程【见小节8.1】</span><br><span class="line">    waitUntilAllThreadsStopped(); &#x2F;&#x2F;等待所有子线程结束【见小节8.2】</span><br><span class="line">    token &#x3D; nativePreFork(); &#x2F;&#x2F;完成gc堆的初始化工作【见小节8.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daemons-stop"><a href="#Daemons-stop" class="headerlink" title="Daemons.stop"></a>Daemons.stop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void stop() &#123;</span><br><span class="line">    HeapTaskDaemon.INSTANCE.stop(); &#x2F;&#x2F;Java堆整理线程</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.stop(); &#x2F;&#x2F;引用队列线程</span><br><span class="line">    FinalizerDaemon.INSTANCE.stop(); &#x2F;&#x2F;析构线程</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.stop(); &#x2F;&#x2F;析构监控线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处守护线程Stop方式是先调用目标线程interrrupt()方法，然后再调用目标线程join()方法，等待线程执行完成。</p>
<h3 id="waitUntilAllThreadsStopped"><a href="#waitUntilAllThreadsStopped" class="headerlink" title="waitUntilAllThreadsStopped"></a>waitUntilAllThreadsStopped</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void waitUntilAllThreadsStopped() &#123;</span><br><span class="line">    File tasks &#x3D; new File(&quot;&#x2F;proc&#x2F;self&#x2F;task&quot;);</span><br><span class="line">    &#x2F;&#x2F; 当&#x2F;proc中线程数大于1，就出让CPU直到只有一个线程，才退出循环</span><br><span class="line">    while (tasks.list().length &gt; 1) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nativePreFork"><a href="#nativePreFork" class="headerlink" title="nativePreFork"></a>nativePreFork</h3><p>nativePreFork通过JNI最终调用如下方法：</p>
<p>[-&gt; dalvik_system_ZygoteHooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123;</span><br><span class="line">    Runtime* runtime &#x3D; Runtime::Current();</span><br><span class="line">    runtime-&gt;PreZygoteFork(); &#x2F;&#x2F; 见下文</span><br><span class="line">    if (Trace::GetMethodTracingMode() !&#x3D; TracingMode::kTracingInactive) &#123;</span><br><span class="line">      Trace::Pause();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将线程转换为long型并保存到token，该过程是非安全的</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于runtime-&gt;PreZygoteFork的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::PreZygoteFork() &#123;</span><br><span class="line">    &#x2F;&#x2F; 堆的初始化工作。这里就不继续再往下追art虚拟机</span><br><span class="line">    heap_-&gt;PreZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS.preFork()的主要功能便是停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），并等待这些线程的停止，初始化gc堆的工作, 并将线程转换为long型并保存到token</p>
<h3 id="nativeForkAndSpecialize"><a href="#nativeForkAndSpecialize" class="headerlink" title="nativeForkAndSpecialize"></a>nativeForkAndSpecialize</h3><p>nativeForkAndSpecialize()通过JNI最终调用调用如下方法：</p>
<p>[-&gt; com_android_internal_os_Zygote.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(</span><br><span class="line">    JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span><br><span class="line">    jint debug_flags, jobjectArray rlimits,</span><br><span class="line">    jint mount_external, jstring se_info, jstring se_name,</span><br><span class="line">    jintArray fdsToClose, jstring instructionSet, jstring appDataDir) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将CAP_WAKE_ALARM赋予蓝牙进程</span><br><span class="line">    jlong capabilities &#x3D; 0;</span><br><span class="line">    if (uid &#x3D;&#x3D; AID_BLUETOOTH) &#123;</span><br><span class="line">        capabilities |&#x3D; (1LL &lt;&lt; CAP_WAKE_ALARM);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见流程10】</span><br><span class="line">    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, false, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForkAndSpecializeCommon"><a href="#ForkAndSpecializeCommon" class="headerlink" title="ForkAndSpecializeCommon"></a>ForkAndSpecializeCommon</h3><p>[-&gt; com_android_internal_os_Zygote.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  &#x2F;&#x2F;设置子进程的signal信号处理函数</span><br><span class="line">  SetSigChldHandler();</span><br><span class="line">  &#x2F;&#x2F;fork子进程 【见流程10.1】</span><br><span class="line">  pid_t pid &#x3D; fork();</span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程</span><br><span class="line">    DetachDescriptors(env, fdsToClose); &#x2F;&#x2F;关闭并清除文件描述符</span><br><span class="line"></span><br><span class="line">    if (!is_system_server) &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非system_server子进程，则创建进程组</span><br><span class="line">        int rc &#x3D; createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); &#x2F;&#x2F;设置设置group</span><br><span class="line">    SetRLimits(env, javaRlimits); &#x2F;&#x2F;设置资源limit</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; setresgid(gid, gid, gid);</span><br><span class="line">    rc &#x3D; setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); &#x2F;&#x2F;设置调度策略</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;selinux上下文</span><br><span class="line">    rc &#x3D; selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    if (se_info_c_str &#x3D;&#x3D; NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str &#x3D; &quot;system_server&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (se_info_c_str !&#x3D; NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); &#x2F;&#x2F;设置线程名为system_server，方便调试</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为</span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line">    &#x2F;&#x2F;等价于调用zygote.callPostForkChildHooks() 【见流程10.2】</span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入父进程，即Zygote进程</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。</p>
<ul>
<li>父进程中，fork返回新创建的子进程的pid;</li>
<li>子进程中，fork返回0；</li>
<li>当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</li>
</ul>
<p>fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote进程是所有Android进程的母体，包括system_server和各个App进程。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。其中下图中Zygote进程的libc、vm、preloaded classes、preloaded resources是如何生成的，可查看另一个文章<a href="http://gityuan.com/2016/02/13/android-zygote/#preload" target="_blank" rel="noopener">Android系统启动-zygote篇</a>，见下图：</p>
<p><img src="http://gityuan.com/images/boot/zygote/zygote_fork.jpg" alt="zygote_fork"></p>
<p>copy-on-write过程：当父子进程任一方修改内存数据时（这是on-write时机），才发生缺页中断，从而分配新的物理内存（这是copy操作）。</p>
<p>copy-on-write原理：写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork过程只拷贝父进程的页表，并标记这些页表是只读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常(page fault)，Linux收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。</p>
<h5 id="fork-cpp"><a href="#fork-cpp" class="headerlink" title="fork.cpp"></a>fork.cpp</h5><p>[-&gt; bionic/fork.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define FORK_FLAGS (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD)</span><br><span class="line">int fork() &#123;</span><br><span class="line">  __bionic_atfork_run_prepare(); &#x2F;&#x2F;[见小节2.1.1]</span><br><span class="line"></span><br><span class="line">  pthread_internal_t* self &#x3D; __get_thread();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;fork期间，获取父进程pid，并使其缓存值无效</span><br><span class="line">  pid_t parent_pid &#x3D; self-&gt;invalidate_cached_pid();</span><br><span class="line">  &#x2F;&#x2F;系统调用【见小节2.2】</span><br><span class="line">  int result &#x3D; syscall(__NR_clone, FORK_FLAGS, NULL, NULL, NULL, &amp;(self-&gt;tid));</span><br><span class="line">  if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    self-&gt;set_cached_pid(gettid());</span><br><span class="line">    __bionic_atfork_run_child(); &#x2F;&#x2F;fork完成执行子进程回调方法[见小节2.1.1]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    self-&gt;set_cached_pid(parent_pid);</span><br><span class="line">    __bionic_atfork_run_parent(); &#x2F;&#x2F;fork完成执行父进程回调方法</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能说明：在执行syscall的前后都有相应的回调方法。</p>
<ul>
<li>__bionic_atfork_run_prepare： fork完成前，父进程回调方法</li>
<li>__bionic_atfork_run_child： fork完成后，子进程回调方法</li>
<li>__bionic_atfork_run_paren： fork完成后，父进程回调方法</li>
</ul>
<p>以上3个方法的实现都位于bionic/pthread_atfork.cpp。如果有需要，可以扩展该回调方法，添加相关的业务需求。</p>
<h5 id="Zygote-callPostForkChildHooks"><a href="#Zygote-callPostForkChildHooks" class="headerlink" title="Zygote.callPostForkChildHooks"></a>Zygote.callPostForkChildHooks</h5><p>[-&gt; Zygote.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用ZygoteHooks.postForkChild()</span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void postForkChild(int debugFlags, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;【见流程10.3】</span><br><span class="line">    nativePostForkChild(token, debugFlags, instructionSet);</span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。</p>
<h5 id="nativePostForkChild"><a href="#nativePostForkChild" class="headerlink" title="nativePostForkChild"></a>nativePostForkChild</h5><p>nativePostForkChild通过JNI最终调用调用如下方法：</p>
<p>[-&gt; dalvik_system_ZygoteHooks.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处token是由[小节8.3]创建的，记录着当前线程</span><br><span class="line">    Thread* thread &#x3D; reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">    &#x2F;&#x2F;设置新进程的主线程id</span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    ..</span><br><span class="line">    if (instruction_set !&#x3D; nullptr) &#123;</span><br><span class="line">      ScopedUtfChars isa_string(env, instruction_set);</span><br><span class="line">      InstructionSet isa &#x3D; GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">      Runtime::NativeBridgeAction action &#x3D; Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">      if (isa !&#x3D; kNone &amp;&amp; isa !&#x3D; kRuntimeISA) &#123;</span><br><span class="line">        action &#x3D; Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;【见流程10.4】</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="DidForkFromZygote"><a href="#DidForkFromZygote" class="headerlink" title="DidForkFromZygote"></a>DidForkFromZygote</h5><p>[-&gt; Runtime.cc]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) &#123;</span><br><span class="line">  is_zygote_ &#x3D; false;</span><br><span class="line">  if (is_native_bridge_loaded_) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">      case NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge(); &#x2F;&#x2F;卸载用于跨平台的桥连库</span><br><span class="line">        is_native_bridge_loaded_ &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      case NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);&#x2F;&#x2F;初始化用于跨平台的桥连库</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建Java堆处理的线程池</span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  &#x2F;&#x2F;重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line">  if (jit_.get() &#x3D;&#x3D; nullptr &amp;&amp; jit_options_-&gt;UseJIT()) &#123;</span><br><span class="line">    &#x2F;&#x2F;当flag被设置，并且还没有创建JIT时，则创建JIT</span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;设置信号处理函数</span><br><span class="line">  StartSignalCatcher();</span><br><span class="line">  &#x2F;&#x2F;启动JDWP线程，当命令debuger的flags指定&quot;suspend&#x3D;y&quot;时，则暂停runtime</span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于信号处理过程，其代码位于signal_catcher.cc文件中，后续会单独讲解。</p>
<h3 id="postForkCommon"><a href="#postForkCommon" class="headerlink" title="postForkCommon"></a>postForkCommon</h3><p>[-&gt; ZygoteHooks.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void postForkCommon() &#123;</span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void start() &#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM_HOOKS.postForkCommon的主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。</p>
<h3 id="forkAndSpecialize小结"><a href="#forkAndSpecialize小结" class="headerlink" title="forkAndSpecialize小结"></a>forkAndSpecialize小结</h3><p>该方法主要功能：</p>
<ul>
<li>preFork： 停止Zygote的4个Daemon子线程的运行，初始化gc堆；</li>
<li>nativeForkAndSpecialize：调用<code>fork()</code>创建新进程，设置新进程的主线程id，重置gc性能数据，设置信号处理函数等功能。</li>
<li>postForkCommon：启动4个Deamon子线程。</li>
</ul>
<p>其调用关系链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Zygote.forkAndSpecialize</span><br><span class="line">    ZygoteHooks.preFork</span><br><span class="line">        Daemons.stop</span><br><span class="line">        ZygoteHooks.nativePreFork</span><br><span class="line">            dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork</span><br><span class="line">                Runtime::PreZygoteFork</span><br><span class="line">                    heap_-&gt;PreZygoteFork()</span><br><span class="line">    Zygote.nativeForkAndSpecialize</span><br><span class="line">        com_android_internal_os_Zygote.ForkAndSpecializeCommon</span><br><span class="line">            fork()</span><br><span class="line">            Zygote.callPostForkChildHooks</span><br><span class="line">                ZygoteHooks.postForkChild</span><br><span class="line">                    dalvik_system_ZygoteHooks.nativePostForkChild</span><br><span class="line">                        Runtime::DidForkFromZygote</span><br><span class="line">    ZygoteHooks.postForkCommon</span><br><span class="line">        Daemons.start</span><br></pre></td></tr></table></figure>

<p><strong>时序图：</strong> 点击查看<a href="http://gityuan.com/images/android-process/fork_and_specialize.jpg" target="_blank" rel="noopener">大图</a></p>
<p><img src="http://gityuan.com/images/android-process/fork_and_specialize.jpg" alt="fork_and_specialize"></p>
<p>到此App进程已完成了创建的所有工作，接下来开始新创建的App进程的工作。在前面ZygoteConnection.runOnce方法中，zygote进程执行完<code>forkAndSpecialize()</code>后，新创建的App进程便进入<code>handleChildProc()</code>方法，下面的操作运行在App进程。</p>
<h2 id="新进程运行"><a href="#新进程运行" class="headerlink" title="新进程运行"></a>新进程运行</h2><p>在前面[流程6]runOnce()过程中调用forkAndSpecialize()创建完新进程后，返回值pid=0(即运行在子进程)继续开始执行handleChildProc()方法。</p>
<h3 id="handleChildProc"><a href="#handleChildProc" class="headerlink" title="handleChildProc"></a>handleChildProc</h3><p>[-&gt; ZygoteConnection.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;关闭Zygote的socket两端的连接</span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line"></span><br><span class="line">    if (descriptors !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Os.dup2(descriptors[0], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[1], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[2], STDERR_FILENO);</span><br><span class="line">            for (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr &#x3D; System.err;</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Error reopening stdio&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;设置进程名</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;据说这是用于检测进程内存泄露或溢出时场景而设计，后续还需要进一步分析。</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;执行目标类的main()方法 【见流程14】</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zygoteInit"><a href="#zygoteInit" class="headerlink" title="zygoteInit"></a>zygoteInit</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    redirectLogStreams(); &#x2F;&#x2F;重定向log输出</span><br><span class="line"></span><br><span class="line">    commonInit(); &#x2F;&#x2F; 通用的一些初始化【见流程14.1】</span><br><span class="line">    nativeZygoteInit(); &#x2F;&#x2F; zygote初始化 【见流程14.2】</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); &#x2F;&#x2F; 应用初始化【见流程14.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commonInit"><a href="#commonInit" class="headerlink" title="commonInit"></a>commonInit</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置市区，中国时区为&quot;Asia&#x2F;Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent &#x3D; getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的HTTP User-agent格式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Dalvik&#x2F;1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build&#x2F;LMY47V)&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="nativeZygoteInit"><a href="#nativeZygoteInit" class="headerlink" title="nativeZygoteInit"></a>nativeZygoteInit</h3><p>nativeZygoteInit()所对应的jni方法如下：</p>
<p>[–&gt;AndroidRuntime.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onZygoteInit"><a href="#onZygoteInit" class="headerlink" title="onZygoteInit"></a>onZygoteInit</h4><p>[–&gt;app_main.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit() &#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ProcessState::self():主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver().</li>
<li>startThreadPool(): 启动Binder线程池, 详见<a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">进程的Binder线程池工作过程</a></li>
</ul>
<h3 id="applicationInit"><a href="#applicationInit" class="headerlink" title="applicationInit"></a>applicationInit</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    &#x2F;&#x2F;true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span><br><span class="line">    nativeSetExitWithoutCleanup(true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args &#x3D; new Arguments(argv); &#x2F;&#x2F;解析参数</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用startClass的static方法 main() 【见流程15】</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处args.startClass为”android.app.ActivityThread”。</p>
<h3 id="invokeStaticMain"><a href="#invokeStaticMain" class="headerlink" title="invokeStaticMain"></a>invokeStaticMain</h3><p>[–&gt;RuntimeInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line"></span><br><span class="line">    Method m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line"></span><br><span class="line">    int modifiers &#x3D; m.getModifiers();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。【见流程16】</span><br><span class="line">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeStaticMain()方法中抛出的异常<code>MethodAndArgsCaller</code> caller，该方法的参数<code>m</code>是指main()方法, <code>argv</code>是指ActivityThread. 根据前面的【流程4】中可知，下一步进入caller.run()方法，也就是MethodAndArgsCaller.run()。</p>
<h3 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h3><p>[–&gt;ZygoteInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static class MethodAndArgsCaller extends Exception implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;根据传递过来的参数，此处反射调用ActivityThread.main()方法【见流程17】</span><br><span class="line">            mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause &#x3D; ex.getCause();</span><br><span class="line">            if (cause instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) cause;</span><br><span class="line">            &#125; else if (cause instanceof Error) &#123;</span><br><span class="line">                throw (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，总算是进入到了ActivityThread类的main()方法。</p>
<h3 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main"></a>ActivityThread.main</h3><p>[–&gt; ActivityThread.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建主线程looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    &#x2F;&#x2F;attach到系统进程</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程进入循环状态</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Process.start()方法是阻塞操作，等待直到进程创建完成并返回相应的新进程pid，才完成该方法。</p>
<p>当App第一次启动时或者启动远程Service，即AndroidManifest.xml文件中定义了process:remote属性时，都需要创建进程。比如当用户点击桌面的某个App图标，桌面本身是一个app（即Launcher App），那么Launcher所在进程便是这次创建新进程的发起进程，该通过binder发送消息给system_server进程，该进程承载着整个java framework的核心服务。system_server进程从Process.start开始，执行创建进程，流程图（以进程的视角）如下：</p>
<p>点击查看<a href="http://gityuan.com/images/android-process/process-create.jpg" target="_blank" rel="noopener">大图</a></p>
<p><img src="http://gityuan.com/images/android-process/process-create.jpg" alt="process-create"></p>
<p>上图中，<code>system_server</code>进程通过socket IPC通道向<code>zygote</code>进程通信，<code>zygote</code>在fork出新进程后由于fork<strong>调用一次，返回两次</strong>，即在zygote进程中调用一次，在zygote进程和子进程中各返回一次，从而能进入子进程来执行代码。该调用流程图的过程：</p>
<ol>
<li><strong>system_server进程</strong>（<code>即流程1~3</code>）：通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；</li>
<li>zygote进程（即流程4~12）：接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节（详见流程6），其具体工作是依次执行下面的3个方法：<ul>
<li>preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；</li>
<li>nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；</li>
<li>postForkCommon()：在启动之前被暂停的4个Daemon子线程。</li>
</ul>
</li>
<li><strong>新进程</strong>（<code>即流程13~15</code>）：进入handleChildProc()方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即Activity.main()方法。</li>
</ol>
<p>再之后的流程，如果是startActivity则将要进入Activity的onCreate/onStart/onResume等生命周期；如果是startService则将要进入Service的onCreate等生命周期。</p>
<p>system_server进程等待zygote返回进程创建完成(ZygoteConnection.handleParentProc), 一旦Zygote.forkAndSpecialize()方法执行完成, 那么分道扬镳, zygote告知system_server进程进程已创建, 而子进程继续执行后续的handleChildProc操作.</p>
<p>Tips: [小节11]RuntimeInit.java的方法nativeZygoteInit()会调用到onZygoteInit()，这个过程中有startThreadPool()创建Binder线程池。也就是说每个进程无论是否包含任何activity等组件，一定至少会包含一个Binder线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/" itemprop="url">Android系统启动概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T23:48:17+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/refs/tags/android-cts-6.0_r32/init/init.cpp</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-292fb596c9a68b24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h1><p>按下电源之后，首先加载引导程序 BootLoader 到 RAM（运行内存）；然后，执行引导程序 BootLoader 以把系统 OS 拉起来；Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程，该进程是所有用户空间的鼻祖,init进程会启动servicemanager(binder服务管家), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程，下图是这几个系统重量级进程之间的层级关系。</p>
<p><img src="http://gityuan.com/images/android-arch/android-booting.jpg" alt="android-booting"></p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><p><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">init</a>是Linux系统中用户空间的第一个进程(pid=1), Kerner启动后会调用/system/core/init/Init.cpp的main()方法.</p>
<h3 id="init-main"><a href="#init-main" class="headerlink" title="init.main()"></a>init.main()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    ...</span><br><span class="line">    klog_init();  &#x2F;&#x2F;初始化kernel log</span><br><span class="line">    property_init(); &#x2F;&#x2F;创建一块共享的内存空间，用于属性服务</span><br><span class="line">    signal_handler_init();  &#x2F;&#x2F;初始化子进程退出的信号处理过程</span><br><span class="line"></span><br><span class="line">    property_load_boot_defaults(); &#x2F;&#x2F;加载&#x2F;default.prop文件</span><br><span class="line">    start_property_service();   &#x2F;&#x2F;启动属性服务器(通过socket通信)</span><br><span class="line">    init_parse_config_file(&quot;&#x2F;init.rc&quot;); &#x2F;&#x2F;解析init.rc文件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为 on early-init的语句</span><br><span class="line">    action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);</span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为 on init的语句</span><br><span class="line">    action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);</span><br><span class="line">    &#x2F;&#x2F;执行rc文件中触发器为 on late-init的语句</span><br><span class="line">    action_for_each_trigger(&quot;late-init&quot;, action_add_queue_tail);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (!waiting_for_exec) &#123;</span><br><span class="line">            execute_one_command();</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line">        int timeout &#x3D; -1;</span><br><span class="line">        if (process_needs_restart) &#123;</span><br><span class="line">            timeout &#x3D; (process_needs_restart - gettime()) * 1000;</span><br><span class="line">            if (timeout &lt; 0)</span><br><span class="line">                timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!action_queue_empty() || cur_action) &#123;</span><br><span class="line">            timeout &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        &#x2F;&#x2F;循环 等待事件发生</span><br><span class="line">        int nr &#x3D; TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">        if (nr &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        &#125; else if (nr &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            ((void (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init进程的主要功能点:</p>
<ul>
<li>分析和运行所有的init.rc文件;</li>
<li>生成设备驱动节点; （通过rc文件创建）</li>
<li>处理子进程的终止(signal方式);</li>
<li>提供属性服务property service。</li>
</ul>
<h3 id="Zygote自动重启机制"><a href="#Zygote自动重启机制" class="headerlink" title="Zygote自动重启机制"></a>Zygote自动重启机制</h3><p>当init解析到下面这条语句,便会启动Zygote进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main                             &#x2F;&#x2F;伴随着main class的启动而启动</span><br><span class="line">    socket zygote stream 660 root system   &#x2F;&#x2F;创建socket</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart media              &#x2F;&#x2F;当zygote重启时,则会重启media</span><br><span class="line">    onrestart restart netd               &#x2F;&#x2F; 当zygote重启时,则会重启netd</span><br></pre></td></tr></table></figure>

<p>当init子进程(Zygote)退出时，会产生SIGCHLD信号，并发送给init进程，通过socket套接字传递数据，调用到wait_for_one_process()方法，根据是否是oneshot，来决定是重启子进程，还是放弃启动。由于缺省模式oneshot=false,因此Zygote一旦被杀便会再次由init进程拉起.</p>
<p><img src="http://gityuan.com/images/boot/init/init_oneshot.jpg" alt="init_oneshot"></p>
<h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r5/cmds/app_process/app_main.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.0_r5/cmds/app_process/app_main.cpp</a></p>
<p>当<a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Zygote</a>进程启动后, 便会执行到frameworks/base/cmds/app_process/App_main.cpp文件的main()方法. 整个调用流程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">App_main.main</span><br><span class="line">    AndroidRuntime.start</span><br><span class="line">        AndroidRuntime.startVm</span><br><span class="line">        AndroidRuntime.startReg</span><br><span class="line">        ZygoteInit.main (首次进入Java世界)</span><br><span class="line">            registerZygoteSocket</span><br><span class="line">            preload</span><br><span class="line">            startSystemServer</span><br><span class="line">            runSelectLoop</span><br></pre></td></tr></table></figure>

<h3 id="App-main-main"><a href="#App-main-main" class="headerlink" title="App_main.main"></a>App_main.main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    while (i &lt; argc) &#123;</span><br><span class="line">        ...&#x2F;&#x2F;参数解析</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置进程名</span><br><span class="line">    if (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        &#x2F;&#x2F; 启动AppRuntime，见小节[3.2]</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在app_process进程启动过程，有两个分支：</p>
<ul>
<li>当zygote为true时，则执行ZygoteInit.main()</li>
<li>当zygote为false时，则执行RuntimeInit.main()</li>
</ul>
<h3 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime::start"></a>AndroidRuntime::start</h3><p>[-&gt; AndroidRuntime.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 虚拟机创建</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env, zygote) !&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; JNI方法注册</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用ZygoteInit.main()方法[见小节3.3]</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-main–Java"><a href="#ZygoteInit-main–Java" class="headerlink" title="ZygoteInit.main–Java"></a>ZygoteInit.main–Java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        registerZygoteSocket(socketName); &#x2F;&#x2F;为Zygote注册socket</span><br><span class="line">        preload(); &#x2F;&#x2F; 预加载类和资源[见小节3.4]</span><br><span class="line">        ...</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);&#x2F;&#x2F;启动system_server[见小节3.5]</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</span><br><span class="line">        runSelectLoop(abiList); &#x2F;&#x2F;进入循环模式[见小节3.6]</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); &#x2F;&#x2F;启动system_server中会讲到。</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-preload"><a href="#ZygoteInit-preload" class="headerlink" title="ZygoteInit.preload"></a>ZygoteInit.preload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void preload() &#123;</span><br><span class="line">    Log.d(TAG, &quot;begin preload&quot;);</span><br><span class="line">    preloadClasses();</span><br><span class="line">    preloadResources();</span><br><span class="line">    preloadOpenGL();</span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">    Log.d(TAG, &quot;end preload&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-startSystemServer"><a href="#ZygoteInit-startSystemServer" class="headerlink" title="ZygoteInit.startSystemServer"></a>ZygoteInit.startSystemServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">        throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fork子进程system_server</span><br><span class="line">    pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">            parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">            parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags,</span><br><span class="line">            null,</span><br><span class="line">            parsedArgs.permittedCapabilities,</span><br><span class="line">            parsedArgs.effectiveCapabilities);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;进入system_server进程[见小节4.1]</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-runSelectLoop"><a href="#ZygoteInit-runSelectLoop" class="headerlink" title="ZygoteInit.runSelectLoop"></a>ZygoteInit.runSelectLoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;sServerSocket是socket通信中的服务端，即zygote进程</span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">            pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">            pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        Os.poll(pollFds, -1);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当客户端发出 连接请求或者数据处理请求时，则执行continue</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;创建客户端连接</span><br><span class="line">                ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;处理客户端数据事务</span><br><span class="line">                boolean done &#x3D; peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote进程创建Java虚拟机,并注册JNI方法， 真正成为Java进程的母体，用于孵化Java进程. 在创建完system_server进程后,zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</p>
<h2 id="system-server"><a href="#system-server" class="headerlink" title="system_server"></a>system_server</h2><p>Zygote通过fork后创建system_server进程，在小节[3.5]执行完startSystemServer()方法后，进入到了handleSystemServerProcess()方法，如下所示。</p>
<h3 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess"></a>handleSystemServerProcess</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;设置当前进程名为&quot;system_server&quot;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String systemServerClasspath &#x3D; Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">    if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行dex优化操作,比如services.jar</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ClassLoader cl &#x3D; null;</span><br><span class="line">        if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">            cl &#x3D; new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;[见小节4.2]</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>system_server进程创建PathClassLoader类加载器.</p>
<h3 id="RuntimeInit-zygoteInit"><a href="#RuntimeInit-zygoteInit" class="headerlink" title="RuntimeInit.zygoteInit"></a>RuntimeInit.zygoteInit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</span><br><span class="line">    redirectLogStreams(); &#x2F;&#x2F;重定向log输出</span><br><span class="line"></span><br><span class="line">    commonInit(); &#x2F;&#x2F; 通用的一些初始化</span><br><span class="line">    nativeZygoteInit(); &#x2F;&#x2F; zygote初始化</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); &#x2F;&#x2F; [见小节3.4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder线程池启动"><a href="#Binder线程池启动" class="headerlink" title="Binder线程池启动"></a>Binder线程池启动</h2><p>nativeZygoteInit()方法经过层层调用,会进入app_main.cpp中的onZygoteInit()方法, Binder线程池的创建也是在这个过程,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit() &#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程池</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获特殊异常"><a href="#捕获特殊异常" class="headerlink" title="捕获特殊异常"></a>捕获特殊异常</h2><p>applicationInit()方法经过层层调用,会抛出异常ZygoteInit.MethodAndArgsCaller(m, argv), 具体过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv,</span><br><span class="line">        ClassLoader classLoader) &#123;</span><br><span class="line">    ...</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    final Arguments args &#x3D; new Arguments(argv);</span><br><span class="line">    &#x2F;&#x2F;找到目标类的静态main()方法</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    &#x2F;&#x2F;此处的className等于SystemServer</span><br><span class="line">    Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">    Method  m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#x2F;&#x2F;抛出异常Runnable对象</span><br><span class="line">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h3><p>[–&gt;ZygoteInit.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        startSystemServer(abiList, socketName); &#x2F;&#x2F;抛出MethodAndArgsCaller异常</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run(); &#x2F;&#x2F;此处通过反射,会调用SystemServer.main()方法 [见小节4.4]</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MethodAndArgsCaller implements Runnable &#123;</span><br><span class="line">    private final Method mMethod;</span><br><span class="line">    private final String[] mArgs;</span><br><span class="line"></span><br><span class="line">    public MethodAndArgsCaller(Method method, String[] args) &#123;</span><br><span class="line">        mMethod &#x3D; method;</span><br><span class="line">        mArgs &#x3D; args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;执行SystemServer.main()</span><br><span class="line">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用抛出异常的方式,用于栈帧清空,提供利用率, 以至于现在大家看到的每个Java进程的调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">at com.android.server.SystemServer.main(SystemServer.java:175)</span><br><span class="line">at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)</span><br></pre></td></tr></table></figure>

<h3 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main"></a>SystemServer.main</h3><p>[–&gt;SystemServer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class SystemServer &#123;</span><br><span class="line">    ...</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先初始化SystemServer对象，再调用对象的run()方法</span><br><span class="line">        new SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h3><p>[–&gt;SystemServer.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void run() &#123;</span><br><span class="line">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</span><br><span class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</span><br><span class="line">    Looper.prepareMainLooper();&#x2F;&#x2F; 准备主线程looper</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;加载android_servers.so库，该库包含的源码在frameworks&#x2F;base&#x2F;services&#x2F;目录下</span><br><span class="line">    System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检测上次关机过程是否失败，该方法可能不会返回</span><br><span class="line">    performPendingShutdown();</span><br><span class="line">    createSystemContext(); &#x2F;&#x2F;初始化系统上下文</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建系统服务管理</span><br><span class="line">    mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动各种系统服务</span><br><span class="line">    try &#123;</span><br><span class="line">        startBootstrapServices(); &#x2F;&#x2F; 启动引导服务</span><br><span class="line">        startCoreServices();      &#x2F;&#x2F; 启动核心服务</span><br><span class="line">        startOtherServices();     &#x2F;&#x2F; 启动其他服务[见小节4.6]</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;一直循环执行</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class SystemServer &#123;</span><br><span class="line">    private void startBootstrapServices() &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#x2F;&#x2F;phase100</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void startOtherServices() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;phase480 和phase500</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;[见小节4.7]</span><br><span class="line">        mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               &#x2F;&#x2F;phase550</span><br><span class="line">               mSystemServiceManager.startBootPhase(</span><br><span class="line">                       SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;phase600</span><br><span class="line">               mSystemServiceManager.startBootPhase(</span><br><span class="line">                       SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>start: 创建AMS, PMS, LightsService, DMS.</li>
<li>phase100: 进入Phase100, 创建PKMS, WMS, IMS, DBMS, LockSettingsService, JobSchedulerService, MmsService等服务;</li>
<li>phase480 &amp;&amp; 500: 进入Phase480, 调用WMS, PMS, PKMS, DisplayManagerService这4个服务的systemReady();</li>
<li>Phase550: 进入phase550, 执行AMS.systemReady(), 启动SystemUI, WebViewFactory, Watchdog.</li>
<li>Phase600: 进入phase600, 执行AMS.systemReady(), 执行各种服务的systemRunning().</li>
<li>Phase1000: 进入1000, 执行finishBooting, 启动启动on-hold进程.</li>
</ul>
<h3 id="AMS-systemReady"><a href="#AMS-systemReady" class="headerlink" title="AMS.systemReady"></a>AMS.systemReady</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line"></span><br><span class="line">    public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ... &#x2F;&#x2F;update相关</span><br><span class="line">        mSystemReady &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;杀掉所有非persistent进程</span><br><span class="line">        removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">        mProcessesReady &#x3D; true;</span><br><span class="line"></span><br><span class="line">        goingCallback.run();  &#x2F;&#x2F;[见小节1.6.2]</span><br><span class="line"></span><br><span class="line">        addAppLocked(info, false, null); &#x2F;&#x2F;启动所有的persistent进程</span><br><span class="line">        mBooting &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动home</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line">        &#x2F;&#x2F;恢复栈顶的Activity</span><br><span class="line">        mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System_server主线程的启动工作,总算完成, 进入Looper.loop()状态,等待其他线程通过handler发送消息再处理.</p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>对于普通的app进程,跟system_server进程的启动过程有些类似.不同的是app进程是向发消息给system_server进程, 由system_server向zygote发出创建进程的请求.</p>
<p><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a>, 可知进程创建后 接下来会进入ActivityThread.main()过程。</p>
<h3 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main"></a>ActivityThread.main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建主线程looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false); &#x2F;&#x2F;attach到系统进程</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程进入循环状态</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用栈对比"><a href="#调用栈对比" class="headerlink" title="调用栈对比"></a>调用栈对比</h3><p>App进程的主线程调用栈的栈底如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:5442)</span><br><span class="line">    at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)</span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)</span><br></pre></td></tr></table></figure>

<p>跟前面介绍的system_server进程调用栈对比:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">at com.android.server.SystemServer.main(SystemServer.java:175)</span><br><span class="line">at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628)</span><br></pre></td></tr></table></figure>

<h2 id="启动日志分析"><a href="#启动日志分析" class="headerlink" title="启动日志分析"></a>启动日志分析</h2><p>以下列举启动部分重要进程以及关键节点会打印出的log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;system&#x2F;bin&#x2F;vold: 383</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;lmkd: 432</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;surfaceflinger: 434</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;debuggerd64: 537</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;mediaserver: 540</span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;installd: 541</span><br><span class="line">&#x2F;system&#x2F;vendor&#x2F;bin&#x2F;thermal-engine: 552</span><br><span class="line"></span><br><span class="line">zygote64: 557</span><br><span class="line">zygote: 558</span><br><span class="line">system_server: 1274</span><br></pre></td></tr></table></figure>

<h3 id="before-zygote日志"><a href="#before-zygote日志" class="headerlink" title="before zygote日志"></a>before zygote日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动vold, 再列举当前系统所支持的文件系统.  执行到system&#x2F;vold&#x2F;main.cpp的main()</span><br><span class="line">11-23 14:36:47.474   383   383 I vold    : Vold 3.0 (the awakening) firing up  </span><br><span class="line">11-23 14:36:47.475   383   383 V vold    : Detected support for: ext4 vfat   </span><br><span class="line">&#x2F;&#x2F;使用内核的lmk策略</span><br><span class="line">11-23 14:36:47.927   432   432 I lowmemorykiller: Using in-kernel low memory killer interface</span><br><span class="line">&#x2F;&#x2F;启动SurfaceFlinger</span><br><span class="line">11-23 14:36:48.041   434   434 I SurfaceFlinger: SurfaceFlinger is starting</span><br><span class="line">11-23 14:36:48.042   434   434 I SurfaceFlinger: SurfaceFlinger&#39;s main thread ready to run. Initializing graphics H&#x2F;W...</span><br><span class="line">&#x2F;&#x2F; 开机动画</span><br><span class="line">11-23 14:36:48.583   508   508 I BootAnimation: bootanimation launching ...</span><br><span class="line">&#x2F;&#x2F; debuggerd</span><br><span class="line">11-23 14:36:50.306   537   537 I         : debuggerd: starting</span><br><span class="line">&#x2F;&#x2F; installd启动</span><br><span class="line">11-23 14:36:50.311   541   541 I installd: installd firing up</span><br><span class="line">&#x2F;&#x2F; thermal守护进程</span><br><span class="line">11-23 14:36:50.369   552   552 I ThermalEngine: Thermal daemon started</span><br></pre></td></tr></table></figure>

<h3 id="zygote日志"><a href="#zygote日志" class="headerlink" title="zygote日志"></a>zygote日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Zygote64进程(Zygote):  AndroidRuntime::start</span><br><span class="line">11-23 14:36:51.260   557   557 D AndroidRuntime: &gt;&gt;&gt;&gt;&gt;&gt; START com.android.internal.os.ZygoteInit uid 0 &lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">&#x2F;&#x2F; Zygote64进程:  AndroidRuntime::startVm</span><br><span class="line">11-23 14:36:51.304   557   557 D AndroidRuntime: CheckJNI is OFF</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preload()</span><br><span class="line">11-23 14:36:52.134   557   557 D Zygote  : begin preload</span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preloadClasses(), 预加载3860个classes, 花费时长746ms</span><br><span class="line">11-23 14:36:52.134   557   557 I Zygote  : Preloading classes...</span><br><span class="line">11-23 14:36:52.881   557   557 I Zygote  : ...preloaded 3860 classes in 746ms.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preloadClasses(), 预加载86组资源, 花费时长179ms</span><br><span class="line">11-23 14:36:53.114   557   557 I Zygote  : Preloading resources...</span><br><span class="line">11-23 14:36:53.293   557   557 I Zygote  : ...preloaded 86 resources in 179ms.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行ZygoteInit.preloadSharedLibraries()</span><br><span class="line">11-23 14:36:53.494   557   557 I Zygote  : Preloading shared libraries...</span><br><span class="line">11-23 14:36:53.503   557   557 D Zygote  : end preload</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行com_android_internal_os_Zygote_nativeForkSystemServer(),成功fork出system_server进程</span><br><span class="line">11-23 14:36:53.544   557   557 I Zygote  : System server process 1274 has been created</span><br><span class="line">&#x2F;&#x2F; Zygote开始进入runSelectLoop()</span><br><span class="line">11-23 14:36:53.546   557   557 I Zygote  : Accepting command socket connections</span><br></pre></td></tr></table></figure>

<h3 id="system-server日志"><a href="#system-server日志" class="headerlink" title="system_server日志"></a>system_server日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进入system_server, 建立跟Zygote进程的socket通道</span><br><span class="line">11-23 14:36:53.586  1274  1274 I Zygote  : Process: zygote socket opened, supported ABIS: armeabi-v7a,armeabi</span><br><span class="line">&#x2F;&#x2F; 执行SystemServer.run()</span><br><span class="line">11-23 14:36:53.618  1274  1274 I SystemServer: Entered the Android system server!   &lt;&#x3D;&#x3D;&#x3D;&gt; boot_progress_system_run</span><br><span class="line">&#x2F;&#x2F; 等待installd准备就绪</span><br><span class="line">11-23 14:36:53.707  1274  1274 I Installer: Waiting for installd to be ready.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务启动</span><br><span class="line">11-23 14:36:53.732  1274  1274 I ActivityManager: Memory class: 192</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;phase100</span><br><span class="line">11-23 14:36:53.883  1274  1274 I SystemServiceManager: Starting phase 100</span><br><span class="line">11-23 14:36:53.902  1274  1274 I SystemServer: Package Manager</span><br><span class="line">11-23 14:37:03.816  1274  1274 I SystemServer: User Service</span><br><span class="line">...</span><br><span class="line">11-23 14:37:03.940  1274  1274 I SystemServer: Init Watchdog</span><br><span class="line">11-23 14:37:03.941  1274  1274 I SystemServer: Input Manager</span><br><span class="line">11-23 14:37:03.946  1274  1274 I SystemServer: Window Manager</span><br><span class="line">...</span><br><span class="line">11-23 14:37:04.081  1274  1274 I SystemServiceManager: Starting com.android.server.MountService$Lifecycle</span><br><span class="line">11-23 14:37:04.088  1274  2717 D MountService: Thinking about reset, mSystemReady&#x3D;false, mDaemonConnected&#x3D;true</span><br><span class="line">11-23 14:37:04.088  1274  1274 I SystemServiceManager: Starting com.android.server.UiModeManagerService</span><br><span class="line">11-23 14:37:04.520  1274  1274 I SystemServer: NetworkTimeUpdateService</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;phase480 &amp;&amp; 500</span><br><span class="line">11-23 14:37:05.056  1274  1274 I SystemServiceManager: Starting phase 480</span><br><span class="line">11-23 14:37:05.061  1274  1274 I SystemServiceManager: Starting phase 500</span><br><span class="line">11-23 14:37:05.231  1274  1274 I ActivityManager: System now ready  &lt;&#x3D;&#x3D;&gt; boot_progress_ams_ready</span><br><span class="line">11-23 14:37:05.234  1274  1274 I SystemServer: Making services ready</span><br><span class="line">11-23 14:37:05.243  1274  1274 I SystemServer: WebViewFactory preparation</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;phase550</span><br><span class="line">11-23 14:37:05.234  1274  1274 I SystemServiceManager: Starting phase 550</span><br><span class="line">11-23 14:37:05.237  1274  1288 I ActivityManager: Force stopping com.android.providers.media appid&#x3D;10010 user&#x3D;-1: vold reset</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Phase600</span><br><span class="line">11-23 14:37:06.066  1274  1274 I SystemServiceManager: Starting phase 600</span><br><span class="line">11-23 14:37:06.236  1274  1274 D MountService: onStartUser 0</span><br></pre></td></tr></table></figure>

<h3 id="logcat小技巧"><a href="#logcat小技巧" class="headerlink" title="logcat小技巧"></a>logcat小技巧</h3><p>通过adb bugreport抓取log信息.先看zygote是否起来, 再看system_server主线程的运行情况,再看ActivityManager情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -s Zygote</span><br><span class="line">adb logcat -s SystemServer</span><br><span class="line">adb logcat -s SystemServiceManager</span><br><span class="line">adb logcat | grep &quot;1359 1359&quot; &#x2F;&#x2F;system_server情况</span><br><span class="line">adb logcat -s ActivityManager</span><br></pre></td></tr></table></figure>

<p>现场调试命令</p>
<ol>
<li>cat proc/[pid]/stack ==&gt; 查看kernel调用栈</li>
<li>debuggerd -b [pid] ==&gt; 也不可以不带参数-b, 则直接输出到/data/tombstones/目录</li>
<li>kill -3 [pid] ==&gt; 生成/data/anr/traces.txt文件</li>
<li>lsof [pid] ==&gt; 查看进程所打开的文件</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各大核心进程启动后，都会进入各种对象所相应的main()方法，如下</p>
<h3 id="进程main方法"><a href="#进程main方法" class="headerlink" title="进程main方法"></a>进程main方法</h3><table>
<thead>
<tr>
<th align="left">进程</th>
<th align="left">主方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">init进程</td>
<td align="left">Init.main()</td>
</tr>
<tr>
<td align="left">zygote进程</td>
<td align="left">ZygoteInit.main()</td>
</tr>
<tr>
<td align="left">app_process进程</td>
<td align="left">RuntimeInit.main()</td>
</tr>
<tr>
<td align="left">system_server进程</td>
<td align="left">SystemServer.main()</td>
</tr>
<tr>
<td align="left">app进程</td>
<td align="left">ActivityThread.main()</td>
</tr>
</tbody></table>
<p>注意app_process进程是指通过/system/bin/app_process启动的进程，且后面跟的参数不带–zygote，即并非启动zygote进程。 比如常见的有通过adb shell方式来执行am,pm等命令，便是这种方式。</p>
<h3 id="重启相关进程"><a href="#重启相关进程" class="headerlink" title="重启相关进程"></a>重启相关进程</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>关于重要进程重启的过程，会触发哪些关联进程重启名单：</p>
<ul>
<li>zygote：触发media、netd以及子进程(包括system_server进程)重启；</li>
<li>system_server: 触发zygote重启;</li>
<li>surfaceflinger：触发zygote重启;</li>
<li>servicemanager: 触发zygote、healthd、media、surfaceflinger、drm重启</li>
</ul>
<p>所以，surfaceflinger,servicemanager,zygote自身以及system_server进程被杀都会触发Zygote重启。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/" itemprop="url">为什么Android要采用Binder作为IPC机制？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T21:59:55+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Binder/%E4%B8%BA%E4%BB%80%E4%B9%88Android%E8%A6%81%E9%87%87%E7%94%A8Binder%E4%BD%9C%E4%B8%BAIPC%E6%9C%BA%E5%88%B6%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p>Android 另起炉灶开发了 Binder 驱动，而没有采用已有的方案，而 D-Bus 这样的方案也可以实现 Binder 的功能，是出于什么原因和什么考虑？安全性？性能？</p>
<h1 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h1><p><strong>在开始回答 前，先简单概括性地说说Linux现有的所有进程间IPC方式：</strong></p>
<ul>
<li><strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li><strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li><strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li><strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不同机器或跨网络的通信；</li>
<li><strong>信号量</strong>：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>信号</strong>: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ul>
<p><strong>Android的内核也是基于Linux内核，为何不直接采用Linux现有的进程IPC方案呢，难道Linux社区那么多优秀人员都没有考虑到有Binder这样一个更优秀的方案，是google太过于牛B吗？事实是真相并非如此，请细细往下看，您就明白了。</strong></p>
<p><strong>接下来正面回答这个问题，从5个角度来展开对Binder的分析：</strong></p>
<ul>
<li><p><strong>从性能的角度</strong> <strong>数据拷贝次数：</strong></p>
<p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</p>
</li>
<li><p><strong>从稳定性的角度</strong></p>
<p>Binder是基于C/S架构的，简单解释下C/S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。</p>
</li>
</ul>
<p>仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制，那么更重要的原因是：</p>
<ul>
<li><p><strong>从安全的角度</strong></p>
<p>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。 </p>
<p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，<strong>Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行</strong>。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。</p>
<p>针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但<strong>同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。</strong>对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。</p>
<p>Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：<br><a href="https://www.zhihu.com/question/41003297/answer/89328987?from=profile_answer_card" target="_blank" rel="noopener">Android源码的Binder权限是如何控制？ -Gityuan的回答</a></p>
<p><strong>传统IPC</strong>只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p>
<p><strong>说到这，可能有人要反驳</strong>，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在<strong>Google举办的Android Bootcamp 2016</strong>大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。 </p>
<p>话题扯远了，继续说Binder。</p>
</li>
<li><p><strong>从语言层面的角度</strong></p>
<p>大家多知道Linux是基于C语言(面向过程的语言)，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。</p>
<p><strong>另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。</strong>也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在<strong>Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制</strong>，Android中的<strong>Kill Process采用的signal（信号）机制</strong>等等。而<strong>Binder更多则用在system_server进程与上层App层的IPC交互</strong>。</p>
</li>
<li><p><strong>从公司战略的角度</strong></p>
<p>总所周知，Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。 </p>
<p>而Android 之父 Andy Rubin对于GPL显然是不能接受的，为此，Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性，仍有较大争议，但至少目前缓解Android，让GPL止步于内核空间，这是Google在GPL Linux下 开源与商业化共存的一个成功典范。</p>
</li>
</ul>
<p><strong>有了这些铺垫，我们再说说Binder的今世前缘</strong></p>
<p>Binder是基于开源的 <a href="https://link.zhihu.com/?target=http%3A//www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html">OpenBinder</a>实现的，OpenBinder是一个开源的系统IPC机制,最初是由 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Be_Inc.">Be Inc.</a> 开发，接着由<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Palm%2C_Inc.">Palm, Inc.</a>公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择。</p>
<p>另外，再说一点关于OpenBinder，在2015年OpenBinder以及合入到Linux Kernel主线 3.19版本，这也算是Google对Linux的一点回馈吧。</p>
<p><strong>综合上述5点，可知Binder是Android系统上层进程间通信的不二选择。</strong></p>
<p><strong>接着，回答楼主提到的</strong>D-Bus</p>
<p>作者：Gityuan<br>链接：<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">https://www.zhihu.com/question/39440766/answer/89210950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>也采用C/S架构的IPC机制，<strong><a href="https://link.zhihu.com/?target=https%3A//www.freedesktop.org/wiki/Software/dbus/">D-Bus</a></strong>是在用户空间实现的方法，效率低，消息拷贝次数和上下文切换次数都明显多过于Binder。针对D-Bus这些缺陷，于是就产生了<strong>kdbus</strong>，这是D-Bus在内核实现版，效率得到提升，与Binder一样在内核作为字符设计，通过open()打开设备，mmap()映射内存。</p>
<p>（1）kdbus在进程间通信过程，Client端将消息在内存的消息队列，可以存储大量的消息，Server端不断从消息队里中取消息，大小只受限内存；<br>（2）Binder的机制是每次通信，会通信的进程或线程中的todo队里中增加binder事务，并且每个进程所允许Binder线程数，google提供的默认最大线程数为16个，受限于CPU，由于线程数太多，增加系统负载，并且每个进程默认分配的（1M-8K）大小的内存。</p>
<p>而kdbus对于内存消耗较大，同时也适合传输大量数据和大量消息的系统。Binder对CPU和内存的需求比较低，效率比较高，从而进一步说明Binder适合于移动系统Android，但是，也有一定缺点，就是不同利用Binder输出大数据，比如利用Binder传输几M大小的图片，便会出现异常，虽然有厂商会增加Binder内存，但是也不可能比系统默认内存大很多，否则整个系统的可用内存大幅度降低。</p>
<p><strong>最后，简单讲讲Android Binder架构</strong></p>
<p>Binder在Android系统中江湖地位非常之高。在Zygote孵化出system_server进程后，在system_server进程中出初始化支持整个Android framework的各种各样的Service，而这些Service从大的方向来划分，分为Java层Framework和Native Framework层(C++)的Service，几乎都是基于BInder IPC机制。</p>
<ol>
<li><strong>Java framework：作为Server端继承(或间接继承)于Binder类，Client端继承(或间接继承)于BinderProxy类。</strong>例如 ActivityManagerService(用于控制Activity、Service、进程等) 这个服务作为Server端，间接继承Binder类，而相应的ActivityManager作为Client端，间接继承于BinderProxy类。 当然还有PackageManagerService、WindowManagerService等等很多系统服务都是采用C/S架构；</li>
<li><strong>Native Framework层：这是C++层，作为Server端继承(或间接继承)于BBinder类，Client端继承(或间接继承)于BpBinder。</strong>例如MediaPlayService(用于多媒体相关)作为Server端，继承于BBinder类，而相应的MediaPlay作为Client端，间接继承于BpBinder类。</li>
</ol>
<p><strong>总之，一句话”无Binder不Android”。</strong></p>
<p>本来想从Binder源码技术的角度，分析Binder如何做到的，发现不知不觉就写了这么多，对于实现原理有兴趣，查看我的个人博客。通过<strong>Google搜索关键字 “Binder系列”</strong>，第一个出现的便是我的博客 老域名(域名已经释放了，听读者被重定向带色的网站了)，上一张 Google搜索结果的截图：</p>
<p><img src="https://pic4.zhimg.com/50/c986b0f037f7f1aaec0ba485253dba25_hd.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/c986b0f037f7f1aaec0ba485253dba25_1440w.jpg" alt="img"></p>
<blockquote>
<p>为了便于传播与记忆，刚刚申请了新域名gityuan(与我的微博、知乎ID同名)，个人博客由xxx(匿了)迁<strong>移到新域名 <a href="https://link.zhihu.com/?target=http%3A//Gityuan.com">http://Gityuan.com</a></strong>，由于不擅长SEO，网站的google权重降低，更新时间 2016.03.27。</p>
</blockquote>
<p>有网友建议，放上Binder系列的连接：<a href="https://link.zhihu.com/?target=http%3A//gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a>。 更新时间2016.04.09</p>
<p>最后的最后：</p>
<blockquote>
<p><strong>朋友推荐来知乎这边回答网友的问题，涨涨人气，我也是拼了，第一次这么长篇大论的回答知乎的问题，感觉没说清楚，修订了一遍又一遍，如果大家觉得我回答得还行，还请大家随手 点赞、关注、收藏，如果觉得说得不好的，还往评论指正。 若能得到大家的肯定，那也不枉费花时间敲打这么多文字，在这里 Gityuan先谢谢大家。</strong></p>
</blockquote>
<p>==========&gt;      <strong>我的微博：<a href="https://link.zhihu.com/?target=http%3A//weibo.com/gityuan">Gityuan</a></strong><br>==========&gt; <strong>我微信公众号： Gityuan</strong></p>
<p>之前一直在埋头做技术，最近刚刚开通微信、微博，后面会有更多的干货分享，欢迎大家关注，谢谢！！</p>
<p>-—————————————————————————————————————————————–</p>
<blockquote>
<p>关于我是如何学习Android，可以查看我的另一篇知乎文章： <a href="http://zhuanlan.zhihu.com/p/20708611" target="_blank" rel="noopener">如何自学Android</a>？</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/" itemprop="url">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T21:08:24+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Handler/Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop()%E9%87%8C%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8D%A1%E6%AD%BB%EF%BC%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p>app程序入口中为主线程准备好了消息队列</p>
<p><img src="https://pic1.zhimg.com/ce97597327ffe00c04ce76fc2f41030c_b.png" alt="img"></p>
<p>而根据Looper.loop()源码可知里面是一个死循环在遍历消息队列取消息</p>
<p><img src="https://pic3.zhimg.com/10df1f7c70d0d9382f5c8a4b2b6d66a6_b.png" alt="img"></p>
<p>而且并也没看见哪里有相关代码为这个死循环准备了一个新线程去运转，但是主线程却并不会因为Looper.loop()中的这个死循环卡死，为什么呢？</p>
<p>举个例子，像Activity的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？</p>
<h1 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h1><p>要完全彻底理解这个问题，需要准备以下4方面的知识：Process/Thread，Android Binder IPC，Handler/Looper/MessageQueue消息机制，Linux pipe/epoll机制。</p>
<p><strong>总结一下楼主主要有3个疑惑：</strong></p>
<p>1.Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ </p>
<p>2.没看见哪里有相关代码为这个死循环准备了一个新线程去运转？ </p>
<p>3.Activity的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？</p>
<p><strong>(1) Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</strong></p>
<p>这里涉及线程，先说说说进程/线程</p>
<p><strong>进程：</strong>每个app运行时前首先创建一个进程，该进程是由Zygote fork出来的，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。</p>
<p><strong>线程：</strong>线程对应用来说非常常见，比如每次new Thread().start都会创建一个新的线程。该线程与App所在进程之间资源共享，从Linux角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个task_struct结构体<strong>，在CPU看来进程或线程无非就是一段可执行的代码，CPU采用CFS调度算法，保证每个task都尽可能公平的享有CPU时间片</strong>。</p>
<p>有了这么准备，再说说死循环问题：</p>
<p>对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？<strong>简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，</strong>例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。</p>
<p>真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。</p>
<p><strong>(2) 没看见哪里有相关代码为这个死循环准备了一个新线程去运转？</strong></p>
<p>事实上，会在进入死循环之前便创建了新binder线程，在代码ActivityThread.main()中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Looper和MessageQueue对象，用于处理主线程的消息</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建ActivityThread对象</span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread(); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;建立Binder通道 (创建新线程)</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        Looper.loop(); &#x2F;&#x2F;消息循环运行</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>thread.attach(false)；便会创建一个Binder线程（具体是指ApplicationThread，Binder的服务端，用于接收系统服务AMS发送来的事件），该Binder线程通过Handler将Message发送给主线程</strong>，具体过程可查看 <a href="https://link.zhihu.com/?target=http%3A//gityuan.com/2016/03/06/start-service/">startService流程分析</a>，这里不展开说，简单说Binder用于进程间通信，采用C/S架构。关于binder感兴趣的朋友，可查看我回答的另一个知乎问题：<br><a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？ - Gityuan的回答</a></p>
<p>另外，<strong>ActivityThread实际上并非线程</strong>，不像HandlerThread类，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，该人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。</p>
<p><strong>主线程的死循环一直运行是不是特别消耗CPU资源呢？</strong> 其实不然，这里就涉及到<strong>Linux pipe/epoll机制</strong>，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见<a href="https://link.zhihu.com/?target=http%3A//www.yuanhh.com/2015/12/26/handler-message-framework/%23next">Android消息机制1-Handler(Java层)</a>，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 <strong>所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</strong></p>
<p><strong>(3) Activity的生命周期是怎么实现在死循环体外能够执行起来的？</strong></p>
<p>ActivityThread的内部类H继承于Handler，通过handler消息机制，简单说Handler机制用于同一个进程的线程间通信。</p>
<p><strong>Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施：</strong><br>在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。</p>
<p>比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法；</p>
<p>再比如收到msg=H.PAUSE_ACTIVITY，则调用ActivityThread.handlePauseActivity()方法，最终会执行Activity.onPause()等方法。 上述过程，我只挑核心逻辑讲，真正该过程远比这复杂。</p>
<p><strong>主线程的消息又是哪来的呢？</strong>当然是App进程中的其他线程通过Handler发送给主线程，请看接下来的内容：</p>
<p><strong>最后，从进程与线程间通信的角度，</strong>通过一张图加深大家对App运行过程的理解</p>
<p><img src="https://pic4.zhimg.com/50/7fb8728164975ac86a2b0b886de2b872_hd.jpg" alt="img"></p>
<p><strong>system_server进程是系统进程</strong>，java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。</p>
<p><strong>App进程则是我们常说的应用程序</strong>，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），除了图中画的线程，其中还有很多线程，比如signal catcher线程等，这里就不一一列举。</p>
<p>Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事务，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息。</p>
<p><strong>结合图说说Activity生命周期，比如暂停Activity，流程如下：</strong></p>
<ol>
<li>线程1的AMS中调用线程2的ATP；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题）</li>
<li>线程2通过binder传输到App进程的线程4；</li>
<li>线程4通过handler消息机制，将暂停Activity的消息发送给主线程；</li>
<li>主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的调用，最后便会调用到Activity.onPause()，当onPause()处理完后，继续循环loop下去。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/" itemprop="url">Handler（Java层）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T16:03:39+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Handler/Handler%EF%BC%88Java%E5%B1%82%EF%BC%89/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android消息机制1-Handler-Java层"><a href="#Android消息机制1-Handler-Java层" class="headerlink" title="Android消息机制1-Handler(Java层)"></a>Android消息机制1-Handler(Java层)</h1><blockquote>
<p>本文基于Android 6.0的源代码，来分析Java层的handler消息处理机制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">framework&#x2F;base&#x2F;core&#x2F;java&#x2F;andorid&#x2F;os&#x2F;</span><br><span class="line">  - Handler.java</span><br><span class="line">  - Looper.java</span><br><span class="line">  - Message.java</span><br><span class="line">  - MessageQueue.java</span><br></pre></td></tr></table></figure>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，，另一个便是消息机制(由Handler/Looper/MessageQueue等构成的)。关于Binder在<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列</a>中详细讲解过，有兴趣看看。</p>
<p>Android有大量的消息驱动方式来进行交互，比如Android的四剑客<code>Activity</code>, <code>Service</code>, <code>Broadcast</code>, <code>ContentProvider</code>的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。消息机制涉及MessageQueue/Message/Looper/Handler这4个类。</p>
<h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><p>消息机制主要包含：</p>
<ul>
<li><strong>Message</strong>：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li>
<li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li>
<li><strong>Looper</strong>：不断循环执行(<code>Looper.loop</code>)，按分发机制将消息分发给目标处理者。</li>
</ul>
<h3 id="1-2-架构图"><a href="#1-2-架构图" class="headerlink" title="1.2 架构图"></a>1.2 架构图</h3><p><img src="http://gityuan.com/images/handler/Main.jpg" alt="handler_java"></p>
<ul>
<li><strong>Looper</strong>有一个MessageQueue消息队列；</li>
<li><strong>MessageQueue</strong>有一组待处理的Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的Handler；</li>
<li><strong>Handler</strong>中有Looper和MessageQueue。</li>
</ul>
<h3 id="1-3-典型实例"><a href="#1-3-典型实例" class="headerlink" title="1.3 典型实例"></a>1.3 典型实例</h3><p>先展示一个典型的关于Handler/Looper的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();   &#x2F;&#x2F;【见 2.1】</span><br><span class="line"></span><br><span class="line">        mHandler &#x3D; new Handler() &#123;  &#x2F;&#x2F;【见 3.1】</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                &#x2F;&#x2F;TODO 定义消息处理逻辑. 【见 3.2】</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();  &#x2F;&#x2F;【见 2.2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，围绕着这个实例展开详细分析。</p>
<h2 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h2><h3 id="2-1-prepare"><a href="#2-1-prepare" class="headerlink" title="2.1 prepare()"></a>2.1 prepare()</h3><p>对于无参的情况，默认调用<code>prepare(true)</code>，表示的是这个Looper允许退出，而对于false的情况则表示当前Looper不允许退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>sThreadLocal</code>是ThreadLocal类型，下面，先说说ThreadLocal。</p>
<p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p>
<ul>
<li><code>ThreadLocal.set(T value)</code>：将value存储到当前线程的TLS区域，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存数据value到当前线程this</span></span><br><span class="line">    values.put(<span class="keyword">this</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal.get()</code>：获取当前线程TLS区域的数据，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] table = values.table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; values.mask;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) table[index + <span class="number">1</span>]; <span class="comment">//返回当前线程储存区中的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>); <span class="comment">//从目标线程存储区没有查询是则返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的<code>sThreadLocal</code>变量，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;()</span><br></pre></td></tr></table></figure>

<p>可见<code>sThreadLocal</code>的get()和set()操作的类型都是<code>Looper</code>类型。</p>
<p><strong>Looper.prepare()</strong></p>
<p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p>
<p>对于Looper类型的构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue &#x3D; new MessageQueue(quitAllowed);  &#x2F;&#x2F;创建MessageQueue对象. 【见4.1】</span><br><span class="line">    mThread &#x3D; Thread.currentThread();  &#x2F;&#x2F;记录当前线程.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，与prepare()相近功能的，还有一个<code>prepareMainLooper()</code>方法，该方法主要在ActivityThread类中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false); &#x2F;&#x2F;设置不允许退出的Looper</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        &#x2F;&#x2F;将当前的Looper保存为主Looper，每个线程只允许执行一次。</span><br><span class="line">        if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper &#x3D; myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-loop"><a href="#2-2-loop" class="headerlink" title="2.2 loop()"></a>2.2 loop()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me &#x3D; myLooper();  &#x2F;&#x2F;获取TLS存储的Looper对象 【见2.4】</span><br><span class="line">    final MessageQueue queue &#x3D; me.mQueue;  &#x2F;&#x2F;获取Looper对象中的消息队列</span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    &#x2F;&#x2F;确保在权限检查时基于本地进程，而不是调用进程。</span><br><span class="line">    final long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F;进入loop的主循环方法</span><br><span class="line">        Message msg &#x3D; queue.next(); &#x2F;&#x2F;可能会阻塞 【见4.2】</span><br><span class="line">        if (msg &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;没有消息，则退出循环</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span><br><span class="line">        Printer logging &#x3D; me.mLogging;  </span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg); &#x2F;&#x2F;用于分发Message 【见3.2】</span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;恢复调用者信息</span><br><span class="line">        final long newIdent &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        msg.recycleUnchecked();  &#x2F;&#x2F;将Message放入消息池 【见5.2】</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p>
<ul>
<li>读取MessageQueue的下一条Message；</li>
<li>把Message分发给相应的target；</li>
<li>再把分发后的Message回收到消息池，以便重复利用。</li>
</ul>
<p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下<code>logging == null</code>，通过设置setMessageLogging()用来开启debug工作。</p>
<h3 id="2-3-quit"><a href="#2-3-quit" class="headerlink" title="2.3 quit()"></a>2.3 quit()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void quit() &#123;</span><br><span class="line">    mQueue.quit(false); &#x2F;&#x2F;消息移除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true); &#x2F;&#x2F;安全地消息移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法</p>
<p><strong>MessageQueue.quit()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常</span><br><span class="line">        if (!mQuitAllowed) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123; &#x2F;&#x2F;防止多次执行退出操作</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting &#x3D; true;</span><br><span class="line">            if (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked(); &#x2F;&#x2F;移除尚未触发的所有消息</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                removeAllMessagesLocked(); &#x2F;&#x2F;移除所有的消息</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;mQuitting&#x3D;false，那么认定为 mPtr !&#x3D; 0</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消息退出的方式：</p>
<ul>
<li>当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；</li>
<li>当safe =flase时，移除所有的消息</li>
</ul>
<h3 id="2-4-常用方法"><a href="#2-4-常用方法" class="headerlink" title="2.4 常用方法"></a>2.4 常用方法</h3><h4 id="2-4-1-myLooper"><a href="#2-4-1-myLooper" class="headerlink" title="2.4.1 myLooper"></a>2.4.1 myLooper</h4><p>用于获取TLS存储的Looper对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-post"><a href="#2-4-2-post" class="headerlink" title="2.4.2 post"></a>2.4.2 post</h4><p>发送消息，并设置消息的callback，用于处理消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h2><h3 id="3-1-创建Handler"><a href="#3-1-创建Handler" class="headerlink" title="3.1 创建Handler"></a>3.1 创建Handler</h3><h4 id="3-1-1-无参构造"><a href="#3-1-1-无参构造" class="headerlink" title="3.1.1 无参构造"></a>3.1.1 无参构造</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">    &#x2F;&#x2F;匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span><br><span class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        final Class&lt;? extends Handler&gt; klass &#x3D; getClass();</span><br><span class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span><br><span class="line">    mLooper &#x3D; Looper.myLooper();  &#x2F;&#x2F;从当前线程的TLS中获取Looper对象【见2.1】</span><br><span class="line">    if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue &#x3D; mLooper.mQueue; &#x2F;&#x2F;消息队列，来自Looper对象</span><br><span class="line">    mCallback &#x3D; callback;  &#x2F;&#x2F;回调方法</span><br><span class="line">    mAsynchronous &#x3D; async; &#x2F;&#x2F;设置消息是否为异步处理方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p>
<h4 id="3-1-2-有参构造"><a href="#3-1-2-有参构造" class="headerlink" title="3.1.2 有参构造"></a>3.1.2 有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p>
<h3 id="3-2-消息分发机制"><a href="#3-2-消息分发机制" class="headerlink" title="3.2 消息分发机制"></a>3.2 消息分发机制</h3><p>在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;当Message存在回调方法，回调msg.callback.run()方法；</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;当Handler存在Callback成员变量时，回调方法handleMessage()；</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;Handler自身的回调方法handleMessage()</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分发消息流程：</strong></p>
<ol>
<li>当<code>Message</code>的回调方法不为空时，则回调方法<code>msg.callback.run()</code>，其中callBack数据类型为Runnable,否则进入步骤2；</li>
<li>当<code>Handler</code>的<code>mCallback</code>成员变量不为空时，则回调方法<code>mCallback.handleMessage(msg)</code>,否则进入步骤3；</li>
<li>调用<code>Handler</code>自身的回调方法<code>handleMessage()</code>，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。</li>
</ol>
<p>对于很多情况下，消息分发后的处理方法是第3种情况，即Handler.handleMessage()，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p>
<h3 id="3-3-消息发送"><a href="#3-3-消息发送" class="headerlink" title="3.3 消息发送"></a>3.3 消息发送</h3><p>发送消息调用链：</p>
<p><img src="http://gityuan.com/images/handler/java_sendmessage.png" alt="java_sendmessage"></p>
<p>从上图，可以发现所有的发消息方式，最终都是调用<code>MessageQueue.enqueueMessage()</code>;</p>
<h4 id="3-3-1-sendEmptyMessage"><a href="#3-3-1-sendEmptyMessage" class="headerlink" title="3.3.1 sendEmptyMessage"></a>3.3.1 sendEmptyMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendEmptyMessage(int what) &#123;</span><br><span class="line">    return sendEmptyMessageDelayed(what, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-sendEmptyMessageDelayed"><a href="#3-3-2-sendEmptyMessageDelayed" class="headerlink" title="3.3.2 sendEmptyMessageDelayed"></a>3.3.2 sendEmptyMessageDelayed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class="line">    Message msg &#x3D; Message.obtain();</span><br><span class="line">    msg.what &#x3D; what;</span><br><span class="line">    return sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-sendMessageDelayed"><a href="#3-3-3-sendMessageDelayed" class="headerlink" title="3.3.3 sendMessageDelayed"></a>3.3.3 sendMessageDelayed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-sendMessageAtTime"><a href="#3-3-4-sendMessageAtTime" class="headerlink" title="3.3.4 sendMessageAtTime"></a>3.3.4 sendMessageAtTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-sendMessageAtFrontOfQueue"><a href="#3-3-5-sendMessageAtFrontOfQueue" class="headerlink" title="3.3.5 sendMessageAtFrontOfQueue"></a>3.3.5 sendMessageAtFrontOfQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageAtFrontOfQueue(Message msg) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法通过设置消息的触发时间为0，从而使Message加入到消息队列的队头。</p>
<h4 id="3-3-6-post"><a href="#3-3-6-post" class="headerlink" title="3.3.6 post"></a>3.3.6 post</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-7-postAtFrontOfQueue"><a href="#3-3-7-postAtFrontOfQueue" class="headerlink" title="3.3.7 postAtFrontOfQueue"></a>3.3.7 postAtFrontOfQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean postAtFrontOfQueue(Runnable r) &#123;</span><br><span class="line">    return sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-8-enqueueMessage"><a href="#3-3-8-enqueueMessage" class="headerlink" title="3.3.8 enqueueMessage"></a>3.3.8 enqueueMessage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis); 【见4.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p><code>Handler.sendEmptyMessage()</code>等系列方法最终调用<code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code>，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p>
<h3 id="3-4-Handler其他方法"><a href="#3-4-Handler其他方法" class="headerlink" title="3.4 Handler其他方法"></a>3.4 Handler其他方法</h3><h4 id="3-4-1-obtainMessage"><a href="#3-4-1-obtainMessage" class="headerlink" title="3.4.1 obtainMessage"></a>3.4.1 obtainMessage</h4><p>获取消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final Message obtainMessage() &#123;</span><br><span class="line">    return Message.obtain(this); 【见5.2】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler.obtainMessage()</code>方法，最终调用<code>Message.obtainMessage(this)</code>，其中this为当前的Handler对象。</p>
<h4 id="3-4-2-removeMessages"><a href="#3-4-2-removeMessages" class="headerlink" title="3.4.2 removeMessages"></a>3.4.2 removeMessages</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void removeMessages(int what) &#123;</span><br><span class="line">    mQueue.removeMessages(this, what, null); 【见 4.5】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Handler</code>是消息机制中非常重要的辅助类，更多的实现都是<code>MessageQueue</code>, <code>Message</code>中的方法，Handler的目的是为了更加方便的使用消息机制。</p>
<h2 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h2><p>MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private native static long nativeInit();</span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br><span class="line">private native void nativePollOnce(long ptr, int timeoutMillis);</span><br><span class="line">private native static void nativeWake(long ptr);</span><br><span class="line">private native static boolean nativeIsPolling(long ptr);</span><br><span class="line">private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);</span><br></pre></td></tr></table></figure>

<p>关于这些native方法的介绍，见<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<h3 id="4-1-创建MessageQueue"><a href="#4-1-创建MessageQueue" class="headerlink" title="4.1 创建MessageQueue"></a>4.1 创建MessageQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed &#x3D; quitAllowed;</span><br><span class="line">    &#x2F;&#x2F;通过native方法初始化消息队列，其中mPtr是供native代码使用</span><br><span class="line">    mPtr &#x3D; nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-next"><a href="#4-2-next" class="headerlink" title="4.2 next()"></a>4.2 next()</h3><p>提取下一条message</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    final long ptr &#x3D; mPtr;</span><br><span class="line">    if (ptr &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;当消息循环已经退出，则直接返回</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; 循环迭代的首次为-1</span><br><span class="line">    int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis !&#x3D; 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg &#x3D; null;</span><br><span class="line">            Message msg &#x3D; mMessages;</span><br><span class="line">            &#x2F;&#x2F;当消息的Handler为空时，则查询异步消息</span><br><span class="line">            if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;当查询到异步消息，则立刻退出循环</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg &#x3D; msg;</span><br><span class="line">                    msg &#x3D; msg.next;</span><br><span class="line">                &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg !&#x3D; null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    &#x2F;&#x2F;当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取一条消息，并返回</span><br><span class="line">                    mBlocked &#x3D; false;</span><br><span class="line">                    if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                        prevMsg.next &#x3D; msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages &#x3D; msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;设置消息的使用状态，即flags |&#x3D; FLAG_IN_USE</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;   &#x2F;&#x2F;成功地获取MessageQueue中的下一条即将要执行的消息</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有消息</span><br><span class="line">                nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;消息正在退出，返回null</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当消息队列为空，或者是消息队列的第一个消息时</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages &#x3D;&#x3D; null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount &#x3D; mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;没有idle handlers 需要运行，则循环并等待。</span><br><span class="line">                mBlocked &#x3D; true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPendingIdleHandlers &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mPendingIdleHandlers &#x3D; new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers &#x3D; mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler &#x3D; mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] &#x3D; null; &#x2F;&#x2F;去掉handler的引用</span><br><span class="line">            boolean keep &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep &#x3D; idler.queueIdle();  &#x2F;&#x2F;idle时执行的方法</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;重置idle handler个数为0，以保证不会再次重复运行</span><br><span class="line">        pendingIdleHandlerCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span><br><span class="line">        nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nativePollOnce</code>是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p>
<p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当nativePollOnce()返回后，next()从<code>mMessages</code>中提取一个消息。</p>
<p><code>nativePollOnce()</code>在native做了大量的工作，想进一步了解可查看 <a href="http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<h3 id="4-3-enqueueMessage"><a href="#4-3-enqueueMessage" class="headerlink" title="4.3 enqueueMessage"></a>4.3 enqueueMessage</h3><p>添加一条消息到消息队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MessageQueue</code>是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<h3 id="4-4-removeMessages"><a href="#4-4-removeMessages" class="headerlink" title="4.4 removeMessages"></a>4.4 removeMessages</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">//从消息队列的头部开始，移除所有符合条件的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除剩余的符合要求的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked();</span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个移除消息的方法，采用了两个while循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h3 id="4-5-postSyncBarrier"><a href="#4-5-postSyncBarrier" class="headerlink" title="4.5 postSyncBarrier"></a>4.5 postSyncBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面小节[4.3]已说明每一个普通Message必须有一个target，对于特殊的message是没有target，即同步barrier token。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒Looper.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         Message prev = <span class="keyword">null</span>;</span><br><span class="line">         Message p = mMessages;</span><br><span class="line">         <span class="comment">//从消息队列找到 target为空,并且token相等的Message</span></span><br><span class="line">         <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">             prev = p;</span><br><span class="line">             p = p.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">             prev.next = p.next;</span><br><span class="line">             needWake = <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             mMessages = p.next;</span><br><span class="line">             needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">             nativeWake(mPtr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>postSyncBarrier只对同步消息产生影响，对于异步消息没有任何差别。</p>
<h2 id="五、-Message"><a href="#五、-Message" class="headerlink" title="五、 Message"></a>五、 Message</h2><h3 id="5-1-消息对象"><a href="#5-1-消息对象" class="headerlink" title="5.1 消息对象"></a>5.1 消息对象</h3><p>每个消息用<code>Message</code>表示，<code>Message</code>主要包含以下内容：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">成员变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">what</td>
<td align="left">消息类别</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">when</td>
<td align="left">消息触发时间</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg1</td>
<td align="left">参数1</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg2</td>
<td align="left">参数2</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">obj</td>
<td align="left">消息内容</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="left">target</td>
<td align="left">消息响应方</td>
</tr>
<tr>
<td align="left">Runnable</td>
<td align="left">callback</td>
<td align="left">回调方法</td>
</tr>
</tbody></table>
<p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p>
<h3 id="5-2-消息池"><a href="#5-2-消息池" class="headerlink" title="5.2 消息池"></a>5.2 消息池</h3><p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p>
<p>静态变量<code>sPool</code>的数据类型为Message，通过next成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。</p>
<p>消息池常用的操作方法是obtain()和recycle()。</p>
<h4 id="5-2-1-obtain"><a href="#5-2-1-obtain" class="headerlink" title="5.2.1 obtain"></a>5.2.1 obtain</h4><p>从消息池中获取消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool !&#x3D; null) &#123;</span><br><span class="line">            Message m &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; m.next;</span><br><span class="line">            m.next &#x3D; null; &#x2F;&#x2F;从sPool中取出一个Message对象，并消息链表断开</span><br><span class="line">            m.flags &#x3D; 0; &#x2F;&#x2F; 清除in-use flag</span><br><span class="line">            sPoolSize--; &#x2F;&#x2F;消息池的可用大小进行减1操作</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message(); &#x2F;&#x2F; 当消息池为空时，直接创建Message对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p>
<h4 id="5-2-2-recycle"><a href="#5-2-2-recycle" class="headerlink" title="5.2.2 recycle"></a>5.2.2 recycle</h4><p>把不再使用的消息加入消息池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123; &#x2F;&#x2F;判断消息是否正在使用</span><br><span class="line">        if (gCheckRecycle) &#123; &#x2F;&#x2F;Android 5.0以后的版本默认为true,之前的版本默认为false.</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于不再使用的消息，加入到消息池</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    &#x2F;&#x2F;将消息标示位置为IN_USE，并清空消息所有的参数。</span><br><span class="line">    flags &#x3D; FLAG_IN_USE;</span><br><span class="line">    what &#x3D; 0;</span><br><span class="line">    arg1 &#x3D; 0;</span><br><span class="line">    arg2 &#x3D; 0;</span><br><span class="line">    obj &#x3D; null;</span><br><span class="line">    replyTo &#x3D; null;</span><br><span class="line">    sendingUid &#x3D; -1;</span><br><span class="line">    when &#x3D; 0;</span><br><span class="line">    target &#x3D; null;</span><br><span class="line">    callback &#x3D; null;</span><br><span class="line">    data &#x3D; null;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123; &#x2F;&#x2F;当消息池没有满时，将Message对象加入消息池</span><br><span class="line">            next &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; this;</span><br><span class="line">            sPoolSize++; &#x2F;&#x2F;消息池的可用大小进行加1操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>最后用一张图，来表示整个消息机制</p>
<p><img src="http://gityuan.com/images/handler/handler_java.jpg" alt="handler_java"></p>
<p><strong>图解：</strong></p>
<ul>
<li>Handler通过sendMessage()发送Message到MessageQueue队列；</li>
<li>Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；</li>
<li>经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。</li>
<li>将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。</li>
</ul>
<p><strong>消息分发的优先级：</strong></p>
<ol>
<li>Message的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，优先级仅次于1；</li>
<li>Handler的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<p><strong>消息缓存：</strong></p>
<p>为了提供效率，提供了一个大小为50的Message缓存队列，减少对象不断创建与销毁的过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" itemprop="url">Android系统架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T12:52:49+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">Android系统分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/Android/Android%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://gityuan.com/android/" target="_blank" rel="noopener">文章出处</a></p>
<h1 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h1><p>Android大致可以分为四层架构：<strong>Linux内核层、系统运行库层、应用框架层和应用层</strong>。</p>
<p>本文作为Android系统架构的开篇，起到提纲挈领的作用，从系统整体架构角度概要讲解Android系统的核心技术点，带领大家初探Android系统全貌以及内部运作机制。虽然Android系统非常庞大且错综复杂，需要具备全面的技术栈，但整体架构设计清晰。Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-a8c2d9d3a1a3a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>Linux内核层</p>
<p>Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。</p>
</li>
<li><p>系统运行库层</p>
<p>这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGl|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。</p>
<p>同样这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用。另外，Android运行库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机示例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。</p>
</li>
<li><p>应用框架层</p>
<p>这一层主要提供了构建应用程序时可能用到的各种API,Andorid自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。</p>
</li>
<li><p>应用层</p>
<p>所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play上下载的小游戏，当然还包括你自己开发的程序。</p>
</li>
</ul>
<h1 id="系统启动架构"><a href="#系统启动架构" class="headerlink" title="系统启动架构"></a>系统启动架构</h1><p>Google提供的5层架构图很经典，但为了更进一步透视Android系统架构，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌，阐述Android内部的环环相扣的内在联系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4118241-68a5968ed562a20e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>图解：</strong> Android系统启动过程由上图从下往上的一个过程是由Boot Loader引导开机，然后依次进入 -&gt; <code>Kernel</code> -&gt; <code>Native</code> -&gt; <code>Framework</code> -&gt; <code>App</code>，接来下简要说说每个过程：</p>
<h2 id="Loader层"><a href="#Loader层" class="headerlink" title="Loader层"></a>Loader层</h2><ul>
<li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在<code>ROM</code>里的预设代码开始执行，然后加载引导程序到<code>RAM</code>；</li>
<li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。</li>
</ul>
<h2 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h2><p>Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。 </p>
<ul>
<li>启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；</li>
<li>启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。<code>kthreadd进程是所有内核进程的鼻祖</code>。</li>
</ul>
<h2 id="硬件抽象层-HAL"><a href="#硬件抽象层-HAL" class="headerlink" title="硬件抽象层 (HAL)"></a>硬件抽象层 (HAL)</h2><p>硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p>
<h2 id="Android-Runtime-amp-系统库"><a href="#Android-Runtime-amp-系统库" class="headerlink" title="Android Runtime &amp; 系统库"></a>Android Runtime &amp; 系统库</h2><p>每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。</p>
<p>这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，<strong>init进程是所有用户进程的鼻祖</strong>。</p>
<ul>
<li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li>
<li>init进程还启动<code>servicemanager</code>(binder服务管家)、<code>bootanim</code>(开机动画)等重要服务</li>
<li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code>Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li>
</ul>
<h2 id="Framework层"><a href="#Framework层" class="headerlink" title="Framework层"></a>Framework层</h2><ul>
<li><p>Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含： </p>
<ul>
<li>加载ZygoteInit类，注册Zygote Socket服务端套接字</li>
<li>加载虚拟机</li>
<li>提前加载类preloadClasses</li>
<li>提前加载资源preloadResouces</li>
</ul>
</li>
<li><p>System Server进程，是由Zygote进程fork而来，<strong>System Server是Zygote孵化的第一个进程</strong>，System Server负责启动和管理整个Java framework，包含<strong>ActivityManager，WindowManager，PackageManager，PowerManager等服务</strong>。</p>
</li>
<li><p>Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含<strong>AudioFlinger，Camera Service等服务。</strong></p>
</li>
</ul>
<h2 id="Syscall-amp-amp-JNI"><a href="#Syscall-amp-amp-JNI" class="headerlink" title="Syscall &amp;&amp; JNI"></a>Syscall &amp;&amp; JNI</h2><ul>
<li>Native与Kernel之间有一层系统调用(SysCall)层，见<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">Linux系统调用(Syscall)原理</a>;</li>
<li>Java层与Native(C/C++)层之间的纽带JNI，见<a href="http://gityuan.com/2016/05/28/android-jni/" target="_blank" rel="noopener">Android JNI原理分析</a>。</li>
</ul>
<h2 id="App层"><a href="#App层" class="headerlink" title="App层"></a>App层</h2><ul>
<li>Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</li>
<li>Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。</li>
<li>所有的App进程都是由Zygote进程fork生成的。</li>
</ul>
<h1 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h1><p>无论是Android系统，还是各种Linux衍生系统，各个组件、模块往往运行在各种不同的进程和线程内，这里就必然涉及进程/线程之间的通信。对于IPC(Inter-Process Communication, 进程间通信)，Linux现有管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制，Android额外还有Binder IPC机制，Android OS中的Zygote进程的IPC采用的是Socket机制，在上层system server、media server以及上层App之间更多的是采用Binder IPC方式来完成跨进程间的通信。对于Android上层架构中，很多时候是在同一个进程的线程之间需要相互通信，例如同一个进程的主线程与工作线程之间的通信，往往采用的Handler消息机制。</p>
<p>想深入理解Android内核层架构，必须先深入理解Linux现有的IPC机制；对于Android上层架构，则最常用的通信方式是Binder、Socket、Handler，当然也有少量其他的IPC方式，比如杀进程Process.killProcess()采用的是signal方式。下面说说Binder、Socket、Handler：</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder作为Android系统提供的一种IPC机制，无论从系统开发还是应用开发，都是Android系统中最重要的组成，也是最难理解的一块知识点，想了解<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a> 可查看我在知乎上的回答。深入了解Binder机制，最好的方法便是阅读源码，借用Linux鼻祖Linus Torvalds曾说过的一句话：Read The Fucking Source Code。下面简要说说Binder IPC原理。</p>
<h3 id="Binder-IPC原理"><a href="#Binder-IPC原理" class="headerlink" title="Binder IPC原理"></a>Binder IPC原理</h3><p>Binder通信采用c/s架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。</p>
<p><img src="http://gityuan.com/images/android-arch/IPC-Binder.jpg" alt="ServiceManager"></p>
<ul>
<li>想进一步了解Binder，可查看<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a>，Binder系列花费了13篇文章的篇幅，从源码角度出发来讲述Driver、Native、Framework、App四个层面的整个完整流程。根据有些读者反馈这个系列还是不好理解，这个binder涉及的层次跨度比较大，知识量比较广，建议大家先知道binder是用于进程间通信，有个大致概念就可以先去学习系统基本知识，等后面有一定功力再进一步深入研究Binder机制。</li>
</ul>
<p><strong>Binder原理篇</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left"><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></td>
<td align="left">Binder概述</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">Binder系列3—启动Service Manager</a></td>
<td align="left">ServiceManager守护进程 注册和查询服务</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">Binder系列4—获取Service Manager</a></td>
<td align="left">获取代理对象BpServiceManager</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">Binder系列5—注册服务(addService)</a></td>
<td align="left">注册Media服务</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2015/11/15/binder-get-service/" target="_blank" rel="noopener">Binder系列6—获取服务(getService)</a></td>
<td align="left">获取Media代理，以及DeathRecipient</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Binder系列7—framework层分析</a></td>
<td align="left">framework层服务注册和查询，Binder注册</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">理解Binder线程池的管理</a></td>
<td align="left">Binder的startThreadPool过程</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a></td>
<td align="left">startService为主线</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2015/11/28/binder-summary/" target="_blank" rel="noopener">Binder系列10—总结</a></td>
<td align="left">Binder的简单总结</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/03/05/binder-clearCallingIdentity/" target="_blank" rel="noopener">Binder IPC的权限控制</a></td>
<td align="left">clearCallingIdentity/restoreCallingIdentity</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2016/10/03/binder_linktodeath/" target="_blank" rel="noopener">Binder死亡通知机制之linkToDeath</a></td>
<td align="left">Binder死亡通知机制</td>
</tr>
</tbody></table>
<p><strong>Binder驱动篇:</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder系列1—Binder Driver初探</a></th>
<th>驱动open/mmap/ioctl，以及binder结构体</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><a href="http://gityuan.com/2015/11/02/binder-driver-2/" target="_blank" rel="noopener">Binder系列2—Binder Driver再探</a></td>
<td>Binder通信协议，内存机制</td>
</tr>
</tbody></table>
<p><strong>Binder使用篇:</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">Binder系列8—如何使用Binder</a></th>
<th>Native层、Framwrok层自定义Binder服务</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><a href="http://gityuan.com/2015/11/23/binder-aidl/" target="_blank" rel="noopener">Binder系列9—如何使用AIDL</a></td>
<td>App层自定义Binder服务</td>
</tr>
</tbody></table>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket通信方式也是C/S架构，比Binder简单很多。在Android系统中采用Socket通信方式的主要有：</p>
<ul>
<li>zygote：用于孵化进程，system_server创建进程是通过socket向zygote进程发起请求；</li>
<li>installd：用于安装App的守护进程，上层PackageManagerService很多实现最终都是交给它来完成；</li>
<li>lmkd：lowmemorykiller的守护进程，Java层的LowMemoryKiller最终都是由lmkd来完成；</li>
<li>adbd：这个也不用说，用于服务adb；</li>
<li>logcatd:这个不用说，用于服务logcat；</li>
<li>vold：即volume Daemon，是存储类的守护进程，用于负责如USB、Sdcard等存储设备的事件处理。</li>
</ul>
<p>等等还有很多，这里不一一列举，Socket方式更多的用于Android framework层与native层之间的通信。Socket通信方式相对于binder比较简单，这里省略。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><strong>Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信</strong>，Handler消息机制是由一组MessageQueue、Message、Looper、Handler共同组成的，为了方便且称之为Handler消息机制。</p>
<p>有人可能会疑惑，为何Binder/Socket用于进程间通信，能否用于线程间通信呢？答案是肯定，对于两个具有独立地址空间的进程通信都可以，当然也能用于共享内存空间的两个线程间通信，这就好比杀鸡用牛刀。接着可能还有人会疑惑，那handler消息机制能否用于进程间通信？答案是不能，Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。很多时候，Handler是工作线程向UI主线程发送消息，即App应用中只有主线程能更新UI，其他工作线程往往是完成相应工作后，通过Handler告知主线程需要做出相应地UI更新操作，Handler分发相应的消息给UI主线程去完成，如下图：</p>
<p><img src="http://gityuan.com/images/android-arch/handler_thread_commun.jpg" alt="handler_communication"></p>
<p>由于工作线程与主线程共享地址空间，即Handler实例对象mHandler位于线程间共享的内存堆上，工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。工作线程通过mHandler向其成员变量MessageQueue中添加新Message，主线程一直处于loop()方法内，当收到新的Message时按照一定规则分发给相应的handleMessage()方法来处理。所以说，Handler消息机制用于同进程的线程间通信，其核心是线程间共享内存空间，而不同进程拥有不同的地址空间，也就不能用handler来实现进程间通信。</p>
<p>上图只是Handler消息机制的一种处理流程，是不是只能工作线程向UI主线程发消息呢，其实不然，可以是UI线程向工作线程发送消息，也可以是多个工作线程之间通过handler发送消息。更多关于Handler消息机制文章：</p>
<ul>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制-Handler(framework篇)</a></li>
<li><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制-Handler(native篇)</a></li>
<li><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></li>
</ul>
<p>要理解framework层源码，掌握这3种基本的进程/线程间通信方式是非常有必要，当然Linux还有不少其他的IPC机制，比如共享内存、信号、信号量，在源码中也有体现，如果想全面彻底地掌握Android系统，还是需要对每一种IPC机制都有所了解。</p>
<h1 id="核心提纲"><a href="#核心提纲" class="headerlink" title="核心提纲"></a>核心提纲</h1><p>博主对于Android从系统底层一路到上层都有自己的理解和沉淀，通过前面对系统启动的介绍，相信大家对Android系统有了一个整体观。接下来需抓核心、理思路，争取各个击破。后续将持续更新和完善整个大纲，不限于进程、内存、IO、系统服务架构以及分析实战等文章。</p>
<p>当然本站有一些文章没来得及进一步加工，有时间根据大家的反馈，不断修正和完善所有文章，争取给文章，再进一步精简非核心代码，增加可视化图表以及文字的结论性分析。基于<strong>Android 6.0的源码</strong>，专注于分享Android系统原理、架构分析的原创文章。</p>
<p><strong>建议阅读群体</strong>： 适合于正从事或者有兴趣研究Android系统的工程师或者技术爱好者，也适合Android App高级工程师；对于尚未入门或者刚入门的App工程师阅读可能会有点困难，建议先阅读更基础的资料，再来阅读本站博客。</p>
<p>看到Android整个系统架构是如此庞大的, 该问如何学习Android系统, 以下是我自己的Android的学习和研究论，仅供参考<a href="http://gityuan.com/2016/04/24/how-to-study-android/" target="_blank" rel="noopener">如何自学Android</a>。</p>
<p>从整理上来列举一下Android系统的核心知识点概览：</p>
<p><img src="http://gityuan.com/images/android-arch/android_os.png" alt="Android_os"></p>
<h4 id="系统启动系列"><a href="#系统启动系列" class="headerlink" title="系统启动系列"></a>系统启动系列</h4><p><img src="http://gityuan.com/images/android-arch/android-booting.jpg" alt="android-booting"></p>
<p><a href="http://gityuan.com/2016/02/01/android-booting/" target="_blank" rel="noopener">Android系统启动-概述</a>: Android系统中极其重要进程：init, zygote, system_server, servicemanager 进程:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">进程启动</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">init进程</a></td>
<td align="left">Linux系统中用户空间的第一个进程, Init.main</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">zygote进程</a></td>
<td align="left">所有Ａpp进程的父进程, ZygoteInit.main</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/02/14/android-system-server/" target="_blank" rel="noopener">system_server进程(上篇)</a></td>
<td align="left">系统各大服务的载体, forkSystemServer过程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/02/20/android-system-server-2/" target="_blank" rel="noopener">system_server进程(下篇)</a></td>
<td align="left">系统各大服务的载体, SystemServer.main</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">servicemanager进程</a></td>
<td align="left">binder服务的大管家, 守护进程循环运行在binder_loop</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">app进程</a></td>
<td align="left">通过Process.start启动App进程, ActivityThread.main</td>
</tr>
</tbody></table>
<p>再来看看守护进程(也就是进程名一般以d为后缀，比如logd，此处d是指daemon的简称), 下面介绍部分守护进程：</p>
<ul>
<li><a href="http://gityuan.com/2016/06/15/android-debuggerd/" target="_blank" rel="noopener">debuggerd</a></li>
<li><a href="http://gityuan.com/2016/11/13/android-installd" target="_blank" rel="noopener">installd</a></li>
<li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">lmkd</a></li>
<li><a href="http://gityuan.com/2018/01/27/android-log/" target="_blank" rel="noopener">logd</a></li>
</ul>
<h4 id="系统稳定性系列"><a href="#系统稳定性系列" class="headerlink" title="系统稳定性系列"></a>系统稳定性系列</h4><p><a href="http://gityuan.com/2016/06/19/stability_summary/" target="_blank" rel="noopener">Android系统稳定性</a>主要是异常崩溃(crash)和执行超时(timeout),:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="noopener">理解Android ANR的触发原理</a></td>
<td align="left">触发ANR的场景以及机理</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">Input系统—ANR原理分析</a></td>
<td align="left">input触发ANR的原理</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/12/02/app-not-response/" target="_blank" rel="noopener">理解Android ANR的信息收集过程</a></td>
<td align="left">AMS.appNotResponding过程分析,收集traces</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></td>
<td align="left">kill -3 信息收集过程</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/11/27/native-traces/" target="_blank" rel="noopener">Native进程之Trace原理</a></td>
<td align="left">debuggerd -b 信息收集过程</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/06/21/watchdog/" target="_blank" rel="noopener">WatchDog工作原理</a></td>
<td align="left">WatchDog触发机制</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="noopener">理解Java Crash处理流程</a></td>
<td align="left">AMS.handleApplicationCrash过程分析</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/06/25/android-native-crash/" target="_blank" rel="noopener">理解Native Crash处理流程</a></td>
<td align="left">debuggerd守护进程</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2019/01/19/global_ref/" target="_blank" rel="noopener">global reference限制策略</a></td>
<td align="left">global reference</td>
</tr>
</tbody></table>
<h4 id="Android进程系列"><a href="#Android进程系列" class="headerlink" title="Android进程系列"></a>Android进程系列</h4><p>进程/线程是操作系统的魂，各种服务、组件、子系统都是依附于具体的进程实体。深入理解进程机制对于掌握Android系统整体架构和运转机制是非常有必要的，是系统工程师的基本功，下面列举进程相关的文章：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a></td>
<td align="left">Process.start过程分析</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/04/16/kill-signal/" target="_blank" rel="noopener">理解杀进程的实现原理</a></td>
<td align="left">Process.killProcess过程分析</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/10/09/app-process-create-2/" target="_blank" rel="noopener">Android四大组件与进程启动的关系</a></td>
<td align="left">AMS.startProcessLocked过程分析组件与进程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/10/22/force-stop/" target="_blank" rel="noopener">Android进程绝杀技–forceStop</a></td>
<td align="left">force-stop过程分析彻底移除组件与杀进程</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/09/24/android-thread/" target="_blank" rel="noopener">理解Android线程创建流程</a></td>
<td align="left">3种不同线程的创建过程</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a></td>
<td align="left">以start-service为线,阐述进程间通信机理</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">理解Binder线程池的管理</a></td>
<td align="left">Zygote fork的进程都默认开启binder线程池</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2015/10/01/process-lifecycle/" target="_blank" rel="noopener">Android进程生命周期与ADJ</a></td>
<td align="left">进程adj, processState以及lmk</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></td>
<td align="left">lmk原理分析</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2015/10/01/process-priority/" target="_blank" rel="noopener">进程优先级</a></td>
<td align="left">进程nice,thread priority以及scheduler</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a></td>
<td align="left">updateOomAdjLocked过程</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2015/12/19/android-process-category/" target="_blank" rel="noopener">Android进程整理</a></td>
<td align="left">整理系统的所有进程/线程</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="http://gityuan.com/2018/05/19/android-process-adj/" target="_blank" rel="noopener">解读Android进程优先级ADJ算法</a></td>
<td align="left">Android进程ADJ优先级</td>
</tr>
</tbody></table>
<h4 id="四大组件系列"><a href="#四大组件系列" class="headerlink" title="四大组件系列"></a>四大组件系列</h4><p>对于App来说，Android应用的四大组件Activity，Service，Broadcast Receiver， Content Provider最为核心，接下分别展开介绍：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/03/18/start-activity-cycle/" target="_blank" rel="noopener">简述Activity生命周期</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService启动过程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/05/01/bind-service/" target="_blank" rel="noopener">bindService启动过程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">以Binder视角来看Service启动</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/06/04/broadcast-receiver/" target="_blank" rel="noopener">Android Broadcast广播机制分析</a></td>
<td align="left">Broadcast</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="noopener">理解ContentProvider原理</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/05/03/content_provider_release/" target="_blank" rel="noopener">ContentProvider引用计数</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2015/05/31/android-lifecycle/" target="_blank" rel="noopener">Activity与Service生命周期</a></td>
<td align="left">Activity&amp;&amp;Service</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2017/04/16/activity-with-window/" target="_blank" rel="noopener">简述Activity与Window关系</a></td>
<td align="left">Activity&amp;&amp;Window</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2017/05/19/ams-abstract/" target="_blank" rel="noopener">四大组件之综述</a></td>
<td align="left">AMS</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2017/05/25/service_record/" target="_blank" rel="noopener">四大组件之ServiceRecord</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="http://gityuan.com/2017/06/03/broadcast_record/" target="_blank" rel="noopener">四大组件之BroadcastRecord</a></td>
<td align="left">Broadcast</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="http://gityuan.com/2017/06/04/content_provider_record/" target="_blank" rel="noopener">四大组件之ContentProviderRecord</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="http://gityuan.com/2017/04/09/android_context/" target="_blank" rel="noopener">理解Android Context</a></td>
<td align="left">Context</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="http://gityuan.com/2017/04/02/android-application/" target="_blank" rel="noopener">理解Application创建过程</a></td>
<td align="left">Application</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="http://gityuan.com/2016/05/02/unbind-service/" target="_blank" rel="noopener">unbindService流程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="http://gityuan.com/2017/06/11/activity_record/" target="_blank" rel="noopener">四大组件之ActivityRecord</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="http://gityuan.com/2017/06/25/ams_summary_1/" target="_blank" rel="noopener">AMS总结(一)</a></td>
<td align="left">AMS</td>
</tr>
</tbody></table>
<h4 id="图形系统系列"><a href="#图形系统系列" class="headerlink" title="图形系统系列"></a>图形系统系列</h4><p>图形也是整个系统非常复杂且重要的一个系列，涉及WindowManager,SurfaceFlinger服务。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2017/01/08/windowmanger/" target="_blank" rel="noopener">WindowManager启动篇</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2017/01/15/wms_starting_window/" target="_blank" rel="noopener">WMS之启动窗口篇</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2017/01/22/start-activity-wms/" target="_blank" rel="noopener">以Window视角来看startActivity</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">Android图形系统概述</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2017/02/11/surface_flinger/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">SurfaceFlinger绘图篇</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">Choreographer原理</a></td>
<td align="left">Choreographer</td>
</tr>
</tbody></table>
<h4 id="系统服务篇"><a href="#系统服务篇" class="headerlink" title="系统服务篇"></a>系统服务篇</h4><p>再则就是在整个架构中有大量的服务，都是基于<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder</a>来交互的，<a href="http://gityuan.com/2016/10/01/system_service_common/" target="_blank" rel="noopener">Android系统服务的注册过程</a>也是在此之上的构建的。计划针对部分核心服务来重点分析：</p>
<ul>
<li>AMS服务<ul>
<li><a href="http://gityuan.com/2016/02/21/activity-manager-service/" target="_blank" rel="noopener">AMS启动过程（一）</a></li>
<li>更多组件篇[见小节4.3]</li>
</ul>
</li>
<li>Input系统<ul>
<li><a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">Input系统—启动篇</a></li>
<li><a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">Input系统—InputReader线程</a></li>
<li><a href="http://gityuan.com/2016/12/17/input-dispatcher/" target="_blank" rel="noopener">Input系统—InputDispatcher线程</a></li>
<li><a href="http://gityuan.com/2016/12/24/input-ui/" target="_blank" rel="noopener">Input系统—UI线程</a></li>
<li><a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">Input系统—进程交互</a></li>
<li><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">Input系统—ANR原理分析</a></li>
</ul>
</li>
<li>PKMS服务<ul>
<li><a href="http://gityuan.com/2016/11/06/packagemanager" target="_blank" rel="noopener">PackageManager启动篇</a></li>
<li><a href="http://gityuan.com/2016/11/13/android-installd" target="_blank" rel="noopener">Installd守护进程</a></li>
</ul>
</li>
<li>Alarm服务<ul>
<li><a href="http://gityuan.com/2017/03/12/alarm_manager_service/" target="_blank" rel="noopener">理解AlarmManager机制</a></li>
</ul>
</li>
<li>JobScheduler服务<ul>
<li><a href="http://gityuan.com/2017/03/10/job_scheduler_service/" target="_blank" rel="noopener">理解JobScheduler机制</a></li>
</ul>
</li>
<li>BatteryService<ul>
<li><a href="http://gityuan.com/2016/01/10/power_rank/" target="_blank" rel="noopener">Android耗电统计算法</a></li>
</ul>
</li>
<li>PMS服务</li>
<li>DropBox服务<ul>
<li><a href="http://gityuan.com/2016/06/12/DropBoxManagerService/" target="_blank" rel="noopener">DropBoxManager启动篇</a></li>
</ul>
</li>
<li>UserManagerService<ul>
<li><a href="http://gityuan.com/2016/11/20/user_manager/" target="_blank" rel="noopener">多用户管理UserManager</a></li>
</ul>
</li>
<li>更多系统服务</li>
</ul>
<h4 id="内存-amp-amp-存储篇"><a href="#内存-amp-amp-存储篇" class="headerlink" title="内存&amp;&amp;存储篇"></a>内存&amp;&amp;存储篇</h4><ul>
<li>内存篇<ul>
<li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></li>
<li><a href="http://gityuan.com/2015/10/30/kernel-memory/" target="_blank" rel="noopener">Linux内存管理</a></li>
<li><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">Android内存分析命令</a></li>
</ul>
</li>
<li>存储篇<ul>
<li><a href="http://gityuan.com/2016/07/17/android-io/" target="_blank" rel="noopener">Android存储系统之源码篇</a></li>
<li><a href="http://gityuan.com/2016/07/23/android-io-arch" target="_blank" rel="noopener">Android存储系统之架构篇</a></li>
</ul>
</li>
<li>Linux驱动篇</li>
<li>dalvik/art<ul>
<li><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></li>
</ul>
</li>
</ul>
<h4 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h4><p>再来说说Android相关的一些常用命令和工具以及调试手段.</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/19/android-build/" target="_blank" rel="noopener">理解Android编译命令</a></td>
<td align="left">build</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2018/06/02/android-bp/" target="_blank" rel="noopener">理解Android.bp</a></td>
<td align="left">build</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">性能工具Systrace</a></td>
<td align="left">systrace</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">Android内存分析命令</a></td>
<td align="left">Memory</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2015/10/11/ps-command/" target="_blank" rel="noopener">ps进程命令</a></td>
<td align="left">Process</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/02/27/am-command/" target="_blank" rel="noopener">Am命令用法</a></td>
<td align="left">Am</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/02/28/pm-command/" target="_blank" rel="noopener">Pm命令用法</a></td>
<td align="left">Pm</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/06/10/bugreport/" target="_blank" rel="noopener">调试系列1：bugreport源码篇</a></td>
<td align="left">bugreport</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/06/11/bugreport-2/" target="_blank" rel="noopener">调试系列2：bugreport实战篇</a></td>
<td align="left">bugreport</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/05/14/dumpsys-command/" target="_blank" rel="noopener">dumpsys命令用法</a></td>
<td align="left">dumpsys</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2018/01/27/android-log/" target="_blank" rel="noopener">Android logd日志原理</a></td>
<td align="left">logd</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2017/09/09/gdb/" target="_blank" rel="noopener">介绍gdb调试工具</a></td>
<td align="left">gdb</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2017/09/02/addr2line/" target="_blank" rel="noopener">介绍addr2line调试命令</a></td>
<td align="left">addr2line</td>
</tr>
</tbody></table>
<h4 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h4><p>下面列举处理过的部分较为典型的案例，供大家参考</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2018/05/12/binder-driver-bug/" target="_blank" rel="noopener">Binder Driver缺陷导致定屏的案例</a></td>
<td align="left">binder</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2019/01/13/arraymap/" target="_blank" rel="noopener">深度解读ArrayMap优势与缺陷</a></td>
<td align="left">ArrayMap</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2018/02/10/reboot-locked-method/" target="_blank" rel="noopener">数组越界导致系统重启的案例</a></td>
<td align="left">数组越界</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2018/02/03/log-fc/" target="_blank" rel="noopener">一行Log引发多线程并发问题的案例</a></td>
<td align="left">多线程并发</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2018/02/17/monkey-deadlock/" target="_blank" rel="noopener">跑monkey压力测试过程的冻屏案例</a></td>
<td align="left">monkey冻屏</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2018/02/24/process-keep-forever/" target="_blank" rel="noopener">深度剖析APP保活案例</a></td>
<td align="left">保活</td>
</tr>
</tbody></table>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Android系统之博大精深，包括Linux内核、Native、虚拟机、Framework，通过系统调用连通内核与用户空间，通过JNI打通用户空间的Java层和Native层，通过Binder、Socket、Handler等打通跨进程、跨线程的信息交换。只有真正阅读并理解系统核心架构的设计，解决问题和设计方案才能做到心中无剑胜有剑，才能做到知其然知其所以然。当修炼到此，恭喜你对系统有了更高一个层次的理解，正如太极剑法，忘记了所有招式，也就练成了太极剑法。</p>
<p>再回过头去看看那些API，看到的将不再是一行行代码、一个个接口的调用，而是各种信息的传递与交互工作，而是背后成千上万个小蝌蚪的动态执行流。记得《侠客行》里面的龙木二岛主终其一生也无法参透太玄经，石破天却短短数日练成绝世神功，究其根源是龙木二岛主以静态视角去解读太玄经，而石破天把墙壁的图案想象成无数游动的蝌蚪，最终成就绝世神功。一言以蔽之，程序代码是死的，系统运转是活的，要以动态视角去理解系统架构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BDppt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/22/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BDppt/" itemprop="url">如何做好ppt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-22T19:50:44+08:00">
                2020-05-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/22/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BDppt/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/22/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BDppt/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>普通人做的PPT，和高手做的专业PPT，最主要的差别在5个方面，具体如下：</p>
<ol>
<li><p>逻辑思路 </p>
</li>
<li><p>配色和字体 </p>
</li>
<li><p>图形化表达 </p>
</li>
<li><p>细节处理（图标等）</p>
</li>
<li><p>页面设计</p>
</li>
</ol>
<p>换句话说，只要我们找到办法，解决好这5个问题，我们同样可以做出非常漂亮的PPT作品。</p>
<h1 id="逻辑思路"><a href="#逻辑思路" class="headerlink" title="逻辑思路"></a>逻辑思路</h1><p>PPT的本质是<strong>表达思想、观点、知识</strong>。所以首先我们自己必须对自己<strong>要表达的内容非常清楚</strong>，并且能够梳<strong>理成条理分明、简洁明了的树状结构</strong>。</p>
<p>如果想要表达的意思都模糊、混乱，讲不清楚，那么即便PPT设计得再精美也没有意义。它就像是PPT的灵魂，在本质上决定了一份PPT的高度。</p>
<p>对表达内容逻辑条理的梳理，是PPT制作中最核心的工作，但也是唯一比较难用“整合”的方法去提高的一个工作。这方面的解决办法，我们放到最后面来解决。</p>
<h1 id="配色和字体"><a href="#配色和字体" class="headerlink" title="配色和字体"></a>配色和字体</h1><p>很多时候，一份PPT给我们很Low的感觉，主要是因为它的配色、字体用得不好。之所以如此，是因为大部分人对色彩的认识都是非常不专业的，对什么是好的色彩搭配，什么是不好的色彩搭配，基本停留在“靠感觉”的阶段。</p>
<p>我国的学校教育，除了相关专业，好像基本也不会涉及色彩知识的教育。所以所有人都停留在很低的层次，差别主要在天赋。</p>
<p>什么叫“业余”的色彩搭配配？我们来看个例子：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/61ea1df4jw1f8vfilk9swj20hs0dc753.jpg" alt="业余PPT配色"></p>
<p>这种PPT，我们在很多国企、事业单位看到。鲜艳而低俗的配色，一下子拉低了PPT整体档次。</p>
<p>当然，上面这张PPT之所以不好看，不仅限于配色，它的差是全方位的，这点我们后面会接着说。</p>
<p>基本同样的内容，我们稍微调整一下配色、结构，大家会发现效果就完全不一样了：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/61ea1df4jw1f8vfilzpwrj20hs0a40t9.jpg" alt="PPT配色改进"></p>
<p>普通人如何提高自己的PPT配色水平呢？下面会给出最快速的解决方案，下面先说忌讳点：</p>
<ul>
<li>不要用纯度太高的颜色、不要用对比度太强烈太刺眼的颜色、一张PPT不要弄太多颜色！</li>
</ul>
<p>再来说字体。很多人喜欢在PPT里面用宋体、隶书、楷书等字体。这些字体想用好都是非常难的，大部分人用出来的效果都惨不忍睹，如下图：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/61ea1df4jw1f8vfim9yw7j20hs0ddab1.jpg" alt="PPT字体混乱"></p>
<p>这也是经常见到的一种ppt风格，常见于中老年人做出来的作品当中。</p>
<p>还有这样的：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/61ea1df4jw1f8vfinfl02j20hs0dcjsn.jpg" alt="PPT风格老气"></p>
<p>其实只要有正常审美的人，都会知道这样的PPT是“不好看”的，很可能制作的人自己也非常羞愧。问题是有心无力，想做得漂亮点，真不知道如何用力。</p>
<p><strong>给大家的建议：</strong></p>
<p>我们要在短时间内就能做出专业的PPT，如果从头开始学习色彩搭配学、字体搭配学，甚至是字体的设计，那学到天荒地老都不一定能学好。更何况，配色和字体只不过是ppt组成的其中一小部分而已。</p>
<p>我们不需要成为色彩搭配和字体搭配的专家，通过整合的方法，只要使用别人经过磨练的成熟结果即可！</p>
<p>先说字体：<strong>最保守且安全的选择，全部用微软雅黑</strong>。 这肯定不是最佳的选择，但你要提升自己对字体的掌控能力，说不得小半年又过去了！在这之前，请老老实实地用微软雅黑这种字体吧。</p>
<p>再说配色，教大家2个最快的方法：</p>
<p><strong>方法1：直接记录好的配色组合</strong></p>
<p>工具：一个Word文档（或者直接就是PPT文档），一个Photoshop软件。</p>
<p>方法：找到各种经典的PPT，把它们的色彩搭配记录下来（用Photoshop的取色功能，记录下颜色的代码值）。</p>
<p><strong>方法2：直接使用色彩搭配工具</strong></p>
<p>现在网络上已经有很多网站或者工具，可以给我们成熟的色彩搭配组合，我们直接使用就是了。</p>
<p>工具1：<a href="http://www.peise.net/tools/web/" target="_blank" rel="noopener">http://www.peise.net/tools/web/</a></p>
<p>工具2：<a href="http://www.peise.net/palette/" target="_blank" rel="noopener">http://www.peise.net/palette/</a></p>
<p>工具3：<a href="https://color.adobe.com/zh/create/color-wheel/" target="_blank" rel="noopener">https://color.adobe.com/zh/create/color-wheel/</a></p>
<h1 id="图形化表达"><a href="#图形化表达" class="headerlink" title="图形化表达"></a>图形化表达</h1><p>专业级别的PPT，图片必须是清晰的，大的，震撼的。好的图片，能够极大程度提升ppt的逼格和档次。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/61ea1df4jw1f8vfinxsx7j20go09ddg1.jpg" alt="PPT图形化表达"></p>
<p>而且你如果仔细研究，发现在PPT里做出这样的效果其实并不复杂：<strong>一张足够有说服力的、清晰的大图，以及适度放一些说明文字。</strong></p>
<p><img src="http://ww3.sinaimg.cn/mw690/61ea1df4jw1f8vfio85d5j20hs0d60te.jpg" alt="PPT失败案例"></p>
<p>别笑，我们大部分人曾经都做过这种等级的PPT。不少人的巅峰水准可能就停留在这个档位了。</p>
<p>如何用好图片，让我们的PPT看起来很牛掰？很高冷？</p>
<ul>
<li>图片一定要清晰</li>
<li>图片最好不要太多花哨的元素，要有一大片干净的区域，适合我们用来放文字、标题等信息</li>
<li>图片和文字搭配在一起要协调、美观</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/" itemprop="url">使用AIDL实现一个多进程消息推送(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-22T00:19:00+08:00">
                2020-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/22/Android/Binder/%E4%BD%BF%E7%94%A8AIDL%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>像图片选择这样的多进程需求，可能并不需要我们额外编写进程通讯的代码，使用四大组件传输Bundle就行了，但是像推送服务这种需求，进程与进程之间需要高度的交互，此时就绕不过进程通讯这一步了。</p>
<p>下面我们就用即时聊天软件为例，手动去实现一个多进程的推送例子，具体需求如下：</p>
<ol>
<li>UI和消息推送的Service分两个进程；</li>
<li>UI进程用于展示具体的消息数据，把用户发送的消息，传递到消息Service，然后发送到远程服务器；</li>
<li>Service负责收发消息，并和远程服务器保持长连接，UI进程可通过Service发送消息到远程服务器，Service收到远程服务器消息通知UI进程；</li>
<li>即使UI进程退出了，Service仍需要保持运行，收取服务器消息。</li>
</ol>
<p><strong>实现思路</strong></p>
<ol>
<li><p>创建UI进程（下文统称为客户端）；</p>
</li>
<li><p>创建消息Service（下文统称为服务端）；</p>
</li>
<li><p>把服务端配置到独立的进程(AndroidManifest.xml中指定process标签)；</p>
</li>
<li><p>客户端和服务端进行绑定（bindService）；</p>
</li>
<li><p>让客户端和服务端具备交互的能力。(AIDL使用)</p>
</li>
</ol>
<h1 id="例子具体实现"><a href="#例子具体实现" class="headerlink" title="例子具体实现"></a>例子具体实现</h1><h2 id="AIDL调用流程概览"><a href="#AIDL调用流程概览" class="headerlink" title="AIDL调用流程概览"></a>AIDL调用流程概览</h2><p>开始之前，我们先来概括一下使用AIDL进行多进程调用的整个流程：</p>
<ol>
<li>客户端使用bindService方法绑定服务端；</li>
<li>服务端在onBind方法返回Binder对象；</li>
<li>客户端拿到服务端返回的Binder对象进行跨进程方法调用；</li>
</ol>
<p><img src="http://jsh180.net/blog_aidl_img_flow_1.jpg" alt="AIDL调用过程"></p>
<p><strong>整个AIDL调用过程概括起来就以上3个步骤，下文中我们使用上面描述的例子，来逐步分解这些步骤，并讲述其中的细节。</strong></p>
<h2 id="客户端使用bindService方法绑定服务端"><a href="#客户端使用bindService方法绑定服务端" class="headerlink" title="客户端使用bindService方法绑定服务端"></a>客户端使用bindService方法绑定服务端</h2><h3 id="创建客户端和服务端，把服务端配置到另外的进程"><a href="#创建客户端和服务端，把服务端配置到另外的进程" class="headerlink" title="创建客户端和服务端，把服务端配置到另外的进程"></a>创建客户端和服务端，把服务端配置到另外的进程</h3><ol>
<li>创建客户端 -&gt; MainActivity；</li>
<li>创建服务端 -&gt; MessageService;</li>
<li>把服务端配置到另外的进程 -&gt; android:process=”:remote”</li>
</ol>
<p>上面描述的客户端、服务端、以及把服务端配置到另外进程，体现在AndroidManifest.xml中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;application ...&gt;</span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.test.test_aidl.TestAidlMessageActivity&quot; &#x2F;&gt;</span><br><span class="line">        &lt;service</span><br><span class="line">            android:name&#x3D;&quot;.test.test_aidl.MessageService&quot;</span><br><span class="line">            android:enabled&#x3D;&quot;true&quot;</span><br><span class="line">            android:exported&#x3D;&quot;true&quot;</span><br><span class="line">            android:process&#x3D;&quot;:remote&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>

<p>开启多进程的方法很简单，只需要给四大组件指定android:process标签。</p>
<h3 id="绑定MessageService到MainActivity"><a href="#绑定MessageService到MainActivity" class="headerlink" title="绑定MessageService到MainActivity"></a>绑定MessageService到MainActivity</h3><p><strong>创建MessageService</strong></p>
<p>此时的MessageService就是刚创建的模样，onBind中返回了null，下一步中我们将返回一个可操作的对象给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line">    </span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端MainActivity调用bindService方法绑定MessageService</strong></p>
<p>这一步其实是属于Service组件相关的知识，在这里就比较简单地说一下，启动服务可以通过以下两种方式：</p>
<ul>
<li>使用bindService方法 -&gt; bindService(Intent service, ServiceConnection conn, int flags)；</li>
<li>使用startService方法 -&gt; startService(Intent service);</li>
</ul>
<p><strong>bindService &amp; startService区别：</strong></p>
<p>使用bindService方式，多个Client可以同时bind一个Service，但是当所有Client unbind后，Service会退出，通常情况下，如果希望和Service交互，一般使用bindService方法，使用onServiceConnected中的IBinder对象可以和Service进行交互，不需要和Service交互的情况下，使用startService方法即可。</p>
<p>正如上面所说，我们是要和Service交互的，所以我们需要使用bindService方法，<strong>但是我们希望unbind后Service仍保持运行，这样的情况下，可以同时调用bindService和startService</strong>（比如像本例子中的消息服务，退出UI进程，Service仍需要接收到消息），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端在onBind方法返回Binder对象"><a href="#服务端在onBind方法返回Binder对象" class="headerlink" title="服务端在onBind方法返回Binder对象"></a>服务端在onBind方法返回Binder对象</h2><h3 id="首先，什么是Binder"><a href="#首先，什么是Binder" class="headerlink" title="首先，什么是Binder?"></a>首先，什么是Binder?</h3><p>要说Binder，首先要说一下IBinder这个接口，IBinder是远程对象的基础接口，轻量级的远程过程调用机制的核心部分，该接口描述了与远程对象交互的抽象协议，而Binder实现了IBinder接口，简单说，Binder就是Android SDK中内置的一个多进程通讯实现类，在使用的时候，我们不用也不要去实现IBinder，而是继承Binder这个类即可实现多进程通讯。</p>
<h3 id="其次，这个需要在onBind方法返回的Binder对象从何而来？"><a href="#其次，这个需要在onBind方法返回的Binder对象从何而来？" class="headerlink" title="其次，这个需要在onBind方法返回的Binder对象从何而来？"></a>其次，这个需要在onBind方法返回的Binder对象从何而来？</h3><p><strong>在这里就要引出本文中的主题了——AIDL</strong></p>
<p>多进程中使用的Binder对象，一般通过我们定义好的 .adil 接口文件自动生成，当然你可以走野路子，直接手动编写这个跨进程通讯所需的Binder类，其本质无非就是一个继承了Binder的类，鉴于野路子走起来麻烦，而且都是重复步骤的工作，Google提供了 AIDL 接口来帮我们自动生成Binder这条正路，下文中我们围绕 AIDL 这条正路继续展开讨论</p>
<h3 id="定义AIDL接口"><a href="#定义AIDL接口" class="headerlink" title="定义AIDL接口"></a>定义AIDL接口</h3><p>很明显，接下来我们需要搞一波上面说的Binder，让客户端可以调用到服务端的方法，而这个Binder又是通过AIDL接口自动生成，那我们就先从AIDL搞起，搞之前先看看注意事项，以免出事故：</p>
<p>AIDL支持的数据类型：</p>
<ul>
<li>Java 编程语言中的所有基本数据类型（如 int、long、char、boolean 等等）</li>
<li>String和CharSequence</li>
<li>Parcelable：实现了Parcelable接口的对象</li>
<li>List：其中的元素需要被AIDL支持，另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口</li>
<li>Map：其中的元素需要被AIDL支持，包括 key 和 value，另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接口</li>
</ul>
<p>其他注意事项：</p>
<ul>
<li>在AIDL中传递的对象，必须实现Parcelable序列化接口；</li>
<li>在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类；</li>
<li>跟普通接口的区别：只能声明方法，不能声明变量；</li>
<li>所有非基础数据类型参数都需要标出数据走向的方向标记。可以是 in、out 或 inout，基础数据类型默认只能是 in，不能是其他方向。</li>
</ul>
<h3 id="创建一个AIDL接口"><a href="#创建一个AIDL接口" class="headerlink" title="创建一个AIDL接口"></a>创建一个AIDL接口</h3><p>接口中提供发送消息的方法（Android Studio创建AIDL：项目右键 -&gt; New -&gt; AIDL -&gt; AIDL File），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageSender.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface MessageSender &#123;</span><br><span class="line">    void sendMessage(in MessageModel messageModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被“in”标记的参数，就是接收实际数据的参数，这个跟我们普通参数传递一样的含义。在AIDL中，“out” 指定了一个仅用于输出的参数，换而言之，这个参数不关心调用方传递了什么数据过来，但是这个参数的值可以在方法被调用后填充（无论调用方传递了什么值过来，在方法执行的时候，这个参数的初始值总是空的），这就是“out”的含义，仅用于输出。而“inout”显然就是“in”和“out”的合体了，输入和输出的参数。区分“in”、“out”有什么用？这是非常重要的，因为每个参数的内容必须编组（序列化，传输，接收和反序列化）。in/out标签允许Binder跳过编组步骤以获得更好的性能。</p>
</blockquote>
<p>上述的MessageModel为消息的实体类，该类在AIDL中传递，实现了Parcelable序列化接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.model;</span><br><span class="line"></span><br><span class="line">import android.os.Parcel;</span><br><span class="line">import android.os.Parcelable;</span><br><span class="line"></span><br><span class="line">public class MessageModel implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    private String from;</span><br><span class="line">    private String to;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public MessageModel() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MessageModel(String from, String to, String content) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected MessageModel(Parcel in) &#123;</span><br><span class="line">        from &#x3D; in.readString();</span><br><span class="line">        to &#x3D; in.readString();</span><br><span class="line">        content &#x3D; in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;MessageModel&gt; CREATOR &#x3D; new Creator&lt;MessageModel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public MessageModel createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new MessageModel(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public MessageModel[] newArray(int size) &#123;</span><br><span class="line">            return new MessageModel[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public String getFrom() &#123;</span><br><span class="line">        return from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFrom(String from) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTo() &#123;</span><br><span class="line">        return to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTo(String to) &#123;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MessageModel&#123;&quot; +</span><br><span class="line">                &quot;from&#x3D;&#39;&quot; + from + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, to&#x3D;&#39;&quot; + to + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(from);</span><br><span class="line">        dest.writeString(to);</span><br><span class="line">        dest.writeString(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完MessageModel这个实体类，别忘了还有一件事要做：”在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类“。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageModel.aidl</span><br><span class="line">package com.zhyen.android.model;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">parcelable MessageModel;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>MessageSender.aidl -&gt; 定义了发送消息的方法，会自动生成名为MessageSender.Stub的Binder类，在服务端实现，返回给客户端调用</li>
<li>MessageModel.java -&gt; 消息实体类，由客户端传递到服务端，实现了Parcelable序列化</li>
<li>MessageModel.aidl -&gt; 声明了MessageModel可在AIDL中传递，放在跟MessageModel.java相同的包路径下</li>
</ul>
<h3 id="服务端MessageService"><a href="#服务端MessageService" class="headerlink" title="服务端MessageService"></a>服务端MessageService</h3><p>在服务端创建MessageSender.aidl这个AIDL接口自动生成的Binder对象，并返回给客户端调用，服务端MessageService代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MessageService&quot;;</span><br><span class="line"></span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageSender.Stub是Android Studio根据我们MessageSender.aidl文件自动生成的Binder对象（至于是怎样生成的，下文会有答案），我们需要把这个Binder对象返回给客户端。</p>
<h2 id="客户端拿到Binder对象后调用远程方法"><a href="#客户端拿到Binder对象后调用远程方法" class="headerlink" title="客户端拿到Binder对象后调用远程方法"></a>客户端拿到Binder对象后调用远程方法</h2><p>调用步骤如下：</p>
<ol>
<li>在客户端的onServiceConnected方法中，拿到服务端返回的Binder对象；</li>
<li>使用MessageSender.Stub.asInterface方法，取得MessageSender.aidl对应的操作接口；</li>
<li>取得MessageSender对象后，像普通接口一样调用方法即可。</li>
</ol>
<p>此时客户端代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中我们调用了MessageSender的sendMessage方法，向服务端发送了一条消息，并把生成的MessageModel对象作为参数传递到了服务端，最终服务端打印的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 10:53:25.747 22509-22545&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两点要说：</p>
<ul>
<li>服务端已经接收到客户端发送过来的消息，并正确打印；</li>
<li>服务端和客户端区分两个进程，PID不一样，进程名也不一样；</li>
</ul>
<h1 id="分析Binder上层机制"><a href="#分析Binder上层机制" class="headerlink" title="分析Binder上层机制"></a>分析Binder上层机制</h1><p>我们通过上述的调用流程，看看从客户端到服务端，都经历了些什么事，看看Binder的上层是如何工作的，至于Binder的底层，这是一个非常复杂的话题，本文不深究。（如果看到这里你又想问什么是Binder的话，请手动倒带往上看…）</p>
<p>我们先来回顾一下从客户端发起的调用流程：</p>
<ul>
<li>MessageSender messageSender = MessageSender.Stub.asInterface(service);</li>
<li>messageSender.sendMessage(messageModel);</li>
</ul>
<p>抛开其它无关代码，客户端调跨进程方法就这两个步骤，而这两个步骤都封装在 MessageSender.aidl 最终生成的 MessageSender.java 源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> *&#x2F;</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">public interface MessageSender extends android.os.IInterface &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.zhyen.android.MessageSender &#123;</span><br><span class="line">		    &#x2F;&#x2F;描述符，该值为全类名</span><br><span class="line">        private static final java.lang.String DESCRIPTOR &#x3D; &quot;com.zhyen.android.MessageSender&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         根据AIDL的使用流程，Server会在onBind的时候返回一个Stub实例，</span><br><span class="line">         调用了Stub的构造器内部调用Binder的attachInterface方法将当前实例以及描述符存到Binder实例中</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Stub() &#123;</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 把IBinder对象转换为MessageSender 接口</span><br><span class="line">         * 判断IBinder是否处于相同进程，相同进程返回Stub实现的MessageSender接口</span><br><span class="line">         * 不同进程，则返回Stub.Proxy实现的MessageSender接口</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public static com.zhyen.android.MessageSender asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">            if ((obj &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin !&#x3D; null) &amp;&amp; (iin instanceof com.zhyen.android.MessageSender))) &#123;</span><br><span class="line">                return ((com.zhyen.android.MessageSender) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.zhyen.android.MessageSender.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 同一进程时，不会触发</span><br><span class="line">         *</span><br><span class="line">         * 不同进程时，asInterface会返回Stub.Proxy，客户端调用 messageSender.sendMessage(messageModel)</span><br><span class="line">         * 实质是调用了 Stub.Proxy 的 sendMessage 方法，从而触发跨进程数据传递，</span><br><span class="line">         * 最终Binder底层将处理好的数据回调到此方法，并调用我们真正的sendMessage方法</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</span><br><span class="line">            java.lang.String descriptor &#x3D; DESCRIPTOR;</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_sendMessage: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.zhyen.android.model.MessageModel _arg0;</span><br><span class="line">                    if ((0 !&#x3D; data.readInt())) &#123;</span><br><span class="line">                        _arg0 &#x3D; com.zhyen.android.model.MessageModel.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _arg0 &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.sendMessage(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    return super.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.zhyen.android.MessageSender &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote &#x3D; remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * Proxy中的sendMessage方法，并不是直接调用我们定义的sendMessage方法，而是经过一顿的Parcel读写，</span><br><span class="line">             * 然后调用mRemote.transact方法，把数据交给Binder处理，transact处理完毕后会调用上方的onTransact方法，</span><br><span class="line">             * onTransact拿到最终得到的参数数据，调用由我们真正的sendMessage方法</span><br><span class="line">             *&#x2F;</span><br><span class="line">            @Override</span><br><span class="line">            public void sendMessage(com.zhyen.android.model.MessageModel messageModel) throws android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    if ((messageModel !&#x3D; null)) &#123;</span><br><span class="line">                        _data.writeInt(1);</span><br><span class="line">                        messageModel.writeToParcel(_data, 0);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        _data.writeInt(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;调用Binder的transact方法进行多进程数据传输，处理完毕后调用上方的onTransact方法</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_sendMessage, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_sendMessage &#x3D; (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(com.zhyen.android.model.MessageModel messageModel) throws android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只看代码的话，可能会有点懵逼，相信结合代码再看下方的流程图会更好理解：</p>
<p><img src="http://jsh180.net/image/jpg/blog_aidl_flowchart.jpg" alt="flow chart"></p>
<p>从客户端的sendMessage开始，整个AIDL的调用过程如上图所示，asInterface方法，将会判断onBind方法返回的Binder是否存处于同一进程，在同一进程中，则进行常规的方法调用，若处于不同进程，整个数据传递的过程则需要通过Binder底层去进行编组（序列化，传输，接收和反序列化），得到最终的数据后再进行常规的方法调用。</p>
<p><strong>对象跨进程传输的本质就是 序列化，传输，接收和反序列化 这样一个过程，这也是为什么跨进程传输的对象必须实现Parcelable接口</strong></p>
<h1 id="跨进程的回调接口"><a href="#跨进程的回调接口" class="headerlink" title="跨进程的回调接口"></a>跨进程的回调接口</h1><p>在上面我们已经实现了从客户端发送消息到跨进程服务端的功能，接下来我们还需要将服务端接收到的远程服务器消息，传递到客户端。有同学估计会说：“这不就是一个回调接口的事情嘛”，设置回调接口思路是对的，但是在这里使用的回调接口有点不一样，在AIDL中传递的接口，不能是普通的接口，只能是AIDL接口，所以我们需要新建一个AIDL接口传到服务端，作为回调接口。</p>
<p>新建消息收取的AIDL接口MessageReceiver.aidl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageReceiver.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line">&#x2F;&#x2F;消息回调接口</span><br><span class="line">interface MessageReceiver &#123;</span><br><span class="line">    void onMessageReceived(in MessageModel receivedMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们把回调接口注册到服务端去，修改我们的MessageSender.aidl:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MessageSender.aidl</span><br><span class="line">package com.zhyen.android;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">&#x2F;&#x2F; Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface MessageSender &#123;</span><br><span class="line">    void sendMessage(in MessageModel messageModel);</span><br><span class="line"></span><br><span class="line">    void registerReceiveListener(MessageReceiver messageReceiver);</span><br><span class="line"></span><br><span class="line">    void unregisterReceiveListener(MessageReceiver messageReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我们最终修改好的aidl接口，接下来我们需要做出对应的变更：</p>
<ul>
<li><p>在服务端中增加MessageSender的注册和反注册接口的方法；</p>
</li>
<li><p>在客户端中实现MessageReceiver接口，并通过MessageSender注册到服务端。</p>
</li>
</ul>
<p>客户端变更，修改MainActivity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_register).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (connected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.registerReceiveListener(messageReceiver);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消息监听回调接口</span><br><span class="line">    private MessageReceiver.Stub messageReceiver &#x3D; new MessageReceiver.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;onMessageReceived: &quot; + receivedMessage.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;解除消息监听接口</span><br><span class="line">        if (messageSender !&#x3D; null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                messageSender.unregisterReceiveListener(messageReceiver);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端主要有3个变更：</p>
<ol>
<li>增加了messageReceiver对象，用于监听服务端的消息通知；</li>
<li>onServiceConnected方法中，把messageReceiver注册到Service中去；</li>
<li>onDestroy时候解除messageReceiver的注册。</li>
</ol>
<p><strong>下面对服务端MessageServie进行变更：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteCallbackList;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line">public class MessageService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MessageService&quot;;</span><br><span class="line">    private AtomicBoolean serviceStop &#x3D; new AtomicBoolean();</span><br><span class="line">    &#x2F;&#x2F;RemoteCallbackList专门用来管理多进程回调接口</span><br><span class="line">    private RemoteCallbackList&lt;MessageReceiver&gt; listenerList &#x3D; new RemoteCallbackList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MessageService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.register(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.unregister(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        new Thread(new FakeTCPTask()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        serviceStop.set(true);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;模拟长连接，通知客户端有新消息到达</span><br><span class="line">    private class FakeTCPTask implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!serviceStop.get()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;Service&quot;);</span><br><span class="line">                messageModel.setTo(&quot;Client&quot;);</span><br><span class="line">                messageModel.setContent(String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * RemoteCallbackList的遍历方式</span><br><span class="line">                 * beginBroadcast和finishBroadcast一定要配对使用</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                final int listenerCount &#x3D; listenerList.beginBroadcast();</span><br><span class="line">                Log.d(TAG, &quot;listenerCount &#x3D;&#x3D; &quot; + listenerCount);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; listenerCount; i++) &#123;</span><br><span class="line">                    MessageReceiver messageReceiver &#x3D; listenerList.getBroadcastItem(i);</span><br><span class="line">                    if (messageReceiver !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            messageReceiver.onMessageReceived(messageModel);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                listenerList.finishBroadcast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端主要变更：</p>
<ol>
<li>MessageSender.Stub实现了注册和反注册回调接口的方法；</li>
<li>增加了RemoteCallbackList来管理AIDL远程接口；</li>
<li>FakeTCPTask模拟了长连接通知客户端有新消息到达。</li>
</ol>
<p>这里还有一个需要讲一下的，就是RemoteCallbackList，为什么要用RemoteCallbackList，普通ArrayList不行吗？当然不行，不然干嘛又整一个RemoteCallbackList 🙃，registerReceiveListener 和 unregisterReceiveListener在客户端传输过来的对象，经过Binder处理，在服务端接收到的时候其实是一个新的对象，这样导致在 unregisterReceiveListener 的时候，普通的ArrayList是无法找到在 registerReceiveListener 时候添加到List的那个对象的，但是它们底层使用的Binder对象是同一个，RemoteCallbackList利用这个特性做到了可以找到同一个对象，这样我们就可以顺利反注册客户端传递过来的接口对象了。RemoteCallbackList在客户端进程终止后，它能自动移除客户端所注册的listener，它内部还实现了线程同步，所以我们在注册和反注册都不需要考虑线程同步，的确是个666的类。（至于使用ArrayList的幺蛾子现象，大家可以自己试试，篇幅问题，这里就不演示了）</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>客户端结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 12:15:07.405 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120907403&#39;&#125;</span><br><span class="line">2020-05-22 12:15:10.408 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120910406&#39;&#125;</span><br><span class="line">2020-05-22 12:15:13.409 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120913408&#39;&#125;</span><br><span class="line">2020-05-22 12:15:16.411 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120916410&#39;&#125;</span><br><span class="line">2020-05-22 12:15:19.413 31763-31868&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120919412&#39;&#125;</span><br><span class="line">2020-05-22 12:15:22.415 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120922414&#39;&#125;</span><br><span class="line">2020-05-22 12:15:25.419 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120925417&#39;&#125;</span><br><span class="line">2020-05-22 12:15:28.422 31763-32268&#x2F;com.zhyen.android D&#x2F;TestAidlMessageActivity: onMessageReceived: MessageModel&#123;from&#x3D;&#39;Service&#39;, to&#x3D;&#39;Client&#39;, content&#x3D;&#39;1590120928420&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>服务端结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 12:14:37.395 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:39.397 32152-32152&#x2F;com.zhyen.android:remote D&#x2F;AwareBitmapCacher: handleInit disable com.zhyen.android:remote</span><br><span class="line">2020-05-22 12:14:40.395 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:43.397 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:46.398 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:49.399 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:52.400 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:55.400 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:14:56.750 32152-32191&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br><span class="line">2020-05-22 12:14:56.751 32152-32191&#x2F;com.zhyen.android:remote D&#x2F;MessageService: sendMessage: MessageModel&#123;from&#x3D;&#39;client user id&#39;, to&#x3D;&#39;receiver user id&#39;, content&#x3D;&#39;This is message content&#39;&#125;</span><br><span class="line">2020-05-22 12:14:58.401 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:01.402 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:04.402 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 0</span><br><span class="line">2020-05-22 12:15:07.403 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br><span class="line">2020-05-22 12:15:10.407 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br><span class="line">2020-05-22 12:15:13.408 32152-32192&#x2F;com.zhyen.android:remote D&#x2F;MessageService: listenerCount &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure>

<h1 id="DeathRecipient"><a href="#DeathRecipient" class="headerlink" title="DeathRecipient"></a>DeathRecipient</h1><p>不知道你有没有感觉到，两个进程交互总是觉得缺乏那么一点安全感…比如说服务端进程Crash了，而客户端进程想要调用服务端方法，这样就调用不到了。此时我们可以给Binder设置一个DeathRecipient对象，当Binder意外挂了的时候，我们可以在DeathRecipient接口的回调方法中收到通知，并作出相应的操作，比如重连服务等等。</p>
<p>DeathRecipient的使用如下：</p>
<ul>
<li>声明DeathRecipient对象，实现其binderDied方法，当binder死亡时，会回调binderDied方法；</li>
<li>给Binder对象设置DeathRecipient对象。</li>
</ul>
<p>在客户端MainActivity声明DeathRecipient：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android.test.test_aidl;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Binder;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import com.zhyen.android.MessageReceiver;</span><br><span class="line">import com.zhyen.android.MessageSender;</span><br><span class="line">import com.zhyen.android.R;</span><br><span class="line">import com.zhyen.android.model.MessageModel;</span><br><span class="line"></span><br><span class="line">public class TestAidlMessageActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;TestAidlMessageActivity&quot;;</span><br><span class="line">    private MessageSender messageSender;</span><br><span class="line">    private boolean connected;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_aidl_message_activity);</span><br><span class="line">        findViewById(R.id.btn_send_msg).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                &#x2F;&#x2F;使用asInterface方法取得AIDL对应的操作接口</span><br><span class="line">                MessageModel messageModel &#x3D; new MessageModel();</span><br><span class="line">                messageModel.setFrom(&quot;client user id&quot;);</span><br><span class="line">                messageModel.setTo(&quot;receiver user id&quot;);</span><br><span class="line">                messageModel.setContent(&quot;This is message content&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用远程Service的sendMessage方法，并传递消息实体对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.sendMessage(messageModel);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findViewById(R.id.btn_register).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (!connected) return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    messageSender.registerReceiveListener(messageReceiver);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setupService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setupService() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(this, MessageService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Binder可能会意外死忙（比如Service Crash），Client监听到Binder死忙后可以进行重连服务等操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Binder.DeathRecipient deathRecipient &#x3D; new IBinder.DeathRecipient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void binderDied() &#123;</span><br><span class="line">            Log.d(TAG, &quot;binderDied: &quot;);</span><br><span class="line">            if (messageSender !&#x3D; null) &#123;</span><br><span class="line">                messageSender.asBinder().unlinkToDeath(this, 0);</span><br><span class="line">                messageSender &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;重连服务或其他操作</span><br><span class="line">            setupService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消息监听回调接口</span><br><span class="line">    private MessageReceiver.Stub messageReceiver &#x3D; new MessageReceiver.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;onMessageReceived: &quot; + receivedMessage.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            connected &#x3D; true;</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: name &#x3D; &quot; + name);</span><br><span class="line">            Log.d(TAG, &quot;onServiceConnected: service &#x3D; &quot; + service);</span><br><span class="line">            messageSender &#x3D; MessageSender.Stub.asInterface(service);</span><br><span class="line">            &#x2F;&#x2F;设置Binder死亡监听</span><br><span class="line">            try &#123;</span><br><span class="line">                messageReceiver.asBinder().linkToDeath(deathRecipient, 0);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            connected &#x3D; false;</span><br><span class="line">            Log.d(TAG, &quot;onServiceDisconnected: name &#x3D; &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;解除消息监听接口</span><br><span class="line">        if (messageSender !&#x3D; null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                messageSender.unregisterReceiveListener(messageReceiver);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Binder中两个重要方法：</p>
<ol>
<li>linkToDeath -&gt; 设置死亡代理 DeathRecipient 对象；</li>
<li>unlinkToDeath -&gt; Binder死亡的情况下，解除该代理。</li>
</ol>
<p>此外，Binder中的isBinderAlive也可以判断Binder是否死亡。</p>
<h1 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h1><p>就算是公交车，上车也得嘀卡对不，如果希望我们的服务进程不想像公交车一样谁想上就上，那么我们可以加入权限验证。</p>
<p>介绍两种常用验证方法：</p>
<ul>
<li>在服务端的onBind中校验自定义permission，如果通过了我们的校验，正常返回Binder对象，校验不通过返回null，返回null的情况下客户端无法绑定到我们的服务；</li>
<li>在服务端的onTransact方法校验客户端包名，不通过校验直接return false，校验通过执行正常的流程。</li>
</ul>
<p>自定义permission，在Androidmanifest.xml中增加自定义的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission</span><br><span class="line">        android:name&#x3D;&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot;</span><br><span class="line">        android:protectionLevel&#x3D;&quot;normal&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>服务端检查权限的方法：</p>
<ul>
<li>校验权限的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        &#x2F;&#x2F;自定义permission方式检查权限</span><br><span class="line">        if (checkCallingOrSelfPermission(&quot;com.zhyen.android.permission.REMOTE_SERVICE_PERMISSION&quot;) &#x3D;&#x3D; PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onBind: 没有设置权限&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return stub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断包名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private MessageSender.Stub stub &#x3D; new MessageSender.Stub() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sendMessage(MessageModel messageModel) throws RemoteException &#123;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel);</span><br><span class="line">            if (messageModel &#x3D;&#x3D; null) return;</span><br><span class="line">            Log.d(TAG, &quot;sendMessage: &quot; + messageModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.register(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123;</span><br><span class="line">            listenerList.unregister(messageReceiver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 包名验证方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            String packageName &#x3D; null;</span><br><span class="line">            String[] packages &#x3D; getPackageManager().getPackagesForUid(getCallingUid());</span><br><span class="line">            if (packages !&#x3D; null &amp;&amp; packages.length &gt; 0) &#123;</span><br><span class="line">                packageName &#x3D; packages[0];</span><br><span class="line">            &#125;</span><br><span class="line">            if (packageName &#x3D;&#x3D; null || !packageName.startsWith(&quot;com.zhyen.android&quot;)) &#123;</span><br><span class="line">                Log.d(&quot;onTransact&quot;, &quot;拒绝调用：&quot; + packageName);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="根据不同进程，做不同的初始化工作"><a href="#根据不同进程，做不同的初始化工作" class="headerlink" title="根据不同进程，做不同的初始化工作"></a>根据不同进程，做不同的初始化工作</h1><p>相信前一两年很多朋友还在使用Android-Universal-Image-Loader来加载图片，它是需要在Application类进行初始化的。打个比如，我们用它来加载图片，而且还有一个图片选择进程，那么我们希望分配更多的缓存给图片选择进程，又或者是一些其他的初始化工作，不需要在图片选择进程初始化怎么办？</p>
<p>这里提供一个简单粗暴的方法，博主也是这么干的…直接拿到进程名判断，作出相应操作即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhyen.android;</span><br><span class="line"></span><br><span class="line">import android.app.ActivityManager;</span><br><span class="line">import android.app.Application;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.nfc.Tag;</span><br><span class="line">import android.os.Process;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ZhyenApplication extends Application &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;ZhyenApplication&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.d(TAG, getProcessName(getApplicationContext()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得进程名</span><br><span class="line">    public static String getProcessName(Context context) &#123;</span><br><span class="line">        ActivityManager am &#x3D; (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps &#x3D; am.getRunningAppProcesses();</span><br><span class="line">        if (runningApps &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123;</span><br><span class="line">            if (procInfo.pid &#x3D;&#x3D; Process.myPid()) &#123;</span><br><span class="line">                return procInfo.processName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个进程创建，都会调用Application的onCreate方法，这是一个需要注意的地方，我们也可以根据当前进程的pid，拿到当前进程的名字去做判断，然后做一些我们需要的逻辑，我们这个例子，拿到的两个进程名分别是：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-05-22 13:54:17.090 16347-16347&#x2F;com.zhyen.android:remote D&#x2F;ZhyenApplication: com.zhyen.android:remote</span><br><span class="line"></span><br><span class="line">2020-05-22 13:54:08.698 16280-16280&#x2F;? D&#x2F;ZhyenApplication: com.zhyen.android</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="url">adb常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T21:21:56+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/21/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><p><a href="https://www.wanandroid.com/blog/show/2310" target="_blank" rel="noopener">ADB命令大全</a></p>
<p><a href="https://developer.android.com/studio/command-line/adb.html#test_harness" target="_blank" rel="noopener">Android官方</a></p>
<h2 id="ADB简介"><a href="#ADB简介" class="headerlink" title="ADB简介"></a>ADB简介</h2><p>ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 sdk/platform-tools 目录下。虽然现在 Android Studio 已经将大部分 ADB 命令以图形化的形式实现了，但是了解一下还是有必要的。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><strong>启动ADB</strong>的2种方式：</p>
<ul>
<li>直接进入<strong>sdk/platform-tools</strong>目录：然后在命令行中输入<strong>adb devices</strong>来验证设备是否连接。<ul>
<li>缺点：每次进入platform-tools目录很麻烦。</li>
</ul>
</li>
<li>将adb地址写入环境变量**（即配置adb为环境变量）</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看当前连接设备："><a href="#查看当前连接设备：" class="headerlink" title="查看当前连接设备："></a>查看当前连接设备：</h3><ul>
<li>查看当前连接设备：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<ul>
<li>如果发现多个设备：</li>
</ul>
<figure class="highlight plain"><figcaption><span>-s 设备号 其他指令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s 设备号 其他指令</span><br></pre></td></tr></table></figure>

<h3 id="事件输入"><a href="#事件输入" class="headerlink" title="事件输入"></a>事件输入</h3><ol>
<li>使用<strong>adb shell input</strong>命令向屏幕输入一些信息，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input text &quot;insert%stext%shere&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：%s表示空格。</strong></p>
<ol start="2">
<li>使用<strong>adb shell input tap</strong>命令来模拟屏幕点击事件，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input tap 500 1450</span><br></pre></td></tr></table></figure>

<p>表示在屏幕上（500，1450）的坐标点上进行一次点击。 </p>
<ol start="3">
<li>使用<strong>adb shell input swipe</strong>命令来模拟手势滑动事件，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 100 500 100 1450 100</span><br></pre></td></tr></table></figure>

<p>表示从屏幕坐标（100，500）开始，滑动到(100,1450)结束，整个过程耗时100ms.</p>
<ol start="4">
<li>使用上面的命令还可以模拟”<strong>长按（long press）</strong>操作，也就是2个坐标点相同，耗时超过500ms.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 100 500 100 500 500</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用<strong>adb shell input keyevent</strong>命令来模拟点按实体按钮的命令，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure>

<p>该命令表示调低音量。数字25是在AOSP源码中的<strong>KeyEvent类</strong>里定义的一个事件常量。该类定义了将近300个事件常量。</p>
<h3 id="查看顶部Activity"><a href="#查看顶部Activity" class="headerlink" title="查看顶部Activity"></a>查看顶部Activity</h3><ul>
<li>windows环境下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Linux、Mac环境下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</span><br></pre></td></tr></table></figure>

<h3 id="查看日志："><a href="#查看日志：" class="headerlink" title="查看日志："></a>查看日志：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat</span><br></pre></td></tr></table></figure>

<h3 id="安装apk文件："><a href="#安装apk文件：" class="headerlink" title="安装apk文件："></a>安装apk文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install xxx.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>此安装方式，如果已经存在，无法安装；<br>推荐使用<strong>覆盖安装：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r xxx.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>比分直接RUN出来的包是test-onlu的无法安装，推荐使用<strong>-t</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r -t xxx.apk</span><br></pre></td></tr></table></figure>

<h3 id="卸载App"><a href="#卸载App" class="headerlink" title="卸载App:"></a>卸载App:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.zhy.app</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想要保留数据，则：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall -k com.zhy.app</span><br></pre></td></tr></table></figure>

<h3 id="传递文件："><a href="#传递文件：" class="headerlink" title="传递文件："></a>传递文件：</h3><ul>
<li>电脑往手机SDCard传递文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 文件名 手机端SDCard路径</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 帅照.jpg &#x2F;sdcard&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>从手机端拉取文件到电脑：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;sdcard&#x2F;xxx.txt</span><br></pre></td></tr></table></figure>

<h3 id="查看手机端安装的所有app包名"><a href="#查看手机端安装的所有app包名" class="headerlink" title="查看手机端安装的所有app包名:"></a>查看手机端安装的所有app包名:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<h3 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity:"></a>启动Activity:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start 包名&#x2F;完整Activity路径</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">adb shell am start com.zhyen.android&#x2F;com.zhyen.android.MainActivity</span><br></pre></td></tr></table></figure>

<p>如果需要携带参数(携带一个Intent,Key 为name):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start com.zhyen.android&#x2F;com.zhyen.android.MainActivity -e name zhy</span><br></pre></td></tr></table></figure>

<p>启动一个隐式的Intent:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a &quot;android.intent.action,VIEW&quot; -d &quot;https:&#x2F;&#x2F;www.google.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="发送广播："><a href="#发送广播：" class="headerlink" title="发送广播："></a>发送广播：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a &quot;broadcastactionfilter&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要携带参数（携带一个Intent,key为name）:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a &quot;broadcastactionfilter&quot; -e name zhy</span><br></pre></td></tr></table></figure>

<h3 id="启动服务："><a href="#启动服务：" class="headerlink" title="启动服务："></a>启动服务：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice &quot;com.zhy.aaa&#x2F;com.zhy.aaa.MyService&quot;</span><br></pre></td></tr></table></figure>

<h3 id="屏幕截图："><a href="#屏幕截图：" class="headerlink" title="屏幕截图："></a>屏幕截图：</h3><ul>
<li>可以使用screencap命令来进行手机屏幕截图，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap &#x2F;sdcard&#x2F;screen.png</span><br></pre></td></tr></table></figure>

<h3 id="录制视频："><a href="#录制视频：" class="headerlink" title="录制视频："></a>录制视频：</h3><p>可以使用screenrecord[options] filename命令来录制屏幕视频，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord &#x2F;sdcard&#x2F;demo.mp4</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冯星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冯星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/" itemprop="url">多进程(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T19:56:56+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Binder/" itemprop="url" rel="index">
                    <span itemprop="name">Binder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/21/Android/Binder/%E5%A4%9A%E8%BF%9B%E7%A8%8B(1)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按照操作系统中的描述。线程是 CPU 调度的最小单元，同时线程也是一种有限的资源。而进程一般指一个执行单元，在 PC 和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程。对于 Android 来说，它是一种基于 Linux 内核的移动操作系统，它的进程和线程有着其特有的性质。我们这篇文章就来聊聊关于 Android 中的进程和线程，我们需要了解的知识。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>我们都知道Android系统是基于Linux改造而来的，进程系统也是一脉相承，进程，其实就是程序的具体实现。当程序第一次启动，Android会启动一个Linux进程（具体由Zygote fork出来）以及一个主线程，默认的情况下，所有组件都将运行在该进程内。同一个应用由系统分配一个独立的Linux账户，该应用的产生的所有进程，都会是这同一个Linux账户。</p>
<h2 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h2><p>在开发中，我们通常会使用修改清单文件的<code>android:process</code>来使用多进程。<code>activity</code>、<code>service</code>、<code>receiver</code> 和 <code>provider</code>均支持<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。如果<code>android:process</code>的value值以冒号<code>:</code>开头的话，那么该进程就是私有进程，如果是以其他字符开头，那么就是公有进程，拥有相同 ShareUID 的不同应用可以跑在同一进程里。另外，我们还可以通过设置<code>application</code>的<code>android:process</code>属性，来设置所有组件的默认进程。</p>
<p><strong>私有进程</strong></p>
<p>如果<code>android:process</code>的值以冒号开头的话，那么该进程就是<strong>私有进程</strong>，如下：</p>
<p><code>&lt;service android:name=&quot;.ProcessTestService&quot; android:process=&quot;:remote&quot;/&gt;</code>   </p>
<p>这种设置形式表示该进程为当前应用的私有进程，<strong>其他应用的组件不可以和它跑在同一个进程中</strong>。</p>
<p><strong>公有进程</strong></p>
<p>进程名称不以“:”开头的进程都可以叫公有进程，如</p>
<p><code>&lt;service android:name=&quot;.ProcessTestService&quot; android:process=&quot;remote&quot;/&gt;</code>   </p>
<p>以小写字母开头，表示运行在一个以这个名字命名的全局进程中，<strong>其他应用通过设置相同的ShareUID可以和它跑在同一个进程</strong>。</p>
<p><strong>ShareUID</strong></p>
<p>ShareUserId，在Android里面每个app都有一个唯一的linux user ID，则这样权限就被设置成该应用程序的文件只对该用户可见，只对该应用程序自身可见，而我们可以使他们对其他的应用程序可见，这会使我们用到SharedUserId，也就是让两个apk使用相同的userID，这样它们就可以看到对方的文件。为了节省资源，具有相同ID的apk也可以在相同的linux进程中进行(注意，并不是一定要在一个进程里面运行)，共享一个虚拟机。<br>ShareUserId的作用，数据共享、调用其他程序资源。</p>
<h2 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h2><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入 “重要性层次结构” 中。必要时，系统会首先消除重要性最低的进程，然后是重要性相对较高的进程，以此类推，以回收进程。</p>
<h3 id="前台进程-—-Foreground-process"><a href="#前台进程-—-Foreground-process" class="headerlink" title="前台进程 — Foreground process"></a>前台进程 — Foreground process</h3><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即是为前台进程：</p>
<ul>
<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>
<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>托管正在 “前台” 运行的 Service（服务已调用 startForeground()）</li>
<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>托管正执行其 onReceive() 方法的 BroadcastRecevier</li>
</ul>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支撑他们同时运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>
<h3 id="可见进程-—-Visible-process"><a href="#可见进程-—-Visible-process" class="headerlink" title="可见进程 — Visible process"></a>可见进程 — Visible process</h3><p> 没有任何前台组件、但仍会影响用户在屏幕上所见内存的进程</p>
<ul>
<li><p>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）例如，如果前台 <code>Activity</code> 启动了一个对话框，允许在其后显示上一 <code>Activity</code>，则有可能会发生这种情况。</p>
</li>
<li><p>托管绑定到可见（或前台）Activity 的 Service</p>
</li>
</ul>
<p>可见进程被视为极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
<h3 id="服务进程-—-Service-process"><a href="#服务进程-—-Service-process" class="headerlink" title="服务进程 — Service process"></a>服务进程 — Service process</h3><p>​        正在运行已使用 startService() 方法启动的服务且不属于和上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但它们通常在「执行一些用户关心的操作」（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维护所有前台进程和可见进程同时运行，否则会让服务进程保持运行状态。</p>
<h3 id="后台进程-—-Background-process"><a href="#后台进程-—-Background-process" class="headerlink" title="后台进程 — Background process"></a>后台进程 — Background process</h3><p>​        包含目前对用户不可见的 <code>Activity</code> 的进程（已调用 <code>Activity</code> 的 <code>onStop()</code> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 <code>Activity</code> 的进程最后一个被终止。如果某个 <code>Activity</code> 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 <code>Activity</code> 时，<code>Activity</code> 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 <code>Activity</code>文档。</p>
<h3 id="空进程-—-Empty-process"><a href="#空进程-—-Empty-process" class="headerlink" title="空进程 — Empty process"></a>空进程 — Empty process</h3><p>​        不含任意活动应用组件的进程。保留这种进程的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>进程按照状态分完重要性之后，就要开始杀进程了。Android的Low Memory Killer基于Linux的OOM机制，在Linux中，内存是以页面(page)为单位，当申请页面分配不足的时候，系统会通过Low Memory Killer来杀掉bad进程，释放内存。Low Memory Killer会根据进程的adj级别以及所占的内存，来决定是否杀掉该进程，adj越大，占用内存越多，进程越容易被杀掉。</p>
<h4 id="adj分级："><a href="#adj分级：" class="headerlink" title="adj分级："></a>adj分级：</h4><ul>
<li>UNKNOWN_ADJ = 16<br>级别最低级的进程，通常是被缓存的进程，但是系统也不清楚缓存的内容。</li>
<li>CACHED_APP_MAX_ADJ = 15<br>这是一个只托管不可见的活动的进程，因此可以在没有任何中断的情况下被杀死。</li>
<li>CACHED_APP_MIN_ADJ = 9<br>缓存进程，没有英文解释。</li>
<li>SERVICE_B_ADJ = 8<br>不活跃的服务，不想adj=5的服务那么活跃。<br>PS:这里说一句，在root以后，有的系统优化大师，会把所有服务统一调成adj=8这个级别，来达到内存优化的目的。</li>
<li>PREVIOUS_APP_ADJ = 7<br>被切换的进程，一般是用户前一个使用的进程。两个应用来回切换，那么前一个应用一般adj设置为7。</li>
<li>HOME_APP_ADJ = 6<br>与主应用程序有交互的进程。</li>
<li>SERVICE_ADJ = 5<br>活跃的服务进程。</li>
<li>HEAVY_WEIGHT_APP_ADJ = 4<br>高权重进程</li>
<li>BACKUP_APP_ADJ = 3<br>正在备份的进程</li>
<li>PERCEPTIBLE_APP_ADJ = 2<br>可感知进程（通常是前台Service进程）</li>
<li>VISIBLE_APP_ADJ = 1<br>可见进程</li>
<li>FOREGROUND_APP_ADJ = 0<br>前台进程</li>
</ul>
<p>剩下的就是adj值为负数的进程，基本上都是系统集成，不在本文的讨论范围内。负数进程是不会被lmk杀掉的。</p>
<h4 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h4><p>首先通过 adb shell ps 指令查找对应进程的pid</p>
<p>然后通过 adb shell cat /proc/${pid}/oom_adj（设备需要root）返回对应进程的adj值。</p>
<p>还可以把oom_adj替换成oom_score或者oom_score_adj来查看这两项的数值，当oom_adj相同时，LowMemoryKiller会根据oom_score_adj和RSS内存大小来杀掉对应的进程。</p>
<h2 id="整个app都在一个进程有什么弊端？"><a href="#整个app都在一个进程有什么弊端？" class="headerlink" title="整个app都在一个进程有什么弊端？"></a>整个app都在一个进程有什么弊端？</h2><p>在Android中，虚拟机分配给各个进程的运行内存是有限制值的（这个值可以是32M，48M，64M等，根据机型而定），试想一下，如果在app中，增加了一个很常用的图片选择模块用于上传图片或者头像，加载大量Bitmap会使app的内存占用迅速增加，如果你还把查看过的图片缓存在了内存中，那么OOM的风险将会大大增加，如果此时还需要使用WebView加载一波网页，我就问你怕不怕！</p>
<p><strong>微信，微博等主流app是如何解决这些问题的？</strong></p>
<p>微信移动开发团队在 <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=400656149&idx=1&sn=122b4f4965fafebf78ec0b4fce2ef62a&mpshare=1&scene=1&srcid=0501f6p8yRsM5qj6OBKEVY1T&key=16e063fbfd27c52cdf5c92791e0542126da55aeb373dcd13df6aa6c417ec61127af2618384b2201ffa7c918e4bbe6780b4d20d3e2ec989af4e2ec3adfda18308cac9706ac4f970ae73fb86211c44b7c2&ascene=0&uin=ODExMTkxNjU%3D&devicetype=iMac+MacBookPro11%2C2+OSX+OSX+10.12.3+build&version=12020510&nettype=WIFI&fontScale=100&pass_ticket=AxhG0QxjCX8weF512sU8ttFb%2B7z%2B8JxvShlgh7diOtM%3D" target="_blank" rel="noopener">《Android内存优化杂谈》</a> 一文中就说到：“对于webview，图库等，由于存在内存系统泄露或者占用内存过多的问题，我们可以采用单独的进程。微信当前也会把它们放在单独的tools进程中”。</p>
<p><img src="http://jsh180.net/image/jpg/ps.png" alt="img"></p>
<p><strong>进入adb shell后，使用 “ps | grep 条目名称” 可以过滤出想要查看的进程。</strong></p>
<p>可以看到，微信的确有一个tools进程，而新浪微博也有image相关的进程，而且它们当中还有好些其它的进程，比如微信的push进程，微博的remote进程等，这里可以看出，他们不单单只是把上述的WebView、图库等放到单独的进程，还有推送服务等也是运行在独立的进程中的。一个消息推送服务，为了保证稳定性，可能需要和UI进程分离，分离后即使UI进程退出、Crash或者出现内存消耗过高等情况，仍不影响消息推送服务。</p>
<p><strong>可见，合理使用多进程不仅仅是有多大好处的问题，我个人认为而且是很有必要的。</strong></p>
<h2 id="为什么需要“跨进程通讯”？"><a href="#为什么需要“跨进程通讯”？" class="headerlink" title="为什么需要“跨进程通讯”？"></a>为什么需要“跨进程通讯”？</h2><p>Android的进程与进程之间通讯，有些不需要我们额外编写通讯代码，例如：把选择图片模块放到独立的进程，我们仍可以使用startActivityForResult方法，将选中的图片放到Bundle中，使用Intent传递即可。（看到这里，你还不打算把你项目的图片选择弄到独立进程么？）</p>
<p>但是对于把“消息推送Service”放到独立的进程，这个业务就稍微复杂点了，这个时候可能会发生Activity跟Service传递对象，调用Service方法等一系列复杂操作。</p>
<p>由于各个进程运行在相对独立的内存空间，所以它们是不能直接通讯的，因为程序里的变量、对象等初始化后都是具有内存地址的，举个简单的例子，读取一个变量的值，本质是找到变量的内存地址，取出存放的值。不同的进程，运行在相互独立的内存（其实就可以理解为两个不同的应用程序），显然不能直接得知对方变量、对象的内存地址，这样的话也自然不能访问对方的变量，对象等。此时两个进程进行交互，就需要使用跨进程通讯的方式去实现。简单说，跨进程通讯就是一种让进程与进程之间可以进行交互的技术。</p>
<h3 id="跨进程通讯的方式有哪些？"><a href="#跨进程通讯的方式有哪些？" class="headerlink" title="跨进程通讯的方式有哪些？"></a>跨进程通讯的方式有哪些？</h3><ol>
<li>四大组件间传递Bundle;</li>
<li>使用文件共享方式，多进程读写一个相同的文件，获取文件内容进行交互；</li>
<li>使用Messenger，一种轻量级的跨进程通讯方案，底层使用AIDL实现；</li>
<li>使用AIDL(Android Interface Definition Language)，Android接口定义语言，用于定义跨进程通讯的接口；</li>
<li>使用ContentProvider，常用于多进程共享数据，比如系统的相册，音乐等，我们也可以通过ContentProvider访问到；</li>
<li>使用Socket传输数据。</li>
</ol>
<h2 id="多进程的应用场景"><a href="#多进程的应用场景" class="headerlink" title="多进程的应用场景"></a>多进程的应用场景</h2><h3 id="常驻后台任务应用"><a href="#常驻后台任务应用" class="headerlink" title="常驻后台任务应用"></a>常驻后台任务应用</h3><p>类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。</p>
<p>现在要做一款音乐播放器，现在有以下几种方案：</p>
<p>A. 在Activity中直接播放音乐。<br>B. 启动后台Service，播放音乐。<br>C. 启动前台Service，播放音乐。<br>D. 在新的进程中，启动后台Service，播放音乐。<br>E. 在新的进程中，启动前台Service，播放音乐。</p>
<h4 id="分析A方案"><a href="#分析A方案" class="headerlink" title="分析A方案"></a>分析A方案</h4><p>在A中，我们的播放器是直接在activity中启动的。首先这么做肯定是不对的，我们需要在后台播放音乐，所以当activity退出后就播不了了，之所以给出这个例子是为了控制变量作对比。</p>
<p>音乐播放器无非是 <strong>打开app，选歌，播放，退到桌面，切其他应用</strong>。我们选取了三个场景，<strong>打开、按home切换其他应用、按back退回桌面</strong>。让我们看一下<strong>A</strong>的相对应的 <strong>oom_adj、oom_score、oom_score_adj</strong> 的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHcyc5RrvgkqdibQvj7lPkn7Vf2tAOYACeM1MbAokOdyUkibB8nOmeHzzA/640?wx_fmt=jpeg" alt="打开状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHf14icAA7Qic83Op12RtibFnmniaicjjDicYT23UIPAeib35wtu2smUo7nU4sg/640?wx_fmt=jpeg" alt="按了Home键被切换状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHL8wZicbIN8h3FMkmeiapWQ3S25xXJqc3sVAmzAFPvfwrn6mGkFWnK2WQ/640?wx_fmt=jpeg" alt="按了Back键被退出状态"></p>
<p>当我们应用在前台的时候，无论 adj 还是 score 还是 score_adj，他们的值都非常的小，基本不会被LMK所杀掉，但是当我们<strong>按了Home</strong>之后，进程的 adj 就会急剧增大，变为 <strong>7</strong>，相应的 score 和 score_adj 也会增大。</p>
<p>在上篇文章中我们得知，<strong>adj=7</strong> 即为 <strong>被切换的进程</strong>，两个进程来回切换，上一个进程就会被设为7。当我们<strong>按Back键</strong>的时候，adj 就会被设为 <strong>9</strong>，也就是<strong>缓存进程</strong>，优先级比较低，有很大的几率被杀掉。</p>
<h4 id="接着我们分析B"><a href="#接着我们分析B" class="headerlink" title="接着我们分析B"></a>接着我们分析B</h4><p><strong>启动后台Service，播放音乐</strong></p>
<p>B是直接启动一个后台service并且播放音乐，这个处理看起来比A好了很多，那么实际上，B的各个场景的优先级和A又有什么不同呢？让我们来看下B的对应的 打开、切换、退出相应 的 adj、score、score_adj 的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHVr6pjKo7ykhEl2ANGvlRvVE89Kf6jDAqdx0uSfrGxqAtyvGJjfYugg/640?wx_fmt=jpeg" alt="打开状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHQlEtnyG5aHpF3OG98c0e6R6s1V54eJrhEkSrDT9hbCSOXxzE9qad5w/640?wx_fmt=jpeg" alt="按了Home键被切换状态"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHc8Kq3VtWdIrTTWqBHyXDgOEXZRZKEMn14mk4Kzauo48dmBNTBt371g/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>B的情况其实是与A类似的，三种状态的 adj、score_adj 的值都是一样的，只有 score 有一点出入，其实分析源码得知，LMK杀进程的时候，score 的左右其实并不大，所以我们暂时忽略它。所以，与A相比，他们的 adj 和 score_adj 的值都相同，如果遇到内存不足的情况下，这两个应用谁占得内存更大，谁就会被杀掉。不过鉴于A实在 activity 中播放音乐，所以B还是比A略好的方案。</p>
<p>这里有朋友肯定要问了，为什么切到后台后，adj的值是<strong>7</strong>而不是<strong>5</strong>，后台不是还有service在跑吗？</p>
<p>我们通过查看源码可以找出来，当切换Home的时候，会调用 ActivityStack.java 的 finishCurrentActivityLocked 函数，然后调用到了 ActivityManagerService.java的computeOomAdjLocked 函数，在这里，对进程的 ADJ 值进行重新计算。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGH1ibiaP5BqV16uxkib5bIRAqDrsFGFYzjZGfo1HicSicploZCuicxCZ9axylQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<h4 id="接下来分析C"><a href="#接下来分析C" class="headerlink" title="接下来分析C"></a>接下来分析C</h4><p><strong>启动前台Service，播放音乐</strong></p>
<p><strong>C</strong>的话是启动一个前台Service来播放音乐。让我们来看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHiaUkuJPHFYESPevxKQlolnqM0zTnbWHRTibCMABdIuAIdUkgiayjAEl7A/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHnJvlKYnSibkVfEj8v2HgZLb526NnhLTskqarPwQ380VWt483ueh9mrA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHuPkF4v4L1Q141L9K4v6SF0jqqd0GGels6UOhces082CnXJMTuibbqYg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>在前台的时候，和AB是一样的，adj 都是 0，当切到后台，或者back结束时，C对应的 adj 就是 2，也就是可感知进程。adj=2 可以说是很高优先级了，非root手机，非系统应用已经没有办法将其杀掉了。具体可参见 ActivityManagerService：</p>
<blockquote>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java</a></p>
</blockquote>
<p>中的 <strong>killBackgroundProcesses</strong> 方法以及 <strong>killPackageProcessesLocked</strong> 方法。<strong>adj&lt;5</strong> 的应用不会被杀掉。</p>
<p>总的来说，C方案比B优秀，拥有 前台Service 的C更不容易被系统或者其他应用所杀掉了，进程的优先级一下子提高到了2，相对于B来说更稳定，用户体验更好。不过有一点不足是必须启动一个前台service。不过现在大部分的音乐类软件都会提供一个前台service，也就不是什么缺点了。其实也是有灰色方法可以启动一个不显示通知的前台service，这里就不过多介绍了。</p>
<p>那么还有可改进的余地吗？答案当然是肯定的。</p>
<h4 id="让我们来看看D"><a href="#让我们来看看D" class="headerlink" title="让我们来看看D"></a>让我们来看看D</h4><p><strong>在新的进程中，启动后台Service，播放音乐</strong></p>
<p><strong>D</strong>把应用进行了拆分，把用于播放音乐的service放到了新的进程内，让我们看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHKI1mzbia2qcfdjgnw5Ojaxdwn2lfayRoFXDg7Bk22OLx3SRbV3n3NEg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHLnzrJmOnE4L8TIuAOCerxTR6icwsavwtlBThXom8YeNN6bAB0L6Iiagg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHFEQn5QfE2aXWj3a4KynNjQibkU73icPrl3Z9uxwAiaASAcmKcpghRZPKQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>上面三张图对应的是<strong>D</strong>应用主进程的ADJ相关值，我们可以看出来，跟<strong>A</strong>类似，adj都是0，7，9。由于少了service部分，内存使用变少，最后计算出的 oom_score_adj 也更低了，意味着主进程部分也更不容易被杀死。</p>
<p>下面我们看下拆分出的service的相关值</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHmZzGib1icZjK3wicCSFEBs4KJSYq3RFJy1gxBAp3tBGONgdSssjjL9n7w/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>因为是service进程，所以不受打开，关闭，切换所影响，这里就放了一张图。</p>
<p>我们可以看到，service的 adj 值一直是 5，也就是活跃的服务进程，相比于B来说，优先级高了不少。不过对于C来说，其实这个方案反倒不如C的 adj=2 的前台进程更稳定。但是D可以自主释放主进程，使D实际所占用的内存很小，从而不容易被杀掉。那么到底C和D谁是更优秀的设计？我个人认为，在ABCDE这5个设计中，D是最具智慧的设计，具体是为什么？先卖个关子，等我们说完了E，再作总结。</p>
<p><strong>那就赶紧分析E吧</strong></p>
<p><strong>在新的进程中，启动前台Service，播放音乐</strong></p>
<p><strong>E</strong>也是使用了多进程，并且在新进程中，使用了前台service，先来看下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHnIjZc1LThH8XPFUYSVRU5tNC9InsObWXhR1UcDF5qU5ppu145whL8A/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHJbdbhWIbCdagxpPZBIfJiaZT4HgZw7gEibAVTdyL80jsanBLchUC1rXg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHgqicd37ychiax3l4fL0FyjwqzB2kSibPUSyvvia38N0AbkZGqU6OA8RcNA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>这个不多解释，和ABD基本差不多，都是0，7，9。我们看下拆分出来的进程的值。</p>
<p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_jpg/v1LbPPWiaSt4ibAYzGfib7aHCticWSHDypGHN6Fu6BWgh59ShhVXpKgm0gkycurmTHUEdO2dqt1w5BVJUDV6JicKDSA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
<p>我们可以看到，这个进程的值是 <strong>2</strong>，像<strong>C</strong>方案，非常小，非常稳定，而且，我们还可以在系统进入后台后，手动杀掉主进程，使整个应用的内存消耗降到最低，内存低，优先级又高。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ABCDE，5种方案都已经分析完了。显然，<strong>E是最稳定的方案</strong>，不过，我刚才说过，我个人最倾向于<strong>D</strong>方案，并且认为<strong>D是最智慧的方案</strong>，这是为什么呢？</p>
<p>景点平常没人的时候还好，谁拿票都能进，当人逐渐拥挤的时候，保安就开始根据票的等级，往外轰人。E方案就是一个拿着普通票的妈妈，带着一个VIP的孩子去参观，D方案就是一个拿着普通票的妈妈，带着一个拿着中等票的孩子参观。当内存不够的时候，保安会先把两个妈妈轰出去，孩子们在里面看，再不够了，就会把D孩子给轰出去。这么看来，显然E的效果更好一些，不过由于Android系统对于VIP票的发放没有节制，大家都可以领VIP票，那也就是相当于没有VIP票了。所以如果E方案是一种精明，那么D才是真正的智慧。将调度权还给系统，做好自己，维护好整个Android生态。</p>
<h3 id="可以获得更多内存"><a href="#可以获得更多内存" class="headerlink" title="可以获得更多内存"></a>可以获得更多内存</h3><p>可以获得更多内存。进程是系统分配资源和调度的基本单位，进程越多得到的资源就越多。Android对内存的限制是针对于进程的。设置为多个进程就可以获取更多的资源。</p>
<h3 id="分散内存的占用"><a href="#分散内存的占用" class="headerlink" title="分散内存的占用"></a>分散内存的占用</h3><p>我们知道Android系统对每个应用进程的内存占用是有限制的，而且占用内存越大的进程，通常被系统杀死的可能性越大。让一个组件运行在单独的进程中，可以减少主进程所占用的内存，避免OOM问题，降低被系统杀死的概率，</p>
<h3 id="实现多模块"><a href="#实现多模块" class="headerlink" title="实现多模块"></a>实现多模块</h3><p>比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。</p>
<blockquote>
<p>当我们的应用开发越来越大，模块越来越多，团队规模也越来越大，协作开发也是个很麻烦的事情。项目解耦，模块化，是这阶段的目标。通过模块解耦，开辟新的进程，独立的JVM，来达到数据解耦目的。模块之间互不干预，团队并行开发，责任分工也明确。</p>
</blockquote>
<h3 id="单一进程崩溃并不影响整体应用的使用"><a href="#单一进程崩溃并不影响整体应用的使用" class="headerlink" title="单一进程崩溃并不影响整体应用的使用"></a>单一进程崩溃并不影响整体应用的使用</h3><p>多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap 申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。</p>
<h3 id="主进程退出，子进程可以继续工作"><a href="#主进程退出，子进程可以继续工作" class="headerlink" title="主进程退出，子进程可以继续工作"></a>主进程退出，子进程可以继续工作</h3><p>主进程退出，子进程可以继续工作，这个最常见的的情况是，主进程启动了推送服务，在主进程结束之后，用户仍然能一直收到推送服务</p>
<h2 id="多进程的问题"><a href="#多进程的问题" class="headerlink" title="多进程的问题"></a>多进程的问题</h2><h3 id="进程之间的内存空间是相互不可见的"><a href="#进程之间的内存空间是相互不可见的" class="headerlink" title="进程之间的内存空间是相互不可见的"></a>进程之间的内存空间是相互不可见的</h3><h3 id="Application的多次重建"><a href="#Application的多次重建" class="headerlink" title="Application的多次重建"></a>Application的多次重建</h3><p>不同进程跑在不同虚拟机上，每个虚拟机上会创建自己的Application 所以在Application中的只存放尽可能少的逻辑，有些sdk要求一定在Application中，此时可以判断当前是否在主进程中，只有主进程中才启动相应逻辑。</p>
<p><strong>思路：判断是否为主进程，只有主进程的时候才执行初始化的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String getProcessName() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;&quot; + android.os.Process.myPid() + &quot;&#x2F;&quot; + &quot;cmdline&quot;);</span><br><span class="line">        BufferedReader mBufferedReader &#x3D; new BufferedReader(new FileReader(file));</span><br><span class="line">        String processName &#x3D; mBufferedReader.readLine().trim();</span><br><span class="line">        mBufferedReader.close();</span><br><span class="line">        return processName;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例-静态变量的失效"><a href="#单例-静态变量的失效" class="headerlink" title="单例/静态变量的失效"></a>单例/静态变量的失效</h3><p>每个进程中保持有独立的一份单例，单例退化为某进程中的单例，而不是整个app运行期间的单例 静态变量相对于类仍然只有一份，但是不同进程中同一个类会加载两次，所以一个类中的静态变量每个进程都独立有一个值，之间没有任何关联</p>
<h3 id="文件共享问题"><a href="#文件共享问题" class="headerlink" title="文件共享问题"></a>文件共享问题</h3><p>多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等。在多线程的情况下我们有锁机制控制资源的共享，但是在多进程中比较难，虽然有文件锁、排队等机制，但是在Android里很难实现。解决办法就是多进程的时候不并发访问同一个文件，比如子进程涉及到操作数据库，就可以考虑调用主进程进行数据库的操作。</p>
<h3 id="线程同步机制可能失效"><a href="#线程同步机制可能失效" class="headerlink" title="线程同步机制可能失效"></a>线程同步机制可能失效</h3><p>例如原本一个线程池中我们最多只希望有2个线程在运行，如果这个线程池同时在两个进程中均存在，那么就可以有4个线程同时运行</p>
<h3 id="ObjectBox"><a href="#ObjectBox" class="headerlink" title="ObjectBox"></a>ObjectBox</h3><p>objectbox在多进程中使用时有坑，项目在单进程时运行很稳定，但配置成多进程之后。Buggly上存在很多Objectbox上报的crash，我们不知道其中错误的细节，但是坑是肯定存在的。</p>
<h3 id="SqlLite"><a href="#SqlLite" class="headerlink" title="SqlLite"></a>SqlLite</h3><p>android API 26 Platform中包含sqllite。一下是一段关于Sqllite的官网介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQLite是一个很快的数据库，但&quot;快&quot;这个词本身是一个主观的和模糊不清的词。坦白地讲，对于有些事情，SQLite比其他数据库做得快，也有些事情比不上其他数据库。利用SQLite提供的配置参数，SQLite是足够快速和高效的。与大多数数据库一样，SQLite使用B-tree做索引，使用B+-tree处理表。因此，在对单表进行查询时，平均而言，SQLite与其他数据库一样快（至少不慢于）。简单的SELECT、INSERT和UPDATE语句是相当快速的--几乎与内存（如果是内存数据库）或者磁盘同速。SQLite通常要快于其他数据库，因为它在处理一个事务开始，或者一个查询计划的产生方面开销较小，并且没有调用服务器的网络或认证以及权限协商的开销。它的简单性使它更快。</span><br><span class="line"></span><br><span class="line">但是随着查询变大变复杂，查询时间使得网络调用或者事务处理开销相形见绌，SQLite将会与其他数据库一样。这时一些大型的设计复杂的数据库开始发挥作用了。虽然SQLite也能处理复杂的查询，但是它没有精密的优化器或者查询计划器。SQLite知道如何使用索引，但是它没有保存详细的表统计信息。假如执行17路join，SQLite也会连接表并给您结果，并不像您在Oracle或者PostgreSQL中期望的那样，SQLite没有通过计算各种替代查询计划并选择最快的候选计划来尝试判断优化路径。因此，假如您在大型数据集合上运行复杂的查询，SQLite与那些有复杂设计的查询计划器的数据库运行一样快的机会是非常小的。</span><br><span class="line"></span><br><span class="line">一些情况下，SQLite可能不如大型数据库快，但大多数的这些情况是预期的。SQLite是为中小规模的应用程序设计的一个嵌入式的数据库，这些限制是设计目的预见到的。许多新用户错误地认为使用SQLite可以代替大型关系数据库。事实是有时可以这样做，有时不行，这完全取决于您准备用SQLite来做什么。</span><br><span class="line"></span><br><span class="line">一般情况下，SQLite的局限性主要有以下两方面：</span><br><span class="line"></span><br><span class="line">并发。SQLite的锁机制是粗粒度的，它允许多个读，但是一次只允许一个写。写锁会在写期间排他地锁定数据库，其他人在此期间不能访问数据库。SQLite已经采取措施以最小化排它锁所占用的时间。通常来讲，SQLite中的锁只保持几毫秒。但是按照一般经验，如果您的应用程序有很高的写并发（许多连接竞争向同一数据库写），并且是时间关键型，您可能需要其他数据库。需要实际测试您的应用程序才能知道能获得怎样的性能。作者曾见过一个简单的网络应用程序中，SQLite用100个并发连接每秒处理500多个事务。您的事务所修改的记录数以及查询所涉及的复杂性可能有所不同。什么样的并发性是可接受的，这取决于具体的应用程序，只能通过直接测试来判断。总之，对任何数据库都是真理：直到您做了实际测试才能知道应用程序能获得怎样的性能。</span><br><span class="line"></span><br><span class="line">网络。虽然SQLite数据库可以通过网络文件系统共享，但是与这种文件系统相关的潜在延时会导致性能受损。更糟的是，网络文件系统实现中的一些缺陷也使得打开和修改远程文件--SQLite或其他--很容易出错。如果文件系统的锁实现不当，可能允许两个客户端同时修改同一个数据库文件，这样必然会导致数据库出错。实际上，并不是因为SQLite的实现导致SQLite不能在网络文件系统上工作。相反，SQLite在底层文件系统和有线协议下工作，但是这些技术有时并不完善。例如，许多NFS使用有缺陷的fcntl()，这意味着锁可能并不像设想的那样工作。一些较新版本的NFS，如Solaris NFSV4就可以工作正常，SQLite需要的锁机制也是相当可靠的。然而，SQLite开发者既没有时间，也没有资源去验证任何给定的网络文件系统在所有的情况下都可以无缺陷工作。</span><br><span class="line"></span><br><span class="line">再次申明，绝大部分限制是有意设计的--它们是SQLite设计的结果。例如，支持高度的写并发会带来很大的复杂性，这将使SQLite的简单性无法保持。同样，作为嵌入式数据库，SQLite是有意不支持网络的。这一点并不奇怪。总之，SQLite不能做的都是它所能做的直接结果。它开始的设计就是一款模块化、简单、紧凑的以及易于使用的嵌入式关系数据库，它的基础代码都在使用它的程序员的掌握范围内。从多方面看，它能完成许多其他数据库不能做的事情，例如，运行在电力消耗实际上是一项制约因素的嵌入式环境中。</span><br></pre></td></tr></table></figure>

<p>当Android系统中存在多个进程时，会有多个SQLiteDatabase对象被创建出来，每个对象都去试图连接同一个数据文件，这个没有什么问题。我们的项目中使用的是“一写多读”的模式，一个进程写，多个进程读取，这个是OK的。</p>
<p>但是如果同时有多个进程进行写操作。个人认为大概率会存在问题，多进程中每个SQLiteDatabase中的锁必然是相互独立，彼此不关联的，那么这个锁必然拦截不住多个进程同时写同一张表的情况。</p>
<h4 id="其他DB"><a href="#其他DB" class="headerlink" title="其他DB"></a>其他DB</h4><p>总体来说，db在多进程间使用时，需要遵照一写多读的方式，并且这个db中没有缓存机制的情况下，还是可用的。但是如果像greendao或者其他本身包含缓存机制的db，那么多进程间即使使用一写多读的工作模式，同样存在风险，因为此时还存在内存与db文件之间不一致的风险</p>
<h3 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h3><p>使用文件同使用数据库本质上一样，全读 / 一写多读没有问题，但是存在多个写时，如何对多个写操作之间进行同步，这个是个大问题。目前看，没有找到什么工具内部处理好了这件事情，都需要业务层自己来做好互斥、管理。</p>
<h3 id="Broadcaster"><a href="#Broadcaster" class="headerlink" title="Broadcaster"></a>Broadcaster</h3><p>以上均是多进程之间对于持久化信息之间的共享，Android上多进程之间非持久化通信莫过于Broadcaster了。可以基于Broadcaster来封装一个好用一点的通信组件。</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>这个方式比较原始。相对于前面所有提到的通信方式，它最大的优点是：不需要context。看起来这不算什么有用的优点。不过特殊情况下，比如我们项目中，由于历史原因获取不到能够支持Service的Context，这个反而成了唯一的选项</p>
<h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>Messenger是基于AIDL实现的，服务端（被动方）提供一个Service来处理客户端（主动方）连接，维护一个Handler来创建Messenger，在onBind时返回Messenger的binder。</p>
<p>双方用Messenger来发送数据，用Handler来处理数据。Messenger处理数据依靠Handler，所以是串行的，也就是说，Handler接到多个message时，就要排队依次处理。</p>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>AIDL通过定义服务端暴露的接口，以提供给客户端来调用，AIDL使服务器可以并行处理，而Messenger封装了AIDL之后只能串行运行</p>
<h3 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h3><p>参考下面的后续看看： <a href="https://www.jianshu.com/p/875d13458538" target="_blank" rel="noopener">https://www.jianshu.com/p/875d13458538</a> <a href="https://juejin.im/entry/590833711b69e60058eb34b9" target="_blank" rel="noopener">https://juejin.im/entry/590833711b69e60058eb34b9</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>进程间的通信在实际场景中频次一般有限，总体来说，先想明白业务的需求。在确定通信需求不是很大的情况下，使用普通db + broadcast基本能满足需求了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冯星</p>
              <p class="site-description motion-element" itemprop="description">人生就像是一个马尔可夫链，你的未来取决于你当下正在做的事，而无关于过去做完的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯星</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'bbc85MrQ0qhACWJxhCKrJoAj-gzGzoHsz',
        appKey: 'fWH5REKFSsGT4TKe1lWt1ke4',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
